/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _weixinJsSdk = __webpack_require__(170);
	
	var _weixinJsSdk2 = _interopRequireDefault(_weixinJsSdk);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	_vue2.default.filter('time', function (value) {
	    var hour = Math.floor(value / 3600);
	    var min = Math.floor(value % 3600 / 60);
	    if (hour < 10) {
	        hour = '0' + hour;
	    }
	    if (min < 10) {
	        min = '0' + min;
	    }
	    var sec = value % 60;
	    if (sec < 10) {
	        sec = '0' + sec;
	    }
	    return (hour > 0 ? hour + ':' : '') + min + ':' + sec;
	});
	_vue2.default.filter('datetime', function (value) {
	    return new Date(value).toLocaleString();
	});
	var config = {};
	_requestList2.default.getMainConfig().then(function (res) {
	    config = res.data;
	    console.log(config);
	}, function (res) {
	    console.error(res);
	});
	
	var main = new _vue2.default({
	    el: 'body',
	    components: { app: _App2.default }
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, jQuery) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2), __webpack_require__(3)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable no-unused-vars*/
	/*!
	 * jQuery JavaScript Library v3.1.0
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-07-07T21:44Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.0",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.0
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-04
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true;
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
		// Known :disabled false positives:
		// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
		// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Check form elements and option elements for explicit disabling
			return "label" in elem && elem.disabled === disabled ||
				"form" in elem && elem.disabled === disabled ||
	
				// Check non-disabled form elements for fieldset[disabled] ancestors
				"form" in elem && elem.disabled === false && (
					// Support: IE6-11+
					// Ancestry is covered for us
					elem.isDisabled === disabled ||
	
					// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						("label" in elem || !disabledAncestor( elem )) !== disabled
				);
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnotwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? JSON.parse( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) ),
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support: IE <=9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox <=42
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			opt.duration = typeof opt.duration === "number" ?
				opt.duration : opt.duration in jQuery.fx.speeds ?
					jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in uncached url if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rts, "" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	return jQuery;
	} );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(9)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(169)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0692510b/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue", function() {
				var newContent = require("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n", "", {"version":3,"sources":["/./src/App.vue?34c08e7a"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkJA;IACA,UAAA;CACA;;AAEA;;IAEA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oCAAA;IACA,SAAA;IACA,QAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;CACA","file":"App.vue","sourcesContent":["<template lang=\"pug\">\n        background\n        menu-bar(v-bind:game-data=\"gameData\",v-bind:notice=\"notice\",v-bind:zoom-rate=\"zoomRate\")\n        bet-and-bonus(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        play-panel(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        state(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        //- bet-multiple\n        message(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        modal.modal(v-if=\"error\")\n        tip-modal\n</template>\n<script>\nimport Background from './components/Background.vue'\nimport MenuBar from './components/MenuBar.vue'\nimport BetAndBonus from './components/BetAndBonus.vue'\nimport PlayPanel from './components/PlayPanel.vue'\nimport State from './components/State.vue'\nimport BetMultiple from './components/BetMultiple.vue'\nimport Message from './components/Message.vue'\nimport gameData from './data/data' //  \nimport RequestList from './js/request-list'\nexport default {\n    props: [],\n    ready() {\n        let that = this\n        window.onresize = function() {\n            that.screenSize.width = window.innerWidth\n            that.screenSize.height = window.innerHeight\n        }\n        this.init()\n    },\n    data() {\n        return {\n            userBet: {\n                betmoney: 1000 //1000\n            },\n            gameData: gameData,\n            lotterynum: { //\n                id: '',\n                createdAt: 0,\n                lotterynums: ''\n            },\n            countDown: 300, // \n            countNum: 300, // 3\n            error: false,\n            bets: [], // \n            notice: require('./data/notice'),\n            userinfo: require('./data/singleuser'),\n            stageSize: { // ,\n                width: 640,\n                height: 1008\n            },\n            screenSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            }\n        }\n    },\n    methods: {\n        init() {\n            // \n\n            // \n            RequestList.getBonusNum().then(res => this.lotterynum = res.data)\n            this.getUserInfoByNet()\n                // \n            this.$emit('getLastNotice')\n        },\n        show() {},\n        getUserInfoByNet() { //user\n            var that = this\n            RequestList.getuserCodeFromNet(RequestList.getCode()).then(res => {\n                // \n                that.userinfo = Object.assign({}, that.userinfo, res.data)\n                that.$emit('getUserInfo')\n            }, res => {\n                console.error(res.data)\n            })\n        }\n    },\n    computed: {\n        zoomRate() { // \n            let x = this.screenSize.width / this.stageSize.width\n            let y = this.screenSize.height / this.stageSize.height\n            return {\n                x: x,\n                y: y\n            }\n        },\n        lockmoney() { //\n            let result = 0\n            for (let i = 0; i < this.bets.length; i++) {\n                result += this.bets[i].betmoney\n            }\n            return result\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.$broadcast('showMessage', event)\n        },\n        getUserInfo(event) {\n            var that = this\n            RequestList.getuserinfo(JSON.parse(JSON.stringify(this.userinfo))).then((res) => {\n                if (Object.prototype.toString.call(res.data) === '[object Object]') {\n                    that.userinfo = Object.assign({}, that.userinfo, res.data)\n                    that.userBet.userinfoOpenid = res.data.openid\n                } else {}\n                return\n            }, (res) => {\n                console.error(res)\n            })\n        },\n        getLastNotice(event) {\n            RequestList.getLastNotice().then(res => this.notice = res.data, res => console.error(res))\n        },\n        cancelbet(event) {\n            this.$broadcast('cancelBet')\n        },\n        reloadinfo(event) {\n            this.init()\n        },\n        // \n        error() {\n            this.error = true\n        },\n        showTip(event) {\n            this.$broadcast('showTip', event)\n        }\n    },\n    components: {\n        'modal': {\n            template: '<div class=\"modal\"></div>'\n        },\n        'tip-modal': require('./components/tip-modal.vue'),\n        'background': Background,\n        'menu-bar': MenuBar,\n        'bet-and-bonus': BetAndBonus,\n        'play-panel': PlayPanel,\n        'state': State,\n        'bet-multiple': BetMultiple,\n        'message': Message\n    }\n}\n</script>\n<style>\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if (media) {
			styleElement.setAttribute("media", media);
		}
	
		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Background = __webpack_require__(49);
	
	var _Background2 = _interopRequireDefault(_Background);
	
	var _MenuBar = __webpack_require__(55);
	
	var _MenuBar2 = _interopRequireDefault(_MenuBar);
	
	var _BetAndBonus = __webpack_require__(67);
	
	var _BetAndBonus2 = _interopRequireDefault(_BetAndBonus);
	
	var _PlayPanel = __webpack_require__(77);
	
	var _PlayPanel2 = _interopRequireDefault(_PlayPanel);
	
	var _State = __webpack_require__(85);
	
	var _State2 = _interopRequireDefault(_State);
	
	var _BetMultiple = __webpack_require__(94);
	
	var _BetMultiple2 = _interopRequireDefault(_BetMultiple);
	
	var _Message = __webpack_require__(99);
	
	var _Message2 = _interopRequireDefault(_Message);
	
	var _data = __webpack_require__(161);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: [],
	    ready: function ready() {
	        var that = this;
	        window.onresize = function () {
	            that.screenSize.width = window.innerWidth;
	            that.screenSize.height = window.innerHeight;
	        };
	        this.init();
	    },
	    data: function data() {
	        return {
	            userBet: {
	                betmoney: 1000 },
	            gameData: _data2.default,
	            lotterynum: {
	                id: '',
	                createdAt: 0,
	                lotterynums: ''
	            },
	            countDown: 300,
	            countNum: 300,
	            error: false,
	            bets: [],
	            notice: __webpack_require__(162),
	            userinfo: __webpack_require__(163),
	            stageSize: {
	                width: 640,
	                height: 1008
	            },
	            screenSize: {
	                width: window.innerWidth,
	                height: window.innerHeight
	            }
	        };
	    },
	
	    methods: {
	        init: function init() {
	            var _this = this;
	
	            _requestList2.default.getBonusNum().then(function (res) {
	                return _this.lotterynum = res.data;
	            });
	            this.getUserInfoByNet();
	
	            this.$emit('getLastNotice');
	        },
	        show: function show() {},
	        getUserInfoByNet: function getUserInfoByNet() {
	            var that = this;
	            _requestList2.default.getuserCodeFromNet(_requestList2.default.getCode()).then(function (res) {
	                that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                that.$emit('getUserInfo');
	            }, function (res) {
	                console.error(res.data);
	            });
	        }
	    },
	    computed: {
	        zoomRate: function zoomRate() {
	            var x = this.screenSize.width / this.stageSize.width;
	            var y = this.screenSize.height / this.stageSize.height;
	            return {
	                x: x,
	                y: y
	            };
	        },
	        lockmoney: function lockmoney() {
	            var result = 0;
	            for (var i = 0; i < this.bets.length; i++) {
	                result += this.bets[i].betmoney;
	            }
	            return result;
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.$broadcast('showMessage', event);
	        },
	        getUserInfo: function getUserInfo(event) {
	            var that = this;
	            _requestList2.default.getuserinfo(JSON.parse((0, _stringify2.default)(this.userinfo))).then(function (res) {
	                if (Object.prototype.toString.call(res.data) === '[object Object]') {
	                    that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                    that.userBet.userinfoOpenid = res.data.openid;
	                } else {}
	                return;
	            }, function (res) {
	                console.error(res);
	            });
	        },
	        getLastNotice: function getLastNotice(event) {
	            var _this2 = this;
	
	            _requestList2.default.getLastNotice().then(function (res) {
	                return _this2.notice = res.data;
	            }, function (res) {
	                return console.error(res);
	            });
	        },
	        cancelbet: function cancelbet(event) {
	            this.$broadcast('cancelBet');
	        },
	        reloadinfo: function reloadinfo(event) {
	            this.init();
	        },
	        error: function error() {
	            this.error = true;
	        },
	        showTip: function showTip(event) {
	            this.$broadcast('showTip', event);
	        }
	    },
	    components: {
	        'modal': {
	            template: '<div class="modal"></div>'
	        },
	        'tip-modal': __webpack_require__(164),
	        'background': _Background2.default,
	        'menu-bar': _MenuBar2.default,
	        'bet-and-bonus': _BetAndBonus2.default,
	        'play-panel': _PlayPanel2.default,
	        'state': _State2.default,
	        'bet-multiple': _BetMultiple2.default,
	        'message': _Message2.default
	    }
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(11), __esModule: true };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(12)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(14), __esModule: true };

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(15);
	module.exports = __webpack_require__(12).Object.assign;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(16);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(30)});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , core      = __webpack_require__(12)
	  , ctx       = __webpack_require__(18)
	  , hide      = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 17 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(19);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(21)
	  , createDesc = __webpack_require__(29);
	module.exports = __webpack_require__(25) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(22)
	  , IE8_DOM_DEFINE = __webpack_require__(24)
	  , toPrimitive    = __webpack_require__(28)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(25) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(25) && !__webpack_require__(26)(function(){
	  return Object.defineProperty(__webpack_require__(27)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(26)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23)
	  , document = __webpack_require__(17).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(23);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(31)
	  , gOPS     = __webpack_require__(46)
	  , pIE      = __webpack_require__(47)
	  , toObject = __webpack_require__(48)
	  , IObject  = __webpack_require__(35)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(26)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(45);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(33)
	  , toIObject    = __webpack_require__(34)
	  , arrayIndexOf = __webpack_require__(38)(false)
	  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(35)
	  , defined = __webpack_require__(37);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(34)
	  , toLength  = __webpack_require__(39)
	  , toIndex   = __webpack_require__(41);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(40)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(43)('keys')
	  , uid    = __webpack_require__(44);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(17)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 46 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 47 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(37);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(50)
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7658d6de/Background.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(51);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(" + __webpack_require__(52) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(" + __webpack_require__(53) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/Background.vue?b29085ae"],"names":[],"mappings":";;;;;;AAMA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,YAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,iDAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,sBAAA;IACA,uBAAA;IACA,6BAAA;CACA","file":"Background.vue","sourcesContent":["<template lang=\"pug\">\n    div.background\n    \tdiv.up-background\n    \tdiv.buttom-background\n</template>\n<style>\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(../assets///BG.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(../assets///dock.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4b4a6609b989655a4d67f245bd57e41d.png";

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABlCAIAAAADEh6SAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5RjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDlBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlGQzJEOTlEM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yDa1IwAAABxJREFUeNpisArsZGJgYGB+//EbiB7FA48BAgwAr7gEtOjH9QQAAAAASUVORK5CYII="

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "<div class=\"background\"><div class=\"up-background\"></div><div class=\"buttom-background\"></div></div>";

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(56)
	__vue_script__ = __webpack_require__(59)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\MenuBar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(66)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a5fa5098/MenuBar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(" + __webpack_require__(58) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/MenuBar.vue?542b96fa"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;IACA,mBAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,eAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;IACA,aAAA;IACA,sBAAA;IACA,aAAA;IACA;2BACA;IACA,wBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"MenuBar.vue","sourcesContent":["<template lang=\"pug\">\n    //-\n    div.menu\n        div.notice\n            table\n                tr\n                    td\n                        span(v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\",v-html='notice.title')\n        div.option(@touchend=\"triggerOption\")\n        options-dialog(v-bind:game-data=\"gameData\",v-bind:zoom-rate=\"zoomRate\")\n</template>\n<script>\nimport OptionsDialog from './OptionsDialog.vue'\nexport default {\n    props: ['gameData', 'zoomRate', 'notice'],\n    ready() {\n        console.log(this.gameData.notice)\n    },\n    data() {\n        return {\n            name: 'liu',\n            isShowOption: false\n        }\n    },\n    methods: {\n        triggerOption() {\n            this.$broadcast('triggerOption')\n        }\n    },\n    components: {\n        'options-dialog': OptionsDialog\n    }\n}\n</script>\n<style>\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA0CAYAAAA5bTAhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUI5QzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUI5RDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcwMzg1MUZGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwMzg1MjAwM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+mrp5MgAABkJJREFU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"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _OptionsDialog = __webpack_require__(60);
	
	var _OptionsDialog2 = _interopRequireDefault(_OptionsDialog);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['gameData', 'zoomRate', 'notice'],
	    ready: function ready() {
	        console.log(this.gameData.notice);
	    },
	    data: function data() {
	        return {
	            name: 'liu',
	            isShowOption: false
	        };
	    },
	
	    methods: {
	        triggerOption: function triggerOption() {
	            this.$broadcast('triggerOption');
	        }
	    },
	    components: {
	        'options-dialog': _OptionsDialog2.default
	    }
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(61)
	__vue_script__ = __webpack_require__(63)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\OptionsDialog.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(65)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-3d271406/OptionsDialog.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/*  */\n\n.expand-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter  */\n\n\n/* .expand-leave  */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n", "", {"version":3,"sources":["/./src/components/OptionsDialog.vue?53ddea8e"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,iBAAA;IACA,iBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;;AAGA,QAAA;;AAEA;IACA,iCAAA;IAAA,yBAAA;IACA,iBAAA;IACA,kBAAA;IACA,2BAAA;IACA,iBAAA;CACA;;;AAGA,6BAAA;;;AAGA,6BAAA;;AAEA;;IAEA,UAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,6BAAA;IACA,mBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;AAEA;IACA,eAAA;IACA,gBAAA;IACA,oBAAA;IACA,mBAAA;IACA,oBAAA;IACA,4BAAA;CACA;;AAEA;IACA,cAAA;IACA,mCAAA;CACA","file":"OptionsDialog.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.option-list(v-show=\"isOptionShow\",transition=\"expand\",v-bind:style=\"optionStyle\")\n        //- img(v-bind:src=\"menuImg\")\n        div.pointer\n        div.inner-pointer\n        div.option-item(v-html=\"n\",v-for=\"n in gameData.options\",@touchend=\"showMessage($index)\",v-bind:style=\"itemStyle\")\n</template>\n<script>\nexport default {\n    ready() {\n            console.log(this.gameData)\n        },\n        props: ['gameData', 'zoomRate'],\n        data() {\n            return {\n                isOptionShow: false,\n                menuImg: require('../assets///.png')\n            }\n        },\n        computed: {\n            optionStyle() {\n                return {\n                    borderRadius: 12 * this.zoomRate.x + 'px'\n                }\n            },\n            itemStyle() {\n                return {\n                    fontSize: 26 * this.zoomRate.x + 'px'\n                }\n            }\n        },\n        methods: {\n            showMessage(event) {\n                this.isOptionShow = false\n                this.$dispatch('showMessage', event)\n            }\n        },\n        events: {\n            triggerOption() {\n                this.isOptionShow = !this.isOptionShow\n            }\n        }\n}\n</script>\n<style>\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/*  */\n\n.expand-transition {\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter  */\n\n\n/* .expand-leave  */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.gameData);
	    },
	
	    props: ['gameData', 'zoomRate'],
	    data: function data() {
	        return {
	            isOptionShow: false,
	            menuImg: __webpack_require__(64)
	        };
	    },
	
	    computed: {
	        optionStyle: function optionStyle() {
	            return {
	                borderRadius: 12 * this.zoomRate.x + 'px'
	            };
	        },
	        itemStyle: function itemStyle() {
	            return {
	                fontSize: 26 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        showMessage: function showMessage(event) {
	            this.isOptionShow = false;
	            this.$dispatch('showMessage', event);
	        }
	    },
	    events: {
	        triggerOption: function triggerOption() {
	            this.isOptionShow = !this.isOptionShow;
	        }
	    }
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAFcCAYAAABhrZRpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUJBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUJBMTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQjlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkyN0JFQjlGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ePgOugAAKRNJREFU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"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<div class=\"option-list\" v-show=\"isOptionShow\" transition=\"expand\" v-bind:style=\"optionStyle\"><div class=\"pointer\"></div><div class=\"inner-pointer\"></div><div class=\"option-item\" v-html=\"n\" v-for=\"n in gameData.options\" @touchend=\"showMessage($index)\" v-bind:style=\"itemStyle\"></div></div>";

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<div class=\"menu\"><div class=\"notice\"><table><tr><td><span v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\" v-html=\"notice.title\"></span></td></tr></table></div><div class=\"option\" @touchend=\"triggerOption\"></div><options-dialog v-bind:game-data=\"gameData\" v-bind:zoom-rate=\"zoomRate\"></options-dialog></div>";

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(68)
	__vue_script__ = __webpack_require__(73)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetAndBonus.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7138c18e/BetAndBonus.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(70) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(71) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(72) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n", "", {"version":3,"sources":["/./src/components/BetAndBonus.vue?17f568bf"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2GA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,gBAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,kBAAA;IACA,aAAA;CACA;;AAEA;;IAEA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;IACA,eAAA;CACA;;AAEA;IACA,aAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;CACA","file":"BetAndBonus.vue","sourcesContent":["<template lang=\"pug\">\n    //-    \n    div.bonus-bar\n        div.bonus-item.bet\n            div.item-back.forzen\n                div.item-show\n                    div.bet-num(v-bind:style=\"betNum\",v-html=\"lockmoney\")\n        div.bonus-item.count-down\n            div.count-down-back\n                div.count-down-show\n                    div.count-down-num(v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\",v-html=\"countDown | time\")\n        div.bonus-item.bonus\n            div.item-back.balance\n                div.item-show(@touchend=\"showMessage\")\n                    div.bet-num(v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\")\n</template>\n<script>\nimport RequestList from '../js/request-list'\nexport default {\n    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],\n    ready() {\n        this.getCount(this.count(this.countDown))\n    },\n    data() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight\n        }\n    },\n    computed: {\n        betNum() {\n            return {\n                fontSize: 34 * this.zoomRate.x + 'px',\n                lineHeight: 3 * 34 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        // \n        getCount(fn) {\n            var that = this\n            RequestList.getCount().then((res) => {\n                that.countDown = res.data.countDown\n                that.countNum = res.data.countNum\n                that.userBet.idnum = res.data.idnum + 1 //\n                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {\n                    that.$dispatch('error')\n                    return\n                }\n                fn ? fn() : null\n            }, (res) => {\n                that.countDown = 0\n            })\n        },\n        // \n        createUserBets() {\n            var that = this\n            RequestList.createUserBets(JSON.stringify(this.bets)).then((res) => {\n                if (typeof res.data.errmsg !== 'undefined') {\n                    that.$dispatch('showTip', res.data.errmsg)\n                }\n                console.log(res.data)\n            }, (res) => {\n                console.log(res.data)\n            })\n        },\n        getBonusNum() { // \n            var that = this\n            RequestList.getBonusNum().then((res) => {\n                that.lotterynum = res.data\n                that.getCount(that.count)\n                that.$dispatch('cancelbet')\n                that.$dispatch('reloadinfo')\n            }, (res) => {\n                console.error(res)\n            })\n            this.countDown = this.countNum\n        },\n        showMessage() {\n            this.$dispatch('showMessage', 5)\n        },\n        count() {\n            // 30 \n            if (this.countDown === 30 && this.bets && this.bets.length > 0) {\n                this.createUserBets()\n            }\n            // \n            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {\n                this.$dispatch('showTip', ',')\n                return\n            }\n            // console.log(this.countDown)\n            this.countDown--\n                let that = this\n            setTimeout(function() {\n                if (that.countDown > 0) {\n                    that.count()\n                } else {\n                    // 0  \n                    that.getBonusNum()\n                }\n            }, 1000)\n        }\n    }\n}\n</script>\n<style>\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///count-down.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ2RTNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ2RjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0ZCM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0ZDM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jqTgIAAAGLJJREFU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"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNkJDRDdGOTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGQTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0Y3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0Y4M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8Nwv7wAAFD1JREFU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"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAACVCAYAAACzfqM2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ3MjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ3MzNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBEMDg0NDcwM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBEMDg0NDcxM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gONmGwAAMvxJREFU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"

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],
	    ready: function ready() {
	        this.getCount(this.count(this.countDown));
	    },
	    data: function data() {
	        return {
	            width: window.innerWidth,
	            height: window.innerHeight
	        };
	    },
	
	    computed: {
	        betNum: function betNum() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                lineHeight: 3 * 34 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        getCount: function getCount(fn) {
	            var that = this;
	            _requestList2.default.getCount().then(function (res) {
	                that.countDown = res.data.countDown;
	                that.countNum = res.data.countNum;
	                that.userBet.idnum = res.data.idnum + 1;
	                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {
	                    that.$dispatch('error');
	                    return;
	                }
	                fn ? fn() : null;
	            }, function (res) {
	                that.countDown = 0;
	            });
	        },
	        createUserBets: function createUserBets() {
	            var that = this;
	            _requestList2.default.createUserBets((0, _stringify2.default)(this.bets)).then(function (res) {
	                if (typeof res.data.errmsg !== 'undefined') {
	                    that.$dispatch('showTip', res.data.errmsg);
	                }
	                console.log(res.data);
	            }, function (res) {
	                console.log(res.data);
	            });
	        },
	        getBonusNum: function getBonusNum() {
	            var that = this;
	            _requestList2.default.getBonusNum().then(function (res) {
	                that.lotterynum = res.data;
	                that.getCount(that.count);
	                that.$dispatch('cancelbet');
	                that.$dispatch('reloadinfo');
	            }, function (res) {
	                console.error(res);
	            });
	            this.countDown = this.countNum;
	        },
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        count: function count() {
	            if (this.countDown === 30 && this.bets && this.bets.length > 0) {
	                this.createUserBets();
	            }
	
	            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {
	                this.$dispatch('showTip', ',');
	                return;
	            }
	
	            this.countDown--;
	            var that = this;
	            setTimeout(function () {
	                if (that.countDown > 0) {
	                    that.count();
	                } else {
	                    that.getBonusNum();
	                }
	            }, 1000);
	        }
	    }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	
	module.exports.getBonusRecord = function () {
	    return _vue2.default.http.get('getBonusRecord');
	};
	
	module.exports.getMainConfig = function () {
	    return _vue2.default.http.get('getMainConfig', { params: { url: window.location.href.split('#')[0] } });
	};
	
	module.exports.getCount = function () {
	    return _vue2.default.http.get('getCount');
	};
	
	module.exports.getBonusNum = function (params) {
	    return _vue2.default.http.get('getBonusNum', params);
	};
	
	module.exports.createUserBets = function (params) {
	    return _vue2.default.http.post('createUserBets', params);
	};
	
	module.exports.getuserCodeFromNet = function (code) {
	    return _vue2.default.http.get('getUserCode', { params: { code: code } });
	};
	
	module.exports.getuserinfo = function (userinfo) {
	    return _vue2.default.http.post('getuserinfo', userinfo);
	};
	
	module.exports.getLastNotice = function () {
	    return _vue2.default.http.get('getLastNotice');
	};
	
	module.exports.getCode = function () {
	    var reg = new RegExp("(^|&)" + 'code' + "=([^&]*)(&|$)", "i");
	    var r = window.location.search.substr(1).match(reg);
	    if (r != null) return unescape(r[2]);
	    return null;
	};
	
	module.exports.updateuserinfo = function (params) {
	    return _vue2.default.http.post('updateuserinfo', params);
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	/*!
	 * vue-resource v0.9.3
	 * https://github.com/vuejs/vue-resource
	 * Released under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */
	
	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING = 2;
	
	function Promise$2(executor) {
	
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	
	    var promise = this;
	
	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}
	
	Promise$2.reject = function (r) {
	    return new Promise$2(function (resolve, reject) {
	        reject(r);
	    });
	};
	
	Promise$2.resolve = function (x) {
	    return new Promise$2(function (resolve, reject) {
	        resolve(x);
	    });
	};
	
	Promise$2.all = function all(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        var count = 0,
	            result = [];
	
	        if (iterable.length === 0) {
	            resolve(result);
	        }
	
	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;
	
	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }
	
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};
	
	Promise$2.race = function race(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};
	
	var p$1 = Promise$2.prototype;
	
	p$1.resolve = function resolve(x) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        var called = false;
	
	        try {
	            var then = x && x['then'];
	
	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;
	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }
	
	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};
	
	p$1.reject = function reject(reason) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};
	
	p$1.notify = function notify() {
	    var promise = this;
	
	    nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];
	
	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};
	
	p$1.then = function then(onResolved, onRejected) {
	    var promise = this;
	
	    return new Promise$2(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};
	
	p$1.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};
	
	var PromiseObj = window.Promise || Promise$2;
	
	function Promise$1(executor, context) {
	
	    if (executor instanceof PromiseObj) {
	        this.promise = executor;
	    } else {
	        this.promise = new PromiseObj(executor.bind(context));
	    }
	
	    this.context = context;
	}
	
	Promise$1.all = function (iterable, context) {
	    return new Promise$1(PromiseObj.all(iterable), context);
	};
	
	Promise$1.resolve = function (value, context) {
	    return new Promise$1(PromiseObj.resolve(value), context);
	};
	
	Promise$1.reject = function (reason, context) {
	    return new Promise$1(PromiseObj.reject(reason), context);
	};
	
	Promise$1.race = function (iterable, context) {
	    return new Promise$1(PromiseObj.race(iterable), context);
	};
	
	var p = Promise$1.prototype;
	
	p.bind = function (context) {
	    this.context = context;
	    return this;
	};
	
	p.then = function (fulfilled, rejected) {
	
	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);
	};
	
	p.catch = function (rejected) {
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.catch(rejected), this.context);
	};
	
	p.finally = function (callback) {
	
	    return this.then(function (value) {
	        callback.call(this);
	        return value;
	    }, function (reason) {
	        callback.call(this);
	        return PromiseObj.reject(reason);
	    });
	};
	
	var debug = false;
	var util = {};
	var array = [];
	function Util (Vue) {
	    util = Vue.util;
	    debug = Vue.config.debug || !Vue.config.silent;
	}
	
	function warn(msg) {
	    if (typeof console !== 'undefined' && debug) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	}
	
	function error(msg) {
	    if (typeof console !== 'undefined') {
	        console.error(msg);
	    }
	}
	
	function nextTick(cb, ctx) {
	    return util.nextTick(cb, ctx);
	}
	
	function trim(str) {
	    return str.replace(/^\s*|\s*$/g, '');
	}
	
	var isArray = Array.isArray;
	
	function isString(val) {
	    return typeof val === 'string';
	}
	
	function isBoolean(val) {
	    return val === true || val === false;
	}
	
	function isFunction(val) {
	    return typeof val === 'function';
	}
	
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	
	function isPlainObject(obj) {
	    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	}
	
	function isFormData(obj) {
	    return typeof FormData !== 'undefined' && obj instanceof FormData;
	}
	
	function when(value, fulfilled, rejected) {
	
	    var promise = Promise$1.resolve(value);
	
	    if (arguments.length < 2) {
	        return promise;
	    }
	
	    return promise.then(fulfilled, rejected);
	}
	
	function options(fn, obj, opts) {
	
	    opts = opts || {};
	
	    if (isFunction(opts)) {
	        opts = opts.call(obj);
	    }
	
	    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
	}
	
	function each(obj, iterator) {
	
	    var i, key;
	
	    if (typeof obj.length == 'number') {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (isObject(obj)) {
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }
	
	    return obj;
	}
	
	var assign = Object.assign || _assign;
	
	function merge(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source, true);
	    });
	
	    return target;
	}
	
	function defaults(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	
	        for (var key in source) {
	            if (target[key] === undefined) {
	                target[key] = source[key];
	            }
	        }
	    });
	
	    return target;
	}
	
	function _assign(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source);
	    });
	
	    return target;
	}
	
	function _merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
	            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
	                target[key] = {};
	            }
	            if (isArray(source[key]) && !isArray(target[key])) {
	                target[key] = [];
	            }
	            _merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}
	
	function root (options, next) {
	
	    var url = next(options);
	
	    if (isString(options.root) && !url.match(/^(https?:)?\//)) {
	        url = options.root + '/' + url;
	    }
	
	    return url;
	}
	
	function query (options, next) {
	
	    var urlParams = Object.keys(Url.options.params),
	        query = {},
	        url = next(options);
	
	    each(options.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });
	
	    query = Url.params(query);
	
	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }
	
	    return url;
	}
	
	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */
	
	function expand(url, params, variables) {
	
	    var tmpl = parse(url),
	        expanded = tmpl.expand(params);
	
	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }
	
	    return expanded;
	}
	
	function parse(template) {
	
	    var operators = ['+', '#', '.', '/', ';', '?', '&'],
	        variables = [];
	
	    return {
	        vars: variables,
	        expand: function (context) {
	            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
	                if (expression) {
	
	                    var operator = null,
	                        values = [];
	
	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }
	
	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });
	
	                    if (operator && operator !== '+') {
	
	                        var separator = ',';
	
	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }
	
	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }
	                } else {
	                    return encodeReserved(literal);
	                }
	            });
	        }
	    };
	}
	
	function getValues(context, operator, key, modifier) {
	
	    var value = context[key],
	        result = [];
	
	    if (isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();
	
	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }
	
	            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            result.push(encodeValue(operator, value[k], k));
	                        }
	                    });
	                }
	            } else {
	                var tmp = [];
	
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        tmp.push(encodeValue(operator, value));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(encodeValue(operator, value[k].toString()));
	                        }
	                    });
	                }
	
	                if (isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }
	
	    return result;
	}
	
	function isDefined(value) {
	    return value !== undefined && value !== null;
	}
	
	function isKeyOperator(operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	}
	
	function encodeValue(operator, value, key) {
	
	    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);
	
	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	}
	
	function encodeReserved(str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	}
	
	function template (options) {
	
	    var variables = [],
	        url = expand(options.url, options.params, variables);
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	}
	
	/**
	 * Service for URL templating.
	 */
	
	var ie = document.documentMode;
	var el = document.createElement('a');
	
	function Url(url, params) {
	
	    var self = this || {},
	        options = url,
	        transform;
	
	    if (isString(url)) {
	        options = { url: url, params: params };
	    }
	
	    options = merge({}, Url.options, self.$options, options);
	
	    Url.transforms.forEach(function (handler) {
	        transform = factory(handler, transform, self.$vm);
	    });
	
	    return transform(options);
	}
	
	/**
	 * Url options.
	 */
	
	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};
	
	/**
	 * Url transforms.
	 */
	
	Url.transforms = [template, query, root];
	
	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */
	
	Url.params = function (obj) {
	
	    var params = [],
	        escape = encodeURIComponent;
	
	    params.add = function (key, value) {
	
	        if (isFunction(value)) {
	            value = value();
	        }
	
	        if (value === null) {
	            value = '';
	        }
	
	        this.push(escape(key) + '=' + escape(value));
	    };
	
	    serialize(params, obj);
	
	    return params.join('&').replace(/%20/g, '+');
	};
	
	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */
	
	Url.parse = function (url) {
	
	    if (ie) {
	        el.href = url;
	        url = el.href;
	    }
	
	    el.href = url;
	
	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};
	
	function factory(handler, next, vm) {
	    return function (options) {
	        return handler.call(vm, options, next);
	    };
	}
	
	function serialize(params, obj, scope) {
	
	    var array = isArray(obj),
	        plain = isPlainObject(obj),
	        hash;
	
	    each(obj, function (value, key) {
	
	        hash = isObject(value) || isArray(value);
	
	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }
	
	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}
	
	function xdrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xdr = new XDomainRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith(xdr.responseText, {
	                status: xdr.status,
	                statusText: xdr.statusText
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xdr.abort();
	        };
	
	        xdr.open(request.method, request.getUrl(), true);
	        xdr.timeout = 0;
	        xdr.onload = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = function () {};
	        xdr.onprogress = function () {};
	        xdr.send(request.getBody());
	    });
	}
	
	var ORIGIN_URL = Url.parse(location.href);
	var SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();
	
	function cors (request, next) {
	
	    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {
	        request.crossOrigin = true;
	    }
	
	    if (request.crossOrigin) {
	
	        if (!SUPPORTS_CORS) {
	            request.client = xdrClient;
	        }
	
	        delete request.emulateHTTP;
	    }
	
	    next();
	}
	
	function crossOrigin(request) {
	
	    var requestUrl = Url.parse(Url(request));
	
	    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;
	}
	
	function body (request, next) {
	
	    if (request.emulateJSON && isPlainObject(request.body)) {
	        request.body = Url.params(request.body);
	        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	    }
	
	    if (isFormData(request.body)) {
	        delete request.headers['Content-Type'];
	    }
	
	    if (isPlainObject(request.body)) {
	        request.body = JSON.stringify(request.body);
	    }
	
	    next(function (response) {
	
	        var contentType = response.headers['Content-Type'];
	
	        if (isString(contentType) && contentType.indexOf('application/json') === 0) {
	
	            try {
	                response.data = response.json();
	            } catch (e) {
	                response.data = null;
	            }
	        } else {
	            response.data = response.text();
	        }
	    });
	}
	
	function jsonpClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var name = request.jsonp || 'callback',
	            callback = '_jsonp' + Math.random().toString(36).substr(2),
	            body = null,
	            handler,
	            script;
	
	        handler = function (event) {
	
	            var status = 0;
	
	            if (event.type === 'load' && body !== null) {
	                status = 200;
	            } else if (event.type === 'error') {
	                status = 404;
	            }
	
	            resolve(request.respondWith(body, { status: status }));
	
	            delete window[callback];
	            document.body.removeChild(script);
	        };
	
	        request.params[name] = callback;
	
	        window[callback] = function (result) {
	            body = JSON.stringify(result);
	        };
	
	        script = document.createElement('script');
	        script.src = request.getUrl();
	        script.type = 'text/javascript';
	        script.async = true;
	        script.onload = handler;
	        script.onerror = handler;
	
	        document.body.appendChild(script);
	    });
	}
	
	function jsonp (request, next) {
	
	    if (request.method == 'JSONP') {
	        request.client = jsonpClient;
	    }
	
	    next(function (response) {
	
	        if (request.method == 'JSONP') {
	            response.data = response.json();
	        }
	    });
	}
	
	function before (request, next) {
	
	    if (isFunction(request.before)) {
	        request.before.call(this, request);
	    }
	
	    next();
	}
	
	/**
	 * HTTP method override Interceptor.
	 */
	
	function method (request, next) {
	
	    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	        request.headers['X-HTTP-Method-Override'] = request.method;
	        request.method = 'POST';
	    }
	
	    next();
	}
	
	function header (request, next) {
	
	    request.method = request.method.toUpperCase();
	    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);
	
	    next();
	}
	
	/**
	 * Timeout Interceptor.
	 */
	
	function timeout (request, next) {
	
	    var timeout;
	
	    if (request.timeout) {
	        timeout = setTimeout(function () {
	            request.abort();
	        }, request.timeout);
	    }
	
	    next(function (response) {
	
	        clearTimeout(timeout);
	    });
	}
	
	function xhrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xhr = new XMLHttpRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {
	                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
	                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),
	                headers: parseHeaders(xhr.getAllResponseHeaders())
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xhr.abort();
	        };
	
	        xhr.open(request.method, request.getUrl(), true);
	        xhr.timeout = 0;
	        xhr.onload = handler;
	        xhr.onerror = handler;
	
	        if (request.progress) {
	            if (request.method === 'GET') {
	                xhr.addEventListener('progress', request.progress);
	            } else if (/^(POST|PUT)$/i.test(request.method)) {
	                xhr.upload.addEventListener('progress', request.progress);
	            }
	        }
	
	        if (request.credentials === true) {
	            xhr.withCredentials = true;
	        }
	
	        each(request.headers || {}, function (value, header) {
	            xhr.setRequestHeader(header, value);
	        });
	
	        xhr.send(request.getBody());
	    });
	}
	
	function parseHeaders(str) {
	
	    var headers = {},
	        value,
	        name,
	        i;
	
	    each(trim(str).split('\n'), function (row) {
	
	        i = row.indexOf(':');
	        name = trim(row.slice(0, i));
	        value = trim(row.slice(i + 1));
	
	        if (headers[name]) {
	
	            if (isArray(headers[name])) {
	                headers[name].push(value);
	            } else {
	                headers[name] = [headers[name], value];
	            }
	        } else {
	
	            headers[name] = value;
	        }
	    });
	
	    return headers;
	}
	
	function Client (context) {
	
	    var reqHandlers = [sendRequest],
	        resHandlers = [],
	        handler;
	
	    if (!isObject(context)) {
	        context = null;
	    }
	
	    function Client(request) {
	        return new Promise$1(function (resolve) {
	
	            function exec() {
	
	                handler = reqHandlers.pop();
	
	                if (isFunction(handler)) {
	                    handler.call(context, request, next);
	                } else {
	                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');
	                    next();
	                }
	            }
	
	            function next(response) {
	
	                if (isFunction(response)) {
	
	                    resHandlers.unshift(response);
	                } else if (isObject(response)) {
	
	                    resHandlers.forEach(function (handler) {
	                        response = when(response, function (response) {
	                            return handler.call(context, response) || response;
	                        });
	                    });
	
	                    when(response, resolve);
	
	                    return;
	                }
	
	                exec();
	            }
	
	            exec();
	        }, context);
	    }
	
	    Client.use = function (handler) {
	        reqHandlers.push(handler);
	    };
	
	    return Client;
	}
	
	function sendRequest(request, resolve) {
	
	    var client = request.client || xhrClient;
	
	    resolve(client(request));
	}
	
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	
	/**
	 * HTTP Response.
	 */
	
	var Response = function () {
	    function Response(body, _ref) {
	        var url = _ref.url;
	        var headers = _ref.headers;
	        var status = _ref.status;
	        var statusText = _ref.statusText;
	        classCallCheck(this, Response);
	
	
	        this.url = url;
	        this.body = body;
	        this.headers = headers || {};
	        this.status = status || 0;
	        this.statusText = statusText || '';
	        this.ok = status >= 200 && status < 300;
	    }
	
	    Response.prototype.text = function text() {
	        return this.body;
	    };
	
	    Response.prototype.blob = function blob() {
	        return new Blob([this.body]);
	    };
	
	    Response.prototype.json = function json() {
	        return JSON.parse(this.body);
	    };
	
	    return Response;
	}();
	
	var Request = function () {
	    function Request(options) {
	        classCallCheck(this, Request);
	
	
	        this.method = 'GET';
	        this.body = null;
	        this.params = {};
	        this.headers = {};
	
	        assign(this, options);
	    }
	
	    Request.prototype.getUrl = function getUrl() {
	        return Url(this);
	    };
	
	    Request.prototype.getBody = function getBody() {
	        return this.body;
	    };
	
	    Request.prototype.respondWith = function respondWith(body, options) {
	        return new Response(body, assign(options || {}, { url: this.getUrl() }));
	    };
	
	    return Request;
	}();
	
	/**
	 * Service for sending network requests.
	 */
	
	var CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };
	var COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };
	var JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };
	
	function Http(options) {
	
	    var self = this || {},
	        client = Client(self.$vm);
	
	    defaults(options || {}, self.$options, Http.options);
	
	    Http.interceptors.forEach(function (handler) {
	        client.use(handler);
	    });
	
	    return client(new Request(options)).then(function (response) {
	
	        return response.ok ? response : Promise$1.reject(response);
	    }, function (response) {
	
	        if (response instanceof Error) {
	            error(response);
	        }
	
	        return Promise$1.reject(response);
	    });
	}
	
	Http.options = {};
	
	Http.headers = {
	    put: JSON_CONTENT_TYPE,
	    post: JSON_CONTENT_TYPE,
	    patch: JSON_CONTENT_TYPE,
	    delete: JSON_CONTENT_TYPE,
	    custom: CUSTOM_HEADERS,
	    common: COMMON_HEADERS
	};
	
	Http.interceptors = [before, timeout, method, body, jsonp, header, cors];
	
	['get', 'delete', 'head', 'jsonp'].forEach(function (method) {
	
	    Http[method] = function (url, options) {
	        return this(assign(options || {}, { url: url, method: method }));
	    };
	});
	
	['post', 'put', 'patch'].forEach(function (method) {
	
	    Http[method] = function (url, body, options) {
	        return this(assign(options || {}, { url: url, method: method, body: body }));
	    };
	});
	
	function Resource(url, params, actions, options) {
	
	    var self = this || {},
	        resource = {};
	
	    actions = assign({}, Resource.actions, actions);
	
	    each(actions, function (action, name) {
	
	        action = merge({ url: url, params: params || {} }, options, action);
	
	        resource[name] = function () {
	            return (self.$http || Http)(opts(action, arguments));
	        };
	    });
	
	    return resource;
	}
	
	function opts(action, args) {
	
	    var options = assign({}, action),
	        params = {},
	        body;
	
	    switch (args.length) {
	
	        case 2:
	
	            params = args[0];
	            body = args[1];
	
	            break;
	
	        case 1:
	
	            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
	                body = args[0];
	            } else {
	                params = args[0];
	            }
	
	            break;
	
	        case 0:
	
	            break;
	
	        default:
	
	            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';
	    }
	
	    options.body = body;
	    options.params = assign({}, options.params, params);
	
	    return options;
	}
	
	Resource.actions = {
	
	    get: { method: 'GET' },
	    save: { method: 'POST' },
	    query: { method: 'GET' },
	    update: { method: 'PUT' },
	    remove: { method: 'DELETE' },
	    delete: { method: 'DELETE' }
	
	};
	
	function plugin(Vue) {
	
	    if (plugin.installed) {
	        return;
	    }
	
	    Util(Vue);
	
	    Vue.url = Url;
	    Vue.http = Http;
	    Vue.resource = Resource;
	    Vue.Promise = Promise$1;
	
	    Object.defineProperties(Vue.prototype, {
	
	        $url: {
	            get: function () {
	                return options(Vue.url, this, this.$options.url);
	            }
	        },
	
	        $http: {
	            get: function () {
	                return options(Vue.http, this, this.$options.http);
	            }
	        },
	
	        $resource: {
	            get: function () {
	                return Vue.resource.bind(this);
	            }
	        },
	
	        $promise: {
	            get: function () {
	                var _this = this;
	
	                return function (executor) {
	                    return new Vue.Promise(executor, _this);
	                };
	            }
	        }
	
	    });
	}
	
	if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(plugin);
	}
	
	module.exports = plugin;

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bonus-bar\"><div class=\"bonus-item bet\"><div class=\"item-back forzen\"><div class=\"item-show\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"lockmoney\"></div></div></div></div><div class=\"bonus-item count-down\"><div class=\"count-down-back\"><div class=\"count-down-show\"><div class=\"count-down-num\" v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\" v-html=\"countDown | time\"></div></div></div></div><div class=\"bonus-item bonus\"><div class=\"item-back balance\"><div class=\"item-show\" @touchend=\"showMessage\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\"></div></div></div></div></div>";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(81)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\PlayPanel.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(84)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-5febd0b0/PlayPanel.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(79);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.playpanel {\n    /*background: url(../assets///.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(" + __webpack_require__(80) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/PlayPanel.vue?dfc2404a"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+NA;IACA,sDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;CACA;;AAEA;IACA,WAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;IACA,kBAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,qBAAA;IACA,+BAAA;CACA;;AAEA;IACA,6BAAA;CACA;;AAEA;IACA,4BAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"PlayPanel.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.playpanel\n        div.table-panel(v-el:panel,v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n            div.num.single(v-bind:style=\"single\",@touchend=\"dobet('single')\")\n                img.chip(v-for=\"item in bets|filterBy 'single' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.double(v-bind:style=\"double\",@touchend=\"dobet('double')\")\n                img.chip(v-for=\"item in bets|filterBy 'double' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.zero(v-bind:style=\"zero\",@touchend=\"dobet(0)\")\n                img.chip(v-for=\"item in bets|filterBy 0 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.one(v-bind:style=\"one\",@touchend=\"dobet(1)\")\n                img.chip(v-for=\"item in bets|filterBy 1 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.two(v-bind:style=\"two\",@touchend=\"dobet(2)\")\n                img.chip(v-for=\"item in bets|filterBy 2 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.three(v-bind:style=\"three\",@touchend=\"dobet(3)\")\n                img.chip(v-for=\"item in bets|filterBy 3 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.four(v-bind:style=\"four\",@touchend=\"dobet(4)\")\n                img.chip(v-for=\"item in bets|filterBy 4 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.five(v-bind:style=\"five\",@touchend=\"dobet(5)\")\n                img.chip(v-for=\"item in bets|filterBy 5 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.six(v-bind:style=\"six\",@touchend=\"dobet(6)\")\n                img.chip(v-for=\"item in bets|filterBy 6 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.seven(v-bind:style=\"seven\",@touchend=\"dobet(7)\")\n                img.chip(v-for=\"item in bets|filterBy 7 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.eight(v-bind:style=\"eight\",@touchend=\"dobet(8)\")\n                img.chip(v-for=\"item in bets|filterBy 8 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.nine(v-bind:style=\"nine\",@touchend=\"dobet(9)\")\n                img.chip(v-for=\"item in bets|filterBy 9 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.big(v-bind:style=\"big\",@touchend=\"dobet('big')\")\n                img.chip(v-for=\"item in bets|filterBy 'big' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.small(v-bind:style=\"small\",@touchend=\"dobet('small')\")\n                img.chip(v-for=\"item in bets|filterBy 'small' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.formula(v-bind:style=\"formula\",v-html=\"bonusNum\") \n            div.num.bonudnum(v-bind:style=\"bonudnum\")\n                table\n                    tr\n                        td(v-html=\"userBet.betnum\")\n        img(v-bind:src=\"tablePanelImg\",v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],\n    data() {\n        return {\n            tablePanelImg: require('../assets///.png'),\n            chipImg: require('../assets///5X-.png'),\n            imgSize: {\n                width: 640,\n                height: 528\n            }\n        }\n    },\n    computed: {\n        // TODO \n        bonusNum() {\n            var nums = this.lotterynum.lotterynums.split(',')\n            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1])\n            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')'\n        },\n        single() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'\n            }\n        },\n        double() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        zero() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        one() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        two() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        three() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        four() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        five() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        six() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        seven() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        eight() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        nine() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        big() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'\n            }\n        },\n        small() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        formula() {\n            return {\n                width: 210 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                // height: 83 * this.zoomRate.y + 'px',\n                fontSize: 42 * this.zoomRate.x + 'px',\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'\n            }\n        },\n        // TODO \n        bonudnum() {\n            return {\n                width: 68 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                fontSize: 40 * this.zoomRate.x + 'px',\n                height: 68 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        bet(event) {\n            console.log('Height' + event.target.offsetHeight)\n            console.log('Width' + event.target.offsetWidth)\n            console.log(event)\n        },\n        // \n        dobet(num) {\n            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return\n            if (this.countDown < 10) return // 10\n            if (Object.prototype.toString.call(num) === '[object Number]') {\n                this.userBet.type = 'NUMBER'\n                this.userBet.betnum = num\n            } else if (Object.prototype.toString.call(num) === '[object String]') {\n                switch (num) {\n                    case 'single':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'double':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'big':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    case 'small':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    default:\n                        break\n                }\n            }\n            this.bets.push(Object.assign({}, this.userBet))\n        }\n    },\n    events: {\n        cancelBet(event) {\n            this.bets = []\n        }\n    }\n}\n</script>\n<style>\n.playpanel {\n    /*background: url(../assets///.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(../assets///-.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABJCAYAAACesWDiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4NzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4ODNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTg1M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTg2M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Uv2HIAAABDxJREFUeNrsnLGOFDEMhuPM6BDFFbRX8wR0xyvwKDwPj8JrUCNETUd1BTppJyGZtXP/eDPL5ITAIEfKJuzMLcmX3453FQ99+JxDKeuLl215f/+WYnm5cRS75SaWl1vnsFtuK6AXzmG3vJh77/549zpMRGudS43cj9Cncl/klri1VKpTzTmvbeJ2KW3iKv0T92t9+fHrxed0AQmYKcY+JIHDfYFkClCFUsaUuF9h1DELnMhwysVAKe1+zi6gCmdmKFgRFKonGgMkqmmgRDW8oAvft466zDXvQOoCQjBzT0UMZmIo0aKJMZQy0LNieJyiHuIaCpg1xinX8lFAUUwM/BCqBxWEcKyYWVUNQkLTaqoBkNIuIyYWFZyeiUVlXmRIPWJmAofApBZ1b+Y5LyMKmjo7l/gmkWsEcyNLgLjWsYnPEX+5sK+ReyYGlHbUvwsodkxK4CC4CKZlAVKG700Z4ZxtrznkSZw57MpDu1hU7UW/Y2JWdrLEviZpQAxJNpfM/QTvHQJEoCJCtfSqChQtKEjMhhiSVpdUwpgu5zETk0lj1NyDYzGaxvgn8FavASVQj4hgTEHgW5opyfvS11u9AUirMiA4jAxJnHZmVUlMtMKBXe4YINiVNhDA5Mjo9zGSbR63eFZ7hsUVeMRwaFRBBE44dPwLQiFDwWIWNTAkUv6FOr6WrvigeGhVQFEXgaGxSJp2xhbVHI6OdX6OhLutkWhadidRkphVfubYYvDigByQA3JADsgBOSAH5MUBOSAH5IAckANyQA7IiwNyQA7IATkgB+SAHJADcgQOyAE5IAfkgP7ZMnw+KHfa9fwNn+aykNvZUhF2xvzbFSR5V3hCtP2HfA0HZgYOjC2pORwd67ynEsmxynBULXfuwaO2ZAUSLipA6s1hnaO659eAeOLtA+RIbXg6RiunSTdHbY0cAw4q07AtNtekr19Z2F0FSaZewJSi8HQIMvFA8KgtXVmJv6WgxEl0Mqek3QRcPwyo0ZYENEgp2uQ9dI7amlAQugmBpKrksKLCxhQkeZ7c3xyhVfeKp49GdrGWzIIq6kFSwA4DEtVgexYMO+SwzcnCncJUOpRSkOSsLqov7ZCJJfWHa6ZeTUaLsTnBHDo5WVZ8UM/EeA4JUsFRUUOAFlaDJHpIuuKajMam1BJDxCUZAtQzsUW1GtSYidU/DGGTw7DmYik/JQ68maCxSBohLQrSSf17SEEnmbQCFOBrxQR+qqU8GlKRLNwiDjmE7hMXTqMKak8kWGmlc9DIQBKkZ2L8Y/rBAqAgVNKiIE0jJkbskLNyfJtcK0hGM/loCgh4EzjsCxWVuS6jgMQhB6We9nATMK1r+VZWoukjDzc5bGL4FJTMO9jyn/7eM8HG4z+Y+S+KDuiPFwqv7u9K+6bUO8exKd9K/VSd9GOp353HRalMHiugh1K/BH/Ymy5VOA8/BRgA3V2MtlWnR+sAAAAASUVORK5CYII="

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],
	    data: function data() {
	        return {
	            tablePanelImg: __webpack_require__(82),
	            chipImg: __webpack_require__(83),
	            imgSize: {
	                width: 640,
	                height: 528
	            }
	        };
	    },
	
	    computed: {
	        bonusNum: function bonusNum() {
	            var nums = this.lotterynum.lotterynums.split(',');
	            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1]);
	            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')';
	        },
	        single: function single() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'
	            };
	        },
	        double: function double() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        zero: function zero() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        one: function one() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        two: function two() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        three: function three() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        four: function four() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        five: function five() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        six: function six() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        seven: function seven() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        eight: function eight() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        nine: function nine() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        big: function big() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'
	            };
	        },
	        small: function small() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        formula: function formula() {
	            return {
	                width: 210 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	
	                fontSize: 42 * this.zoomRate.x + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'
	            };
	        },
	        bonudnum: function bonudnum() {
	            return {
	                width: 68 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	                fontSize: 40 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        bet: function bet(event) {
	            console.log('Height' + event.target.offsetHeight);
	            console.log('Width' + event.target.offsetWidth);
	            console.log(event);
	        },
	        dobet: function dobet(num) {
	            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return;
	            if (this.countDown < 10) return;
	            if (Object.prototype.toString.call(num) === '[object Number]') {
	                this.userBet.type = 'NUMBER';
	                this.userBet.betnum = num;
	            } else if (Object.prototype.toString.call(num) === '[object String]') {
	                switch (num) {
	                    case 'single':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'double':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'big':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'small':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    default:
	                        break;
	                }
	            }
	            this.bets.push((0, _assign2.default)({}, this.userBet));
	        }
	    },
	    events: {
	        cancelBet: function cancelBet(event) {
	            this.bets = [];
	        }
	    }
	};

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAIQCAYAAAARq99gAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4MzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4NDNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTgxM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTgyM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+vclhJQAAXSNJREFU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"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAlCAYAAAAqXEs9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5NzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDk5ODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQkE2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTk2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EVwcGQAADetJREFU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"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "<div class=\"playpanel\"><div class=\"table-panel\" v-el:panel=\"v-el:panel\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"><div class=\"num single\" v-bind:style=\"single\" @touchend=\"dobet('single')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'single' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num double\" v-bind:style=\"double\" @touchend=\"dobet('double')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'double' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num zero\" v-bind:style=\"zero\" @touchend=\"dobet(0)\"><img class=\"chip\" v-for=\"item in bets|filterBy 0 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num one\" v-bind:style=\"one\" @touchend=\"dobet(1)\"><img class=\"chip\" v-for=\"item in bets|filterBy 1 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num two\" v-bind:style=\"two\" @touchend=\"dobet(2)\"><img class=\"chip\" v-for=\"item in bets|filterBy 2 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num three\" v-bind:style=\"three\" @touchend=\"dobet(3)\"><img class=\"chip\" v-for=\"item in bets|filterBy 3 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num four\" v-bind:style=\"four\" @touchend=\"dobet(4)\"><img class=\"chip\" v-for=\"item in bets|filterBy 4 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num five\" v-bind:style=\"five\" @touchend=\"dobet(5)\"><img class=\"chip\" v-for=\"item in bets|filterBy 5 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num six\" v-bind:style=\"six\" @touchend=\"dobet(6)\"><img class=\"chip\" v-for=\"item in bets|filterBy 6 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num seven\" v-bind:style=\"seven\" @touchend=\"dobet(7)\"><img class=\"chip\" v-for=\"item in bets|filterBy 7 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num eight\" v-bind:style=\"eight\" @touchend=\"dobet(8)\"><img class=\"chip\" v-for=\"item in bets|filterBy 8 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num nine\" v-bind:style=\"nine\" @touchend=\"dobet(9)\"><img class=\"chip\" v-for=\"item in bets|filterBy 9 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num big\" v-bind:style=\"big\" @touchend=\"dobet('big')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'big' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num small\" v-bind:style=\"small\" @touchend=\"dobet('small')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'small' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num formula\" v-bind:style=\"formula\" v-html=\"bonusNum\"> </div><div class=\"num bonudnum\" v-bind:style=\"bonudnum\"><table><tr><td v-html=\"userBet.betnum\"></td></tr></table></div></div><img v-bind:src=\"tablePanelImg\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"/></div>";

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(86)
	__vue_script__ = __webpack_require__(91)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\State.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(93)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0ce74191/State.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(87);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(" + __webpack_require__(88) + ") 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets///1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(" + __webpack_require__(89) + ") 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(" + __webpack_require__(90) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets///.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n", "", {"version":3,"sources":["/./src/components/State.vue?46a91f68"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;IACA,gBAAA;IACA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,4DAAA;IACA,yBAAA;CACA;;AAEA;IACA,2EAAA;IACA,YAAA;IACA,aAAA;IACA;+BACA;IACA,aAAA;CACA;;AAEA;IACA,kDAAA;IACA,6BAAA;IACA,yBAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;IACA,YAAA;CACA;;AAEA;IACA,sBAAA;CACA;;;AAGA;;GAEA;;AAEA;IACA,oDAAA;IACA,6BAAA;IACA,iCAAA;CACA;;AAEA;IACA,YAAA;IACA,iBAAA;CACA;;AAEA;IACA,aAAA;IACA,+CAAA;IACA,iBAAA;CACA","file":"State.vue","sourcesContent":["<template lang=\"pug\">\n    //-  \n    div.state\n        div.state-item.money.table\n            div.money-state.table-cell\n                div.button\n                    table\n                        tr\n                            td\n                                span.money-num(contenteditable=\"true\",@keyup=\"checkData\",@blur=\"changeData\",v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\",v-html=\"userBet.betmoney\")\n        div.state-item.portrait\n            div.polygon(@touchend=\"showMessage\",v-bind:style=\"headstyle\")\n                svg(xmlns=\"http://www.w3.org/2000/svg\",version=\"1.1\",v-bind:width=\"headsize.width+'px'\",v-bind:height=\"headsize.height+'px'\")\n                    defs\n                        pattern(id=\"image\",x=\"0\",y=\"0\",patternUnits=\"userSpaceOnUse\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                            image(v-el:image,x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                    polygon(v-bind:points=\"headborder\",fill=\"url(#image)\")\n                    image(x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\",v-bind:xlink:href=\"headborderimg\")\n        div.state-item.stars.table\n            div.money-state.table-cell\n                div.button.undo(@click=\"cancelbet\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userBet', 'userinfo'],\n    ready() {\n        console.log(this.zoomRate)\n        console.log(this.$els.image)\n    },\n    data() {\n        return {\n            headzoom: 1.2,\n            headborderimg: require('../assets///1.png')\n        }\n    },\n    watch: {\n        'userinfo.headimgurl': function(newval) {\n            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval)\n        }\n    },\n    computed: {\n        headsize() {\n            return {\n                width: 142 * this.headzoom * this.zoomRate.x,\n                height: 165 * this.headzoom * this.zoomRate.y\n            }\n        },\n        headborder() {\n            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y\n        },\n        headstyle() {\n            return {\n                // width: 640 / 3 * this.zoomRate.x + 'px',\n                // height: 640 / 3 * this.zoomRate.y + 'px',\n                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' //\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ')'\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ',' + this.headsize.height / (1008 * 0.17) + ')'\n            }\n        }\n    },\n    methods: {\n        showMessage() {\n            this.$dispatch('showMessage', 5) // 5\n        },\n        cancelbet() {\n            this.$dispatch('cancelbet')\n        },\n        checkData(event) {\n            // console.log(/\\d+/.test(event.target.innerHTML))\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 // 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        },\n        changeData(event) {\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 // 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        }\n    }\n}\n</script>\n<style>\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(../assets/th.jpg) 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets///1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(./../assets///.png) 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets///.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGMjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkI2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkI3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0Y1lLQAAHf9JREFUeNrsnQl8VNXVwM97b/Yte8hOgEBISIKAiICyqVh3rHurVdti7Vd/VVv1931Fa2217rWfWj+rrVo3BNFirbuyCsgmkAASIGRPSCbbJJnJbO+97547k0neMpMEg3Xiu3B+M3lz577l/u+555y7DCOuXQAnMSUQmUvkVCLTiEwgkk0kkYgNtDSWUy+RLiJNRI4ROUBkF5FtRFyjdRLmOqfkbx2Io34jOUSuIvJ9InOIcFrdfieTLSzIw2mDjvNEthN5m8ibROpG86Q6GD2iUdXfSeQ8DWItxUjIxrywPEzkAyKPEdk4GoWzo1DGIiKbwhd0oQazlkYINzKzIczQoq+tocUTV9CZggiPsQz8YKiMdc4g7Dnmh8NNAahr46GxPQhdbgE8PlGr0jGYLEYGEq0sZKfoIC+VgylZepgx0QB5abpYXzuTyHrC1OuEqTvI++YTsqmFt88Y8Zd4Aa7kWHgu7PSppqrjQfj3zj5YX+GF4128VstagoxEDhaXmuCCU81QkBkTbhdh7CbC2OohTYzr20cG9H1Hn428v7fgZgNpQX8iLegXanlR22+r9MGLn/VCRW0gctxgToCUrFJITC8Ea2I2WOzj6DFOZwSW02s1PYaSwAeAD/rA3+cCT08LuLsaoau1EtqbKuix/lQ6Xg83LLHBvKlGYJgoZYnwF8Lar41Xbff1H/OtmjME0G/FBvp3YaB/V3CznQC7lpx8iVq+Q40BeGxtN+yvC4GsN9khe/JiyJy0ABLSJuGptNr+TicRXM4qaK7aBI1H1kPA20OPluTp4Y5lDpiara7YCHObCXPLjFdv76BAvyED+gYF0PNjXsa9R56F+ybfnEYK/pAUPFP+uT8owjMf9MLqLR5sUWC0JEF+6TLILVpKNLBJq0ctKU1WosEbD38Gx/a+BT5PBxAtDJfPs8At59vAoGPUoC4n7J1tvHqH0/fGaTKgO6RA80MAjXYyAXUDOekp8g/qiYN392tdcKQpCAzLwfiSi2DSjKuA02sga2kYYAe8ULVnFdTufxdEgYfJWTq4/4eJkJvKqZkf+wiDC0E2KMMpgF4zL9Y5DcQ4/4gY54pwCpoWd7zkgm6PAJaETChbcgfYUyZqtaSlEaee9mqoWP8EsbfrwWFh4bEbEqgpohKM2EBYPBcNgwjQN3ZK8nD3XpkbK5rxNCngcvnxbZV+uJPA7PaJkDb+NJhx7j1gsqVrNaOlE0oGcyJkEX/L3dUAnW0N8MleH0whNrVcUxMNnU+YTCOv7/Uf+/07XmkeGppQkT6fcDXHiDfLjx+o88OKV13gDYiQPXUplJ11F+j0Fq1WtPS1EpqpZWfdSZlCtpAxZE3OHzJJ2LwmckyWGP7NuYqDHW4xN8nCVBBDXBJnbmjnYfkzXeAiZkbO1HOhcN5NWk1oadRT5dbnoOHQR8T8YOD5nycpNDXh2NXlEcuSrEwd9+MuacP47RU5kgO6n7iY+5aZXiGmRtng44GgCLe/1ANNnQKk5s2GojNvAS0Up6WTkZJzZkBvRw10tjdBeW0Qzp9hAFY6ScNEzI4C43LXG/LvKuZytD/tONugg4vkx5/50EOjGdaEbChecGssa0UTTb6WIFvIGLKGzCF7CrubMNrxtGOpCtBYQkiIdmbNevjD4GMolY0BeGu7l4bmihbcBixnJCcWNdHkpAkyhqwhc8geMijn0qSH++RKmR2cp+4x+1kGDuYMPiYKAI//ywMCec0uugCsieM1LaLJNyLIWk7RhZS9P73roSwOZhNZrX7EdrbEZBbDnqJ+eQ/r+ovtTrnjuK0yAAcbgmAwJ0Fe6WUgitoMOS19cym39PvQcmwTHKjvpOHiuYXS+HSylc7M+xTHXiQ29Ie/suSY9YxinsYrm0JxvtySS7WhbC198+E8wlxe6ffp+5c3eRWfI7PIbkRD98fyijOZHzEgcoMXsFS18LC/jmhnox3GTVqkaWct/UdS+sSFULdvNRyo64GjzUEoyBgI4zGEeWSXvL2famhEVH9Tr95hZi4RZWb3R/uIIc4wkDrhTGKcGzS7TpP/iCB7yCCyiEzKOUV2EePISOGjVxjSzTpxprykTytCQ+Zp48/QPG9N/qOSOj40iW7d/oCCeGQXGQ6ZHITxJVPZBQwjSsIf1a0CtHWLoDc5wJI0/jtlbpQWDQyQejxBqKp1K/LYrDqYkGeVHHO2eeG406fZCCchWZPyaWDC2d0J9e085KYM4EoUN4sMk7crdYafebijfzTPki/+rqgLLZtypE8jMI+NEcELzs6EsxdmS469+PoRKP/KNWhYVYQbr5k80LDruuHJ5ysVo6KnTk+Ci783XnLs769VQnOrd9gjqLcuL5Q+84OdsG5L64jva7TK+XYnhrBYDG21W2BvNQE6WTommGBmZpOX1biwS2/Si9Pk+vdwM0+rxZZcAGNBN4uiAIIQVBwPCgH4JQGCGZRvcMpMt8Avf0o+D68TevfjBjhS0wOT8qXaubOrD3buOw4GgxlYZmigJ+SZID/PLjm2dWczCOT8DKNcjF82qNdwD+o1eHJP8nIOV3VGylkyPx0s5gEnasM2J/S6g3GqpSdCOwH6aAuPw4DSsXC9WIQs41GDUcfkyamtawtVrNGWCaIQn0iXFSdAXrY1DCoPE2UQhrR2DmRl2KOWYTIR02K8YyBMZBQhLYmFaVNTpeZGezdcfE4WeaIm9GJCz7DRDeUH1TYJEiE5QQltwQQrpCabCIgDAPb1BeHTzS2weP44yXXcumIH1Vp+vzKUFQh6IRgMAsdysGDuOEhMMEY+e+fDemDZ+NxpwmjLoK/1yKYMScowHREnVBtYMU2eodUVBtqaHpf2M15zbpYJzlmUHTNfVoZjROVmZxpg8kRlw5gyaRyVwenj9XWwd39nRLv3J9SqyYnKVc+nzVRea3WtCz4g5dQ2dEiALim0QsUhNwQCfsV3cKGqwAfBamEkMB+tbgN/wAdGgwnicWKZ0Rp6vs2dgmLqqIGF9H4NreM40S5HtrsvZG1zxgSIR3+QF3iipfyjXu55ZxcMOy+eH6+DY3Uy4AQoLEgeVhloJnl9fXDkWAssmp8fOT53dhrV5BWVvSr6X6TrOxfPS5c1DicECewG0RyfgyyERWSSWHf0HiWfcYBaRqejgzEMmOQaus8fasP9E5HiDmiioXh+eECvXrsFliwoJd29VFv//tE3JX8XFebCFRefPoJr8NPrYAeZEE8/NGdE9yGQBsETCL/4sgGWXzfw3ZKidCpP/61HzaKBvz6m3ISzxdkdmp8TpxErZBGZ9PpBYXIQhs2UZYjMuIvedcdjEgQBetxeOHSkMTTDiqTU1AQFtHUNTlj17h44/dQpADKluWF7PaQl22DVc7EXMhw6XK/ilLP0/Hgd/c+QF6I7Y7v3HoWqmuPSIkgZPh9HzYNetwj1jW2Qmy213YMqjVbu2PanLytaSZm2MRKCVb0H2hcysW4wfu+dgbc/OAIvrNpM7EYvvf9bbjgDrlwmXeX+yuqtMLtsEuTlpClKWLfmVzHP4Onzwb8/2gVPvbRZYScb9CZIdGRAEpH+Z+jz9UUt6/3PyuGzrdWSctCps1tTINE+jjqb6zYfgguWlkkaZSDgUzG3glB5tDkEthgaT/tk40Gob/ZCkj0BxgLPUZhldNFhj28NjUAb9GawWZKp3Yi2KMsqVxIvml8MX+xqHHapaJ78+YX1IXVATAkEF8/Bkc7ulOJ0cNhCThhGEnx+PdTUi5FniNdReQRDc1JN7Wzrga27nQS2cdIIBIHbaLCQsvW0jDffOwx/X7WFmjFoQ5qNdjAZbXDnLUoN/V//szrUkOl1MmAxJxBHNJtq/TGhoaPcgi7ap/2aIm7tLVJxFqODQo0VjA4axxkU+ebPmQxf7G4afjMh5V64eDp9ZYg+8PpYOFrjp47fitvPArNpwAHc/5UTnnz+kOQZ3vrbteDuc0kanolAi9rcakmU2NtYB3ge1NTnnZMFZSUzifUUDJcnhuLVKjHvRfOnQmlR7kC90nI4UrYOHv3LgbgGeqAHE6MDHesGhTjW0LhvniG8dx7LeMFmNUeNJAwnoYnBEcfkN7dLV6jd+/BOAiMrgRnTwUonjXL0x6Wxh7justNIPmbQVYauU8eZqCaWh9M8fUH4YF0jmM06mDwxdVjXmULsfhTVyAvPx20cejiWg+5EvxiPD2DW9BzVzzDG++Y72wnYsaMih4+1wRd7OuG8s0sJlAPmy5yZyaThK3dY3bb7GDEPTAQgXdgm1sOcWROgYELysK+7qroL/vVxNSlndOaIoBmCZsxYTbqhPL+xMicpO8MEyUnKAREEOTcrEa64ZHjhtIef/AR2762GM06fEjm2+Mw8aGjskkVP2qC6vhsS7ObIMwxFPISRRWuIvY2DJ7wwOsPVAWJ6GcbCPipiTJNDrcMeSxpahNLilCha1wl63fArGM2GPRV1EqBRW0+eJI2SHDjUSCMTaBMPOIV+uofbiK4cB4h4v2olvfHPzfDE39ZH/e5LT9wIRVNyFT1VXNvQQyhaHQwR5hgLQOPgRNHkJNXPONagCLkN1TjeW1cNP7nWBxazMWquvfubiF0cKrv/GaKGrq5Duzq0gjktJQFSU6Rx8bb2bnC2uyLVV9fQFdLsqo6vDszE8VW7fjo5CRjV+hzDcegYJkckyhH/t45hrimT0qJoXN2I7hHz6nVm2LXnGCyYVxQ13+c7WyDRkSmbesvAE89vhx53O4X6tp8shKsvle7P/emmcvjz3zeGnEVybRiHRlFtjMRBTUnMUY3e+AN9EWdUfv1xXaf9jVcccZSDiWiVeE+FkyxgNuuH3do3fF4B6z8/QN/f999XK8JGOp2RaODGqEDv3nuMaGcjDZVJnx8LRmK/ipZQGJFldKpa12pKpDCzbCg/rQuVOlo0vxCmT8tXnW6KTmpOpl3FhBHGRJ1GY1Y3tK0S7ypahLLi5BH5FiVF4yEjPSlKp0YeGjFT3ltXAz+9Tt3sOFbbRqFnQDqIgbFqizkJTEY7cc58qpoVjyXYMyLmSqgHUTc5UpKtVEYKwliwoU8gyjE2TA7URlOnpI7IFEO7Vm7bDm4A6BiiI7lzTxUsnFesyPPZ5moCr5U+Q+nzY2HlX78X83ovu2gmlf50tLoL7n5w26gGB8aGCR1DQ4sxnEJBiO+7t1rEqPZzbHc4uoZjgAM9Z4K9FQ0KoNGpq2nogwSbQ/HshBMIvYWiHLxqBVIHsi36rwyPz0tX9CA4UBbvdRqL2ahzOeJ96Ls/nTo9+QRaemxzW6SmgR627joOt/5M+vGO3VU0XMcMCtf1J1+gb+Q9jBgk9rZPtfo+2bAPHn9+vXo0g/x75X9vgKLCPBUNPQaGvsURmxxjoVcSYEKeY8TfO1hZB/v219D311y2QD3CQMyO7l4lSCXFecR+rqEOnbK340/oHqJ9D+1rK7HJWVbpCuGqFbUoxxiq3BhRjjFqcsyZkQRnnD5+xN5yq9MFh460qKoBuhqEPBOc/DSrNFPxeV5OCuTnOKC5RVR8H783/6LHweMNmQl33XwWaTALJXlWvrURHnn2s4gTabOkEklRrUCWOKcOKzqQyggOhu0YYFXr8ztpckCcRznwuieMt4HZbBjxdxedUUolmmagkQLydlZZpmqWhXOzYOU/6xU+OTYCg94a7vYFyWLYgS6VA5PBTkNxOIkIY95MFE17xSWzqHyXohxDOT9RTY6hhhi//dENnkhAcqy2vhXG56Z/Pacw/ExwJC4/T/2XoWedkgmvrqlVzGrDGXUO6zgQzDzdPoFjjSqmjBESHTmgw7nbTGgkM3YfOvIbiGeemeGZHLHDXvGYgnxQElVoa3fB1u1fKYE+AacwNMmIh8LJ6r/8lZudCHYrQI9b/uzYyLwRjjh60TS0UWelcezIvZC8o0WhMFYGVmCkTmGcRzlwROzjjUeg/OARqql3lTfB9VfOHf6TiWG74TMpneoASwxzZsmZGbD2g+Oxu/6oPYDULIiW9+Ah3CahOuo5li4+BVJTElSvPz4rladc6lgls8QtCEaADgqil2SSbP5s1ovQF2CIt0w0CWeMx/gOHKvzQHllO516iV24w24b1ldfX7MRHnrmE/q+fN39qlDPKJUO1ng8PrBYBp5TSVEqvP1+U1T7VxzKrBlGXozEPPbcpqiTkE4pnaACNMTtTlhieE642aC8i6AA3gjQ/gB4dAYp0A7yl5eYoEKgm9iCqXF4++iA2WBRWQbceM0Man3l5iQOy1vGbn/x6UVw8/ULFZ9NmZQCl180HaYUSJ/J2ve/gB9cPpB/RlkOPHyPGV5bcxjKv+oatrN9wdISYmtb6LTTDVuboabBHTUvQxqp1ZwS2fdjdtk4SHCYwqZFENJTE8eUUygE3bTpWg3KVhkMAgb5RXwSotsPHUQjS0Yg0mwCtPZwwHvbgTHEH9CoGXU6EyQlJBBbd9zImgJxxNJTxkFRYY4KEIICZkzvfbof5s8pktjoUwpSwGbtn8/BKDRlT69yFQqaMZdeOJW+P3ysE6rre0N1J6pdJwKdSud94DmWXzdf9doG/IjuuB765r1t9DXVKigapdvPYCyUbqErdHvFFvkvDGUnhRwHvq8lTvcUDtlZ8kiHPNXWdykeTrTFp/2aTw2UwzVuKD9Qp3ROiUOHERe1azxYGXuHUNyoZvC+HkqPn6UDPBgJYVVGJuWpps4Z2WgmHoXvCz2vEJtSXnt8IjosAmpovqWbqZ6YLEo2rJiYEgbaUxfXm83EWie48q3PCYguyMtJkKvh0EibLOEi2YamdskxnIz/1HOfgJGYN2verYC5sydL7FY8P16HYuSQPNKd5a3w2FPvwvnnlEkDU/Q/B52u7khj6On1kgZQH9k0h25kQ471VzZdDSNGnyuCNv6rb+6Ma0ef9zTQ10mpys0aCcM1+LgZsBel/HmZ76brZwf/ODhDXQcLt62xAaOzgaV4BcTj5n6oTd197eByN4PfH9p+tnRKOkzMS4Ud++rB1YMjcWk0X7enhebBeRgWYpeOS7ZAyVSbZHHq7ooW6HAJdHfPQLAvtPcfTgk1JVHxBzzQ62mDAO+ljcJgsEKCNZPaufLhaZyv7PW5oNvdAj5/r2KtIa77w1FALBfzYrm9fc5QCA+dH50RbOY0OpKIc6/9ATcUT8b9N4I0pChPuyuaocdjoXFwHKyJx0Cd56sHQSQ+3dNX9UJWgvR5/WOn7je3rTU+h0858Oou/a4fzQoKzKCx0jyi1lMsInR4eknLaATWnB2XsUrsjg06a2i/C3LgcI0HKqvr6OQiszGBVi5qt/48mB8BQXA/2lRH4e3XnLjHBwrC2b/lAOY1GxNJOVbqTOI+dFww5LXQrQnwt2lUtCITjklbTMmgY42KVeNYbmi+NN1hkJZlNiQCrwv1HGhq4DGIzLlmSSN10kaiXIEeunaLyU4XEMSjhhb6Ggmp3dR+znJINTR2qCv36HYhywi0f1cDe/x4D1RlOsTJgws5o8AP/yo3At+5BxhTVhy2aoZCYydaSaTr8kSqvVAbhuY0h7YYYBk9sFYdzRMactaF8+giq62pk4m2Kn4GAs2LrNFGwBkoKPietehDOyPRH7thKayhedGiqlOHjQHNFbmGZmjjoju1UfgxD15vfz56neSc/YsI8Nwmo4M2BHnkhl47uUY9Z1adBRgX5kbXXvo6f1JA4SEf72GqttdyaEP7qYYm0runkd2WYQ9KgF7QD3TXHuDSzyE1oI+/4B2BwjCouw+t/hApCP1TERE8g8wkwEqnGlIctPvQoO+oR1Y49e5cjD54TRsCF317lH74aMOLssCIztHGbclIL6HnLMqQyKBrj0v7mTj2fOeXESbl97CnkcMVEL1UQ3f8vodP/q3d/cwWw4fnTgleyw4yO/KTeCgcF4TKFg8ESYFs0hyI/8QODDCIsbU76dhlUH7bQ15sVNvr23/tMXgm7Im8h7KITA5urzh5ENnFyB0qcl34074tNdyx2k5m/4RkYbDLDZdN98KDH9tAaFsPjOMU8swMoCUtfXM0+0PshVmU9z61nex+ZBcZDjXp0OeYs/31L/Vr5b9qOCMnAAVpxCYM9tCCtaSlb5Tn9vWUPWQQWZTzSZkl7IYZxl+SFaH9Phfa0a7HNxk3N7iYKhEG/uG3fjrPQ2w4Yn91bQPR26T9EKQm34wga53bKHvIIIAo+YesIrPIbtgXDGvokJZGo7rlld2GNfJWMDE5COdO9dLZTkLTajpJRPvJXk1OqhDGhObVlDlkDxmUc/nal/o1yGyY3X4vIkI0Ruydj240bqh0svvk3772VDdMwEID7SAex3J4UJxBE01GRfgQY/52yhyyJ8+DjD68wbQBmQ2zCxIN3X5vFwY4u4k03fme+UUfzl4aVIaeGCe3LewBm0EExl0J0Pq+pkU0OSmCbCFjyBoyh+wNZhHZREaR1TCzkSA+d9fSgTnCj2w0o9oV6rtYJsEkwuzc4MzBBrrNKMC0zABsqTYC39dEjXXRUhCXw+Ja+la6gMA4/w1M9y4w6kRYsdQFeUnK+Sl/3W56+eXdxnXk7bEw0KIq0Hct8ooEajSumfVV+p4FE4PZOQmCZGOHZIsA+aQb2FFnBMHbTLqFFhDNkyM/16IlLZ1oeI5tfQuY3nLQcyLcvqgbpmUoJ4h9Uafbsvwt6yvk7eGw/SwhnrvrHOneaARoVN84RY1975CheVmxryTRJJ0rnengoTA9CLvrjRDA+dLugyCa8kDkbFrFaGnEiSFKkT3+KjDeWrASM+POJS4oy1LOkqzrYo9d/A/Hk74gcwj/7A/VxRxaavtthxgedal3eZmjP3zD/nSbm22W55uW4YcHzu+g2poJdADX9DdgO0kvIAa1GtLS8BJhBZnhmp4nDDkpS8gUsqXgkjD4g5X2p5BJZBMZDbMqbRzOR9RXLqf9IQUnbuBSj+KSjOD0Vdf03JZuExQzlAI8Ayv32OHDSkvIqOfsIDjmgmAn5jej1ypNSyogB4Dt3QesawswfDddS7F0igd+OLOHmhtqMF/xuv2J/cd15eRP3Oe4xXlPeyDM6fCADmfGqWIIcVFuolD49rXdv8hP4iep5a3u0MOLOxxwtC0EschaQLCWAk9ENGRqlaglYlo0A+euAJYII3josYLUANx4WjdMSFZfWVTfxVZftdLxzJE27ivy50GMbBCYfYMYlQOdFvMi0v6QipNucTJ0IbGlJ758VffVc/MC81UbHpG9jUZ4Z78NDjsH5nyInBVEYz4IxmwQ9Skg6pIo8MAYxvb+a99J7Ytzlf0UWCbYSUyJdmB9jcD4aog2dkeyTUnzwyUlvXBKti9qjGxbnX7rj1Y5VnZ5GYxmVBJpdN7T5pXxKQP64bQhrzHtfgo1qlmcXpp39xL3mT+f473SwImmaN+p79LBxioL7Kg3kS6D0ypaS5Bi4WFOnhcWTOqDvMToaz39PHj/b7t59f3rrJvD9jJGNJqdd7d5VdgcOdDhL6L5gZknEsmfnhkc//j5vZeS1xlDfbe5WwdftRqghpglx3s4cPbqoNfPgDfIAi9oFT2WEkc6XJNOoIMiqTYeMu1B4uwFoCjdD5mOoQMG+5p1e3/9vu1t8lpL/qyBUKzZSWD2ReFSBvRDw9+iIO2BNDSQcbMH/K2wCUTSl8/uK/n5nL7zcxP4fK06tXSiqd7F1Ty7w/zBczvMFeRPXN5dHdbOXc4VzkAMJqVAtz40sj030h9IQ6PXGo6A5IWdxsQfn9pX/ONZfYsmp/JTGW3oUEvDMbfJf+LsHXpht3nDC7vM6PDhjjw4nI0xZhw0cbeucApD8Pj1gA4XgsCitsb1+hlhpxFLdszOCWTcOKtvxul5gZJsh5DLRF1GoaXvKMRCYzdb/0Wdfv+Lu817djbocS0gDl/jJKNGIvg3nQ5KYBaHwaIc6JQTvrj0B9IRVmMY7LQw3Fgg/p6YOSeBty8r9k2YmRXIyU/iM1IsQrJFL1pNOjDrOdHAMqB5i2MwCSLwAZ7xe4PQ5wkw7nYP21HTyR3/sknfsPagsbrBxfVAaIUJvraHIXaGQfa1rmgVRsCgDOgHU772DaT/MQK2LWxjY6H40634exC4atQQ1ug44YMNCwOaaTKGFTEVISzoDaId7A+DjBq5Mwwzmhm9FOTftAonwJ4UaLAXjeaNMGFoMZxnCYstLJbwcTnYWhqDSloGMobbPGFwe8PvPeHjQRjFDVF1J6FlBsKC3QkXBljT0JqG7tfQ+MqfrBP/vwADACEDIyDLOMXrAAAAAElFTkSuQmCC"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCNDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNkNBNkJCNTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkIyM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkIzM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++LpzqQAAEvFJREFU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"

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userBet', 'userinfo'],
	    ready: function ready() {
	        console.log(this.zoomRate);
	        console.log(this.$els.image);
	    },
	    data: function data() {
	        return {
	            headzoom: 1.2,
	            headborderimg: __webpack_require__(92)
	        };
	    },
	
	    watch: {
	        'userinfo.headimgurl': function userinfoHeadimgurl(newval) {
	            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval);
	        }
	    },
	    computed: {
	        headsize: function headsize() {
	            return {
	                width: 142 * this.headzoom * this.zoomRate.x,
	                height: 165 * this.headzoom * this.zoomRate.y
	            };
	        },
	        headborder: function headborder() {
	            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y;
	        },
	        headstyle: function headstyle() {
	            return {
	                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' };
	        }
	    },
	    methods: {
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        cancelbet: function cancelbet() {
	            this.$dispatch('cancelbet');
	        },
	        checkData: function checkData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        },
	        changeData: function changeData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        }
	    }
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "<div class=\"state\"><div class=\"state-item money table\"><div class=\"money-state table-cell\"><div class=\"button\"><table><tr><td><span class=\"money-num\" contenteditable=\"true\" @keyup=\"checkData\" @blur=\"changeData\" v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\" v-html=\"userBet.betmoney\"></span></td></tr></table></div></div></div><div class=\"state-item portrait\"><div class=\"polygon\" @touchend=\"showMessage\" v-bind:style=\"headstyle\"><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" v-bind:width=\"headsize.width+'px'\" v-bind:height=\"headsize.height+'px'\"><defs><pattern id=\"image\" x=\"0\" y=\"0\" patternUnits=\"userSpaceOnUse\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"><image v-el:image=\"v-el:image\" x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"></image></pattern></defs><polygon v-bind:points=\"headborder\" fill=\"url(#image)\"></polygon><image x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\" v-bind:xlink:href=\"headborderimg\"></image></svg></div></div><div class=\"state-item stars table\"><div class=\"money-state table-cell\"><div class=\"button undo\" @click=\"cancelbet\"></div></div></div></div>";

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(95)
	__vue_script__ = __webpack_require__(97)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetMultiple.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(98)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-8ff4067e/BetMultiple.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(96);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n", "", {"version":3,"sources":["/./src/components/BetMultiple.vue?3803979b"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA;IACA,iCAAA;IACA,YAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,aAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,gBAAA;IACA,gBAAA;IACA,eAAA;IACA,qBAAA;IACA,oEAAA;IACA,kBAAA;IACA,mBAAA;CACA","file":"BetMultiple.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.multiple\n        div.bet-button-area.one\n            div.table-cell\n                a.button 1X\n        div.bet-button-area.five\n            div.table-cell\n                a.button 5X\n        div.bet-button-area.ten\n            div.table-cell\n                a.button 10X\n</template>\n<script>\nexport default {\n    data() {\n        return {}\n    }\n}\n</script>\n<style>\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 97 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multiple\"><div class=\"bet-button-area one\"><div class=\"table-cell\"><a class=\"button\">1X</a></div></div><div class=\"bet-button-area five\"><div class=\"table-cell\"><a class=\"button\">5X</a></div></div><div class=\"bet-button-area ten\"><div class=\"table-cell\"><a class=\"button\">10X</a></div></div></div>";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(100)
	__vue_script__ = __webpack_require__(103)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\Message.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(160)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-33fdb807/Message.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(101);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(" + __webpack_require__(102) + ");\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n", "", {"version":3,"sources":["/./src/components/Message.vue?5d23d056"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,aAAA;IACA,mCAAA;IACA,0CAAA;IACA,OAAA;IACA,sBAAA;CACA;;AAEA;IACA,iCAAA;IAAA,yBAAA;CACA;;AAEA;;IAEA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,sBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA","file":"Message.vue","sourcesContent":["<template lang=\"pug\">\n    div.model(v-show='dialogShow',transition=\"message\")\n        div.dialog(v-bind:style=\"dialog\")\n            div.close(v-bind:style=\"close\",@touchend=\"dialogShow = false\")\n            div.content(v-bind:style=\"content\")\n            div(v-bind:is=\"dialogImg[currentIndex].type\",v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\")\n            img(v-bind:src=\"dialogImg[currentIndex].background\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo'],\n    data() {\n        return {\n            dialogShow: false,\n            currentIndex: 0,\n            dialogImg: [{\n                type: 'betInfo',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'bonusRecord',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'ruleIntroduce',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'recharge',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }]\n        }\n    },\n    computed: {\n        dialog() {\n            return {\n                width: 550 * this.zoomRate.x + 'px',\n                height: 760 * this.zoomRate.y + 'px',\n                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'\n            }\n        },\n        content() {\n            return {\n                width: 478 * this.zoomRate.x + 'px',\n                height: 618 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\n            }\n        },\n        close() {\n            return {\n                width: 42 * this.zoomRate.x + 'px',\n                height: 42 * this.zoomRate.y + 'px',\n                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',\n                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'\n            }\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.dialogShow = true\n            this.currentIndex = event\n        }\n    },\n    components: {\n        betInfo: require('./messageComponent/betInfo.vue'),\n        bonusRecord: require('./messageComponent/bonusRecord.vue'),\n        exchange: require('./messageComponent/Exchange.vue'),\n        Recharge: require('./messageComponent/Recharge.vue'),\n        ruleIntroduce: require('./messageComponent/ruleIntroduce.vue')\n    }\n}\n</script>\n<style>\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(../assets//.png);\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZEQzMwRDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZEQzMwRTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkRDMzBCM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkRDMzBDM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+X2ymawAAAA9JREFUeNpiYGBgmAkQYAAAngCaoMXLCwAAAABJRU5ErkJggg=="

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    data: function data() {
	        return {
	            dialogShow: false,
	            currentIndex: 0,
	            dialogImg: [{
	                type: 'betInfo',
	                background: __webpack_require__(104),
	                close: __webpack_require__(105)
	            }, {
	                type: 'bonusRecord',
	                background: __webpack_require__(106),
	                close: __webpack_require__(107)
	            }, {
	                type: 'ruleIntroduce',
	                background: __webpack_require__(108),
	                close: __webpack_require__(109)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(110),
	                close: __webpack_require__(111)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(112),
	                close: __webpack_require__(113)
	            }, {
	                type: 'recharge',
	                background: __webpack_require__(114),
	                close: __webpack_require__(115)
	            }]
	        };
	    },
	
	    computed: {
	        dialog: function dialog() {
	            return {
	                width: 550 * this.zoomRate.x + 'px',
	                height: 760 * this.zoomRate.y + 'px',
	                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        close: function close() {
	            return {
	                width: 42 * this.zoomRate.x + 'px',
	                height: 42 * this.zoomRate.y + 'px',
	                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',
	                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'
	            };
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.dialogShow = true;
	            this.currentIndex = event;
	        }
	    },
	    components: {
	        betInfo: __webpack_require__(116),
	        bonusRecord: __webpack_require__(122),
	        exchange: __webpack_require__(128),
	        Recharge: __webpack_require__(140),
	        ruleIntroduce: __webpack_require__(154)
	    }
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMDVDNDY0MjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMDVDNDY0MzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAwNUM0NjQxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Ii2N+QAAGLNJREFUeNrs3QtsXfV9wPG/n3HsBFgSVlh4dUBR2MLQIBVUiBZaJlJVtBsqKxq066oKWB9ap02aqgl164Q2TYNJBQn2VEc7ujKmlTHoylZaVA1UYCphDQXKKI8MKCRQHDv2tX2987vY2fG55z78uOYGfz7SX5Bzr6+dY0fn63P+5397ZnfdmZagNxs7snFeNs7MxtuysTUbI9lYlwCAtWIyG2PZ2JONx7PxYDbuycYD2ag2/KjtO0s39y/ykx+TjU9k49eycazvBQCseevmxqbIjWxcPLf92Wx8ORs3ZOO5dl+st83nbZ574Sez8XuiBABo4di5ZnhyriE2r1SYXJKNH2TjN7MxaD8DAIswONcQ0RK/2urJ/S0e+0I2rix7sPqT11Jl9xNpes/zaeblfak6uj+lqek0Oz3tWwAAa0RPf5YLA/2pd+OG1LdlU+rfenQaPPXk1Hv4YcWnbsnGV7Lxrmx8KhulwdDTYPLrcDb+IRvvKz4wveeFVNm1O0088D3fDQCg1NCO09PgaadmoXJU2cN3pDh7sn3neDthEmdKbsvGRcUHxu++N03c96C9DQC0Fyhnn5mGLzi37KHbU0yU3b5zuhghRdcXo2T6mT1p7Ov3pJkXfmwPAwBtixMaU089nUYuPD/1H7c1/9BFc82xYMpIcfJrTEq5Ir9h6skfpdFb/lmUAABLMvPCS7WWiKYouCI9cteljcJk81y5HDT99HNp/213ptnJSXsVAFiyaIloimiLguuzODmyLEz+KL0+Y/agsX+7J81OTNibAMDy4yRripgaUhALs32+GCbHZeNj+WfFRNc49QIAsFJmXnwpjX/j28XNv5Eeueu4fJhclY2B+UdjbRJ33wAAnTBx/0O11sgZmGuRWpjEuCz/6OTDu+01AKBjSlrjsvTIXb3z7xJ8zPzW6quvpckHH7bHAIDOhUnWGtEcOdEiOyJMzs9vrTz6hL0FAHRcSXOcF2FyRn5L4ZoPAEBHlDTHmREmp+S3xBvyAQB0WklznBJhcnR+S3X/mD0FAHRcSXMcHWGyMb9ldrJiTwEAHVfSHBsjTAYXbJqZsacAgM6rb47BXnsFAOgWwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAndZvF0CH/5FtPyOtv/SjB/8888xTafzGP6v9f88Rm1P/qact+bVn9jybqk//sO7z9Ww87OCfZ0dfS9OPPNT+byvHn5T6th67YNv07l1p9tW9i/67ljlwy9/Wvp51v3JZGjzzrGXv3/nXm7dSr9vW/s99LwFhAoeEiISBk08p/weYRcnGz3x2ya89fvttaeLmhWESYZD/fLMHDqRXPnxRy/iYN3jWuWnd2efUfZ6ZJx8rfX4+Wpr9XedNzEVTz8iGls9tx0QuwlbydQFhAm8K8Rt7HBzn9R35lgWP923ekoYuvzILihs78vmnHv3vBQfmnvXrayGSP7MyeO570vBFF7f9ms2eO3rdNWnqP+/xjQeECXSjuIzQ7Df23k2bawf6ToVJ9cXn6/+hn/JzqVK45PNmFWd24gxPJwyd867a9w8QJrBmTO95Ns2Oj5f/gz3muNoZkKYf/9j36z/uZ09KldWIguxrbxUF8ZylBkQ7YRBnbzp1Bmdg288LExAmsLYc+OrNDQ+sG6+5vuX8ibhkE/NK8gEz9O4LU8/whtS75cjanyfuuK1hFMTBt/g5Ju/7Tpp56cWmoTH/uYtzXlYyINoJg4F3nJf6TuzMHJO4DAcIEzikxJ0aeT3Dw6m/MNG0U5ca5k0/90xdXOQntI42i4LLr6z72Mr99x4y80giShYzfwYQJvCmVrx9NH6DL95506n5JfOKE2ABhAnQUNyVU7n33zv2+pP/cmvpJZlOa7YuS9maK50Q+7XRrc3Ltf6Sy+vOfgHCBA55calhJQ6e/ce/te5W4BDriox+9pPLXsBt0V9Pk3VZytZcWazZ8bGWz4l90akAGnqfS0QgTOAQ13vU1oYHubIzGrFSa7sGf+EX0/TT7zl4wI9IGbnitxY8Jy7rdPrS0VIsJZp6hkda7+8mi8ct+2seHq77c6x2u5iVdQFhAm+ogVO3L+r5zQ5yrc4YxJmC4i3FcfDsxjBZ7qq3DWNtkYvHLevvkAVQrLQ7Kkxg5X6Zswugg//Ast/e46xGUVzWqL78Ut32qSeaX96Z+NpXU3Vf8/esmXr80bqDZ3wdqyHO9sTfYTp3C3Gnzazi5wJWIfjtAuic+O29NDBuvrF2t05+bZDZsf2p8s27mr5enE159YoPLXijvuKBefrpp+piKL6O/PyOZm+2V7ZWR0z6bDS/Iv8mevHfOHtQdidSJ0SkVdfIirYgTIDlh8kZb2/4WNl6GyOXfmTRnyPeqyZ/cJ7+3gMpFV53/QXvrd2lczCM7rhtUXfsNLsTpfgmessRC8PFGixtPXd8rHYGqSz6FnPpatOtdy/4c5zxiYnDgDCBN5W4fPJG3FoaZy2KK7/G/+dDZKJL91lEyXKjICbVbvzcn9bt+/1/eX2qfONry3rteIPGeC+kvMqD96fJf/qSH3gQJtDdGl3GWQ0xz6RsbstaELdK77/umnT4569dEGcbPp4Fz8f/P3pavStyWYQUzzLFXJpWl98AYQJdId5wblUOxCW3F8cljoG3bWv4hn/Tu3fVDsylQXXWuQuWrw8xWbfRuivxWt0mLm3tv/G6Zc1z6RnZ0PJy1/hf31ALIUCYQFeLyZ+t3mwu5kHEKqVla27EwT5/wIvf3svmn4zd8sXS24tj2ysfvqj2dTQ6q9DobEHZG+BFlBwq75UzL77esaO2puEPXNLyHZmXImLN+iUgTKDrtfMOwAcD4SevpPXZb/XF+RBxiWD0c79bC4hmUdJqbkMcnOPrKdu+FsT+iVG26FqrMz3NlraPs1SiBIQJHJLiLo9GoVJbOj4LkOJkzfj/2FZ56Luli4XFb+vtTLiM24LL5kWsNRElxTNBcZv1Yi/DFM9kAcIEDr3f2r91d9MzKM3ipOyunsn7vtP27bD9p++oP7j+4Ptrav/HXTobrvzMgss5EYut9mHETHGOyuvv93OjH2roICu/wgqLBcdiYmmMV3/nqrZuUZ2Pk1ZnMyJKxq79g7a/lvzaJQfD5H/W1oJk6z/063VzTMZu+vOWHxeXu4or8cZ6MBE6gDCBQ0bMPagd1LKxmFVJW8VJ5eH/WlSUxAG07EzN1He/s2a+F3Epa+jdFy7YVns7gDa/L7EQ3YJ9mgVOhA4gTGBN6Dv2hNS3aUvpY3H7bxxo2zXw9nPqo2kJ8ypWU9n7By0lRuJupMFfen8a/tgnFr7+vr11l2JiMbpGIi7jLFVehE6ju52AFfiFwi6AlTd0+ZUtnxN328RaGXm1SwUNbm2N7Ydd/ce1A2X+PXaKt/LGXTixXHuETF2YzM0vKS7D3kptrkWDNUHaXcI9vyx+o+fH+imDf3f7om7vLS6UFu8B1GhOz9gXb3o92rKwmJ8M2+pzHbjty3XrusT+qH7kitot4fs+eIEfeBAm0N3K7qQpilVFW91WXHZHT9niZ/kDc7PXnPnxi2/YPikui9/seZ0QQTe/n8rep2heRF1eXPaJjy3u91br1ABL41IOrLLihMpGIjjizEK8x0uzyw3titdYreXTy1ajrYukVbxtOS7hxJmPtr4/ux+p2xYfuxLfA6A1Z0xgFcUE1rJ3xM2LeSCT937z4DolcVdP9fnn0tD7L0k9wyP1ETC2v+XnjdfML5/ebhy1Y+aZp+o/3yMPlZ5lKJ6JmPiPr6d173jnip4laeeyUlz+ivAr2162+Fx8ra9++qOp/9TT/BBDh/XM7rpzNr9h3x9ea68AAKti09W/veDPLuUAAF1DmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAArJD+bv8CZ7OxrzJVG6NTM6lSrda2AQCt9fX0pMHenjTS35c2DQ7URo8wWZqIkafHJ9LETNVPFgAswczsbDowE6OaXp6cSkN9ven44aFaoHSjrryUE2dEIkgeGx0XJQCwguK4GsfXOM524xWIrgyTZ7Kd9b8HJv30AECHxHE2jrfCpIW9lSlRAgCrFCdx3BUmDcQppR+NTfhJAYBVEsfdbrqk01VhsndyqnbXDQCwOuK4G5NihUmJfV12OgkA1oJXKsKk1P7pGT8dALCGj79dFSZTsy7jAMBq66ZpFF0VJlVLugLAqjP5FQBAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhYhcAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCpAv09fT4jgDAKuumo29XhclArzABgNU22Ns9OdBVYTLS1+enAwBW2Yb+7jn+dlWYbBoc8NMBAKvsp7ro+NtVYbJ53UBXnU4CgDe7OO5uFiblYobJCSNDfkoAYJXEcbebpnh23emJqLafWb/OTwoAdFgcbzd32TSKrrxuctzwUDpqaNBPDAB0SBxn43jbbfq7cWfFGaW3jqxPhw30p2fGJ9LETNVPEACsgKG+3lqQbO7SG076u3nnxU6LO3X2Tk6lfZWptH96JlWq1TTr5woA2v5lPya4xi3BcUyNG026edWw/kNhh27JdmIMAODNzb25AIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAoD5MKgu29PXZKwBA59U3RyXCZDS/pWfdoB0FAHRcSXOMRpg8n9/Su2HEngIAOq6kOZ6PMHksv6VvyyZ7CgDouJLmeCzC5KH8lv6tR9lTAEDH9W89urjpwQiTe/JbBre9zZ4CADpucNvJxU33RJh8NxvPzW/pPeKwNLTjdHsLAOiYaI1ojpxokQciTKrZ+NKCgjntVHsMAOiYktb4Utq+szq/wNoNKbeeScwzGTr7THsNAFhx0RiFOa2VuRY5uPJrnD75q/wzhi84N/W95Uh7DwBYMX0/vaXWGAV/k7bvfC4fJuHqbOzNP2vkwvNSz9CQvQgALFs0xcjO84uboz1+f/4PvYUHPpl/Zv/xx6QNF7839QwO2JsAwNKjZN1grSmiLQo+nbbv3FsWJuEr2bgpv2HgxBPSxkt/2WUdAGBJoiE2fugDtaYo+IssSv5+QcDM7rqz+KRYuP7WbFxUfGD87m+nifsesocBgLYMnX1GGr7gnWUP3Z6ND2ZhUmkVJmE4G/+YjZ3FB6b3vJAqu3aniQe+Z28DAOVBsuP02i3BDVaU/9dsXJJFyXjxgUZhEmJiyReycUXZg9VXf5Iqj/4wC5Xn08zL+1J1dH+ancyip1r13QCAtaK3tzZ/pHfjhtp738Qy84PbTkq9Rxze6CNiysinsiiZKnuwv8mnig+4MhvfmguULQu+juwTxukZAIA2vJxiomtKtzTtnDZeKCbEbsvGjSm3CBsAQBsqcw2xrVWUtBsm85VzVTZOzMafZGOP/QwANLFnrhlOnGuIl9v5oGZzTFoFzY5sxCopcT0n3pI4bkzekF6fmwIArA0x9WN/en0V+cezEbfvfjMbD6TX34+v3PadpZv/T4ABAMFnY+3Ft1qIAAAAAElFTkSuQmCC"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMxRDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMxRTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQ0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzFDM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MfthnAAABlJJREFU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"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyNjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzIzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzI0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+M8ZK3gAAF+xJREFU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TAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMLnwv0xbm38RAJhjLS0twqRI27wOnw4AmOvjb3vzHH+bKkzmL1jo0wEAc6xzYbcwKdK1ZKlPBwBcwsffpgqT7t5laV67yzkAMFfiuNvd2ydMisTkm2Vr1/uUAMAcieNuS0vz5EDT3S4c1da78jKfFABosDjeNtPZkqYMk9C35orUs3y1TwwANEjP8lWl422zmdeUe6ulJS2/fH1asGhxOrB7Zxo9OewTBAB10D6/M/Vdti51L+lryt9vXjPvvNhpXT1L09FDA+nY4YPp5PGj6dToSBobG/PJAoCa/q/fUprgOn9hd+num7jRpJkWVLuowqS8QxctXV4aAMBHm2flAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAgIlhMlK5oa21xV4BABquoDlGIkyGKrd0tDmJAgA0XkFzDMWW/sotXfPb7SkAoOEKmqM/wuStyi1LuzrsKQCg4Qqa460Ik5cqt6zqWWBPAQANt7pnYX7TixEm2yq3bFjRY08BAA13zYrF+U3bIkyez8au8pbFC9rTTZcvtbcAgIaJ1ojmqBAt8kKEyZlsPF75yg2rl9hjAEDDFLTG45vXpzPl+3S+kSrWM4l5JhvXLbPXAIC6i8bIzWkdOdci51d+jdMnf1v5jk9vWJmWL+q09wCAulnW3VlqjJy/37z+7LSSypVN/iwbByrftena1amzvc1eBABmLZrijutW5TdHe/xJ+YvW3At/UPnOtb0L069+cm1qtxosADALHfNaS02xtrcr/9JXN6//8MRIyxPvjOXf8M1s3Fe5Ydeh42nbW/1p/9CwPQsATMvy7s606brVpRMeOY9lUTKuOYrCJJZh++ds3J1/4btv700v7TxgDwMANbllXV/6pQ2ril56Ohu/mYXJyFRhEiJpnsrGnfkX9g6eSK/3H06vvH/Q3gYACsU6JXFLcJUV5Z/Jxj1ZlBzPv1AtTEKsevJIyl3WKRs8MZJ+8sFQ6h88ng4eG0lHT46mkVNn0pmxMf8aAHCJaG1pKc0f6Z7fXnr2TSwz/7EVi1LPgqrP3ns0Gw9kUTJa9OJkYVK2+VygWNgEAJipgWx8NRtPlOJifZXQqeEHbcnG9enspNgR+xUAmIaRcw1xfTlKJlPrfcBROfdn4+psfD0bu+1nAGASu881w9XnGmKglm+q5VJOtaC5NRt3ZOOWbGzIxtpsdKezc1MAgEtDzBU5ms6uIv92Nl7Kxn9l44V09nl8hapdyvl/AQYAVOAKyrWfc2EAAAAASUVORK5CYII="

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyQ0I2ODYzNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyQ0I2ODYzNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJDQjY4NjMyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJDQjY4NjMzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IMkNPQAABoZJREFU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"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNkE4MjEwNjNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozQzNFNkNCQTNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM2QTgyMTA0M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM2QTgyMTA1M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jGVjpAAAGdJJREFU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TAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTGwCAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwsQmAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABg1YZJ1/Sk3wgArLTpaWFSaeqINwcArLCuDtr/dlSYdB/9qXcHAKz4/veQMKnSM/6idwcArOL9b0eFSe/4gdQ1NeEdAgArJPa7sf8VJlWmp1PfyG7vEgBYITP7XYNfG+sZfyGtGXvWOwUA2iz2t7Hf7SQdOY/JmtHh1PvT57xjAKBNYj8b+9uO+746c3PFKZ2nUs/ESJpYtyVN9/R7BwHAMuiaHE99o3s67khJh4fJrNhoL5t4MR3tH0yT/aelqd6BLFL6YrN6ZwFAi3/sd01OpO6jYzNX38wMdO2gMSUnVJjMbs/p1Ht4/8wCAJzc3CsHABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAA1IfJRHFNj60CAKxAhdQ1x0SEyUjxSf02FACwAmFS1xwjESbPFFb1rbOhAID2q2+OZyJMHiusWrvRhgIA2q++OR6LMHmgsGrduTYUANB+6zaX1+yMMPlmYdXgpTYUANB+g5eU13wzwuS+bNkzv6p/Q0pnb7exAID2idaI5jgmWuT+CJOpbPls4clnDNlgAED71LfGZ9PQjqnaBGufSPn5TGKcyaarbTQAYPlFYxTHtE7Mtcj8zK9x+ORThU/a+rqUBs628QCA5TNw1mxjFH0mDe3Ykw+T8MFs2V942vlvSKl3rY0IABy/aIqfe2N5bbTHX9Q+6C498MeFp67fmtJFv5VST5+NCQAsXU//bFOcurX8yK1paMf+qjAJn8+WTxbWbLggpW1vcVoHAFiaOH2z7cbZpii6LYuSz+VXVN1d+NZs+XJhTRw5GXpnSpuusnEBgNZFOwz9wWxLFEVr3FJe2TX98B2VbZMtX8yWHXWPjD6d0r5dKe3daWMDANVinpK4JLh6RvmvZMuNaWjHWKthEtZky8ey5V2Vj46/mNKBx7JQGU7p8P6UJkZSmhxPaXrKLwMAVouu7tnxI33rZ+99E9PMD25Lqf+0Rp8RQ0ZuyaLkSNWDvU2+VHzCu7Pl7rlAOaPwaHxBp3YAgNbsS7PDRf6l2ZO6W3ihGBAbN9D5+5SfhA0AYGETcw1x6UJR0mqY1CrnPdlyYbb8VbYM284AQBPDc81w4VxD7Gvlk5qNMVkoaK7MltdmyxXZcnG2bMmWdWl2bAoAsDrE0I/RNDuL/A+y5YFs+Ua23J9m78dXbWhH5er/F2AAstWqWoT5nd4AAAAASUVORK5CYII="

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyMTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyMjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzFGM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzIwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++YKmbwAABkhJREFU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"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5ODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5OTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjk2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjk3M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MTGWBAAAFjdJREFU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CQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAEAEyWh+w6K2drMCALRMSWuMRpAMTLpRe7eZAgBaFyS1rTEQQXIov6Wte7mZAgBapqQ1DkWQPJPfsrj3EjMFALRMSWs8E0Hy0/yWjos2mykAoGVKWmNPBMkj+S1dl15tpgCAlilpjUciSP4zGweqWxb39KUlm28yWwBA00VjRGvkRIPsjiAZz8Z9+T3dG95kxgCApitpjPvSmu3j1QujfSHlrkfScdHrUs/W7WYNAGiaaItojJzRiQZ57Uqtcbjky/lb9L7+3al9xXqzBwDMWfvySyttUfDVtGb7gXyQhD/PxtH8rZZddXta1NFjFgGAWYuWWHbVjuLmaI4/q37TVtjxR/lbdvRtTSuu+1Ba1N5lNgGAmcdIe3elJTr6Lyvu+mRas/1oWZCEB7LxpfyGzouvTCt/6+PevgEAZqR9+bqsIe6qtETBvVmMfH1SuJw+9FDxRp3Z+EY23lHcMfjkt9PQc7vMMAAwpVjAWrJmJDyYjduyIBmdLkgq95ONb2bjbcUdJ1/+RRre/5N0Yt+jZhsAmCSuMxKn9hbOpqn6XjZuz8ZQFiSpkSAJHdn4XDY+Urbz1NDRNPLC41mg7EunBl9M48PH0/jYcErjp/w2AOB817Y4tbV3p7buFZXPponLwccVWAsXPcuLJSGfyMbJynczCJKq90yESb/ZBwBm6EiKBawp3T9payFI2hq4o1joekU2vphyF08DAJjC6EQ7XFETIyXaGrzTqJuPZWNLNv4mGwfNMwBQ4uBEK2yZaIcjjfyhRt6yqRcy12fjlmxcm41t2YjzgnvTmbUnAMD5LdaCDKYzV3t/Nhs/zcb3s7E7nfmcvKkV3rL5fwEGAEDIMmUyEQC5AAAAAElFTkSuQmCC"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5QzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5RDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlBM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjlCM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+uB+DYwAABmJJREFU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"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwNzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTA1M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTA2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+E7Z1owAAIPNJREFU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qHeP1TF2xxi+OYKk2cyvxtoqrlr3MSsxAgDrKEpm13TmY3Y2dscYXryeyYYNkrhr7/S1qfal4GdnRoQIAKy/MJmZKWmP2zGGx1i+4YPk6vjZ2eNT9Zp1IwCwnmOkYszOx/IVtuIXRpu8+F5rkUz7vjSte9PUdAgArMMuaXbuI5c6QVLPx/KVtuIzJNcvX25fAK7zxCqKDABY+xqZ+XP3uJ2P5Rs9SKavTZZCpFZ6CwCskyrpftsOk3ws3+hB0pxuzD65TpiYGQGAddokxbG6VhrLN3KQdO4oqEEAYIPFSStM8rF8owdJ9bMDANZ3iayuup0OAKy1VQwSMyMAsLGs3ththgQAWHOCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAB4PwVJ094GgA1l9cZuMyQAwJpbgyAxUwIA69vqj9UrHiS1WvYjmk0dAgAbsUuyMTwfyzd8kAzUZ59VJ0ya6gQA1meEFMfqZmks38BBMjA0UpohaZbeAgDrpEa637bDJB/LN3qQDG7bNlta5UM3ZkoAYJ20SLO7Swrjdj6Wb/QgGRndmT2fRrY1U+d/4glqEQBYh01SGK/zsTsbw2Ms3/BBsmX32GxlNZqF4mrOLTIAYI1KJHWP0YUxOx/LN3qQjNy0Kw0MDWdPqNHaGmIEANZ1lORjdWvcjjE8xvINHySpVkvbbz2QPadGtnWmf1pPtClMAGBdhEhxbM63GLOzsTvG8BjLN36QZEYPHkr5U2k0CltnLYkoAYC1j5H2zEhhrK61x/DVsCpBMrhla9q+77astKbbWyNfJGM9CQCsbYwUx+L8JJT8iEZrvN5+6235GL5pgiTs/sCRVKsPzFRXs73NHLoRJQCw6jEyc6imMy53ZkeyMXv34SOr9iutWpDUh4bT2D33p+b0dL6l2EpR0izXGgCwvCFSOExTjJE8RNpjdGxj99yXj92bLkjC9n0H0o44dDN9vRAm2Y6YbnTNnCRhAgArEiL5rEhhJiQfg/OxuBMj1/OxOpZarKbB1d4nNx95IE1PTqYr42c7eynbBvK3+c176rXsT+0b8tVqrYW9+U6s+Q8KABZfIzNNMhslrZNLOmtGZmZGrk+nrbv35GP1alv1IKnV6+mWBz+U3nn+B+nq+XP5fqpFuNWz/1PP/5BFSCtGYmvOnGrUXJXTjgBg87RIs/vPzcIZroU1I52ZkbgAWozRMVZv+iDJo2RgIO394GPp3Ms/TpdOn2jFRjNmRQZmZkZipiSfIYmZkbxDaoVJEmECAPOUSOFNs/2/s6f2zgbJ9EyQxGGam+99oHW0Yg0MrtWuiic8dvShtGXXWDr36oupcf16a4ak3jpskxrtt6k2OzNihgQAFtElhXUjafYKrM3GbJDU6wP5eLzaa0bWTZB0xELXLWN70vnXX0kTb59o1VpESRRa+7BNa0upe5ak/T4A0CmQ0h+bM3funbnERnvdSIygO269Le06fKR1i5c1Nrgedl/siLGjD6addx5OF4+/kS69fSo1rk21Q6Te6g6zJACwiDYpnrGaZi5IGqfyju4/mEYP3rlqFz3bMEEy88tkO2b33fel3YePpskL59PV8bNp8uJ76fqVy/mZOfmim+Q0YABYSL4Kc2AgDYxsSYNbt6WR0Z35otX8Rnnr8MX94Prci7U0snN3vgEAm1/dLgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBgPQTJVPGBoXrTXgEAVkxFa0xFkFwsPrJ9QJAAACunojUuRpCcKj4yNtKwpwCAFVPRGqciSF4uPnLHtuv2FACwYipa4+UIkh8UH3lg5zV7CgBYMQ/ObY2/iCD5VvGRT++9ak8BACvmU3Nb41sRJM9k2/HOI/u3Tqcnb79sbwEAyy4aI1qjIBrk+xEksbLkd4of+dz+K/YYALDsKhrjd9K+xxudC6P9dipcj+T+m66lLx6asNcAgGUTbRGNUTDVbpCZK7XGdMl/KX7Gl+65mO4edcYNAHDjDu+4nrdFyX9N+x4/XgyS8K+y7Wzxs379yIU0OuS6JADA0kVL/Pq9F8oPR3P8i8479dIHvlT8zEd2T6V//eB7aaurtwIAS7B9sJm3xId2T5U/9E/TvsfPVgVJ+Fq2/afiAx8bm0z/7pFxh28AgEW5e8f19G8/OJ63RMl/zmLkd4sP1Jqnvln+pOFs+x/Z9kT5A195dTR99dh2exgAmNevHJpIX567ZiR8Pdv+RhYkUwsFSdiWbf8z2z5X/sCLF4bSH53amp56a5u9DQB0ieuMxKm9pbNpOv4w276QbZezIEn9BEkYyravZNs/rPrgySsD6dvvbEkvvDeU3rw8mN6drKfL1+vpuuUmALDpDdZS2jbYSLeMNPJ708Tl4D+592o60H3Rs6JYEvLlbGuVyiKCpONvtcNkj90PACzSmRQLWFP6atejpSCp9/GNYqHrfdn2H1Ph4mkAAPOYarfDfXNipEK9z28adfNr2XY4234z207YzwBAhRPtVjjcbocz/XxRP4dseoXMR7LtM9n2aLYdybaD2bYjtdaeAACbW6wFuZRaV3t/Jdt+kG1/km3fT6375M2vdMjm/wswAOFHcKYGBK+BAAAAAElFTkSuQmCC"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwMzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTAxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTAyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/IKTpgAABoJJREFU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"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFGNzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGODNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU1REU2MUY1M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUY2M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xBVG6wAADz5JREFUeNrs3U9sVVUewPHD62tLrXVaCppaamRqJCXOwiBuR91NYnRhojHjyiHB/2tjjBvduFYTHYkrZ3SSWU0y28GZpUjGhYKYICbQaYZ/VaCUvrYPz6+84u3lSl+lLyb4+SS/Bee+9iXnbb65vZy34f2Dl9LPUMuzK8+Dee7Lc3ee0Tz9eXoTAHCjm8szk2cyz9d5PsuzL8/+PM3Vfnj3xMp/19f45lvzPJ/nj3nGfBYA8KvV25pNeX6X57HW+rE8f8nzTp7j7f6yWpuvG2794iN5XhYjAMBPGGu1wpFWOwyvV5A8nuerPM/l6bHPAEAbelrtEA3xxGovrq9y7a08z1RdnJ1rpP+dmk7T52bSzOxcujg3nxaazdRsNn0EAHCDq9VqqZ5nY2936u/rTUMD/en2zUOpr/eqexeb83yc54E8L+ZZWEuQ3JTnb3keLl/4LgfIsRNn0rdTJ30aAPArFTcgGjELC+nszGyaOvVdOnh0Mt05siWN3bopDQ70l38kbnDEs6hxt+RCO0ESax9VxUi80ZHJ//sUAIBKccMiZnz0trRj22j58sOtxogHYFfcKal6huTtPI8UF86cPZ/+8/lXYgQAaEs0w7//e2ipIUoeabVGulaQxG2UPcWFk9Nn06cHj6Tvz1+wuwBA2+JPOdEQ0RIle/YeSk/+VJAMl4vl9Pfn04HDR9P8wqJdBQDWLBoiWiKaouTtHCVbqoLkjXT5SdgrvvjmmBgBAK47SqIpSuJAtdfLQXJHnj8VXxUPsMatFgCA6xVN8eXRqw5ufXrvoaUGuRIkz+bpXr4aZ4t4gBUAWE/fTJ5YaoyC7laDLAVJzFPFq8dPnLFrAMC6q2iMp/YeSrXlb+3durx64WLDoWcAQEdEY0RrFESD7Iogeai4OnV62m4BAB1T0RoPRpDsLK6U/rYDALCuKlrjvgiS7cWV+KI8AIBOqWiN7REkI8WVi415OwUAdExFa4xEkAwUVxYWHYQGAHRORWsMRJD0FFeazUt2CgDomIrW6KnZFgDglyZIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAEEHSWLFQ22BXAIDOxcfVrdGIIDlXXKl3ddkpAKBjKlrjXATJVHFlY0+3nQIAOqaiNaYiSA4XV/r7eu0UANAxFa1xOILkQHFlaKDfTgEAHVPRGp9FkOwrrowMD9kpAKBjKlpjXwTJp3mOL6/ctLEn3TmyxW4BAOsuGiNaoyAaZH8ESTPPh8UrY7dusmMAwLqraIwPd0+k5vLBaO+kwnkkgwP9aXz0NrsGAKybaIvBlc+PNFoNcuWk1rhdsrf4ih3bRtMt/X12DwC4btEU0RYlH+yeuPzYSPHo+NfynC6+6p7fjqXuuoPSAICfL1oimqIkmuPV5X/UShdeKL5y+Dc3p53bt6V6l6+8AQDWLk5ljZaIpih5affEjzdCyqXxcZ73igtbhm5J9++4y59vAIA1iXa4f8f4UkuU/DnHyF+LC1W3Pl7K84/iQlTN7++d8KArANCWaIZoh4o7I9EYL5YX6xW/I554fTLP3/P8oXghHka5ffNgOnbiTPp26qTdBgBWiHNG4r/2Dlaf/P7PVmM02gmScCHPo3neyrOneCHeYPm/BU+dnk7T52bSzOxcmp2bT4uLi6l56ZJPAwBucLUNG1JXV1fq6+1e+m6aOA4+TmAtHXpWFI+ExJ2R+aqL9Wu8V/zAM3k+aYXJ5uLFeEN/wgEAVnEqXX4c5KNrBk4bvygedJ3I826quMUCAFCh0WqHidVipN0gWa6bZ/OM53kzz6R9BgAqTLZaYbzVDqfa+aH6Gt8kTlN7Oc8reXbleSjPzjx359maJx6l7fZZAMANLx7tON9qg6/zHMjzrzz70+XvyVuTHwQYANsFYMWa99MrAAAAAElFTkSuQmCC"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4MDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4MTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjdFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjdGM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+o5CrmQAABp1JREFUeNrEmWtsFFUUx+/M7O50d9ul3T63tNAnFbCttilBDTESUeEDQa0f/GB4xOcXRfli1GCiMeoX/CKvRFRQE6OQEJGKD0ATRGhLgAKhLfTFlm67pVu7753dmfGc3Vtt6c7uzO623uSfTnfn3vubs+eec+8ZnaX1fZJGM4AeAD0CagAtA9lA2fR7L8gB6gV1gU6D/gIJ0wOsvfCepgl1KYLeD3oZ1AqyJrjPSrUS9CToXdAk6HvQPtBFrROzGu9vBB0HXQC9mARWqeXRvjhG26nmnY3zAZwF2gXqBG0AMST9hmOsxzEB+hNQVqaAa0DnQK+n4ULJ3HI7zgHQNWkBM7K0ii6SRjL/Dec4f7rpndUpAQPsaplhT8FlAVm4ZoU5f0sEHReYlcVa6HgMLs1k4ZsZ5/696e1aVcC84DZCh8MLbNm7WwEy/Fm/3Zg0Dof15o9lwjTEG6W0KJ9se3o9WWorJh1Xe8jBo7+QkCBoIjFm8WTzpsfIfffUEPuok3x+5ARxjE/MuQ8ZgOUjuHxt5uccv2Ltv//oI/5mkeP3x7P84uIC8uYLz5KSAithWZaUlxSSuooy0n6lh4iiqBp2x9ZnSP2yKqLjOGJdZCEt9XXkcnc/8foDc6EZtnm4qOX40rGzjjkuASmSAdgPlULX860bSI7ZNOuzWgDesaWV8AaDatjq8tJZn1uyzWTrU08ohjzKxMwBBn9ZJTHco0o9bYXxk9o0dBZv0Aw709WUGjCtQ7ZZwNS6rybKYF09A4qDIvQbm+NDJ4PFdrm7L2E6mMkW82GGWCYtVeC7DK/U68qNgajP5uda4n6Pn+P3uBgj1KfVwPYM2Mm+b48RUZIU75FZroIwzO48z1AoamFn7vI1sCpzEj1mMCSQXQcPkxuDw6osrRZ215eHiRAOJ/R/ZEPGqIXXB86wQ7Y1r4DZVydbOGg5tKAaSz/UdG9GYP/zXcm5ZOzcr2hhvcToGtTGUbWWziRsbPFFGfUIzEusrlJL8FcDnUnYKHCMkUdgA4SOfK0TpwKdKiwNb8hoYKOJgmFMqSR8LdDpwMaCW5RRh8BcWscGhiEsl/wcwOJ9bNoHlehMDOx9A6n0VhO61CQXVYaJMTJR07BSeGo+YTMBPc2IwLI+EhyZb9h0oSmjjMCiIezpyyQsLjC1GVF1xSbGKCJwZJFvuDOTsBgNtKRxNQ0YsY4RQWChzHm+E85xgUzBYujSuvdI6L+yGCwHRmRF4FCW4HaZA+MdiTpt2fS45nSrFvq5jesSn0oD4+1w1sRzVHS3hjO4bROXfkzUqWlFbUpJQQ10orGxlUxcRjY3srKnmnfiRtRb5mzvMIYmryt1uuVwppzBkkHbFcaOuiIwgTt00EqoNJ2ifLgtXjp65muGyHF30geOtBG315dyulWC/tvtJZ8d+Umh+CZLwPQVslHG2Imj0vEHQjI5/lFxMqeyLMjnztm9eXwBOCb1kyVwxMdFcuFaL9kLJwUte4Pp/XSRNZfkWrLJ0MgY+fSbo2RsYjLu/bmeW6eX2U98B5d4PvNEH2K6oA3nOqweVgn67Jb25S99IOjNi//HQgrEXd/Iquv73zKEvegO/fgj3V35CYFG4Yb+5UM/7OGksO//gsW5gWE3siATZZt9zIfFJ1OzD+ZP3bhUa/95L2w4hIWGxTlxbmRAFsokx638DJQ+LIE/o1NKOX5HiA97Rl2W6kaZYfULActKEX+dvW1P6Z2LZ3FNk9j7kVDC2hr1ldu434COLC94/NcrNm4D3y6dX5/1joAbfJE/dRMt20sZgnPcZaaFqZUJtTKm6ogp5ApDUrnmMZeaQ3xuOW6fM+oCELryPINnmnoPHcgOOLupZYdoGJOTAt8F7cen5KSIbJvo6jcH79z0GoutYZ0pI6VYU3Ciu+5W26Ga2ydPwhyDFNauBDsrrMVrWMIisRcyCFgBKgPljVlX1twubHnQbSqth9OsSaOfBiz+ka7F451ni11Xb5LYa7BhusDuUDeQFX8RNS8WARwXHVaGSrDyCirCwqPIGcyj1oZql6WqOsBbbSF9dqHIGiwyy0W3X4wkCpwkuPmwd9wYcjms7v6+EldXHycKPro3cFJfHaXRIGkWYtS+CaXWxtqbhVq8EAs9JPbWE38FPRU3o6iIlhIpSJhaD/cEuPMapxZ100ggq/L5TZV67esk9srWRK1uoX8R3DgDmsyADVBQDwX00PUhqAVNFNaSNZlaBDVFAXn6EDoFC0coXIg+gJTqQv1HgAEARDAmwaNYIQ4AAAAASUVORK5CYII="

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(117)
	__vue_script__ = __webpack_require__(119)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\betInfo.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(121)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-e2a4ac6e/betInfo.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(118);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/betInfo.vue?7661e2a1"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;CACA","file":"betInfo.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.bet-info(v-bind:style=\"content\")\r\n\t\tdiv.record(v-for=\"item in betRecord\")\r\n\t\t\tp.created-time(v-html=\"item.createdAt\")\r\n\t\t\tp.detail\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.playlaw\")\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.betmoney\")\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.multiple\")\r\n\t\t\tp.bonus-num\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.num\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {},\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                betRecord: require('../../data/betRecord')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            betRecord: __webpack_require__(120)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in betRecord\"><p class=\"created-time\" v-html=\"item.createdAt\"></p><p class=\"detail\"><span></span><span v-html=\"item.playlaw\"></span><span></span><span v-html=\"item.betmoney\"></span><span></span><span v-html=\"item.multiple\"></span></p><p class=\"bonus-num\"><span></span><span v-html=\"item.num\"></span></p></div></div>";

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(123)
	__vue_script__ = __webpack_require__(125)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\bonusRecord.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(127)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-692cd0ba/bonusRecord.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(124);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/bonusRecord.vue?c765f018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,oBAAA;IACA,iBAAA;CACA","file":"bonusRecord.vue","sourcesContent":["<template lang=\"pug\">\r\n    div.bet-info(v-bind:style=\"content\")\r\n        div.record(v-for=\"item in bonusRecord\")\r\n            p.created-time(v-html=\"item.createdAt | datetime\")\r\n            p.bonus-num\r\n                span \r\n                span(v-html=\"lotterynum(item.lotterynums)\")\r\n</template>\r\n<script>\r\nimport RequestList from '../../js/request-list'\r\nexport default {\r\n    props: ['zoomRate'],\r\n    ready() {\r\n        RequestList.getBonusRecord().then(res => this.bonusRecord = res.data)\r\n    },\r\n    data() {\r\n        return {\r\n            bonusRecord: require('../../data/bounsRecord')\r\n        }\r\n    },\r\n    methods: {\r\n        lotterynum(nums) {\r\n            if (Object.prototype.toString.call(nums) !== '[object String]') {\r\n                throw new Error('')\r\n            }\r\n            // \r\n            nums = nums.split(',')\r\n            return (nums[0] + nums[nums.length - 1]) % 10\r\n        }\r\n    },\r\n    computed: {\r\n        content() {\r\n            return {\r\n                width: 458 * this.zoomRate.x + 'px',\r\n                height: 580 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate'],
	    ready: function ready() {
	        var _this = this;
	
	        _requestList2.default.getBonusRecord().then(function (res) {
	            return _this.bonusRecord = res.data;
	        });
	    },
	    data: function data() {
	        return {
	            bonusRecord: __webpack_require__(126)
	        };
	    },
	
	    methods: {
	        lotterynum: function lotterynum(nums) {
	            if (Object.prototype.toString.call(nums) !== '[object String]') {
	                throw new Error('');
	            }
	
	            nums = nums.split(',');
	            return (nums[0] + nums[nums.length - 1]) % 10;
	        }
	    },
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in bonusRecord\"><p class=\"created-time\" v-html=\"item.createdAt | datetime\"></p><p class=\"bonus-num\"><span></span><span v-html=\"lotterynum(item.lotterynums)\"></span></p></div></div>";

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(129)
	__vue_script__ = __webpack_require__(131)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Exchange.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(139)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-f367a86e/Exchange.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(130);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Exchange.vue?4d705018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Exchange.vue","sourcesContent":["<template lang=\"pug\">\r\n    //-   \r\n    div.exchange(v-bind:style=\"content\")\r\n        //- img.background-img(v-bind:src=\"backgroundImg\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"bonusMoney\",v-html=\"item.goodname\")\r\n                    img.exchange(v-bind:src=\"doexchange\",v-bind:style=\"exchangeBtn\")\r\n            div.change-button(v-bind:style=\"buttonBar\")\r\n                div.bonus-button\r\n                    img.bonus-button(v-bind:src=\"bonusButton\")\r\n                div.prize-button\r\n                    img.prize-button(v-bind:src=\"prizeButton\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                moneyData: require('../../data/money-data.js'),\r\n                backgroundImg: require('../../assets///.png'),\r\n                moneyBack: require('../../assets///.png'),\r\n                bonusButton: require('../../assets///.png'),\r\n                prizeButton: require('../../assets///.png'),\r\n                doexchange: require('../../assets///.png'),\r\n                moneyImg: require('../../assets///.png')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 618 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyblock() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n                }\r\n            },\r\n            buttonBar() {\r\n                return {\r\n                    width: 260 * this.zoomRate.x + 'px',\r\n                    height: 68 * this.zoomRate.y + 'px',\r\n                    margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            barcontent() {\r\n                return {\r\n                    margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n                }\r\n            },\r\n            bonusMoney() {\r\n                return {\r\n                    width: 150 * this.zoomRate.x + 'px',\r\n                    height: 20 * this.zoomRate.y + 'px',\r\n                    margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyImg() {\r\n                return {\r\n                    width: 116 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: 0 * this.zoomRate.y + 'px 0 0 0px'\r\n                }\r\n            },\r\n            exchangeBtn() {\r\n                return {\r\n                    width: 90 * this.zoomRate.x + 'px',\r\n                    height: 50 * this.zoomRate.y + 'px',\r\n                    margin: 30 * this.zoomRate.y + 'px 0 0 ' + (364) * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(132),
	            backgroundImg: __webpack_require__(134),
	            moneyBack: __webpack_require__(135),
	            bonusButton: __webpack_require__(136),
	            prizeButton: __webpack_require__(137),
	            doexchange: __webpack_require__(138),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: 0 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        exchangeBtn: function exchangeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '10000',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50000',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '10W',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50W',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEMzREOUUxMjQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEMzREOUUxMzQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzNEQ5RTEwNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzNEQ5RTExNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MrPF1wAAIN9JREFU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"

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAIICAYAAACYbhx1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg4MTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg4MjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjYzODRGODdGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODgwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6e7g8wAAD2RJREFU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AwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwD/f4Je/Y8BAI+Uug26kAPAIx/2chL4etyuSg8A16zb9TiY19MhvUwpndd6usf95AcAgOswhD8wcLet1vDW8hJbv1yeqO2JkykdALiGYV8iPrd7eVx/Waaafj4/UXvM+7heVR0ArlfML2n11AbyaHkEvf5wOjyxlP6yY+oAwNVO5euqLYduLw3/YZvQ/2dc6t6f7CN8dWIcAFyfqPc239fs3vDvl3Gq355iqz0x9trPE/uac1M6AFz5dD5P5ak3um663RoeLS/x4Lv7qd4dlyfmF9YRfjulizoAXEHMT6bzvqu9N7stc8Nr/V4ZxzrFg3/ZL0+mfT2d1i+71g0A+P3E/DCdb/rcWn3odjT8L++8PpX9NKX9OL0ay3nbjsDPyzKpx4dMfUoXdQC4gpjXucXzrvapHjrd+33eGt7eWi7ixVjuXoz1a7Gki3Fqj+fqr7vfpyrqAHAVMZ82u9n3S7OXVs/Nrv/8F3devzsHfR7X44XzcXo5RvQ3zvsb9+2Nrf51M62LOgD8fmPeD4fPTe6Dd2v13Oxx+vL6I+0Yeq/8/MJL8YYW93Sv17/98CHqUz/7fb2gXdgB4HcS8sPZ7POdW3tze8z3vdX3lgE89VZ/4dk7r7+xfsbwZ08+lnJOseS2/kFJ+YmU01PxaPnmlry8sT2uef2xfPJ8ysf/qOz/FwB469P4ZiI/3Jt9PvktzWext8l8Hrz3S8j/d1n/00f+7cdf3X7Ebj7lPd5Y8hRL+/q1/IWo8hOx+UyL83J/95LqMKVdFL3Em4b5F4D5vbFeRvWcj/+BWdYB4CEx33zBSj2up3552rg5Zr7vk/nFHPMx3dtP/xnL5+//zF37DSDHD+R4c14m7PP447nY/Ea89OfrLvaziPrUYh41n6LeZV7qMtlvhvblkR3xAPBmUd/eNGa9A9zh8rTxeALcfCh8Py//Fctz9/bj+QNBn0+BT2uM57q3538Tmx+J5ZX4zBfWg/LTUNIQU/ouL5P6Iepp2WW/lL2azwHgoTE/bqzfmHZyNvsa9OMJcG35xzaZR8wv2sT+YNDr4X5y/Y8yX3weT13Eny/GbwnfGaf6yrgrj7e/YDeVtGuT+rzrPS+73ueY1+WYe5/WAYCHF3392vL1Dq3zZH64Ycxy7DxC/ot2Alwsr/Wwz89fEvT+a0E5Rr0us/p6uvyd+PBvxvKV/ZA/uRvqjW3QSw/64cS67acLOwBcMpofd7NvvgL1NOjjdN6uM4+Q/21M6hH19frz5fK1B4K+XOeWT6K+/CVTH/1L+/BfxPKZizH/QwT9pQj687G8s2yivsY8Zx0HgDfrer3v2PnmRLifzrdkH6fb+/nGb/0s934d+r7fw/2BoM/77/Mm6nn7F+QUPU/7WLcD82cl392N9YvDkL8UIf9ATOkfipi/Pyb098b6VtT87fH2M9M5ADx8So/5+SJi+6vI690YoH80f535VL/Vvmhl+Z6V451b11u9zl/I0s9ru9//CTAAwcI8aGUDpYoAAAAASUVORK5CYII="

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OTRCNTVEQzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OTRCNTVERDNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY5NEI1NURBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY5NEI1NURCM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FIWMwgAAJ/FJREFU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"

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI2RTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI2RjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjczMzVBODg5M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjczMzVBODhBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Nzdc8AAAB/ZJREFU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"

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI3MjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI3MzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4NzE2MjcwM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NzE2MjcxM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+QQjJUwAACBpJREFU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"

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDg5RkQxOTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDg5RkQxQTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlFM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY0ODlGRDE4M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CgsFFAAAC2RJREFU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"

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = "<div class=\"exchange\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"bonusMoney\" v-html=\"item.goodname\"></div><img class=\"exchange\" v-bind:src=\"doexchange\" v-bind:style=\"exchangeBtn\"/></div></div><div class=\"change-button\" v-bind:style=\"buttonBar\"><div class=\"bonus-button\"><img class=\"bonus-button\" v-bind:src=\"bonusButton\"/></div><div class=\"prize-button\"><img class=\"prize-button\" v-bind:src=\"prizeButton\"/></div></div></div></div>";

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(141)
	__vue_script__ = __webpack_require__(143)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Recharge.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(153)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-9e1d8b66/Recharge.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Recharge.vue?4d573667"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Recharge.vue","sourcesContent":["<template lang=\"pug\">\r\n    //-   \r\n    img.recharge-record(v-bind:src=\"recordImg\",v-bind:style=\"recordImgStyle\")\r\n    div.recharge(v-bind:style=\"content\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\",v-html=\"item.goodname\")\r\n                        //- \r\n                    div.bonus-money.bonus-sub(v-if=\"item.sub\",v-bind:style=\"bonusSub\",v-html=\"item.sub\")\r\n                    img.recharge(v-bind:src=\"dorecharge\",v-bind:style=\"rechargeBtn\")\r\n    div.my-money(v-bind:style=\"footer\") : {{userinfo.money}}\r\n</template>\r\n<script>\r\nexport default {\r\n    props: ['zoomRate', 'userinfo'],\r\n    ready() {\r\n\r\n    },\r\n    data() {\r\n        return {\r\n            moneyData: require('../../data/exchange-data'),\r\n            recordImg: require('../../assets///.png'),\r\n            moneyBack: require('../../assets///.png'),\r\n            dorecharge: require('../../assets///.png'),\r\n            moneyImg: require('../../assets///.png')\r\n        }\r\n    },\r\n    computed: {\r\n        recordImgStyle() {\r\n            return {\r\n                width: 136 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        content() {\r\n            return {\r\n                width: 495 * this.zoomRate.x + 'px',\r\n                height: 618 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyblock() {\r\n            return {\r\n                width: '100%',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n            }\r\n        },\r\n        buttonBar() {\r\n            return {\r\n                width: 260 * this.zoomRate.x + 'px',\r\n                height: 68 * this.zoomRate.y + 'px',\r\n                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        barcontent() {\r\n            return {\r\n                margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n            }\r\n        },\r\n        bonusMoney() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusMoneyHasSub() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusSub() {\r\n            return {\r\n                fontSize: 14 * this.zoomRate.x + 'px',\r\n                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',\r\n                borderRadius: 10 * this.zoomRate.x + 'px',\r\n                // width: 150 * this.zoomRate.x + 'px',\r\n                // height: 20 * this.zoomRate.y + 'px',\r\n                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyImg() {\r\n            return {\r\n                width: 116 * this.zoomRate.x + 'px',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: -2 * this.zoomRate.y + 'px 0 0 0px'\r\n            }\r\n        },\r\n        rechargeBtn() {\r\n            return {\r\n                width: 90 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        footer() {\r\n            return {\r\n                // width: 136 * this.zoomRate.x + 'px',\r\n                fontSize: 34 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    ready: function ready() {},
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(144),
	            recordImg: __webpack_require__(150),
	            moneyBack: __webpack_require__(151),
	            dorecharge: __webpack_require__(152),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        recordImgStyle: function recordImgStyle() {
	            return {
	                width: 136 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 495 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: '100%',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusMoneyHasSub: function bonusMoneyHasSub() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusSub: function bonusSub() {
	            return {
	                fontSize: 14 * this.zoomRate.x + 'px',
	                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',
	                borderRadius: 10 * this.zoomRate.x + 'px',
	
	                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: -2 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        rechargeBtn: function rechargeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        },
	        footer: function footer() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '500',
	        price: 500,
	        sub: '',
	        goodsimg: __webpack_require__(145),
	        goodsnum: 200
	    }, {
	        goodname: '1000',
	        price: 1000,
	        sub: '',
	        goodsimg: __webpack_require__(146),
	        goodsnum: 200
	    }, {
	        goodname: '2000',
	        price: 2000,
	        sub: '+188',
	        goodsimg: __webpack_require__(147),
	        goodsnum: 200
	    }, {
	        goodname: '5000',
	        price: 5000,
	        sub: '+888',
	        goodsimg: __webpack_require__(148),
	        goodsnum: 200
	    }, {
	        goodname: '10000',
	        price: 10000,
	        sub: '+2888',
	        goodsimg: __webpack_require__(149),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg3OTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg3QTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjQwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODc4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+3Q/9KQAAEj9JREFU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"

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzRjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjNDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjNENDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Z4g2cwAAGIhJREFU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"

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzQTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzQjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjM4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjM5NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YbZkgAAJTdJREFU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"

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQjUwMkFGRDQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQjUwMkFGRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZCNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQUZDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+L33IaQAAMdZJREFU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"

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzNjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzNzQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQjAwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+56FGOgAAQAZJREFU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"

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAAxCAYAAAABf+HvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNDBFMThBMjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNDBFMThBMzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEEwM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE0MEUxOEExM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gmaSkAAACUhJREFU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"

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4NDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4NTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjgyM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjgzM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+aqH0aAAAKFxJREFU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"

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFFRjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGMDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEE0M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUVFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CibruAAACphJREFU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"

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<img class=\"recharge-record\" v-bind:src=\"recordImg\" v-bind:style=\"recordImgStyle\"/><div class=\"recharge\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\" v-html=\"item.goodname\"></div><div class=\"bonus-money bonus-sub\" v-if=\"item.sub\" v-bind:style=\"bonusSub\" v-html=\"item.sub\"></div><img class=\"recharge\" v-bind:src=\"dorecharge\" v-bind:style=\"rechargeBtn\"/></div></div></div></div><div class=\"my-money\" v-bind:style=\"footer\">: {{userinfo.money}}</div>";

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(155)
	__vue_script__ = __webpack_require__(157)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\ruleIntroduce.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(159)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-41af1aed/ruleIntroduce.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(156);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/ruleIntroduce.vue?482cbdbb"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA","file":"ruleIntroduce.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.introduce(v-bind:style=\"content\",v-html=\"rule\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n            console.log(this.rule)\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                rule: require('./../../data/ruleIntro.html')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.rule);
	    },
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            rule: __webpack_require__(158)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n";

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "<div class=\"introduce\" v-bind:style=\"content\" v-html=\"rule\"></div>";

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<div class=\"model\" v-show=\"dialogShow\" transition=\"message\"><div class=\"dialog\" v-bind:style=\"dialog\"><div class=\"close\" v-bind:style=\"close\" @touchend=\"dialogShow = false\"></div><div class=\"content\" v-bind:style=\"content\"></div><div v-bind:is=\"dialogImg[currentIndex].type\" v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\"></div><img v-bind:src=\"dialogImg[currentIndex].background\"/></div></div>";

/***/ },
/* 161 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    notice: {
	        'content': '?????',
	        'createdAt': 1469543980000,
	        'id': 6,
	        'title': 'title'
	    },
	    options: ['', '', '', '', '']
	};

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {};

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    'createdAt': 1469548675000,
	    'money': 10000,
	    'code': 0,
	    'nickname': '222',
	    'openid': 'xxxxxxxxxxxx'
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(165)
	__vue_script__ = __webpack_require__(167)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\tip-modal.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(168)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-691c031b/tip-modal.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /*  scale  */\r\n}\r\n\r\n.bounce-enter {\r\n    -webkit-animation: bounce-in .5s;\r\n            animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    -webkit-animation: bounce-out .5s;\r\n            animation: bounce-out .5s;\r\n}\r\n\r\n@-webkit-keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@-webkit-keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n", "", {"version":3,"sources":["/./src/components/tip-modal.vue?79187cbe"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;IACA,oBAAA;IACA,mBAAA;IACA,WAAA;IACA,aAAA;IACA,+BAAA;IACA,aAAA;IACA,mBAAA;IACA,mBAAA;IACA,mBAAA;CACA;;AAEA;IACA,sBAAA;IACA,qBAAA;CACA;;AAEA;IACA,iCAAA;YAAA,yBAAA;CACA;;AAEA;IACA,kCAAA;YAAA,0BAAA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA","file":"tip-modal.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.tip-content(transition=\"bounce\",v-show=\"isShow\",v-html=\"content\")\r\n</template>\r\n<script>\r\nexport default {\r\n    props: [],\r\n    data() {\r\n        return {\r\n            isShow: false,\r\n            content: ''\r\n        }\r\n    },\r\n    methods: {\r\n        showTip(content) {\r\n            this.content = content\r\n            this.isShow = true\r\n            setTimeout(() => this.isShow = false, 3000)\r\n        }\r\n    },\r\n    events: {\r\n        showTip(event) {\r\n            this.showTip(event)\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /*  scale  */\r\n}\r\n\r\n.bounce-enter {\r\n    animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    animation: bounce-out .5s;\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        transform: scale(0);\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        transform: scale(1);\r\n    }\r\n    100% {\r\n        transform: scale(0);\r\n    }\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: [],
	    data: function data() {
	        return {
	            isShow: false,
	            content: ''
	        };
	    },
	
	    methods: {
	        showTip: function showTip(content) {
	            var _this = this;
	
	            this.content = content;
	            this.isShow = true;
	            setTimeout(function () {
	                return _this.isShow = false;
	            }, 3000);
	        }
	    },
	    events: {
	        showTip: function showTip(event) {
	            this.showTip(event);
	        }
	    }
	};

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tip-content\" transition=\"bounce\" v-show=\"isShow\" v-html=\"content\"></div>";

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<background></background><menu-bar v-bind:game-data=\"gameData\" v-bind:notice=\"notice\" v-bind:zoom-rate=\"zoomRate\"></menu-bar><bet-and-bonus v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></bet-and-bonus><play-panel v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></play-panel><state v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></state><message v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></message><modal class=\"modal\" v-if=\"error\"></modal><tip-modal></tip-modal>";

/***/ },
/* 170 */
/***/ function(module, exports) {

	!function (a, b) {
	    module.exports = b(a)
	}(window, function (a, b) {
	    function c(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.invoke(b, e(c), function (a) {
	            g(b, a, d)
	        }) : j(b, d)
	    }
	
	    function d(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.on(b, function (a) {
	            d && d.trigger && d.trigger(a), g(b, a, c)
	        }) : d ? j(b, d) : j(b, c)
	    }
	
	    function e(a) {
	        return a = a || {}, a.appId = z.appId, a.verifyAppId = z.appId, a.verifySignType = "sha1", a.verifyTimestamp = z.timestamp + "", a.verifyNonceStr = z.nonceStr, a.verifySignature = z.signature, a
	    }
	
	    function f(a) {
	        return {
	            timeStamp: a.timestamp + "",
	            nonceStr: a.nonceStr,
	            "package": a.package,
	            paySign: a.paySign,
	            signType: a.signType || "SHA1"
	        }
	    }
	
	    function g(a, b, c) {
	        var d, e, f;
	        switch (delete b.err_code, delete b.err_desc, delete b.err_detail, d = b.errMsg, d || (d = b.err_msg, delete b.err_msg, d = h(a, d, c), b.errMsg = d), c = c || {}, c._complete && (c._complete(b), delete c._complete), d = b.errMsg || "", z.debug && !c.isInnerInvoke && alert(JSON.stringify(b)), e = d.indexOf(":"), f = d.substring(e + 1)) {
	            case"ok":
	                c.success && c.success(b);
	                break;
	            case"cancel":
	                c.cancel && c.cancel(b);
	                break;
	            default:
	                c.fail && c.fail(b)
	        }
	        c.complete && c.complete(b)
	    }
	
	    function h(a, b) {
	        var d, e, f, g;
	        if (b) {
	            switch (d = b.indexOf(":"), a) {
	                case o.config:
	                    e = "config";
	                    break;
	                case o.openProductSpecificView:
	                    e = "openProductSpecificView";
	                    break;
	                default:
	                    e = b.substring(0, d), e = e.replace(/_/g, " "), e = e.replace(/\b\w+\b/g, function (a) {
	                        return a.substring(0, 1).toUpperCase() + a.substring(1)
	                    }), e = e.substring(0, 1).toLowerCase() + e.substring(1), e = e.replace(/ /g, ""), -1 != e.indexOf("Wcpay") && (e = e.replace("Wcpay", "WCPay")), f = p[e], f && (e = f)
	            }
	            g = b.substring(d + 1), "confirm" == g && (g = "ok"), "failed" == g && (g = "fail"), -1 != g.indexOf("failed_") && (g = g.substring(7)), -1 != g.indexOf("fail_") && (g = g.substring(5)), g = g.replace(/_/g, " "), g = g.toLowerCase(), ("access denied" == g || "no permission to execute" == g) && (g = "permission denied"), "config" == e && "function not exist" == g && (g = "ok"), b = e + ":" + g
	        }
	        return b
	    }
	
	    function i(a) {
	        var b, c, d, e;
	        if (a) {
	            for (b = 0, c = a.length; c > b; ++b)d = a[b], e = o[d], e && (a[b] = e);
	            return a
	        }
	    }
	
	    function j(a, b) {
	        if (!(!z.debug || b && b.isInnerInvoke)) {
	            var c = p[a];
	            c && (a = c), b && b._complete && delete b._complete, console.log('"' + a + '",', b || "")
	        }
	    }
	
	    function k() {
	        if (!("6.0.2" > w || y.systemType < 0)) {
	            var b = new Image;
	            y.appId = z.appId, y.initTime = x.initEndTime - x.initStartTime, y.preVerifyTime = x.preVerifyEndTime - x.preVerifyStartTime, C.getNetworkType({
	                isInnerInvoke: !0,
	                success: function (a) {
	                    y.networkType = a.networkType;
	                    var c = "https://open.weixin.qq.com/sdk/report?v=" + y.version + "&o=" + y.isPreVerifyOk + "&s=" + y.systemType + "&c=" + y.clientVersion + "&a=" + y.appId + "&n=" + y.networkType + "&i=" + y.initTime + "&p=" + y.preVerifyTime + "&u=" + y.url;
	                    b.src = c
	                }
	            })
	        }
	    }
	
	    function l() {
	        return (new Date).getTime()
	    }
	
	    function m(b) {
	        t && (a.WeixinJSBridge ? b() : q.addEventListener && q.addEventListener("WeixinJSBridgeReady", b, !1))
	    }
	
	    function n() {
	        C.invoke || (C.invoke = function (b, c, d) {
	            a.WeixinJSBridge && WeixinJSBridge.invoke(b, e(c), d)
	        }, C.on = function (b, c) {
	            a.WeixinJSBridge && WeixinJSBridge.on(b, c)
	        })
	    }
	
	    var o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
	    if (!a.jWeixin)return o = {
	        config: "preVerifyJSAPI",
	        onMenuShareTimeline: "menu:share:timeline",
	        onMenuShareAppMessage: "menu:share:appmessage",
	        onMenuShareQQ: "menu:share:qq",
	        onMenuShareWeibo: "menu:share:weiboApp",
	        onMenuShareQZone: "menu:share:QZone",
	        previewImage: "imagePreview",
	        getLocation: "geoLocation",
	        openProductSpecificView: "openProductViewWithPid",
	        addCard: "batchAddCard",
	        openCard: "batchViewCard",
	        chooseWXPay: "getBrandWCPayRequest"
	    }, p = function () {
	        var b, a = {};
	        for (b in o)a[o[b]] = b;
	        return a
	    }(), q = a.document,
	        r = q.title,
	        s = navigator.userAgent.toLowerCase(), t = -1 != s.indexOf("micromessenger"), u = -1 != s.indexOf("android"), v = -1 != s.indexOf("iphone") || -1 != s.indexOf("ipad"), w = function () {
	        var a = s.match(/micromessenger\/(\d+\.\d+\.\d+)/) || s.match(/micromessenger\/(\d+\.\d+)/);
	        return a ? a[1] : ""
	    }(), x = {initStartTime: l(), initEndTime: 0, preVerifyStartTime: 0, preVerifyEndTime: 0}, y = {
	        version: 1,
	        appId: "",
	        initTime: 0,
	        preVerifyTime: 0,
	        networkType: "",
	        isPreVerifyOk: 1,
	        systemType: v ? 1 : u ? 2 : -1,
	        clientVersion: w,
	        url: encodeURIComponent(location.href)
	    }, z = {}, A = {_completes: []}, B = {state: 0, res: {}}, m(function () {
	        x.initEndTime = l()
	    }), C = {
	        config: function (a) {
	            z = a, j("config", a);
	            var b = z.check === !1 ? !1 : !0;
	            m(function () {
	                var a, d, e;
	                if (b)c(o.config, {verifyJsApiList: i(z.jsApiList)}, function () {
	                    A._complete = function (a) {
	                        x.preVerifyEndTime = l(), B.state = 1, B.res = a
	                    }, A.success = function () {
	                        y.isPreVerifyOk = 0
	                    }, A.fail = function (a) {
	                        A._fail ? A._fail(a) : B.state = -1
	                    };
	                    var a = A._completes;
	                    return a.push(function () {
	                        z.debug || k()
	                    }), A.complete = function () {
	                        for (var c = 0, d = a.length; d > c; ++c)a[c]();
	                        A._completes = []
	                    }, A
	                }()), x.preVerifyStartTime = l(); else {
	                    for (B.state = 1, a = A._completes, d = 0, e = a.length; e > d; ++d)a[d]();
	                    A._completes = []
	                }
	            }), z.beta && n()
	        }, ready: function (a) {
	            0 != B.state ? a() : (A._completes.push(a), !t && z.debug && a())
	        }, error: function (a) {
	            "6.0.2" > w || (-1 == B.state ? a(B.res) : A._fail = a)
	        }, checkJsApi: function (a) {
	            var b = function (a) {
	                var c, d, b = a.checkResult;
	                for (c in b)d = p[c], d && (b[d] = b[c], delete b[c]);
	                return a
	            };
	            c("checkJsApi", {jsApiList: i(a.jsApiList)}, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var c = a.checkResult;
	                        c && (a.checkResult = JSON.parse(c))
	                    }
	                    a = b(a)
	                }, a
	            }())
	        }, onMenuShareTimeline: function (a) {
	            d(o.onMenuShareTimeline, {
	                complete: function () {
	                    c("shareTimeline", {
	                        title: a.title || r,
	                        desc: a.title || r,
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareAppMessage: function (a) {
	            d(o.onMenuShareAppMessage, {
	                complete: function () {
	                    c("sendAppMessage", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        link: a.link || location.href,
	                        img_url: a.imgUrl || "",
	                        type: a.type || "link",
	                        data_url: a.dataUrl || ""
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQQ: function (a) {
	            d(o.onMenuShareQQ, {
	                complete: function () {
	                    c("shareQQ", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareWeibo: function (a) {
	            d(o.onMenuShareWeibo, {
	                complete: function () {
	                    c("shareWeiboApp", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQZone: function (a) {
	            d(o.onMenuShareQZone, {
	                complete: function () {
	                    c("shareQZone", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, startRecord: function (a) {
	            c("startRecord", {}, a)
	        }, stopRecord: function (a) {
	            c("stopRecord", {}, a)
	        }, onVoiceRecordEnd: function (a) {
	            d("onVoiceRecordEnd", a)
	        }, playVoice: function (a) {
	            c("playVoice", {localId: a.localId}, a)
	        }, pauseVoice: function (a) {
	            c("pauseVoice", {localId: a.localId}, a)
	        }, stopVoice: function (a) {
	            c("stopVoice", {localId: a.localId}, a)
	        }, onVoicePlayEnd: function (a) {
	            d("onVoicePlayEnd", a)
	        }, uploadVoice: function (a) {
	            c("uploadVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadVoice: function (a) {
	            c("downloadVoice", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, translateVoice: function (a) {
	            c("translateVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, chooseImage: function (a) {
	            c("chooseImage", {
	                scene: "1|2",
	                count: a.count || 9,
	                sizeType: a.sizeType || ["original", "compressed"],
	                sourceType: a.sourceType || ["album", "camera"]
	            }, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var b = a.localIds;
	                        b && (a.localIds = JSON.parse(b))
	                    }
	                }, a
	            }())
	        }, previewImage: function (a) {
	            c(o.previewImage, {current: a.current, urls: a.urls}, a)
	        }, uploadImage: function (a) {
	            c("uploadImage", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadImage: function (a) {
	            c("downloadImage", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, getNetworkType: function (a) {
	            var b = function (a) {
	                var c, d, e, b = a.errMsg;
	                if (a.errMsg = "getNetworkType:ok", c = a.subtype, delete a.subtype, c)a.networkType = c; else switch (d = b.indexOf(":"), e = b.substring(d + 1)) {
	                    case"wifi":
	                    case"edge":
	                    case"wwan":
	                        a.networkType = e;
	                        break;
	                    default:
	                        a.errMsg = "getNetworkType:fail"
	                }
	                return a
	            };
	            c("getNetworkType", {}, function () {
	                return a._complete = function (a) {
	                    a = b(a)
	                }, a
	            }())
	        }, openLocation: function (a) {
	            c("openLocation", {
	                latitude: a.latitude,
	                longitude: a.longitude,
	                name: a.name || "",
	                address: a.address || "",
	                scale: a.scale || 28,
	                infoUrl: a.infoUrl || ""
	            }, a)
	        }, getLocation: function (a) {
	            a = a || {}, c(o.getLocation, {type: a.type || "wgs84"}, function () {
	                return a._complete = function (a) {
	                    delete a.type
	                }, a
	            }())
	        }, hideOptionMenu: function (a) {
	            c("hideOptionMenu", {}, a)
	        }, showOptionMenu: function (a) {
	            c("showOptionMenu", {}, a)
	        }, closeWindow: function (a) {
	            a = a || {}, c("closeWindow", {immediate_close: a.immediateClose || 0}, a)
	        }, hideMenuItems: function (a) {
	            c("hideMenuItems", {menuList: a.menuList}, a)
	        }, showMenuItems: function (a) {
	            c("showMenuItems", {menuList: a.menuList}, a)
	        }, hideAllNonBaseMenuItem: function (a) {
	            c("hideAllNonBaseMenuItem", {}, a)
	        }, showAllNonBaseMenuItem: function (a) {
	            c("showAllNonBaseMenuItem", {}, a)
	        }, scanQRCode: function (a) {
	            a = a || {}, c("scanQRCode", {
	                needResult: a.needResult || 0,
	                scanType: a.scanType || ["qrCode", "barCode"]
	            }, function () {
	                return a._complete = function (a) {
	                    var b, c;
	                    v && (b = a.resultStr, b && (c = JSON.parse(b), a.resultStr = c && c.scan_code && c.scan_code.scan_result))
	                }, a
	            }())
	        }, openProductSpecificView: function (a) {
	            c(o.openProductSpecificView, {pid: a.productId, view_type: a.viewType || 0}, a)
	        }, addCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, card_ext: g.cardExt}, d.push(h);
	            c(o.addCard, {card_list: d}, function () {
	                return a._complete = function (a) {
	                    var c, d, e, b = a.card_list;
	                    if (b) {
	                        for (b = JSON.parse(b), c = 0, d = b.length; d > c; ++c)e = b[c], e.cardId = e.card_id, e.cardExt = e.card_ext, e.isSuccess = e.is_succ ? !0 : !1, delete e.card_id, delete e.card_ext, delete e.is_succ;
	                        a.cardList = b, delete a.card_list
	                    }
	                }, a
	            }())
	        }, chooseCard: function (a) {
	            c("chooseCard", {
	                app_id: z.appId,
	                location_id: a.shopId || "",
	                sign_type: a.signType || "SHA1",
	                card_id: a.cardId || "",
	                card_type: a.cardType || "",
	                card_sign: a.cardSign,
	                time_stamp: a.timestamp + "",
	                nonce_str: a.nonceStr
	            }, function () {
	                return a._complete = function (a) {
	                    a.cardList = a.choose_card_info, delete a.choose_card_info
	                }, a
	            }())
	        }, openCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, code: g.code}, d.push(h);
	            c(o.openCard, {card_list: d}, a)
	        }, chooseWXPay: function (a) {
	            c(o.chooseWXPay, f(a), a)
	        }
	    }, b && (a.wx = a.jWeixin = C), C
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZGIxODQ1N2UwYTgzNGFlY2Y0NDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC92dWUvMS4wLjI2L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2U2MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/N2YwMSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvYmFiZWwtcnVudGltZS82LjkuMi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT81ZDVmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlPzM4MTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL0JHLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWU/Mzk3ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lNzQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlPzhhZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmciLCJ3ZWJwYWNrOi8vL01lbnVCYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzgyMTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/NmI3NyIsIndlYnBhY2s6Ly8vT3B0aW9uc0RpYWxvZy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/MGVkZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lZDM4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/NmIzNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MzBlMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmciLCJ3ZWJwYWNrOi8vL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlPzU1NjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzM5MWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9jYmRlIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZyIsIndlYnBhY2s6Ly8vUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzhjMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9iMjdjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9lNWUxIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvdGguanBnIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nIiwid2VicGFjazovLy9TdGF0ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT81MzhjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/YTFhMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/NWZmYyIsIndlYnBhY2s6Ly8vQmV0TXVsdGlwbGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT84MDgxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlP2RmYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/ZjRiYiIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mmpfoibLmjKHmnb8ucG5nIiwid2VicGFjazovLy9NZXNzYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWU/ZWRkMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlP2M5MGQiLCJ3ZWJwYWNrOi8vL2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2JldFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/YjU4MSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9hZDBlIiwid2VicGFjazovLy9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/ZGUyYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZT81NjMyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlP2QzM2UiLCJ3ZWJwYWNrOi8vL0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzkwZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NzM3OSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT9jOTEzIiwid2VicGFjazovLy9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlP2Q0ZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2Q4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT9mYzVkIiwid2VicGFjazovLy9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2E5ZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/OGJiNCIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL25vdGljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT9kZmFhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWU/YzkzOCIsIndlYnBhY2s6Ly8vdGlwLW1vZGFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlP2NiZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/ZDExZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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LFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLElBQUk7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsYUFBWSxFQUFFO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7O0FBRUE7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxJQUFJO0FBQ2YsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsdUJBQXVCLEVBQUU7QUFDakQsNkJBQTRCLDJCQUEyQixFQUFFO0FBQ3pELHdCQUF1QixzQkFBc0IsRUFBRTtBQUMvQyw0QkFBMkIsMEJBQTBCLEVBQUU7QUFDdkQ7QUFDQSxlQUFjLGFBQWEsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxhQUFhO0FBQzNCLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsb0JBQW1CO0FBQ25CLHlCQUF3QjtBQUN4QiwyQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUFzQjtBQUN0Qiw0QkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0IscUNBQW9DO0FBQ3BDLDhCQUE2QixXQUFXOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLO0FBQ2hCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGdEQUErQztBQUMvQyxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLG9DQUFtQztBQUNuQztBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHNDQUFxQyxPQUFP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsS0FBSztBQUNsQixjQUFhLElBQUk7QUFDakIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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LGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsSUFBSTtBQUNqQixjQUFhLFFBQVE7QUFDckIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixFQUFFOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN0SHRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRSx1Q0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFD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QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxXQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakIsMkJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsMkNBQTBDO0FBQzFDLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0Msc0NBQXNDO0FBQzlFLHFDQUFvQyx1Q0FBdUM7QUFDM0UscUNBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLFFBQU87QUFDUDtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDLHNDQUFxQztBQUNyQyxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixhQUFhO0FBQ3BDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixrREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUEsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0Esa0VBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLGNBQWM7QUFDbEMsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsWUFBVyxrQkFBa0I7QUFDN0IsZUFBYztBQUNkLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FB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QTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7O0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsMkJBQTJCLFFBQVEsaUJBQWlCO0FBQzlFOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLEtBQUssRUFBRSxLQUFLLE1BQU0sRUFBRTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLDRCQUEyQjtBQUMzQjtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUEsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Es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QUFDaEcsNEJBQTJCLGFBQWE7QUFDeEMsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQyxFIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImJ1aWxkL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgZGIxODQ1N2UwYTgzNGFlY2Y0NDlcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnXG5pbXBvcnQgd3ggZnJvbSAnd2VpeGluLWpzLXNkaydcbmltcG9ydCBWdWVSZXNvdXJjZSBmcm9tICd2dWUtcmVzb3VyY2UnXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXG5WdWUudXNlKFZ1ZVJlc291cmNlKVxuVnVlLmZpbHRlcigndGltZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgbGV0IGhvdXIgPSBNYXRoLmZsb29yKHZhbHVlIC8gMzYwMClcbiAgICBsZXQgbWluID0gTWF0aC5mbG9vcigodmFsdWUgJSAzNjAwKSAvIDYwKVxuICAgIGlmIChob3VyIDwgMTApIHtcbiAgICAgICAgaG91ciA9ICcwJyArIGhvdXJcbiAgICB9XG4gICAgaWYgKG1pbiA8IDEwKSB7XG4gICAgICAgIG1pbiA9ICcwJyArIG1pblxuICAgIH1cbiAgICBsZXQgc2VjID0gdmFsdWUgJSA2MFxuICAgIGlmIChzZWMgPCAxMCkge1xuICAgICAgICBzZWMgPSAnMCcgKyBzZWNcbiAgICB9XG4gICAgcmV0dXJuIChob3VyID4gMCA/IGhvdXIgKyAnOicgOiAnJykgKyBtaW4gKyAnOicgKyBzZWNcbn0pXG5WdWUuZmlsdGVyKCdkYXRldGltZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvTG9jYWxlU3RyaW5nKClcbn0pXG5sZXQgY29uZmlnID0ge31cblJlcXVlc3RMaXN0LmdldE1haW5Db25maWcoKS50aGVuKChyZXMpID0+IHsgLy/ku47lkI7lj7Dojrflj5bphY3nva7mlofku7ZcbiAgICBjb25maWcgPSByZXMuZGF0YVxuICAgIGNvbnNvbGUubG9nKGNvbmZpZylcbiAgICAgICAgLy8gd3guY29uZmlnKHtcbiAgICAgICAgLy8gICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAvLyAgICAgYXBwSWQ6ICc8P3BocCBlY2hvICRzaWduUGFja2FnZVtcImFwcElkXCJdOz8+JyxcbiAgICAgICAgLy8gICAgIHRpbWVzdGFtcDogPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJ0aW1lc3RhbXBcIl07Pz4sXG4gICAgICAgIC8vICAgICBub25jZVN0cjogJzw/cGhwIGVjaG8gJHNpZ25QYWNrYWdlW1wibm9uY2VTdHJcIl07Pz4nLFxuICAgICAgICAvLyAgICAgc2lnbmF0dXJlOiAnPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJzaWduYXR1cmVcIl07Pz4nLFxuICAgICAgICAvLyAgICAganNBcGlMaXN0OiBbXG4gICAgICAgIC8vICAgICAgICAgLy8g5omA5pyJ6KaB6LCD55So55qEIEFQSSDpg73opoHliqDliLDov5nkuKrliJfooajkuK1cbiAgICAgICAgLy8gICAgICAgICAnb25NZW51U2hhcmVUaW1lbGluZScsXG4gICAgICAgIC8vICAgICAgICAgJ29uTWVudVNoYXJlQXBwTWVzc2FnZScsXG4gICAgICAgIC8vICAgICAgICAgJ2Nob29zZUltYWdlJ1xuICAgICAgICAvLyAgICAgXVxuICAgICAgICAvLyB9KTtcbn0sIChyZXMpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKHJlcylcbn0pXG5cbi8vaHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20vY29ubmVjdC9vYXV0aDIvYXV0aG9yaXplP2FwcGlkPXd4ZmZlMTkwZGVjMzI3MWExYyZyZWRpcmVjdF91cmk9aHR0cDovL2xzd2VpeGludGVzdC5hcHBsaW56aS5jb20vcGhwL3VybG9wZW5pZC5waHAmcmVzcG9uc2VfdHlwZT1jb2RlJnNjb3BlPXNuc2FwaV91c2VyaW5mbyZzdGF0ZT0xMjNcbnZhciBtYWluID0gbmV3IFZ1ZSh7XG4gICAgZWw6ICdib2R5JyxcbiAgICBjb21wb25lbnRzOiB7IGFwcDogQXBwIH1cbn0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tYWluLmpzXG4gKiovIiwiLyohXG4gKiBWdWUuanMgdjEuMC4yNlxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBvYi5jb252ZXJ0KGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl9wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGRlbChvYmosIGtleSkge1xuICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVsZXRlIG9ialtrZXldO1xuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgaWYgKG9iai5faXNWdWUpIHtcbiAgICAgIGRlbGV0ZSBvYmouX2RhdGFba2V5XTtcbiAgICAgIG9iai5fZGlnZXN0KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3VucHJveHkoa2V5KTtcbiAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBsaXRlcmFsIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGxpdGVyYWxWYWx1ZVJFID0gL15cXHM/KHRydWV8ZmFsc2V8LT9bXFxkXFwuXSt8J1teJ10qJ3xcIlteXCJdKlwiKVxccz8kLztcblxuZnVuY3Rpb24gaXNMaXRlcmFsKGV4cCkge1xuICByZXR1cm4gbGl0ZXJhbFZhbHVlUkUudGVzdChleHApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUY7XG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIF90b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBDaGVjayBhbmQgY29udmVydCBwb3NzaWJsZSBudW1lcmljIHN0cmluZ3MgdG8gbnVtYmVyc1xuICogYmVmb3JlIHNldHRpbmcgYmFjayB0byBkYXRhXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxOdW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIGJvb2xlYW4gbGl0ZXJhbHMgaW50byByZWFsIGJvb2xlYW5zLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgPyB0cnVlIDogdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlO1xufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZnVuY3Rpb24gc3RyaXBRdW90ZXMoc3RyKSB7XG4gIHZhciBhID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KSA/IHN0ci5zbGljZSgxLCAtMSkgOiBzdHI7XG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCB0b1VwcGVyKTtcbn1cblxuZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGh5cGhlbi91bmRlcnNjb3JlL3NsYXNoIGRlbGltaXRlcmVkIG5hbWVzIGludG9cbiAqIGNhbWVsaXplZCBjbGFzc05hbWVzLlxuICpcbiAqIGUuZy4gbXktY29tcG9uZW50ID0+IE15Q29tcG9uZW50XG4gKiAgICAgIHNvbWVfZWxzZSAgICA9PiBTb21lRWxzZVxuICogICAgICBzb21lL2NvbXAgICAgPT4gU29tZUNvbXBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9cXC9dKShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgdG9VcHBlcik7XG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBiaW5kKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsID8gbCA+IDEgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cykgOiBmbi5jYWxsKGN0eCwgYSkgOiBmbi5jYWxsKGN0eCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheS1saWtlfSBsaXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIHN0YXJ0IGluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqL1xuXG5mdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBbZW51bWVyYWJsZV1cbiAqL1xuXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gX2RlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBNYW51YWwgaW5kZXhPZiBiZWNhdXNlIGl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRoYW5cbiAqIG5hdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY2FuY2VsbGFibGUoZm4pIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGNiLmNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiBjYjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpID8gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpIDogZmFsc2UpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuXG52YXIgaGFzUHJvdG8gPSAoJ19fcHJvdG9fXycgaW4ge30pO1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLy8gVUEgc25pZmZpbmcgZm9yIHdvcmtpbmcgYXJvdW5kIGJyb3dzZXItc3BlY2lmaWMgcXVpcmtzXG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgVUEuaW5kZXhPZigndHJpZGVudCcpID4gMDtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJb3MgPSBVQSAmJiAvKGlwaG9uZXxpcGFkfGlwb2R8aW9zKS9pLnRlc3QoVUEpO1xudmFyIGlvc1ZlcnNpb25NYXRjaCA9IGlzSW9zICYmIFVBLm1hdGNoKC9vcyAoW1xcZF9dKykvKTtcbnZhciBpb3NWZXJzaW9uID0gaW9zVmVyc2lvbk1hdGNoICYmIGlvc1ZlcnNpb25NYXRjaFsxXS5zcGxpdCgnXycpO1xuXG4vLyBkZXRlY3RpbmcgaU9TIFVJV2ViVmlldyBieSBpbmRleGVkREJcbnZhciBoYXNNdXRhdGlvbk9ic2VydmVyQnVnID0gaW9zVmVyc2lvbiAmJiBOdW1iZXIoaW9zVmVyc2lvblswXSkgPj0gOSAmJiBOdW1iZXIoaW9zVmVyc2lvblsxXSkgPj0gMyAmJiAhd2luZG93LmluZGV4ZWREQjtcblxudmFyIHRyYW5zaXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHVuZGVmaW5lZDtcbnZhciBhbmltYXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFOSkge1xuICB2YXIgaXNXZWJraXRUcmFucyA9IHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpc1dlYmtpdEFuaW0gPSB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zID8gJ1dlYmtpdFRyYW5zaXRpb24nIDogJ3RyYW5zaXRpb24nO1xuICB0cmFuc2l0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdFRyYW5zID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xuICBhbmltYXRpb25Qcm9wID0gaXNXZWJraXRBbmltID8gJ1dlYmtpdEFuaW1hdGlvbicgOiAnYW5pbWF0aW9uJztcbiAgYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW0gPyAnd2Via2l0QW5pbWF0aW9uRW5kJyA6ICdhbmltYXRpb25lbmQnO1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAhaGFzTXV0YXRpb25PYnNlcnZlckJ1Zykge1xuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHdlYnBhY2sgYXR0ZW1wdHMgdG8gaW5qZWN0IGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgLy8gaWYgaXQgaXMgdXNlZCBhcyBhIGdsb2JhbCwgc28gd2UgaGF2ZSB0byB3b3JrIGFyb3VuZCB0aGF0IHRvXG4gICAgLy8gYXZvaWQgYnVuZGxpbmcgdW5uZWNlc3NhcnkgY29kZS5cbiAgICB2YXIgY29udGV4dCA9IGluQnJvd3NlciA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG4gICAgdGltZXJGdW5jID0gY29udGV4dC5zZXRJbW1lZGlhdGUgfHwgc2V0VGltZW91dDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNiLCBjdHgpIHtcbiAgICB2YXIgZnVuYyA9IGN0eCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICB9IDogY2I7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuYyk7XG4gICAgaWYgKHBlbmRpbmcpIHJldHVybjtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgfTtcbn0pKCk7XG5cbnZhciBfU2V0ID0gdW5kZWZpbmVkO1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgU2V0LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLykpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuc2V0W2tleV0gPSAxO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIENhY2hlKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG52YXIgcCA9IENhY2hlLnByb3RvdHlwZTtcblxuLyoqXG4gKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uXG4gKiBSZXR1cm5zIHRoZSBlbnRyeSB3aGljaCB3YXMgcmVtb3ZlZCB0byBtYWtlIHJvb20gZm9yXG4gKiB0aGUgbmV3IGVudHJ5LiBPdGhlcndpc2UgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICogKGkuZS4gaWYgdGhlcmUgd2FzIGVub3VnaCByb29tIGFscmVhZHkpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0VudHJ5fHVuZGVmaW5lZH1cbiAqL1xuXG5wLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciByZW1vdmVkO1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5zaGlmdCgpO1xuICAgIH1cbiAgICBlbnRyeSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICB0aGlzLl9rZXltYXBba2V5XSA9IGVudHJ5O1xuICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5O1xuICAgICAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLnNpemUrKztcbiAgfVxuICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuXG4gIHJldHVybiByZW1vdmVkO1xufTtcblxuLyoqXG4gKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZVxuICogY2FjaGUuIFJldHVybnMgdGhlIHJlbW92ZWQgZW50cnkgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICogY2FjaGUgd2FzIGVtcHR5LlxuICovXG5cbnAuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyO1xuICAgIHRoaXMuaGVhZC5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICBlbnRyeS5uZXdlciA9IGVudHJ5Lm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2l6ZS0tO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldO1xuICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG4gIH1cbiAgLy8gSEVBRC0tLS0tLS0tLS0tLS0tVEFJTFxuICAvLyAgIDwub2xkZXIgICAubmV3ZXI+XG4gIC8vICA8LS0tIGFkZCBkaXJlY3Rpb24gLS1cbiAgLy8gICBBICBCICBDICA8RD4gIEVcbiAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyOyAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7IC8vIEMuIC0tPiBFXG4gIH1cbiAgZW50cnkubmV3ZXIgPSB1bmRlZmluZWQ7IC8vIEQgLS14XG4gIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsOyAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7IC8vIEUuIDwtLSBEXG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnk7XG4gIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG59O1xuXG52YXIgY2FjaGUkMSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBmaWx0ZXJUb2tlblJFID0gL1teXFxzJ1wiXSt8J1teJ10qJ3xcIlteXCJdKlwiL2c7XG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvO1xuXG4vKipcbiAqIFBhcnNlciBzdGF0ZVxuICovXG5cbnZhciBzdHI7XG52YXIgZGlyO1xudmFyIGM7XG52YXIgcHJldjtcbnZhciBpO1xudmFyIGw7XG52YXIgbGFzdEZpbHRlckluZGV4O1xudmFyIGluU2luZ2xlO1xudmFyIGluRG91YmxlO1xudmFyIGN1cmx5O1xudmFyIHNxdWFyZTtcbnZhciBwYXJlbjtcbi8qKlxuICogUHVzaCBhIGZpbHRlciB0byB0aGUgY3VycmVudCBkaXJlY3RpdmUgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcbiAgdmFyIGV4cCA9IHN0ci5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKTtcbiAgdmFyIGZpbHRlcjtcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9O1xuICAgIHZhciB0b2tlbnMgPSBleHAubWF0Y2goZmlsdGVyVG9rZW5SRSk7XG4gICAgZmlsdGVyLm5hbWUgPSB0b2tlbnNbMF07XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZyk7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIpIHtcbiAgICAoZGlyLmZpbHRlcnMgPSBkaXIuZmlsdGVycyB8fCBbXSkucHVzaChmaWx0ZXIpO1xuICB9XG4gIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyhhcmcpIHtcbiAgaWYgKHJlc2VydmVkQXJnUkUudGVzdChhcmcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKGFyZyk7XG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZHluYW1pYyA/IGFyZyA6IHN0cmlwcGVkLFxuICAgICAgZHluYW1pYzogZHluYW1pY1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRpcmVjdGl2ZSB2YWx1ZSBhbmQgZXh0cmFjdCB0aGUgZXhwcmVzc2lvblxuICogYW5kIGl0cyBmaWx0ZXJzIGludG8gYSBkZXNjcmlwdG9yLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogXCJhICsgMSB8IHVwcGVyY2FzZVwiIHdpbGwgeWllbGQ6XG4gKiB7XG4gKiAgIGV4cHJlc3Npb246ICdhICsgMScsXG4gKiAgIGZpbHRlcnM6IFtcbiAqICAgICB7IG5hbWU6ICd1cHBlcmNhc2UnLCBhcmdzOiBudWxsIH1cbiAqICAgXVxuICogfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocykge1xuICB2YXIgaGl0ID0gY2FjaGUkMS5nZXQocyk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHM7XG4gIGluU2luZ2xlID0gaW5Eb3VibGUgPSBmYWxzZTtcbiAgY3VybHkgPSBzcXVhcmUgPSBwYXJlbiA9IDA7XG4gIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGRpciA9IHt9O1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9ICFpblNpbmdsZTtcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gIWluRG91YmxlO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgc3RyLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmIHN0ci5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3Qykge1xuICAgICAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7YnJlYWs7IC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICBpblNpbmdsZSA9IHRydWU7YnJlYWs7IC8vICdcbiAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgIHBhcmVuKys7YnJlYWs7IC8vIChcbiAgICAgICAgY2FzZSAweDI5OlxuICAgICAgICAgIHBhcmVuLS07YnJlYWs7IC8vIClcbiAgICAgICAgY2FzZSAweDVCOlxuICAgICAgICAgIHNxdWFyZSsrO2JyZWFrOyAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDpcbiAgICAgICAgICBzcXVhcmUtLTticmVhazsgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6XG4gICAgICAgICAgY3VybHkrKzticmVhazsgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6XG4gICAgICAgICAgY3VybHktLTticmVhazsgLy8gfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGNhY2hlJDEucHV0KHMsIGRpcik7XG4gIHJldHVybiBkaXI7XG59XG5cbnZhciBkaXJlY3RpdmUgPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VEaXJlY3RpdmU6IHBhcnNlRGlyZWN0aXZlXG59KTtcblxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xudmFyIGNhY2hlID0gdW5kZWZpbmVkO1xudmFyIHRhZ1JFID0gdW5kZWZpbmVkO1xudmFyIGh0bWxSRSA9IHVuZGVmaW5lZDtcbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSZWdleCgpIHtcbiAgdmFyIG9wZW4gPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1swXSk7XG4gIHZhciBjbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzFdKTtcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSk7XG4gIHZhciB1bnNhZmVDbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzFdKTtcbiAgdGFnUkUgPSBuZXcgUmVnRXhwKHVuc2FmZU9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICsgb3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJyk7XG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoJ14nICsgdW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnJCcpO1xuICAvLyByZXNldCBjYWNoZVxuICBjYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIHRleHQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+IHwgbnVsbH1cbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2h0bWxdXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtvbmVUaW1lXVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0KSB7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjb21waWxlUmVnZXgoKTtcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWU7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleClcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBodG1sID0gaHRtbFJFLnRlc3QobWF0Y2hbMF0pO1xuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl07XG4gICAgZmlyc3QgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgIG9uZVRpbWUgPSBmaXJzdCA9PT0gNDI7IC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWUgPyB2YWx1ZS5zbGljZSgxKSA6IHZhbHVlO1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHRhZzogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZS50cmltKCksXG4gICAgICBodG1sOiBodG1sLFxuICAgICAgb25lVGltZTogb25lVGltZVxuICAgIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleClcbiAgICB9KTtcbiAgfVxuICBjYWNoZS5wdXQodGV4dCwgdG9rZW5zKTtcbiAgcmV0dXJuIHRva2Vucztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBsaXN0IG9mIHRva2VucyBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKiBlLmcuIHRva2VucyBwYXJzZWQgZnJvbSAnYSB7e2J9fSBjJyBjYW4gYmUgc2VyaWFsaXplZFxuICogaW50byBvbmUgc2luZ2xlIGV4cHJlc3Npb24gYXMgJ1wiYSBcIiArIGIgKyBcIiBjXCInLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbnNUb0V4cCh0b2tlbnMsIHZtKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2VuLCB2bSk7XG4gICAgfSkuam9pbignKycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbnNbMF0sIHZtLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4odG9rZW4sIHZtLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZyA/IHRva2VuLm9uZVRpbWUgJiYgdm0gPyAnXCInICsgdm0uJGV2YWwodG9rZW4udmFsdWUpICsgJ1wiJyA6IGlubGluZUZpbHRlcnModG9rZW4udmFsdWUsIHNpbmdsZSkgOiAnXCInICsgdG9rZW4udmFsdWUgKyAnXCInO1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vO1xuZnVuY3Rpb24gaW5saW5lRmlsdGVycyhleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGUgPyBleHAgOiAnKCcgKyBleHAgKyAnKSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKGV4cCk7XG4gICAgaWYgKCFkaXIuZmlsdGVycykge1xuICAgICAgcmV0dXJuICcoJyArIGV4cCArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICcsbnVsbCwnICsgLy8gb2xkVmFsdWUgKG51bGwgZm9yIHJlYWQpXG4gICAgICBKU09OLnN0cmluZ2lmeShkaXIuZmlsdGVycykgKyAvLyBmaWx0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICcsZmFsc2UpJzsgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbXBpbGVSZWdleDogY29tcGlsZVJlZ2V4LFxuICBwYXJzZVRleHQ6IHBhcnNlVGV4dCxcbiAgdG9rZW5zVG9FeHA6IHRva2Vuc1RvRXhwXG59KTtcblxudmFyIGRlbGltaXRlcnMgPSBbJ3t7JywgJ319J107XG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddO1xuXG52YXIgY29uZmlnID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzLlxuICAgKiBBbHNvIGVuYWJsZXMgc3RhY2sgdHJhY2UgZm9yIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZGVidWc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB1c2UgYXN5bmMgcmVuZGVyaW5nLlxuICAgKi9cblxuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB3YXJuIGFnYWluc3QgZXJyb3JzIGNhdWdodCB3aGVuIGV2YWx1YXRpbmdcbiAgICogZXhwcmVzc2lvbnMuXG4gICAqL1xuXG4gIHdhcm5FeHByZXNzaW9uRXJyb3JzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFsbG93IGRldnRvb2xzIGluc3BlY3Rpb24uXG4gICAqIERpc2FibGVkIGJ5IGRlZmF1bHQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gICAqL1xuXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmbGFnIHRvIGluZGljYXRlIHRoZSBkZWxpbWl0ZXJzIGhhdmUgYmVlblxuICAgKiBjaGFuZ2VkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgX2RlbGltaXRlcnNDaGFuZ2VkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblxuICBfYXNzZXRUeXBlczogWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2VsZW1lbnREaXJlY3RpdmUnLCAnZmlsdGVyJywgJ3RyYW5zaXRpb24nLCAncGFydGlhbCddLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn0sIHtcbiAgZGVsaW1pdGVyczogeyAvKipcbiAgICAgICAgICAgICAgICAgKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCBwYXJzZXIgdG8gcmUtY29tcGlsZSB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgZGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgdW5zYWZlRGVsaW1pdGVyczoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIHVuc2FmZURlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgd2FybiA9IHVuZGVmaW5lZDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gdW5kZWZpbmVkO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVnVlIHdhcm5dOiAnICsgbXNnICsgKHZtID8gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkgOiAnJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9pc1Z1ZSA/IHZtLiRvcHRpb25zLm5hbWUgOiB2bS5uYW1lO1xuICAgICAgcmV0dXJuIG5hbWUgPyAnIChmb3VuZCBpbiBjb21wb25lbnQ6IDwnICsgaHlwaGVuYXRlKG5hbWUpICsgJz4pJyA6ICcnO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbi8qKlxuICogQXBwZW5kIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVdpdGhUcmFuc2l0aW9uKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAtMSwgZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZShlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogQXBwbHkgdHJhbnNpdGlvbnMgd2l0aCBhbiBvcGVyYXRpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogICAgICAgICAgICAgICAgICAxOiBlbnRlclxuICogICAgICAgICAgICAgICAgIC0xOiBsZWF2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSB0aGUgYWN0dWFsIERPTSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNpdGlvbihlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zO1xuICBpZiAoIXRyYW5zaXRpb24gfHxcbiAgLy8gc2tpcCBpZiB0aGVyZSBhcmUgbm8ganMgaG9va3MgYW5kIENTUyB0cmFuc2l0aW9uIGlzXG4gIC8vIG5vdCBzdXBwb3J0ZWRcbiAgIXRyYW5zaXRpb24uaG9va3MgJiYgIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIHRyYW5zaXRpb25zIGZvciBpbml0aWFsIGNvbXBpbGVcbiAgIXZtLl9pc0NvbXBpbGVkIHx8XG4gIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgLy8gZHVyaW5nIHRoZSBwYXJlbnQncyBjb21waWxhdGlvbiBwaGFzZSwgc2tpcCB0aGVcbiAgLy8gYW5pbWF0aW9uLlxuICB2bS4kcGFyZW50ICYmICF2bS4kcGFyZW50Ll9pc0NvbXBpbGVkKSB7XG4gICAgb3AoKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSc7XG4gIHRyYW5zaXRpb25bYWN0aW9uXShvcCwgY2IpO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICBhcHBlbmRXaXRoVHJhbnNpdGlvbjogYXBwZW5kV2l0aFRyYW5zaXRpb24sXG4gIGJlZm9yZVdpdGhUcmFuc2l0aW9uOiBiZWZvcmVXaXRoVHJhbnNpdGlvbixcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb246IHJlbW92ZVdpdGhUcmFuc2l0aW9uLFxuICBhcHBseVRyYW5zaXRpb246IGFwcGx5VHJhbnNpdGlvblxufSk7XG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIHNlbGVjdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gKiBOb3RlOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgc2hvdWxkIHdvcmsgaGVyZVxuICogYnV0IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBjb21tZW50IG5vZGVzIGluIHBoYW50b21qcyxcbiAqIG1ha2luZyB1bml0IHRlc3RzIGRpZmZpY3VsdC4gVGhpcyBpcyBmaXhlZCBieSBkb2luZyB0aGVcbiAqIGNvbnRhaW5zKCkgY2hlY2sgb24gdGhlIG5vZGUncyBwYXJlbnROb2RlIGluc3RlYWQgb2ZcbiAqIHRoZSBub2RlIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaW5Eb2Mobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBkb2MgPT09IG5vZGUgfHwgZG9jID09PSBwYXJlbnQgfHwgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiBkb2MuY29udGFpbnMocGFyZW50KSk7XG59XG5cbi8qKlxuICogR2V0IGFuZCByZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IF9hdHRyXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXR0cihub2RlLCBfYXR0cikge1xuICB2YXIgdmFsID0gbm9kZS5nZXRBdHRyaWJ1dGUoX2F0dHIpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGNvbG9uIG9yIHYtYmluZDogcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHZhbCA9IGdldEF0dHIobm9kZSwgJzonICsgbmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICB2YWwgPSBnZXRBdHRyKG5vZGUsICd2LWJpbmQ6JyArIG5hbWUpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogQ2hlY2sgdGhlIHByZXNlbmNlIG9mIGEgYmluZCBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5kQXR0cihub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgnOicgKyBuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndi1iaW5kOicgKyBuYW1lKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlKGVsLCB0YXJnZXQpIHtcbiAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIGFmdGVyKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0Lm5leHRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG4vKipcbiAqIFByZXBlbmQgZWwgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBwcmVwZW5kKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0LCBlbCkge1xuICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgY2IsIHVzZUNhcHR1cmUpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKTtcbn1cblxuLyoqXG4gKiBGb3IgSUU5IGNvbXBhdDogd2hlbiBib3RoIGNsYXNzIGFuZCA6Y2xhc3MgYXJlIHByZXNlbnRcbiAqIGdldEF0dHJpYnV0ZSgnY2xhc3MnKSByZXR1cm5zIHdyb25nIHZhbHVlLi4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XG4gIHZhciBjbGFzc25hbWUgPSBlbC5jbGFzc05hbWU7XG4gIGlmICh0eXBlb2YgY2xhc3NuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGNsYXNzbmFtZSA9IGNsYXNzbmFtZS5iYXNlVmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBjbGFzc25hbWU7XG59XG5cbi8qKlxuICogSW4gSUU5LCBzZXRBdHRyaWJ1dGUoJ2NsYXNzJykgd2lsbCByZXN1bHQgaW4gZW1wdHkgY2xhc3NcbiAqIGlmIHRoZSBlbGVtZW50IGFsc28gaGFzIHRoZSA6Y2xhc3MgYXR0cmlidXRlOyBIb3dldmVyIGluXG4gKiBQaGFudG9tSlMsIHNldHRpbmcgYGNsYXNzTmFtZWAgZG9lcyBub3Qgd29yayBvbiBTVkcgZWxlbWVudHMuLi5cbiAqIFNvIHdlIGhhdmUgdG8gZG8gYSBjb25kaXRpb25hbCBjaGVjayBoZXJlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBzZXRDbGFzcyhlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgIS9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbHM7XG4gIH0gZWxzZSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGdldENsYXNzKGVsKSArICcgJztcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIHNldENsYXNzKGVsLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBzZXRDbGFzcyhlbCwgY3VyLnRyaW0oKSk7XG4gIH1cbiAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGQ7XG4gIHZhciByYXdDb250ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzVGVtcGxhdGUoZWwpICYmIGlzRnJhZ21lbnQoZWwuY29udGVudCkpIHtcbiAgICBlbCA9IGVsLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRyaW1Ob2RlKGVsKTtcbiAgICByYXdDb250ZW50ID0gYXNGcmFnbWVudCA/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gZWwuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdDb250ZW50O1xufVxuXG4vKipcbiAqIFRyaW0gcG9zc2libGUgZW1wdHkgaGVhZC90YWlsIHRleHQgYW5kIGNvbW1lbnRcbiAqIG5vZGVzIGluc2lkZSBhIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiB0cmltTm9kZShub2RlKSB7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VxdWVuY2VzICovXG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICB3aGlsZSAoKGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlcXVlbmNlcyAqL1xufVxuXG5mdW5jdGlvbiBpc1RyaW1tYWJsZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAzICYmICFub2RlLmRhdGEudHJpbSgpIHx8IG5vZGUubm9kZVR5cGUgPT09IDgpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBbmNob3IoY29udGVudCwgcGVyc2lzdCkge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmRlYnVnID8gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJyk7XG4gIGFuY2hvci5fX3ZfYW5jaG9yID0gdHJ1ZTtcbiAgcmV0dXJuIGFuY2hvcjtcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi87XG5cbmZ1bmN0aW9uIGZpbmRSZWYobm9kZSkge1xuICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjYW1lbGl6ZShuYW1lLnJlcGxhY2UocmVmUkUsICcnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFwIGEgZnVuY3Rpb24gdG8gYSByYW5nZSBvZiBub2RlcyAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3BcbiAqL1xuXG5mdW5jdGlvbiBtYXBOb2RlUmFuZ2Uobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKG5vZGUgIT09IGVuZCkge1xuICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG9wKG5vZGUpO1xuICAgIG5vZGUgPSBuZXh0O1xuICB9XG4gIG9wKGVuZCk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgcmFuZ2Ugb2Ygbm9kZXMgd2l0aCB0cmFuc2l0aW9uLCBzdG9yZVxuICogdGhlIG5vZGVzIGluIGEgZnJhZ21lbnQgd2l0aCBjb3JyZWN0IG9yZGVyaW5nLFxuICogYW5kIGNhbGwgY2FsbGJhY2sgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZW1vdmVkID0gMDtcbiAgdmFyIG5vZGVzID0gW107XG4gIG1hcE5vZGVSYW5nZShzdGFydCwgZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbmQpIGRvbmUgPSB0cnVlO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgcmVtb3ZlV2l0aFRyYW5zaXRpb24obm9kZSwgdm0sIG9uUmVtb3ZlZCk7XG4gIH0pO1xuICBmdW5jdGlvbiBvblJlbW92ZWQoKSB7XG4gICAgcmVtb3ZlZCsrO1xuICAgIGlmIChkb25lICYmIHJlbW92ZWQgPj0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0ZyYWdtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xuICB9XG59XG5cbnZhciBjb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9pO1xudmFyIHJlc2VydmVkVGFnUkUgPSAvXihzbG90fHBhcnRpYWx8Y29tcG9uZW50KSQvaTtcblxudmFyIGlzVW5rbm93bkVsZW1lbnQgPSB1bmRlZmluZWQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpc1Vua25vd25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCB0YWcpIHtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHwgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpICYmXG4gICAgICAgIC8vIENocm9tZSByZXR1cm5zIHVua25vd24gZm9yIHNldmVyYWwgSFRNTDUgZWxlbWVudHMuXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIHVua25vd24gZm9yIHNvbWUgXCJJbnRlcmFjdGl2ZSBlbGVtZW50cy5cIlxuICAgICAgICAhL14oZGF0YXx0aW1lfHJ0Y3xyYnxkZXRhaWxzfGRpYWxvZ3xzdW1tYXJ5KSQvLnRlc3QodGFnKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudCwgaWYgeWVzIHJldHVybiBpdHNcbiAqIGNvbXBvbmVudCBpZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICBpZiAoIWNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiAhcmVzZXJ2ZWRUYWdSRS50ZXN0KHRhZykpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXMgPSBoYXNBdHRycyAmJiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIHJldHVybiBpcztcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUYWcgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwICYmIG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXBbdGFnXTtcbiAgICAgICAgaWYgKGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtICcgKyAnZGlkIHlvdSBtZWFuIDwnICsgZXhwZWN0ZWRUYWcgKyAnPj8gJyArICdIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSBrZWJhYi1jYXNlIGluIHRlbXBsYXRlcy4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Vua25vd25FbGVtZW50KGVsLCB0YWcpKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBcImlzXCIgYmluZGluZyBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKSB7XG4gIC8vIGR5bmFtaWMgc3ludGF4XG4gIHZhciBleHAgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lzJyk7XG4gIGlmIChleHAgIT0gbnVsbCkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCBleHApKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICByZXR1cm4geyBpZDogZXhwIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKlxuICogQWxsIHN0cmF0ZWd5IGZ1bmN0aW9ucyBmb2xsb3cgdGhlIHNhbWUgc2lnbmF0dXJlOlxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyZW50VmFsXG4gKiBAcGFyYW0geyp9IGNoaWxkVmFsXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICovXG5cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEodG8sIGZyb20pIHtcbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodG9WYWwpICYmIGlzT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogRGF0YVxuICovXG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoY2hpbGRWYWwuY2FsbCh0aGlzKSwgcGFyZW50VmFsLmNhbGwodGhpcykpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHZtKSA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHZtKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIEVsXG4gKi9cblxuc3RyYXRzLmVsID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0gJiYgY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXQgPSBjaGlsZFZhbCB8fCBwYXJlbnRWYWw7XG4gIC8vIGludm9rZSB0aGUgZWxlbWVudCBmYWN0b3J5IGlmIHRoaXMgaXMgaW5zdGFuY2UgbWVyZ2VcbiAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID0gc3RyYXRzLmNyZWF0ZWQgPSBzdHJhdHMucmVhZHkgPSBzdHJhdHMuYXR0YWNoZWQgPSBzdHJhdHMuZGV0YWNoZWQgPSBzdHJhdHMuYmVmb3JlQ29tcGlsZSA9IHN0cmF0cy5jb21waWxlZCA9IHN0cmF0cy5iZWZvcmVEZXN0cm95ID0gc3RyYXRzLmRlc3Ryb3llZCA9IHN0cmF0cy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG59O1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBndWFyZEFycmF5QXNzZXRzKGNoaWxkVmFsKSkgOiByZXM7XG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnQgPyBwYXJlbnQuY29uY2F0KGNoaWxkKSA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuXG5zdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cblxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICogY29uc3RydWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzID0gZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKTtcbiAgICB2YXIgZGVmO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFwID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGlkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpZHNbaV07XG4gICAgICBpZiAoY29tbW9uVGFnUkUudGVzdChrZXkpIHx8IHJlc2VydmVkVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyByZWNvcmQgYSBhbGwgbG93ZXJjYXNlIDwtPiBrZWJhYi1jYXNlIG1hcHBpbmcgZm9yXG4gICAgICAvLyBwb3NzaWJsZSBjdXN0b20gZWxlbWVudCBjYXNlIGVycm9yIHdhcm5pbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1hcFtrZXkucmVwbGFjZSgvLS9nLCAnJykudG9Mb3dlckNhc2UoKV0gPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgY29tcG9uZW50c1trZXldID0gVnVlLmV4dGVuZChkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICB2YXIgaSwgdmFsO1xuICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICBvcHRpb25zLnByb3BzID0ge307XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh2YWwubmFtZSkge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNba2V5c1tpXV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICogaW50byB0aGUga2V5LXZhbHVlIE9iamVjdCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gIGlmIChpc0FycmF5KGFzc2V0cykpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBhc3NldDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgIHZhciBpZCA9IHR5cGVvZiBhc3NldCA9PT0gJ2Z1bmN0aW9uJyA/IGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lIHx8IGFzc2V0LmlkIDogYXNzZXQubmFtZSB8fCBhc3NldC5pZDtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBcnJheS1zeW50YXggYXNzZXRzIG11c3QgcHJvdmlkZSBhIFwibmFtZVwiIG9yIFwiaWRcIiBmaWVsZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYXNzZXRzO1xufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXSAtIGlmIHZtIGlzIHByZXNlbnQsIGluZGljYXRlcyB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgIGFuIGluc3RhbnRpYXRpb24gbWVyZ2UuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gIGd1YXJkQ29tcG9uZW50cyhjaGlsZCk7XG4gIGd1YXJkUHJvcHMoY2hpbGQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjaGlsZC5wcm9wc0RhdGEgJiYgIXZtKSB7XG4gICAgICB3YXJuKCdwcm9wc0RhdGEgY2FuIG9ubHkgYmUgdXNlZCBhcyBhbiBpbnN0YW50aWF0aW9uIG9wdGlvbi4nKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgaWYgKGNoaWxkWydleHRlbmRzJ10pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgY2hpbGRbJ2V4dGVuZHMnXSA9PT0gJ2Z1bmN0aW9uJyA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkWydleHRlbmRzJ10ub3B0aW9ucywgdm0pIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIHZhciBtaXhpbk9wdGlvbnMgPSBtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUgPyBtaXhpbi5vcHRpb25zIDogbWl4aW47XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbk9wdGlvbnMsIHZtKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2Fybk1pc3NpbmdcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgdmFyIGNhbWVsaXplZElkO1xuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fFxuICAvLyBjYW1lbENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkID0gY2FtZWxpemUoaWQpXSB8fFxuICAvLyBQYXNjYWwgQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbGl6ZWRJZC5zbGljZSgxKV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEZXAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn1cblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLiRyZW1vdmUoc3ViKTtcbn07XG5cbi8qKlxuICogQWRkIHNlbGYgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0YXJnZXQgd2F0Y2hlci5cbiAqL1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG59O1xuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0b0FycmF5KHRoaXMuc3Vicyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pXG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cblxuO1sncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnLCAnc29ydCcsICdyZXZlcnNlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHNldCcsIGZ1bmN0aW9uICRzZXQoaW5kZXgsIHZhbCkge1xuICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IE51bWJlcihpbmRleCkgKyAxO1xuICB9XG4gIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXTtcbn0pO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgdGhlIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXggb3IgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaXRlbVxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHJlbW92ZScsIGZ1bmN0aW9uICRyZW1vdmUoaXRlbSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMsIGl0ZW0pO1xuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn0pO1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgaW4gY2VydGFpbiBjYXNlcywgZS5nLlxuICogdi1mb3Igc2NvcGUgYWxpYXMgYW5kIHByb3BzLCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb25cbiAqIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZSB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBTbyB3aGVuZXZlciB3ZSB3YW50IHRvIHNldCBhIHJlYWN0aXZlIHByb3BlcnR5IHdpdGhvdXQgZm9yY2luZ1xuICogY29udmVyc2lvbiBvbiB0aGUgbmV3IHZhbHVlLCB3ZSB3cmFwIHRoYXQgY2FsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAqL1xuXG52YXIgc2hvdWxkQ29udmVydCA9IHRydWU7XG5cbmZ1bmN0aW9uIHdpdGhvdXRDb252ZXJzaW9uKGZuKSB7XG4gIHNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgZm4oKTtcbiAgc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvID8gcHJvdG9BdWdtZW50IDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59XG5cbi8vIEluc3RhbmNlIG1ldGhvZHNcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLmNvbnZlcnQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgaW50byBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBlbWl0XG4gKiB0aGUgZXZlbnRzIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkL2NoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBkZWZpbmVSZWFjdGl2ZSh0aGlzLnZhbHVlLCBrZXksIHZhbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gb3duZXIgdm0uIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIG9iamVjdCBpc1xuICogc3dhcHBlZCBvdXQgYXMgYW4gaW5zdGFuY2UncyAkZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLnJlbW92ZVZtID0gZnVuY3Rpb24gKHZtKSB7XG4gIHRoaXMudm1zLiRyZW1vdmUodm0pO1xufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXVnbWVudCh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHZtKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKHNob3VsZENvbnZlcnQgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJiAhdmFsdWUuX2lzVnVlKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKTtcbiAgfVxuICByZXR1cm4gb2I7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlLFxuXHRzZXQ6IHNldCxcblx0ZGVsOiBkZWwsXG5cdGhhc093bjogaGFzT3duLFxuXHRpc0xpdGVyYWw6IGlzTGl0ZXJhbCxcblx0aXNSZXNlcnZlZDogaXNSZXNlcnZlZCxcblx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdHRvTnVtYmVyOiB0b051bWJlcixcblx0dG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG5cdHN0cmlwUXVvdGVzOiBzdHJpcFF1b3Rlcyxcblx0Y2FtZWxpemU6IGNhbWVsaXplLFxuXHRoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcblx0Y2xhc3NpZnk6IGNsYXNzaWZ5LFxuXHRiaW5kOiBiaW5kLFxuXHR0b0FycmF5OiB0b0FycmF5LFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuXHRkZWY6IGRlZixcblx0ZGVib3VuY2U6IF9kZWJvdW5jZSxcblx0aW5kZXhPZjogaW5kZXhPZixcblx0Y2FuY2VsbGFibGU6IGNhbmNlbGxhYmxlLFxuXHRsb29zZUVxdWFsOiBsb29zZUVxdWFsLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRoYXNQcm90bzogaGFzUHJvdG8sXG5cdGluQnJvd3NlcjogaW5Ccm93c2VyLFxuXHRkZXZ0b29sczogZGV2dG9vbHMsXG5cdGlzSUU6IGlzSUUsXG5cdGlzSUU5OiBpc0lFOSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGlzSW9zOiBpc0lvcyxcblx0aW9zVmVyc2lvbk1hdGNoOiBpb3NWZXJzaW9uTWF0Y2gsXG5cdGlvc1ZlcnNpb246IGlvc1ZlcnNpb24sXG5cdGhhc011dGF0aW9uT2JzZXJ2ZXJCdWc6IGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcsXG5cdGdldCB0cmFuc2l0aW9uUHJvcCAoKSB7IHJldHVybiB0cmFuc2l0aW9uUHJvcDsgfSxcblx0Z2V0IHRyYW5zaXRpb25FbmRFdmVudCAoKSB7IHJldHVybiB0cmFuc2l0aW9uRW5kRXZlbnQ7IH0sXG5cdGdldCBhbmltYXRpb25Qcm9wICgpIHsgcmV0dXJuIGFuaW1hdGlvblByb3A7IH0sXG5cdGdldCBhbmltYXRpb25FbmRFdmVudCAoKSB7IHJldHVybiBhbmltYXRpb25FbmRFdmVudDsgfSxcblx0bmV4dFRpY2s6IG5leHRUaWNrLFxuXHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuXHRxdWVyeTogcXVlcnksXG5cdGluRG9jOiBpbkRvYyxcblx0Z2V0QXR0cjogZ2V0QXR0cixcblx0Z2V0QmluZEF0dHI6IGdldEJpbmRBdHRyLFxuXHRoYXNCaW5kQXR0cjogaGFzQmluZEF0dHIsXG5cdGJlZm9yZTogYmVmb3JlLFxuXHRhZnRlcjogYWZ0ZXIsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRwcmVwZW5kOiBwcmVwZW5kLFxuXHRyZXBsYWNlOiByZXBsYWNlLFxuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRzZXRDbGFzczogc2V0Q2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHRleHRyYWN0Q29udGVudDogZXh0cmFjdENvbnRlbnQsXG5cdHRyaW1Ob2RlOiB0cmltTm9kZSxcblx0aXNUZW1wbGF0ZTogaXNUZW1wbGF0ZSxcblx0Y3JlYXRlQW5jaG9yOiBjcmVhdGVBbmNob3IsXG5cdGZpbmRSZWY6IGZpbmRSZWYsXG5cdG1hcE5vZGVSYW5nZTogbWFwTm9kZVJhbmdlLFxuXHRyZW1vdmVOb2RlUmFuZ2U6IHJlbW92ZU5vZGVSYW5nZSxcblx0aXNGcmFnbWVudDogaXNGcmFnbWVudCxcblx0Z2V0T3V0ZXJIVE1MOiBnZXRPdXRlckhUTUwsXG5cdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuXHRyZXNvbHZlQXNzZXQ6IHJlc29sdmVBc3NldCxcblx0Y2hlY2tDb21wb25lbnRBdHRyOiBjaGVja0NvbXBvbmVudEF0dHIsXG5cdGNvbW1vblRhZ1JFOiBjb21tb25UYWdSRSxcblx0cmVzZXJ2ZWRUYWdSRTogcmVzZXJ2ZWRUYWdSRSxcblx0Z2V0IHdhcm4gKCkgeyByZXR1cm4gd2FybjsgfVxufSk7XG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVGhlIG1haW4gaW5pdCBzZXF1ZW5jZS4gVGhpcyBpcyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAgICogY29uc3RydWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBhbmQgdGhlIG9wdGlvbnMgcGFzc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcztcbiAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuJHJlZnMgPSB7fTsgLy8gY2hpbGQgdm0gcmVmZXJlbmNlc1xuICAgIHRoaXMuJGVscyA9IHt9OyAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICB0aGlzLl9kaXJlY3RpdmVzID0gW107IC8vIGFsbCBkaXJlY3RpdmVzXG5cbiAgICAvLyBhIHVpZFxuICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB0aGlzLl9pc1Z1ZSA9IHRydWU7XG5cbiAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICB0aGlzLl9ldmVudHMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IHt9OyAvLyBmb3IgJGJyb2FkY2FzdCBvcHRpbWl6YXRpb25cblxuICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhZ21lbnQgPSAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGw7IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG5cbiAgICAvLyBsaWZlY3ljbGUgc3RhdGVcbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0aGlzLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl91bmxpbmtGbiA9IG51bGw7XG5cbiAgICAvLyBjb250ZXh0OlxuICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgLy8gc2NvcGU6XG4gICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAvLyBmcmFnbWVudDpcbiAgICAvLyBpZiB0aGlzIGluc3RhbmNlIGlzIGNvbXBpbGVkIGluc2lkZSBhIEZyYWdtZW50LCBpdFxuICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMuX2ZyYWcgPSBvcHRpb25zLl9mcmFnO1xuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuJGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucy5cbiAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gc2V0IHJlZlxuICAgIHRoaXMuX3VwZGF0ZVJlZigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIGFzIGVtcHR5IG9iamVjdC5cbiAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdERhdGEoKS5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAvLyBjYWxsIGluaXQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdpbml0Jyk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICAgIHRoaXMuX2luaXRTdGF0ZSgpO1xuXG4gICAgLy8gc2V0dXAgZXZlbnQgc3lzdGVtIGFuZCBvcHRpb24gZXZlbnRzLlxuICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgIC8vIGNhbGwgY3JlYXRlZCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDA7XG52YXIgUFVTSCA9IDE7XG52YXIgSU5DX1NVQl9QQVRIX0RFUFRIID0gMjtcbnZhciBQVVNIX1NVQl9QQVRIID0gMztcblxuLy8gc3RhdGVzXG52YXIgQkVGT1JFX1BBVEggPSAwO1xudmFyIElOX1BBVEggPSAxO1xudmFyIEJFRk9SRV9JREVOVCA9IDI7XG52YXIgSU5fSURFTlQgPSAzO1xudmFyIElOX1NVQl9QQVRIID0gNDtcbnZhciBJTl9TSU5HTEVfUVVPVEUgPSA1O1xudmFyIElOX0RPVUJMRV9RVU9URSA9IDY7XG52YXIgQUZURVJfUEFUSCA9IDc7XG52YXIgRVJST1IgPSA4O1xuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdO1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9QQVRIXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9QQVRIXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fUEFUSF0gPSB7XG4gICd3cyc6IFtJTl9QQVRIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5UXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSURFTlRdID0ge1xuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICcwJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnd3MnOiBbSU5fUEFUSCwgUFVTSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVCwgUFVTSF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBQVVNIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRILCBQVVNIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TVUJfUEFUSF0gPSB7XG4gIFwiJ1wiOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdLFxuICAnXCInOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgSU5DX1NVQl9QQVRIX0RFUFRIXSxcbiAgJ10nOiBbSU5fUEFUSCwgUFVTSF9TVUJfUEFUSF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU1VCX1BBVEgsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU0lOR0xFX1FVT1RFXSA9IHtcbiAgXCInXCI6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBjaGFyYWN0ZXIgaW4gYSBrZXlwYXRoLlxuICpcbiAqIEBwYXJhbSB7Q2hhcn0gY2hcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhDaGFyVHlwZShjaCkge1xuICBpZiAoY2ggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnZW9mJztcbiAgfVxuXG4gIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOlxuICAgICAgLy8gMFxuICAgICAgcmV0dXJuIGNoO1xuXG4gICAgY2FzZSAweDVGOiAvLyBfXG4gICAgY2FzZSAweDI0OlxuICAgICAgLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCc7XG5cbiAgICBjYXNlIDB4MjA6IC8vIFNwYWNlXG4gICAgY2FzZSAweDA5OiAvLyBUYWJcbiAgICBjYXNlIDB4MEE6IC8vIE5ld2xpbmVcbiAgICBjYXNlIDB4MEQ6IC8vIFJldHVyblxuICAgIGNhc2UgMHhBMDogLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogLy8gQnl0ZSBPcmRlciBNYXJrXG4gICAgY2FzZSAweDIwMjg6IC8vIExpbmUgU2VwYXJhdG9yXG4gICAgY2FzZSAweDIwMjk6XG4gICAgICAvLyBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gICAgICByZXR1cm4gJ3dzJztcbiAgfVxuXG4gIC8vIGEteiwgQS1aXG4gIGlmIChjb2RlID49IDB4NjEgJiYgY29kZSA8PSAweDdBIHx8IGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpIHtcbiAgICByZXR1cm4gJ2lkZW50JztcbiAgfVxuXG4gIC8vIDEtOVxuICBpZiAoY29kZSA+PSAweDMxICYmIGNvZGUgPD0gMHgzOSkge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIHJldHVybiAnZWxzZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc3ViUGF0aCwgcmV0dXJuIGl0cyBwbGFpbiBmb3JtIGlmIGl0IGlzXG4gKiBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci4gT3RoZXJ3aXNlIHByZXBlbmQgdGhlXG4gKiBkeW5hbWljIGluZGljYXRvciAoKikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRTdWJQYXRoKHBhdGgpIHtcbiAgdmFyIHRyaW1tZWQgPSBwYXRoLnRyaW0oKTtcbiAgLy8gaW52YWxpZCBsZWFkaW5nIDBcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnMCcgJiYgaXNOYU4ocGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTGl0ZXJhbCh0cmltbWVkKSA/IHN0cmlwUXVvdGVzKHRyaW1tZWQpIDogJyonICsgdHJpbW1lZDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEg7XG4gIHZhciBzdWJQYXRoRGVwdGggPSAwO1xuICB2YXIgYywgbmV3Q2hhciwga2V5LCB0eXBlLCB0cmFuc2l0aW9uLCBhY3Rpb24sIHR5cGVNYXA7XG5cbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbQVBQRU5EXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9IG5ld0NoYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSArPSBuZXdDaGFyO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0lOQ19TVUJfUEFUSF9ERVBUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgc3ViUGF0aERlcHRoKys7XG4gIH07XG5cbiAgYWN0aW9uc1tQVVNIX1NVQl9QQVRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3ViUGF0aERlcHRoID4gMCkge1xuICAgICAgc3ViUGF0aERlcHRoLS07XG4gICAgICBtb2RlID0gSU5fU1VCX1BBVEg7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViUGF0aERlcHRoID0gMDtcbiAgICAgIGtleSA9IGZvcm1hdFN1YlBhdGgoa2V5KTtcbiAgICAgIGlmIChrZXkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnNbUFVTSF0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVVbmVzY2FwZVF1b3RlKCkge1xuICAgIHZhciBuZXh0Q2hhciA9IHBhdGhbaW5kZXggKyAxXTtcbiAgICBpZiAobW9kZSA9PT0gSU5fU0lOR0xFX1FVT1RFICYmIG5leHRDaGFyID09PSBcIidcIiB8fCBtb2RlID09PSBJTl9ET1VCTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBuZXdDaGFyID0gJ1xcXFwnICsgbmV4dENoYXI7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChtb2RlICE9IG51bGwpIHtcbiAgICBpbmRleCsrO1xuICAgIGMgPSBwYXRoW2luZGV4XTtcblxuICAgIGlmIChjID09PSAnXFxcXCcgJiYgbWF5YmVVbmVzY2FwZVF1b3RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBnZXRQYXRoQ2hhclR5cGUoYyk7XG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV07XG4gICAgdHJhbnNpdGlvbiA9IHR5cGVNYXBbdHlwZV0gfHwgdHlwZU1hcFsnZWxzZSddIHx8IEVSUk9SO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gPT09IEVSUk9SKSB7XG4gICAgICByZXR1cm47IC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF07XG4gICAgYWN0aW9uID0gYWN0aW9uc1t0cmFuc2l0aW9uWzFdXTtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBuZXdDaGFyID0gdHJhbnNpdGlvblsyXTtcbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWQgPyBjIDogbmV3Q2hhcjtcbiAgICAgIGlmIChhY3Rpb24oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlID09PSBBRlRFUl9QQVRIKSB7XG4gICAgICBrZXlzLnJhdyA9IHBhdGg7XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRlcm5hbCBwYXJzZSB0aGF0IGNoZWNrIGZvciBhIGNhY2hlIGhpdCBmaXJzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHBhdGhDYWNoZS5nZXQocGF0aCk7XG4gIGlmICghaGl0KSB7XG4gICAgaGl0ID0gcGFyc2UocGF0aCk7XG4gICAgaWYgKGhpdCkge1xuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGl0O1xufVxuXG4vKipcbiAqIEdldCBmcm9tIGFuIG9iamVjdCBmcm9tIGEgcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGgob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXJzZUV4cHJlc3Npb24ocGF0aCkuZ2V0KG9iaik7XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuTm9uRXhpc3RlbnQgPSBmdW5jdGlvbiAocGF0aCwgdm0pIHtcbiAgICB3YXJuKCdZb3UgYXJlIHNldHRpbmcgYSBub24tZXhpc3RlbnQgcGF0aCBcIicgKyBwYXRoLnJhdyArICdcIiAnICsgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgKyAnd2l0aCB0aGUgXCJkYXRhXCIgb3B0aW9uIGZvciBtb3JlIHJlbGlhYmxlIHJlYWN0aXZpdHkgJyArICdhbmQgYmV0dGVyIHBlcmZvcm1hbmNlLicsIHZtKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXQgb24gYW4gb2JqZWN0IGZyb20gYSBwYXRoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gcGF0aFxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBzZXRQYXRoKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9iajtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXJzZShwYXRoKTtcbiAgfVxuICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3QsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmo7XG4gICAga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJyonKSB7XG4gICAgICBrZXkgPSBwYXJzZUV4cHJlc3Npb24oa2V5LnNsaWNlKDEpKS5nZXQuY2FsbChvcmlnaW5hbCwgb3JpZ2luYWwpO1xuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgbGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGxhc3QsIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmouJHNldChrZXksIHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KG9iaiwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHBhdGggPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VQYXRoOiBwYXJzZVBhdGgsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIHNldFBhdGg6IHNldFBhdGhcbn0pO1xuXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgYWxsb3dlZEtleXdvcmRzID0gJ01hdGgsRGF0ZSx0aGlzLHRydWUsZmFsc2UsbnVsbCx1bmRlZmluZWQsSW5maW5pdHksTmFOLCcgKyAnaXNOYU4saXNGaW5pdGUsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksJyArICdlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdCc7XG52YXIgYWxsb3dlZEtleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBhbGxvd2VkS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID0gJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICsgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgKyAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgKyAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArICdwcm90ZWN0ZWQsc3RhdGljLGludGVyZmFjZSxwcml2YXRlLHB1YmxpYyc7XG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxudmFyIHdzUkUgPSAvXFxzL2c7XG52YXIgbmV3bGluZVJFID0gL1xcbi9nO1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYCl8bmV3IHx0eXBlb2YgfHZvaWQgL2c7XG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbnZhciBwYXRoVGVzdFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC87XG52YXIgaWRlbnRSRSA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2c7XG52YXIgbGl0ZXJhbFZhbHVlUkUkMSA9IC9eKD86dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZHxJbmZpbml0eXxOYU4pJC87XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIFNhdmUgLyBSZXdyaXRlIC8gUmVzdG9yZVxuICpcbiAqIFdoZW4gcmV3cml0aW5nIHBhdGhzIGZvdW5kIGluIGFuIGV4cHJlc3Npb24sIGl0IGlzXG4gKiBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgbGV0dGVyIHNlcXVlbmNlcyB0byBiZSBmb3VuZCBpblxuICogc3RyaW5ncyBhbmQgT2JqZWN0IGxpdGVyYWwgcHJvcGVydHkga2V5cy4gVGhlcmVmb3JlIHdlXG4gKiByZW1vdmUgYW5kIHN0b3JlIHRoZXNlIHBhcnRzIGluIGEgdGVtcG9yYXJ5IGFycmF5LCBhbmRcbiAqIHJlc3RvcmUgdGhlbSBhZnRlciB0aGUgcGF0aCByZXdyaXRlLlxuICovXG5cbnZhciBzYXZlZCA9IFtdO1xuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZShzdHIsIGlzU3RyaW5nKSB7XG4gIHZhciBpID0gc2F2ZWQubGVuZ3RoO1xuICBzYXZlZFtpXSA9IGlzU3RyaW5nID8gc3RyLnJlcGxhY2UobmV3bGluZVJFLCAnXFxcXG4nKSA6IHN0cjtcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbn1cblxuLyoqXG4gKiBQYXRoIHJld3JpdGUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmV3cml0ZShyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApO1xuICB2YXIgcGF0aCA9IHJhdy5zbGljZSgxKTtcbiAgaWYgKGFsbG93ZWRLZXl3b3Jkc1JFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMSA/IHBhdGgucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpIDogcGF0aDtcbiAgICByZXR1cm4gYyArICdzY29wZS4nICsgcGF0aDtcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUoc3RyLCBpKSB7XG4gIHJldHVybiBzYXZlZFtpXTtcbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVHZXR0ZXIoZXhwKSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBdm9pZCB1c2luZyByZXNlcnZlZCBrZXl3b3JkcyBpbiBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwO1xuICAvLyBzYXZlIHN0cmluZ3MgYW5kIG9iamVjdCBsaXRlcmFsIGtleXNcbiAgdmFyIGJvZHkgPSBleHAucmVwbGFjZShzYXZlUkUsIHNhdmUpLnJlcGxhY2Uod3NSRSwgJycpO1xuICAvLyByZXdyaXRlIGFsbCBwYXRoc1xuICAvLyBwYWQgMSBzcGFjZSBoZXJlIGJlY2F1c2UgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSkucmVwbGFjZShpZGVudFJFLCByZXdyaXRlKS5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSk7XG4gIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gKlxuICogV2UgaXNvbGF0ZSB0aGUgdHJ5L2NhdGNoIHNvIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZVxuICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlR2V0dGVyRm4oYm9keSkge1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAncmV0dXJuICcgKyBib2R5ICsgJzsnKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBkZWZhdWx0IGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiBlbnZpcm9ubWVudCAnICsgJ3dpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgKyAnVXNlIHRoZSBDU1AtY29tcGxpYW50IGJ1aWxkIGluc3RlYWQ6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbCNDU1AtY29tcGxpYW50LWJ1aWxkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGV4cHJlc3Npb24uICcgKyAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVNldHRlcihleHApIHtcbiAgdmFyIHBhdGggPSBwYXJzZVBhdGgoZXhwKTtcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCB2YWwpIHtcbiAgICAgIHNldFBhdGgoc2NvcGUsIHBhdGgsIHZhbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgc2V0dGVyIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZXhwLCBuZWVkU2V0KSB7XG4gIGV4cCA9IGV4cC50cmltKCk7XG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApO1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKG5lZWRTZXQgJiYgIWhpdC5zZXQpIHtcbiAgICAgIGhpdC5zZXQgPSBjb21waWxlU2V0dGVyKGhpdC5leHApO1xuICAgIH1cbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIHZhciByZXMgPSB7IGV4cDogZXhwIH07XG4gIHJlcy5nZXQgPSBpc1NpbXBsZVBhdGgoZXhwKSAmJiBleHAuaW5kZXhPZignWycpIDwgMFxuICAvLyBvcHRpbWl6ZWQgc3VwZXIgc2ltcGxlIGdldHRlclxuICA/IG1ha2VHZXR0ZXJGbignc2NvcGUuJyArIGV4cClcbiAgLy8gZHluYW1pYyBnZXR0ZXJcbiAgOiBjb21waWxlR2V0dGVyKGV4cCk7XG4gIGlmIChuZWVkU2V0KSB7XG4gICAgcmVzLnNldCA9IGNvbXBpbGVTZXR0ZXIoZXhwKTtcbiAgfVxuICBleHByZXNzaW9uQ2FjaGUucHV0KGV4cCwgcmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1NpbXBsZVBhdGgoZXhwKSB7XG4gIHJldHVybiBwYXRoVGVzdFJFLnRlc3QoZXhwKSAmJlxuICAvLyBkb24ndCB0cmVhdCBsaXRlcmFsIHZhbHVlcyBhcyBwYXRoc1xuICAhbGl0ZXJhbFZhbHVlUkUkMS50ZXN0KGV4cCkgJiZcbiAgLy8gTWF0aCBjb25zdGFudHMgZS5nLiBNYXRoLlBJLCBNYXRoLkUgZXRjLlxuICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG59XG5cbnZhciBleHByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxufSk7XG5cbi8vIHdlIGhhdmUgdHdvIHNlcGFyYXRlIHF1ZXVlczogb25lIGZvciBkaXJlY3RpdmUgdXBkYXRlc1xuLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuLy8gd2Ugd2FudCB0byBndWFyYW50ZWUgZGlyZWN0aXZlIHVwZGF0ZXMgdG8gYmUgY2FsbGVkXG4vLyBiZWZvcmUgdXNlciB3YXRjaGVycyBzbyB0aGF0IHdoZW4gdXNlciB3YXRjaGVycyBhcmVcbi8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4vLyBzdGF0ZS5cblxudmFyIHF1ZXVlID0gW107XG52YXIgdXNlclF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogUmVzZXQgdGhlIGJhdGNoZXIncyBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiByZXNldEJhdGNoZXJTdGF0ZSgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgdXNlclF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBjaXJjdWxhciA9IHt9O1xuICB3YWl0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2hCYXRjaGVyUXVldWUoKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKTtcbiAgICBydW5CYXRjaGVyUXVldWUodXNlclF1ZXVlKTtcbiAgICAvLyB1c2VyIHdhdGNoZXJzIHRyaWdnZXJlZCBtb3JlIHdhdGNoZXJzLFxuICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZGVwbGV0ZXNcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH1cbiAgICAvLyBkZXYgdG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gICAgcmVzZXRCYXRjaGVyU3RhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1biB0aGUgd2F0Y2hlcnMgaW4gYSBzaW5nbGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xuXG5mdW5jdGlvbiBydW5CYXRjaGVyUXVldWUocXVldWUpIHtcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArICd3aXRoIGV4cHJlc3Npb24gXCInICsgd2F0Y2hlci5leHByZXNzaW9uICsgJ1wiJywgd2F0Y2hlci52bSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlclxuICogICBwcm9wZXJ0aWVzOlxuICogICAtIHtOdW1iZXJ9IGlkXG4gKiAgIC0ge0Z1bmN0aW9ufSBydW5cbiAqL1xuXG5mdW5jdGlvbiBwdXNoV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAvLyBwdXNoIHdhdGNoZXIgaW50byBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgIHZhciBxID0gd2F0Y2hlci51c2VyID8gdXNlclF1ZXVlIDogcXVldWU7XG4gICAgaGFzW2lkXSA9IHEubGVuZ3RoO1xuICAgIHEucHVzaCh3YXRjaGVyKTtcbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgIC0ge0FycmF5fSBmaWx0ZXJzXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdHdvV2F5XG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHVzZXJcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzeW5jXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGF6eVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcHJlUHJvY2Vzc11cbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3Bvc3RQcm9jZXNzXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIC8vIG1peCBpbiBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbic7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm47XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLnByZXZFcnJvciA9IG51bGw7IC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICB0aGlzLnNldHRlciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cE9yRm4sIHRoaXMudHdvV2F5KTtcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXQ7XG4gICAgdGhpcy5zZXR0ZXIgPSByZXMuc2V0O1xuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAvLyBzdGF0ZSBmb3IgYXZvaWRpbmcgZmFsc2UgdHJpZ2dlcnMgZm9yIGRlZXAgYW5kIEFycmF5XG4gIC8vIHdhdGNoZXJzIGR1cmluZyB2bS5fZGlnZXN0KClcbiAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJlZm9yZUdldCgpO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIHZhciB2YWx1ZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgd2FybignRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHRoaXMucHJlUHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wcmVQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKHZhbHVlLCBudWxsLCB0aGlzLmZpbHRlcnMsIGZhbHNlKTtcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSk7XG4gIH1cbiAgdGhpcy5hZnRlckdldCgpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aGlzLnNldHRlci5jYWxsKHNjb3BlLCBzY29wZSwgdmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgc2V0dGVyICcgKyAnXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiOiAnICsgZS50b1N0cmluZygpLCB0aGlzLnZtKTtcbiAgICB9XG4gIH1cbiAgLy8gdHdvLXdheSBzeW5jIGZvciB2LWZvciBhbGlhc1xuICB2YXIgZm9yQ29udGV4dCA9IHNjb3BlLiRmb3JDb250ZXh0O1xuICBpZiAoZm9yQ29udGV4dCAmJiBmb3JDb250ZXh0LmFsaWFzID09PSB0aGlzLmV4cHJlc3Npb24pIHtcbiAgICBpZiAoZm9yQ29udGV4dC5maWx0ZXJzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgKyAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgKyAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICsgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yQ29udGV4dC5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgICAgLy8gb3JpZ2luYWwgaXMgYW4gb2JqZWN0XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWUuJHNldChzY29wZS4kaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0RlcH0gZGVwXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaGFsbG93XG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYyB8fCAhY29uZmlnLmFzeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkID8gc2hhbGxvdyA/IHRoaXMuc2hhbGxvdyA6IGZhbHNlIDogISFzaGFsbG93O1xuICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJyk7XG4gICAgfVxuICAgIHB1c2hXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhdGNoZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBiYXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAvLyBub24tc2hhbGxvdyB1cGRhdGUgKGNhdXNlZCBieSBhIHZtIGRpZ2VzdCkuXG4gICAgKGlzT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBpbiBkZWJ1ZyArIGFzeW5jIG1vZGUsIHdoZW4gYSB3YXRjaGVyIGNhbGxiYWNrc1xuICAgICAgLy8gdGhyb3dzLCB3ZSBhbHNvIHRocm93IHRoZSBzYXZlZCBiZWZvcmUtcHVzaCBlcnJvclxuICAgICAgLy8gc28gdGhlIGZ1bGwgY3Jvc3MtdGljayBzdGFjayB0cmFjZSBpcyBhdmFpbGFibGUuXG4gICAgICB2YXIgcHJldkVycm9yID0gdGhpcy5wcmV2RXJyb3I7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXQ7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIERlcC50YXJnZXQgPSBjdXJyZW50O1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdGhpcy52bS5fdkZvclJlbW92aW5nKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgdmFyIGkgPSB1bmRlZmluZWQsXG4gICAgICBrZXlzID0gdW5kZWZpbmVkO1xuICBpZiAoIXNlZW4pIHtcbiAgICBzZWVuID0gc2Vlbk9iamVjdHM7XG4gICAgc2Vlbi5jbGVhcigpO1xuICB9XG4gIHZhciBpc0EgPSBpc0FycmF5KHZhbCk7XG4gIHZhciBpc08gPSBpc09iamVjdCh2YWwpO1xuICBpZiAoKGlzQSB8fCBpc08pICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gICAgfSBlbHNlIGlmIChpc08pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQkMSA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYXR0ciA9IHRoaXMuZWwubm9kZVR5cGUgPT09IDMgPyAnZGF0YScgOiAndGV4dENvbnRlbnQnO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIHRlbXBsYXRlQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgaWRTZWxlY3RvckNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgbWFwID0ge1xuICBlZmF1bHQ6IFswLCAnJywgJyddLFxuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J11cbn07XG5cbm1hcC50ZCA9IG1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAub3B0aW9uID0gbWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9IG1hcC50Ym9keSA9IG1hcC5jb2xncm91cCA9IG1hcC5jYXB0aW9uID0gbWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC5nID0gbWFwLmRlZnMgPSBtYXAuc3ltYm9sID0gbWFwLnVzZSA9IG1hcC5pbWFnZSA9IG1hcC50ZXh0ID0gbWFwLmNpcmNsZSA9IG1hcC5lbGxpcHNlID0gbWFwLmxpbmUgPSBtYXAucGF0aCA9IG1hcC5wb2x5Z29uID0gbWFwLnBvbHlsaW5lID0gbWFwLnJlY3QgPSBbMSwgJzxzdmcgJyArICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnICsgJ3htbG5zOmV2PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzXCInICsgJ3ZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J107XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgc3VwcG9ydGVkIHRlbXBsYXRlIG5vZGUgd2l0aCBhXG4gKiBEb2N1bWVudEZyYWdtZW50IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVhbFRlbXBsYXRlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVGVtcGxhdGUobm9kZSkgJiYgaXNGcmFnbWVudChub2RlLmNvbnRlbnQpO1xufVxuXG52YXIgdGFnUkUkMSA9IC88KFtcXHc6LV0rKS87XG52YXIgZW50aXR5UkUgPSAvJiM/XFx3Kz87LztcbnZhciBjb21tZW50UkUgPSAvPCEtLS87XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0ZW1wbGF0ZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKiBEZXRlcm1pbmVzIGNvcnJlY3Qgd3JhcHBpbmcgYnkgdGFnIHR5cGVzLiBXcmFwcGluZ1xuICogc3RyYXRlZ3kgZm91bmQgaW4galF1ZXJ5ICYgY29tcG9uZW50L2RvbWlmeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVTdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGVTdHJpbmcsIHJhdykge1xuICAvLyB0cnkgYSBjYWNoZSBoaXQgZmlyc3RcbiAgdmFyIGNhY2hlS2V5ID0gcmF3ID8gdGVtcGxhdGVTdHJpbmcgOiB0ZW1wbGF0ZVN0cmluZy50cmltKCk7XG4gIHZhciBoaXQgPSB0ZW1wbGF0ZUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciB0YWdNYXRjaCA9IHRlbXBsYXRlU3RyaW5nLm1hdGNoKHRhZ1JFJDEpO1xuICB2YXIgZW50aXR5TWF0Y2ggPSBlbnRpdHlSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcbiAgdmFyIGNvbW1lbnRNYXRjaCA9IGNvbW1lbnRSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCAmJiAhY29tbWVudE1hdGNoKSB7XG4gICAgLy8gdGV4dCBvbmx5LCByZXR1cm4gYSBzaW5nbGUgdGV4dCBub2RlLlxuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gdGFnTWF0Y2ggJiYgdGFnTWF0Y2hbMV07XG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuZWZhdWx0O1xuICAgIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gICAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcgKyBzdWZmaXg7XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdykge1xuICAgIHRyaW1Ob2RlKGZyYWcpO1xuICB9XG4gIHRlbXBsYXRlQ2FjaGUucHV0KGNhY2hlS2V5LCBmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHRlbXBsYXRlIG5vZGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBub2RlVG9GcmFnbWVudChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC4gSG93ZXZlciwgaU9TIFNhZmFyaSBoYXNcbiAgLy8gYnVnIHdoZW4gdXNpbmcgZGlyZWN0bHkgY2xvbmVkIHRlbXBsYXRlIGNvbnRlbnQgd2l0aCB0b3VjaFxuICAvLyBldmVudHMgYW5kIGNhbiBjYXVzZSBjcmFzaGVzIHdoZW4gdGhlIG5vZGVzIGFyZSByZW1vdmVkIGZyb20gRE9NLCBzbyB3ZVxuICAvLyBoYXZlIHRvIHRyZWF0IHRlbXBsYXRlIGVsZW1lbnRzIGFzIHN0cmluZyB0ZW1wbGF0ZXMuICgjMjgwNSlcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUuaW5uZXJIVE1MKTtcbiAgfVxuICAvLyBzY3JpcHQgdGVtcGxhdGVcbiAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1NDUklQVCcpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLnRleHRDb250ZW50KTtcbiAgfVxuICAvLyBub3JtYWwgbm9kZSwgY2xvbmUgaXQgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsXG4gIHZhciBjbG9uZWROb2RlID0gY2xvbmVOb2RlKG5vZGUpO1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbiAgdHJpbU5vZGUoZnJhZyk7XG4gIHJldHVybiBmcmFnO1xufVxuXG4vLyBUZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIFNhZmFyaSB0ZW1wbGF0ZSBjbG9uaW5nIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd3VnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGEuaW5uZXJIVE1MID0gJzx0ZW1wbGF0ZT4xPC90ZW1wbGF0ZT4nO1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHQucGxhY2Vob2xkZXIgPSAndCc7XG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICB2YXIgaSwgb3JpZ2luYWwsIGNsb25lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciB0ZW1wQ2xvbmUgPSByZXM7XG4gICAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgdGVtcENsb25lID0gcmVzLmNvbnRlbnQ7XG4gICAgfVxuICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IHRlbXBDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZU5vZGUob3JpZ2luYWxbaV0pLCBjbG9uZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgICAgY2xvbmVkID0gcmVzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY2xvbmVkW2ldLnZhbHVlID0gb3JpZ2luYWxbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlOlxuICogICAgICAgIC0gRG9jdW1lbnRGcmFnbWVudCBvYmplY3RcbiAqICAgICAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgICAgICAtIGlkIHNlbGVjdG9yOiAnI3NvbWUtdGVtcGxhdGUtaWQnXG4gKiAgICAgICAgLSB0ZW1wbGF0ZSBzdHJpbmc6ICc8ZGl2PjxzcGFuPnt7bXNnfX08L3NwYW4+PC9kaXY+J1xuICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRDbG9uZVxuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqICAgICAgICBpbmxpbmUgSFRNTCBpbnRlcnBvbGF0aW9uLiBEbyBub3QgY2hlY2sgZm9yIGlkXG4gKiAgICAgICAgc2VsZWN0b3IgYW5kIGtlZXAgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgc2hvdWxkQ2xvbmUsIHJhdykge1xuICB2YXIgbm9kZSwgZnJhZztcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmIChpc0ZyYWdtZW50KHRlbXBsYXRlKSkge1xuICAgIHRyaW1Ob2RlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUodGVtcGxhdGUpIDogdGVtcGxhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgaWYgKCFyYXcgJiYgdGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIC8vIGlkIHNlbGVjdG9yIGNhbiBiZSBjYWNoZWQgdG9vXG4gICAgICBmcmFnID0gaWRTZWxlY3RvckNhY2hlLmdldCh0ZW1wbGF0ZSk7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSk7XG4gICAgICAgICAgLy8gc2F2ZSBzZWxlY3RvciB0byBjYWNoZVxuICAgICAgICAgIGlkU2VsZWN0b3JDYWNoZS5wdXQodGVtcGxhdGUsIGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBzdHJpbmcgdGVtcGxhdGVcbiAgICAgIGZyYWcgPSBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlLCByYXcpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgIC8vIGEgZGlyZWN0IG5vZGVcbiAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQodGVtcGxhdGUpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUoZnJhZykgOiBmcmFnO1xufVxuXG52YXIgdGVtcGxhdGUgPSBPYmplY3QuZnJlZXplKHtcbiAgY2xvbmVOb2RlOiBjbG9uZU5vZGUsXG4gIHBhcnNlVGVtcGxhdGU6IHBhcnNlVGVtcGxhdGVcbn0pO1xuXG52YXIgaHRtbCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGEgY29tbWVudCBub2RlIG1lYW5zIHRoaXMgaXMgYSBiaW5kaW5nIGZvclxuICAgIC8vIHt7eyBpbmxpbmUgdW5lc2NhcGVkIGh0bWwgfX19XG4gICAgaWYgKHRoaXMuZWwubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgIC8vIGhvbGQgbm9kZXNcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggcHJvcGVyIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaHRtbCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBzd2FwOiBmdW5jdGlvbiBzd2FwKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVtb3ZlKHRoaXMubm9kZXNbaV0pO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IHRvQXJyYXkoZnJhZy5jaGlsZE5vZGVzKTtcbiAgICBiZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBhIHBhcnRpYWxseS1jb21waWxlZCBmcmFnbWVudC5cbiAqIENhbiBvcHRpb25hbGx5IGNvbXBpbGUgY29udGVudCB3aXRoIGEgY2hpbGQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtwYXJlbnRGcmFnXVxuICovXG5mdW5jdGlvbiBGcmFnbWVudChsaW5rZXIsIHZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuY2hpbGRGcmFncyA9IFtdO1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnO1xuICBpZiAocGFyZW50RnJhZykge1xuICAgIHBhcmVudEZyYWcuY2hpbGRGcmFncy5wdXNoKHRoaXMpO1xuICB9XG4gIHRoaXMudW5saW5rID0gbGlua2VyKHZtLCBmcmFnLCBob3N0LCBzY29wZSwgdGhpcyk7XG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiZcbiAgLy8gZG8gbm90IGdvIHNpbmdsZSBtb2RlIGlmIHRoZSBvbmx5IG5vZGUgaXMgYW4gYW5jaG9yXG4gICFmcmFnLmNoaWxkTm9kZXNbMF0uX192X2FuY2hvcjtcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXTtcbiAgICB0aGlzLmJlZm9yZSA9IHNpbmdsZUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IHNpbmdsZVJlbW92ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LXN0YXJ0Jyk7XG4gICAgdGhpcy5lbmQgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpO1xuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgcHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIHRoaXMuYmVmb3JlID0gbXVsdGlCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSB0aGlzO1xufVxuXG4vKipcbiAqIENhbGwgYXR0YWNoL2RldGFjaCBmb3IgYWxsIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpblxuICogdGhpcyBmcmFnbWVudC4gQWxzbyBkbyBzbyByZWN1cnNpdmVseSBmb3IgYWxsIGNoaWxkXG4gKiBmcmFnbWVudHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gIHZhciBpLCBsO1xuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5jYWxsSG9vayhob29rKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBob29rKHRoaXMuY2hpbGRyZW5baV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBzaW5nbGVCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZTtcbiAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICBtZXRob2QodGhpcy5ub2RlLCB0YXJnZXQsIHRoaXMudm0pO1xuICBpZiAoaW5Eb2ModGhpcy5ub2RlKSkge1xuICAgIHRoaXMuY2FsbEhvb2soYXR0YWNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBmcmFnbWVudCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb24odGhpcy5ub2RlLCB0aGlzLnZtLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICB9XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKTtcbiAgfSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlSZW1vdmUoKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIHJlbW92ZU5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCB0aGlzLnZtLCB0aGlzLmZyYWcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgZnJhZ21lbnQgZm9yIHJlbW92YWwuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmJlZm9yZVJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gY2FsbCB0aGUgc2FtZSBtZXRob2QgcmVjdXJzaXZlbHkgb24gY2hpbGRcbiAgICAvLyBmcmFnbWVudHMsIGRlcHRoLWZpcnN0XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmJlZm9yZVJlbW92ZShmYWxzZSk7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gQ2FsbCBkZXN0cm95IGZvciBhbGwgY29udGFpbmVkIGluc3RhbmNlcyxcbiAgICAvLyB3aXRoIHJlbW92ZTpmYWxzZSBhbmQgZGVmZXI6dHJ1ZS5cbiAgICAvLyBEZWZlciBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8ga2VlcCB0aGUgY2hpbGRyZW4gdG8gY2FsbCBkZXRhY2ggaG9va3NcbiAgICAvLyBvbiB0aGVtLlxuICAgIHRoaXMuY2hpbGRyZW5baV0uJGRlc3Ryb3koZmFsc2UsIHRydWUpO1xuICB9XG4gIHZhciBkaXJzID0gdGhpcy51bmxpbmsuZGlycztcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gZGlzYWJsZSB0aGUgd2F0Y2hlcnMgb24gYWxsIHRoZSBkaXJlY3RpdmVzXG4gICAgLy8gc28gdGhhdCB0aGUgcmVuZGVyZWQgY29udGVudCBzdGF5cyB0aGUgc2FtZVxuICAgIC8vIGR1cmluZyByZW1vdmFsLlxuICAgIGRpcnNbaV0uX3dhdGNoZXIgJiYgZGlyc1tpXS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGZyYWdtZW50LlxuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXJlbnRGcmFnKSB7XG4gICAgdGhpcy5wYXJlbnRGcmFnLmNoaWxkRnJhZ3MuJHJlbW92ZSh0aGlzKTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSBudWxsO1xuICB0aGlzLnVubGluaygpO1xufTtcblxuLyoqXG4gKiBDYWxsIGF0dGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBhdHRhY2goY2hpbGQpIHtcbiAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbCBkZXRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gZGV0YWNoKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgfVxufVxuXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMCk7XG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhXG4gKiBmcmFnbWVudC4gQ2FjaGVzIHRoZSBjb21waWxlZCBsaW5rZXIgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICovXG5mdW5jdGlvbiBGcmFnbWVudEZhY3Rvcnkodm0sIGVsKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdmFyIHRlbXBsYXRlO1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNTdHJpbmcgfHwgaXNUZW1wbGF0ZShlbCkgJiYgIWVsLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGVsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlcjtcbiAgdmFyIGNpZCA9IHZtLmNvbnN0cnVjdG9yLmNpZDtcbiAgaWYgKGNpZCA+IDApIHtcbiAgICB2YXIgY2FjaGVJZCA9IGNpZCArIChpc1N0cmluZyA/IGVsIDogZ2V0T3V0ZXJIVE1MKGVsKSk7XG4gICAgbGlua2VyID0gbGlua2VyQ2FjaGUuZ2V0KGNhY2hlSWQpO1xuICAgIGlmICghbGlua2VyKSB7XG4gICAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICB9XG4gIHRoaXMubGlua2VyID0gbGlua2VyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gY2xvbmVOb2RlKHRoaXMudGVtcGxhdGUpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMubGlua2VyLCB0aGlzLnZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZyk7XG59O1xuXG52YXIgT04gPSA3MDA7XG52YXIgTU9ERUwgPSA4MDA7XG52YXIgQklORCA9IDg1MDtcbnZhciBUUkFOU0lUSU9OID0gMTEwMDtcbnZhciBFTCA9IDE1MDA7XG52YXIgQ09NUE9ORU5UID0gMTUwMDtcbnZhciBQQVJUSUFMID0gMTc1MDtcbnZhciBJRiA9IDIxMDA7XG52YXIgRk9SID0gMjIwMDtcbnZhciBTTE9UID0gMjMwMDtcblxudmFyIHVpZCQzID0gMDtcblxudmFyIHZGb3IgPSB7XG5cbiAgcHJpb3JpdHk6IEZPUixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgcGFyYW1zOiBbJ3RyYWNrLWJ5JywgJ3N0YWdnZXInLCAnZW50ZXItc3RhZ2dlcicsICdsZWF2ZS1zdGFnZ2VyJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbi9vZiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopICg/OmlufG9mKSAoLiopLyk7XG4gICAgaWYgKGluTWF0Y2gpIHtcbiAgICAgIHZhciBpdE1hdGNoID0gaW5NYXRjaFsxXS5tYXRjaCgvXFwoKC4qKSwoLiopXFwpLyk7XG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpdE1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFsaWFzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdi1mb3IgZXhwcmVzc2lvbiBcIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2FsaWFzIGlzIHJlcXVpcmVkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVpZCBhcyBhIGNhY2hlIGlkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gJ19fdi1mb3JfXycgKyArK3VpZCQzO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIDxzZWxlY3Q+J3NcbiAgICAvLyB2LW1vZGVsIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgIC8vIHRoZSB2LW1vZGVsIGlzIG5vdCBib3VuZCBoZXJlIHlldCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHJldHJpdmUgaXQgaW4gdGhlIGFjdHVhbCB1cGRhdGVNb2RlbCgpIGZ1bmN0aW9uLlxuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgdGhpcy5pc09wdGlvbiA9ICh0YWcgPT09ICdPUFRJT04nIHx8IHRhZyA9PT0gJ09QVEdST1VQJykgJiYgdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnO1xuXG4gICAgLy8gc2V0dXAgYW5jaG9yIG5vZGVzXG4gICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcigndi1mb3ItZW5kJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmVuZCk7XG4gICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5kaWZmKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlUmVmKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICogbWluaW11bSBhbW91bnQgb2YgRE9NIG1hbmlwdWxhdGlvbnMgbmVlZGVkIHRvIG1ha2UgdGhlXG4gICAqIERPTSByZWZsZWN0IHRoZSBuZXcgZGF0YSBBcnJheS5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBkaWZmcyB0aGUgbmV3IGRhdGEgQXJyYXkgYnkgc3RvcmluZyBhXG4gICAqIGhpZGRlbiByZWZlcmVuY2UgdG8gYW4gb3duZXIgdm0gaW5zdGFuY2Ugb24gcHJldmlvdXNseVxuICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgKiBiZXR0ZXIgdGhhbiBhIGxldmVuc2h0ZWluIGRpc3RhbmNlIGJhc2VkIGFsZ29yaXRobSxcbiAgICogd2hpY2ggaXMgTyhtICogbikuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICovXG5cbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF07XG4gICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBvbGRGcmFncyA9IHRoaXMuZnJhZ3M7XG4gICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpbkRvY3VtZW50ID0gaW5Eb2Moc3RhcnQpO1xuICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmU7XG5cbiAgICAvLyBGaXJzdCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBuZXcgQXJyYXkgYW5kIGZpbGwgdXBcbiAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgLy8gaW5zdGFuY2UgZm9yIGl0LCB3ZSByZXVzZSBpdC4gT3RoZXJ3aXNlIGJ1aWxkIGEgbmV3XG4gICAgLy8gaW5zdGFuY2UuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIGtleSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiRrZXkgOiBudWxsO1xuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGZyYWcgPSAhaW5pdCAmJiB0aGlzLmdldENhY2hlZEZyYWcodmFsdWUsIGksIGtleSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWU7XG4gICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgZnJhZy5zY29wZS4kaW5kZXggPSBpO1xuICAgICAgICAvLyB1cGRhdGUgJGtleVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZnJhZy5zY29wZS4ka2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgZm9yIHRyYWNrLWJ5LCBvYmplY3QgcmVwZWF0ICZcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmcmFnLnNjb3BlW2FsaWFzXSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaXNudGFuY2VcbiAgICAgICAgZnJhZyA9IHRoaXMuY3JlYXRlKHZhbHVlLCBhbGlhcywgaSwga2V5KTtcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgfVxuICAgICAgZnJhZ3NbaV0gPSBmcmFnO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgZnJhZy5iZWZvcmUoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcywgZ28gdGhyb3VnaCB0aGUgb2xkIGZyYWdtZW50cyBhbmRcbiAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgLy8gZnJvbSBjYWNoZSlcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gMDtcbiAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgIC8vIHdoZW4gcmVtb3ZpbmcgYSBsYXJnZSBudW1iZXIgb2YgZnJhZ21lbnRzLCB3YXRjaGVyIHJlbW92YWxcbiAgICAvLyB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGJvdHRsZW5lY2ssIHNvIHdlIGJhdGNoIHRoZSB3YXRjaGVyXG4gICAgLy8gcmVtb3ZhbHMgaW50byBhIHNpbmdsZSBmaWx0ZXIgY2FsbCFcbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgIGlmICghZnJhZy5yZXVzZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgaWYgKHJlbW92YWxJbmRleCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMgPSB0aGlzLnZtLl93YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHcuYWN0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2O1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IGZyYWdzW2ldO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXTtcbiAgICAgIHByZXZFbCA9IHRhcmdldFByZXYgPyB0YXJnZXRQcmV2LnN0YWdnZXJDYiA/IHRhcmdldFByZXYuc3RhZ2dlckFuY2hvciA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZSA6IHN0YXJ0O1xuICAgICAgaWYgKGZyYWcucmV1c2VkICYmICFmcmFnLnN0YWdnZXJDYikge1xuICAgICAgICBjdXJyZW50UHJldiA9IGZpbmRQcmV2RnJhZyhmcmFnLCBzdGFydCwgdGhpcy5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50UHJldiAhPT0gdGFyZ2V0UHJldiAmJiAoIWN1cnJlbnRQcmV2IHx8XG4gICAgICAgIC8vIG9wdGltaXphdGlvbiBmb3IgbW92aW5nIGEgc2luZ2xlIGl0ZW0uXG4gICAgICAgIC8vIHRoYW5rcyB0byBzdWdnZXN0aW9ucyBieSBAbGl2b3JhcyBpbiAjMTgwN1xuICAgICAgICBmaW5kUHJldkZyYWcoY3VycmVudFByZXYsIHN0YXJ0LCB0aGlzLmlkKSAhPT0gdGFyZ2V0UHJldikpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGluc3RhbmNlLCBvciBzdGlsbCBpbiBzdGFnZ2VyLlxuICAgICAgICAvLyBpbnNlcnQgd2l0aCB1cGRhdGVkIHN0YWdnZXIgaW5kZXguXG4gICAgICAgIHRoaXMuaW5zZXJ0KGZyYWcsIGluc2VydGlvbkluZGV4KyssIHByZXZFbCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgICBmcmFnLnJldXNlZCA9IGZyYWcuZnJlc2ggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxpYXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIGFsaWFzLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLl9ob3N0O1xuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBzY29wZSA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUpO1xuICAgIC8vIHJlZiBob2xkZXIgZm9yIHRoZSBzY29wZVxuICAgIHNjb3BlLiRyZWZzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kcmVmcyk7XG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscyk7XG4gICAgLy8gbWFrZSBzdXJlIHBvaW50ICRwYXJlbnQgdG8gcGFyZW50IHNjb3BlXG4gICAgc2NvcGUuJHBhcmVudCA9IHBhcmVudFNjb3BlO1xuICAgIC8vIGZvciB0d28td2F5IGJpbmRpbmcgb24gYWxpYXNcbiAgICBzY29wZS4kZm9yQ29udGV4dCA9IHRoaXM7XG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICAvLyBpbXBvcnRhbnQ6IGRlZmluZSB0aGUgc2NvcGUgYWxpYXMgd2l0aG91dCBmb3JjZWQgY29udmVyc2lvblxuICAgIC8vIHNvIHRoYXQgZnJvemVuIGRhdGEgc3RydWN0dXJlcyByZW1haW4gbm9uLXJlYWN0aXZlLlxuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpO1xuICAgIH0pO1xuICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGluZGV4JywgaW5kZXgpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGtleScsIGtleSk7XG4gICAgfSBlbHNlIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAvLyBhdm9pZCBhY2NpZGVudGFsIGZhbGxiYWNrXG4gICAgICBkZWYoc2NvcGUsICcka2V5JywgbnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLml0ZXJhdG9yKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgdGhpcy5pdGVyYXRvciwga2V5ICE9PSBudWxsID8ga2V5IDogaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIGZyYWcuZm9ySWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KTtcbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2LXJlZiBvbiBvd25lciB2bS5cbiAgICovXG5cbiAgdXBkYXRlUmVmOiBmdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZGVzY3JpcHRvci5yZWY7XG4gICAgaWYgKCFyZWYpIHJldHVybjtcbiAgICB2YXIgaGFzaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmcztcbiAgICB2YXIgcmVmcztcbiAgICBpZiAoIXRoaXMuZnJvbU9iamVjdCkge1xuICAgICAgcmVmcyA9IHRoaXMuZnJhZ3MubWFwKGZpbmRWbUZyb21GcmFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmcyA9IHt9O1xuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhhc2hbcmVmXSA9IHJlZnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgIGlmICh0aGlzLmlzT3B0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5zdGFydC5wYXJlbnROb2RlO1xuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChmcmFnLCBpbmRleCwgcHJldkVsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIG51bGwsICdlbnRlcicpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBhbmNob3IgYW5kIGluc2VydCBpdCBzeW5jaHJvbm91c2x5LFxuICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gcmVzb2x2ZSB0aGUgY29ycmVjdCBvcmRlciB3aXRob3V0XG4gICAgICAvLyB3b3JyeWluZyBhYm91dCBzb21lIGVsZW1lbnRzIG5vdCBpbnNlcnRlZCB5ZXRcbiAgICAgIHZhciBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3I7XG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBjcmVhdGVBbmNob3IoJ3N0YWdnZXItYW5jaG9yJyk7XG4gICAgICAgIGFuY2hvci5fX3ZfZnJhZyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBhZnRlcihhbmNob3IsIHByZXZFbCk7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpO1xuICAgICAgICByZW1vdmUoYW5jaG9yKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSBwcmV2RWwubmV4dFNpYmxpbmc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIC8vIHJlc2V0IGVuZCBhbmNob3IgcG9zaXRpb24gaW4gY2FzZSB0aGUgcG9zaXRpb24gd2FzIG1lc3NlZCB1cFxuICAgICAgICAvLyBieSBhbiBleHRlcm5hbCBkcmFnLW4tZHJvcCBsaWJyYXJ5LlxuICAgICAgICBhZnRlcih0aGlzLmVuZCwgcHJldkVsKTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBmcmFnLmJlZm9yZSh0YXJnZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgLy8gaXQncyBub3QgcG9zc2libGUgZm9yIHRoZSBzYW1lIGZyYWcgdG8gYmUgcmVtb3ZlZFxuICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAvLyBpdCBtZWFucyB0aGlzIGZyYWcgaXMgcXVldWVkIGZvciBlbnRlciBidXQgcmVtb3ZlZFxuICAgICAgLy8gYmVmb3JlIGl0cyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIFNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAvLyBmaXggYSBjb21tb24gaXNzdWUgd2l0aCBTb3J0YWJsZTpcbiAgICAvLyBpZiBwcmV2RWwgZG9lc24ndCBoYXZlIG5leHRTaWJsaW5nLCB0aGlzIG1lYW5zIGl0J3NcbiAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAvLyB0aGUgZW5kIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBjb250YWluZXIuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuZW5kLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIH1cbiAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICovXG5cbiAgY2FjaGVGcmFnOiBmdW5jdGlvbiBjYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICAgIGNhY2hlW2lkXSA9IGZyYWc7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGhhc093bih2YWx1ZSwgaWQpKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpZF0gPT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZVtpZF0gPSBmcmFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdGcm96ZW4gdi1mb3Igb2JqZWN0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSB0cmFja2VkLCBtYWtlIHN1cmUgdG8gJyArICdwcm92aWRlIGEgdHJhY2stYnkga2V5LicpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcmFnLnJhdyA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBjYWNoZWQgZnJhZ21lbnQgZnJvbSB0aGUgdmFsdWUvaW5kZXgva2V5XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGdldENhY2hlZEZyYWc6IGZ1bmN0aW9uIGdldENhY2hlZEZyYWcodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgdmFyIGZyYWc7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICBmcmFnID0gdGhpcy5jYWNoZVtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICB9XG4gICAgaWYgKGZyYWcgJiYgKGZyYWcucmV1c2VkIHx8IGZyYWcuZnJlc2gpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqL1xuXG4gIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZEZyYWcoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3O1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgc2NvcGUgPSBmcmFnLnNjb3BlO1xuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgIC8vIGEgcGFyZW50IHJlcGVhdGVyIHdoaWNoIGhhcHBlbnMgdG8gaGF2ZSAka2V5LlxuICAgIHZhciBrZXkgPSBoYXNPd24oc2NvcGUsICcka2V5JykgJiYgc2NvcGUuJGtleTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAodHJhY2tCeUtleSB8fCBrZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVbdGhpcy5pZF0gPSBudWxsO1xuICAgICAgZnJhZy5yYXcgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFnZ2VyIGFtb3VudCBmb3IgYW4gaW5zZXJ0aW9uL3JlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKi9cblxuICBnZXRTdGFnZ2VyOiBmdW5jdGlvbiBnZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlICsgJ1N0YWdnZXInO1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnM7XG4gICAgdmFyIGhvb2tzID0gdHJhbnMgJiYgdHJhbnMuaG9va3M7XG4gICAgdmFyIGhvb2sgPSBob29rcyAmJiAoaG9va3NbdHlwZV0gfHwgaG9va3Muc3RhZ2dlcik7XG4gICAgcmV0dXJuIGhvb2sgPyBob29rLmNhbGwoZnJhZywgaW5kZXgsIHRvdGFsKSA6IGluZGV4ICogcGFyc2VJbnQodGhpcy5wYXJhbXNbdHlwZV0gfHwgdGhpcy5wYXJhbXMuc3RhZ2dlciwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcmUtcHJvY2VzcyB0aGUgdmFsdWUgYmVmb3JlIHBpcGluZyBpdCB0aHJvdWdoIHRoZVxuICAgKiBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKi9cblxuICBfcHJlUHJvY2VzczogZnVuY3Rpb24gX3ByZVByb2Nlc3ModmFsdWUpIHtcbiAgICAvLyByZWdhcmRsZXNzIG9mIHR5cGUsIHN0b3JlIHRoZSB1bi1maWx0ZXJlZCByYXcgdmFsdWUuXG4gICAgdGhpcy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0Y2hlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gX3Bvc3RQcm9jZXNzKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGkpO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmVzW2ldID0ge1xuICAgICAgICAgICRrZXk6IGtleSxcbiAgICAgICAgICAkdmFsdWU6IHZhbHVlW2tleV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSByYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNbdGhpcy5kZXNjcmlwdG9yLnJlZl0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFncykge1xuICAgICAgdmFyIGkgPSB0aGlzLmZyYWdzLmxlbmd0aDtcbiAgICAgIHZhciBmcmFnO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICBmcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGZpbmQgdGhlIHByZXZpb3VzIGVsZW1lbnQgdGhhdCBpcyBhIGZyYWdtZW50XG4gKiBhbmNob3IuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBkZXN0cm95ZWQgZnJhZydzXG4gKiBlbGVtZW50IGNvdWxkIHN0aWxsIGJlIGxpbmdlcmluZyBpbiB0aGUgRE9NIGJlZm9yZSBpdHNcbiAqIGxlYXZpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcywgYnV0IGl0cyBpbnNlcnRlZCBmbGFnXG4gKiBzaG91bGQgaGF2ZSBiZWVuIHNldCB0byBmYWxzZSBzbyB3ZSBjYW4gc2tpcCB0aGVtLlxuICpcbiAqIElmIHRoaXMgaXMgYSBibG9jayByZXBlYXQsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIG9ubHlcbiAqIHJldHVybiBmcmFnIHRoYXQgaXMgYm91bmQgdG8gdGhpcyB2LWZvci4gKHNlZSAjOTI5KVxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7Q29tbWVudHxUZXh0fSBhbmNob3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHJldHVybiB7RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFByZXZGcmFnKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZztcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZWwpIHJldHVybjtcbiAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB3aGlsZSAoKCFmcmFnIHx8IGZyYWcuZm9ySWQgIT09IGlkIHx8ICFmcmFnLmluc2VydGVkKSAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBGaW5kIGEgdm0gZnJvbSBhIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFZtRnJvbUZyYWcoZnJhZykge1xuICB2YXIgbm9kZSA9IGZyYWcubm9kZTtcbiAgLy8gaGFuZGxlIG11bHRpLW5vZGUgZnJhZ1xuICBpZiAoZnJhZy5lbmQpIHtcbiAgICB3aGlsZSAoIW5vZGUuX192dWVfXyAmJiBub2RlICE9PSBmcmFnLmVuZCAmJiBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUuX192dWVfXztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByYW5nZSBhcnJheSBmcm9tIGdpdmVuIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KE1hdGguZmxvb3IobikpO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJldFtpXSA9IGk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRyYWNrIGJ5IGtleSBmb3IgYW4gaXRlbS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHJhY2tCeUtleV1cbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KSB7XG4gIHJldHVybiB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHRyYWNrQnlLZXkuY2hhckF0KDApLm1hdGNoKC9cXHcvKSA/IGdldFBhdGgodmFsdWUsIHRyYWNrQnlLZXkpIDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZGb3Iud2FybkR1cGxpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHdhcm4oJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJy4gVXNlIHRyYWNrLWJ5PVwiJGluZGV4XCIgaWYgJyArICd5b3UgYXJlIGV4cGVjdGluZyBkdXBsaWNhdGUgdmFsdWVzLicsIHRoaXMudm0pO1xuICB9O1xufVxuXG52YXIgdklmID0ge1xuXG4gIHByaW9yaXR5OiBJRixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICghZWwuX192dWVfXykge1xuICAgICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUobmV4dCk7XG4gICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIG1haW4gYmxvY2tcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICByZXBsYWNlKGVsLCB0aGlzLmFuY2hvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1pZj1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgY2Fubm90IGJlICcgKyAndXNlZCBvbiBhbiBpbnN0YW5jZSByb290IGVsZW1lbnQuJywgdGhpcy52bSk7XG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGxhenkgaW5pdCBmYWN0b3J5XG4gICAgaWYgKCF0aGlzLmZhY3RvcnkpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VFbCAmJiAhdGhpcy5lbHNlRnJhZykge1xuICAgICAgaWYgKCF0aGlzLmVsc2VGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZWxzZUZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMuZWxzZUVsLl9jb250ZXh0IHx8IHRoaXMudm0sIHRoaXMuZWxzZUVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG93ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgIHZhciBuZXh0ID0gdGhpcy5lbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmFwcGx5KHRoaXMuZWwsIHZhbHVlKTtcbiAgICBpZiAodGhpcy5lbHNlRWwpIHtcbiAgICAgIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseShlbCwgdmFsdWUpIHtcbiAgICBpZiAoaW5Eb2MoZWwpKSB7XG4gICAgICBhcHBseVRyYW5zaXRpb24oZWwsIHZhbHVlID8gMSA6IC0xLCB0b2dnbGUsIHRoaXMudm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2dnbGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dCQyID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBsYXp5ID0gdGhpcy5wYXJhbXMubGF6eTtcbiAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJhbXMubnVtYmVyO1xuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgLy8gaGFuZGxlIGNvbXBvc2l0aW9uIGV2ZW50cy5cbiAgICAvLyAgIGh0dHA6Ly9ibG9nLmV2YW55b3UubWUvMjAxNC8wMS8wMy9jb21wb3NpdGlvbi1ldmVudC9cbiAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgLy8gZXZlbnRzIHF1aXRlIGRpZmZlcmVudGx5LiBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlclxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyBmb3IgbGFuZ3VhZ2UgaW5wdXQgbWV0aG9kcyBlLmcuXG4gICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAvLyBzdWdnZXN0aW9ucy4uLiAoc2VlIERpc2N1c3Npb24vIzE2MilcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBtZXNzaW5nIHdpdGggdGhlIGlucHV0IHdoZW4gdXNlciBpcyB0eXBpbmcsXG4gICAgLy8gYW5kIGZvcmNlIHVwZGF0ZSBvbiBibHVyLlxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICghaXNSYW5nZSAmJiAhbGF6eSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBkbyBub3Qgc3luYyB2YWx1ZSBhZnRlciBmcmFnbWVudCByZW1vdmFsICgjMjAxNylcbiAgICAgICAgaWYgKCFzZWxmLl9mcmFnIHx8IHNlbGYuX2ZyYWcuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdyBhdHRhY2ggdGhlIG1haW4gbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2JvdW5kICYmICFzZWxmLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IGRlYm91bmNlXG4gICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGpRdWVyeSBldmVudHMsIHNpbmNlIGpRdWVyeS50cmlnZ2VyKCkgZG9lc24ndFxuICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAvLyByZWx5IG9uICQudHJpZ2dlcigpXG4gICAgLy9cbiAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgLy8galF1ZXJ5LCBpdCBpcyBhbHNvIHJlbW92ZWQgd2l0aCBqUXVlcnksIHRoYXQncyB3aHlcbiAgICAvLyB3ZSBkbyB0aGUgY2hlY2sgZm9yIGVhY2ggZGlyZWN0aXZlIGluc3RhbmNlIGFuZFxuICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgIC8vIGVhc2llciB0ZXN0IGNvdmVyYWdlIGNvbnRyb2wgYnkgdW5zZXR0aW5nIHRoZSBnbG9iYWxcbiAgICAvLyBqUXVlcnkgdmFyaWFibGUgaW4gdGVzdHMuXG4gICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vbiA/ICdvbicgOiAnYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgdGhpcy5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIGlzSUU5KSB7XG4gICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKHNlbGYubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiBlbC52YWx1ZS50cmltKCkpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAvLyAjMzAyOSBvbmx5IHVwZGF0ZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBUaGlzIHByZXZlbnRcbiAgICAvLyBicm93c2VycyBmcm9tIG92ZXJ3cml0aW5nIHZhbHVlcyBsaWtlIHNlbGVjdGlvblN0YXJ0XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5lbC52YWx1ZSkgdGhpcy5lbC52YWx1ZSA9IHZhbHVlO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9mZiA/ICdvZmYnIDogJ3VuYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJhZGlvID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdmFsdWUgb3ZlcndyaXRlIHZpYSB2LWJpbmQ6dmFsdWVcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl92YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBlbC52YWx1ZTtcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gdG9OdW1iZXIodmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNldChzZWxmLmdldFZhbHVlKCkpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpO1xuICB9XG59O1xuXG52YXIgc2VsZWN0ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fd2F0Y2hlcikge1xuICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgIHZhciBtdWx0aXBsZSA9IHRoaXMubXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG5cbiAgICAvLyBhdHRhY2ggbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlKTtcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyID8gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodG9OdW1iZXIpIDogdG9OdW1iZXIodmFsdWUpIDogdmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSk7XG4gICAgaWYgKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGggfHwgIW11bHRpcGxlICYmIGluaXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8vIEFsbCBtYWpvciBicm93c2VycyBleGNlcHQgRmlyZWZveCByZXNldHNcbiAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gYSBuZXcgcGFyZW50LCB0aGVyZWZvcmUgd2UgaGF2ZSB0b1xuICAgIC8vIGZvcmNlIGEgRE9NIHVwZGF0ZSB3aGVuZXZlciB0aGF0IGhhcHBlbnMuLi5cbiAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG5leHRUaWNrKF90aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9KTtcbiAgICBpZiAoIWluRG9jKGVsKSkge1xuICAgICAgbmV4dFRpY2sodGhpcy5mb3JjZVVwZGF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdmFyIG11bHRpID0gdGhpcy5tdWx0aXBsZSAmJiBpc0FycmF5KHZhbHVlKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICB2YXIgb3AsIHZhbDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV07XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgb3Auc2VsZWN0ZWQgPSBtdWx0aSA/IGluZGV4T2YkMSh2YWx1ZSwgdmFsKSA+IC0xIDogbG9vc2VFcXVhbCh2YWx1ZSwgdmFsKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHNlbGVjdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2VsZWN0RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QXJyYXl8Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgdmFyIHJlcyA9IG11bHRpID8gW10gOiBudWxsO1xuICB2YXIgb3AsIHZhbCwgc2VsZWN0ZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV07XG4gICAgc2VsZWN0ZWQgPSBpbml0ID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpIDogb3Auc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAqIGNhc2Ugd2UgbmVlZCB0byBtYXRjaCBzdHJpbmcvbnVtYmVycyB3aXRoIGN1c3RvbSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIGNoZWNrYm94ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IGVsLl92YWx1ZSA6IHNlbGYucGFyYW1zLm51bWJlciA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUoKSB7XG4gICAgICB2YXIgdmFsID0gZWwuY2hlY2tlZDtcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfZmFsc2VWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fZmFsc2VWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWU7XG4gICAgICBpZiAoaXNBcnJheShtb2RlbCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihtb2RlbCwgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIG1vZGVsLnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwuJHJlbW92ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBlbC5jaGVja2VkID0gaW5kZXhPZih2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKSA+IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZWwuX3RydWVWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogdGV4dCQyLFxuICByYWRpbzogcmFkaW8sXG4gIHNlbGVjdDogc2VsZWN0LFxuICBjaGVja2JveDogY2hlY2tib3hcbn07XG5cbnZhciBtb2RlbCA9IHtcblxuICBwcmlvcml0eTogTU9ERUwsXG4gIHR3b1dheTogdHJ1ZSxcbiAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICBwYXJhbXM6IFsnbGF6eScsICdudW1iZXInLCAnZGVib3VuY2UnXSxcblxuICAvKipcbiAgICogUG9zc2libGUgZWxlbWVudHM6XG4gICAqICAgPHNlbGVjdD5cbiAgICogICA8dGV4dGFyZWE+XG4gICAqICAgPGlucHV0IHR5cGU9XCIqXCI+XG4gICAqICAgICAtIHRleHRcbiAgICogICAgIC0gY2hlY2tib3hcbiAgICogICAgIC0gcmFkaW9cbiAgICogICAgIC0gbnVtYmVyXG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKCk7XG4gICAgaWYgKHRoaXMuaGFzUmVhZCAmJiAhdGhpcy5oYXNXcml0ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIGEgcmVhZC1vbmx5IGZpbHRlciB3aXRoICcgKyAndi1tb2RlbD1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiLiAnICsgJ1lvdSBtaWdodCB3YW50IHRvIHVzZSBhIHR3by13YXkgZmlsdGVyIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLicsIHRoaXMudm0pO1xuICAgIH1cbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lO1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmICh0YWcgPT09ICdJTlBVVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tlbC50eXBlXSB8fCBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGVsZW1lbnQgdHlwZTogJyArIHRhZywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLl9fdl9tb2RlbCA9IHRoaXM7XG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcyk7XG4gICAgdGhpcy51cGRhdGUgPSBoYW5kbGVyLnVwZGF0ZTtcbiAgICB0aGlzLl91bmJpbmQgPSBoYW5kbGVyLnVuYmluZDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gY2hlY2tGaWx0ZXJzKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGlmICghZmlsdGVycykgcmV0dXJuO1xuICAgIHZhciBpID0gZmlsdGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlcnNbaV0ubmFtZSk7XG4gICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIucmVhZCkge1xuICAgICAgICB0aGlzLmhhc1JlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5lbC5fX3ZfbW9kZWwgPSBudWxsO1xuICAgIHRoaXMuX3VuYmluZCAmJiB0aGlzLl91bmJpbmQoKTtcbiAgfVxufTtcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiBbOCwgNDZdLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwXG59O1xuXG5mdW5jdGlvbiBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cykge1xuICB2YXIgY29kZXMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoYXJDb2RlID0ga2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGNoYXJDb2RlID4gNDcgJiYgY2hhckNvZGUgPCA1OCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2hhckNvZGUgPSBrZXkudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNoYXJDb2RlID4gNjQgJiYgY2hhckNvZGUgPCA5MSkge1xuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlDb2Rlc1trZXldO1xuICB9KTtcbiAgY29kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGNvZGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgIGlmIChjb2Rlcy5pbmRleE9mKGUua2V5Q29kZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcEhhbmRsZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJldmVudEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGZGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZkhhbmRsZXIoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IE9OLFxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIGtleUNvZGVzOiBrZXlDb2RlcyxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKHRoaXMuZWwudGFnTmFtZSA9PT0gJ0lGUkFNRScgJiYgdGhpcy5hcmcgIT09ICdsb2FkJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5pZnJhbWVCaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbihzZWxmLmVsLmNvbnRlbnRXaW5kb3csIHNlbGYuYXJnLCBzZWxmLmhhbmRsZXIsIHNlbGYubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCB0aGlzLmlmcmFtZUJpbmQpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShoYW5kbGVyKSB7XG4gICAgLy8gc3R1YiBhIG5vb3AgZm9yIHYtb24gd2l0aCBubyB2YWx1ZSxcbiAgICAvLyBlLmcuIEBtb3VzZWRvd24ucHJldmVudFxuICAgIGlmICghdGhpcy5kZXNjcmlwdG9yLnJhdykge1xuICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArICdnb3QgJyArIGhhbmRsZXIsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnByZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIgPSBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc2VsZikge1xuICAgICAgaGFuZGxlciA9IHNlbGZGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIGtleSBmaWx0ZXJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kaWZpZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnICYmIGtleSAhPT0gJ3NlbGYnICYmIGtleSAhPT0gJ2NhcHR1cmUnO1xuICAgIH0pO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLmlmcmFtZUJpbmQpIHtcbiAgICAgIHRoaXMuaWZyYW1lQmluZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyLCB0aGlzLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZCA/IHRoaXMuZWwuY29udGVudFdpbmRvdyA6IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgb2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nXTtcbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG52YXIgaW1wb3J0YW50UkUgPSAvIWltcG9ydGFudDs/JC87XG52YXIgcHJvcENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIHRlc3RFbCA9IG51bGw7XG5cbnZhciBzdHlsZSA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLnJlZHVjZShleHRlbmQsIHt9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiBoYW5kbGVPYmplY3QodmFsdWUpIHtcbiAgICAvLyBjYWNoZSBvYmplY3Qgc3R5bGVzIHNvIHRoYXQgb25seSBjaGFuZ2VkIHByb3BzXG4gICAgLy8gYXJlIGFjdHVhbGx5IHVwZGF0ZWQuXG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSB8fCAodGhpcy5jYWNoZSA9IHt9KTtcbiAgICB2YXIgbmFtZSwgdmFsO1xuICAgIGZvciAobmFtZSBpbiBjYWNoZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgbnVsbCk7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICAgIGlmICh2YWwgIT09IGNhY2hlW25hbWVdKSB7XG4gICAgICAgIGNhY2hlW25hbWVdID0gdmFsO1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIGhhbmRsZVNpbmdsZShwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcCk7XG4gICAgaWYgKCFwcm9wKSByZXR1cm47IC8vIHVuc3VwcG9ydGVkIHByb3BcbiAgICAvLyBjYXN0IHBvc3NpYmxlIG51bWJlcnMvYm9vbGVhbnMgaW50byBzdHJpbmdzXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlICs9ICcnO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnO1xuICAgICAgaWYgKGlzSW1wb3J0YW50KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ0l0XFwncyBwcm9iYWJseSBhIGJhZCBpZGVhIHRvIHVzZSAhaW1wb3J0YW50IHdpdGggaW5saW5lIHJ1bGVzLiAnICsgJ1RoaXMgZmVhdHVyZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBWdWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3Aua2ViYWIsIHZhbHVlLCBpc0ltcG9ydGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsLnN0eWxlW3Byb3AuY2FtZWxdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSAnJztcbiAgICB9XG4gIH1cblxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBDU1MgcHJvcGVydHkgbmFtZS5cbiAqIC0gY2FjaGUgcmVzdWx0XG4gKiAtIGF1dG8gcHJlZml4XG4gKiAtIGNhbWVsQ2FzZSAtPiBkYXNoLWNhc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShwcm9wKSB7XG4gIGlmIChwcm9wQ2FjaGVbcHJvcF0pIHtcbiAgICByZXR1cm4gcHJvcENhY2hlW3Byb3BdO1xuICB9XG4gIHZhciByZXMgPSBwcmVmaXgocHJvcCk7XG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEF1dG8gZGV0ZWN0IHRoZSBhcHByb3ByaWF0ZSBwcmVmaXggZm9yIGEgQ1NTIHByb3BlcnR5LlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzUyMzY5MlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcHJlZml4KHByb3ApIHtcbiAgcHJvcCA9IGh5cGhlbmF0ZShwcm9wKTtcbiAgdmFyIGNhbWVsID0gY2FtZWxpemUocHJvcCk7XG4gIHZhciB1cHBlciA9IGNhbWVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWwuc2xpY2UoMSk7XG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cbiAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGg7XG4gIHZhciBwcmVmaXhlZDtcbiAgaWYgKGNhbWVsICE9PSAnZmlsdGVyJyAmJiBjYW1lbCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2ViYWI6IHByb3AsXG4gICAgICBjYW1lbDogY2FtZWxcbiAgICB9O1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBwcmVmaXhlZCA9IGNhbWVsUHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZWJhYjogcHJlZml4ZXNbaV0gKyBwcm9wLFxuICAgICAgICBjYW1lbDogcHJlZml4ZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHhsaW5rXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciB4bGlua1JFID0gL154bGluazovO1xuXG4vLyBjaGVjayBmb3IgYXR0cmlidXRlcyB0aGF0IHByb2hpYml0IGludGVycG9sYXRpb25zXG52YXIgZGlzYWxsb3dlZEludGVycEF0dHJSRSA9IC9edi18Xjp8XkB8Xig/OmlzfHRyYW5zaXRpb258dHJhbnNpdGlvbi1tb2RlfGRlYm91bmNlfHRyYWNrLWJ5fHN0YWdnZXJ8ZW50ZXItc3RhZ2dlcnxsZWF2ZS1zdGFnZ2VyKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4vLyBiZWNhdXNlIHRoZXkgb25seSBhZmZlY3QgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbnZhciBhdHRyV2l0aFByb3BzUkUgPSAvXig/OnZhbHVlfGNoZWNrZWR8c2VsZWN0ZWR8bXV0ZWQpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIGV4cGVjdCBlbnVtcmF0ZWQgdmFsdWVzIG9mIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIlxuLy8gYnV0IGFyZSBub3QgYm9vbGVhbiBhdHRyaWJ1dGVzXG52YXIgZW51bWVyYXRlZEF0dHJSRSA9IC9eKD86ZHJhZ2dhYmxlfGNvbnRlbnRlZGl0YWJsZXxzcGVsbGNoZWNrKSQvO1xuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn07XG5cbnZhciBiaW5kJDEgPSB7XG5cbiAgcHJpb3JpdHk6IEJJTkQsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgLy8gc2hvdWxkIGJlIGRlZXAgd2F0Y2ggb24gb2JqZWN0IG1vZGVcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHRoaXMuZGVlcCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmdzXG4gICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgdmFyIHRva2VucyA9IGRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9ucyB3aXRoIG9uZS10aW1lIHRva2Vuc1xuICAgICAgaWYgKGRlc2NyaXB0b3IuaGFzT25lVGltZSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSB0b2tlbnNUb0V4cCh0b2tlbnMsIHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChkaXNhbGxvd2VkSW50ZXJwQXR0clJFLnRlc3QoYXR0cikgfHwgYXR0ciA9PT0gJ25hbWUnICYmICh0YWcgPT09ICdQQVJUSUFMJyB8fCB0YWcgPT09ICdTTE9UJykpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2F0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIFZ1ZS5qcyAnICsgJ2RpcmVjdGl2ZXMgYW5kIHNwZWNpYWwgYXR0cmlidXRlcy4nLCB0aGlzLnZtKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJhdyA9IGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnO1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3JjXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICdhIDQwNCByZXF1ZXN0LiBVc2Ugdi1iaW5kOnNyYyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FybiBzdHlsZVxuICAgICAgICBpZiAoYXR0ciA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzdHlsZVwiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgKyAnVXNlIHYtYmluZDpzdHlsZSBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIGlmICh0aGlzLmFyZykge1xuICAgICAgdGhpcy5oYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNoYXJlIG9iamVjdCBoYW5kbGVyIHdpdGggdi1iaW5kOmNsYXNzXG4gIGhhbmRsZU9iamVjdDogc3R5bGUuaGFuZGxlT2JqZWN0LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJwID0gdGhpcy5kZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgIGF0dHIgPSBjYW1lbGl6ZShhdHRyKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnAgJiYgYXR0cldpdGhQcm9wc1JFLnRlc3QoYXR0cikgJiYgYXR0ciBpbiBlbCkge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgPyAnJyA6IHZhbHVlIDogdmFsdWU7XG5cbiAgICAgIGlmIChlbFthdHRyXSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgIGVsW2F0dHJdID0gYXR0clZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXQgbW9kZWwgcHJvcHNcbiAgICB2YXIgbW9kZWxQcm9wID0gbW9kZWxQcm9wc1thdHRyXTtcbiAgICBpZiAoIWludGVycCAmJiBtb2RlbFByb3ApIHtcbiAgICAgIGVsW21vZGVsUHJvcF0gPSB2YWx1ZTtcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IGVsLl9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5saXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVcbiAgICBpZiAoZW51bWVyYXRlZEF0dHJSRS50ZXN0KGF0dHIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICAvLyBoYW5kbGUgZWRnZSBjYXNlICMxOTYwOlxuICAgICAgICAvLyBjbGFzcyBpbnRlcnBvbGF0aW9uIHNob3VsZCBub3Qgb3ZlcndyaXRlIFZ1ZSB0cmFuc2l0aW9uIGNsYXNzXG4gICAgICAgIGlmIChlbC5fX3ZfdHJhbnMpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnICcgKyBlbC5fX3ZfdHJhbnMuaWQgKyAnLXRyYW5zaXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIHNldENsYXNzKGVsLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbCA9IHtcblxuICBwcmlvcml0eTogRUwsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMuYXJnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBjYW1lbGl6ZSh0aGlzLmFyZyk7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAoaGFzT3duKHJlZnMsIGlkKSkge1xuICAgICAgcmVmc1tpZF0gPSB0aGlzLmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShyZWZzLCBpZCwgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJlZiA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtcmVmOicgKyB0aGlzLmFyZyArICcgbXVzdCBiZSB1c2VkIG9uIGEgY2hpbGQgJyArICdjb21wb25lbnQuIEZvdW5kIG9uIDwnICsgdGhpcy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPi4nLCB0aGlzLnZtKTtcbiAgfVxufTtcblxudmFyIGNsb2FrID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdGhpcy52bS4kb25jZSgncHJlLWhvb2s6Y29tcGlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gbXVzdCBleHBvcnQgcGxhaW4gb2JqZWN0XG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgdGV4dDogdGV4dCQxLFxuICBodG1sOiBodG1sLFxuICAnZm9yJzogdkZvcixcbiAgJ2lmJzogdklmLFxuICBzaG93OiBzaG93LFxuICBtb2RlbDogbW9kZWwsXG4gIG9uOiBvbiQxLFxuICBiaW5kOiBiaW5kJDEsXG4gIGVsOiBlbCxcbiAgcmVmOiByZWYsXG4gIGNsb2FrOiBjbG9ha1xufTtcblxudmFyIHZDbGFzcyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNldENsYXNzKHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDbGFzcyhub3JtYWxpemUkMSh2YWx1ZSkpO1xuICAgIH1cbiAgfSxcblxuICBzZXRDbGFzczogZnVuY3Rpb24gc2V0Q2xhc3ModmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gdmFsdWVbaV07XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIHZhbCwgYWRkQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWU7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cCh2YWx1ZSkge1xuICAgIHZhciBwcmV2S2V5cyA9IHRoaXMucHJldktleXM7XG4gICAgaWYgKCFwcmV2S2V5cykgcmV0dXJuO1xuICAgIHZhciBpID0gcHJldktleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBhcHBseSh0aGlzLmVsLCBrZXksIHJlbW92ZUNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIG9iamVjdHMgYW5kIGFycmF5cyAocG90ZW50aWFsbHkgY29udGFpbmluZyBvYmplY3RzKVxuICogaW50byBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PFN0cmluZ3xPYmplY3Q+fSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUkMSh2YWx1ZSkge1xuICB2YXIgcmVzID0gW107XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IHZhbHVlW2ldO1xuICAgICAgaWYgKF9rZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfa2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlcy5wdXNoKF9rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gX2tleSkge1xuICAgICAgICAgICAgaWYgKF9rZXlba10pIHJlcy5wdXNoKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgYSBjbGFzcy9jbGFzc2VzIG9uIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBjbGFzcyBuYW1lLiBUaGlzIG1heSBvciBtYXkgbm90XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gYSBzcGFjZSBjaGFyYWN0ZXIsIGluIHN1Y2ggYVxuICogICAgICAgICAgICAgICAgICAgICBjYXNlIHdlJ2xsIGRlYWwgd2l0aCBtdWx0aXBsZSBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICBuYW1lcyBhdCBvbmNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseShlbCwga2V5LCBmbikge1xuICBrZXkgPSBrZXkudHJpbSgpO1xuICBpZiAoa2V5LmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICBmbihlbCwga2V5KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhlIGtleSBjb250YWlucyBvbmUgb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzLlxuICAvLyBTaW5jZSBhIGNsYXNzIG5hbWUgZG9lc24ndCBhY2NlcHQgc3VjaCBjaGFyYWN0ZXJzLCB3ZVxuICAvLyB0cmVhdCBpdCBhcyBtdWx0aXBsZSBjbGFzc2VzLlxuICB2YXIga2V5cyA9IGtleS5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm4oZWwsIGtleXNbaV0pO1xuICB9XG59XG5cbnZhciBjb21wb25lbnQgPSB7XG5cbiAgcHJpb3JpdHk6IENPTVBPTkVOVCxcblxuICBwYXJhbXM6IFsna2VlcC1hbGl2ZScsICd0cmFuc2l0aW9uLW1vZGUnLCAnaW5saW5lLXRlbXBsYXRlJ10sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIGlmICghdGhpcy5lbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGVcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAvLyBleHRyYWN0IGlubGluZSB0ZW1wbGF0ZSBhcyBhIERvY3VtZW50RnJhZ21lbnRcbiAgICAgICAgdGhpcy5pbmxpbmVUZW1wbGF0ZSA9IGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gY29tcG9uZW50IHJlc29sdXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGw7XG4gICAgICAvLyB0cmFuc2l0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAvLyBjcmVhdGUgYSByZWYgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgLy8gcmVtb3ZlIGlzIGF0dHJpYnV0ZS5cbiAgICAgIC8vIHRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgY29tcGlsYXRpb24sIGJ1dCBiZWNhdXNlIGNvbXBpbGF0aW9uIGlzXG4gICAgICAvLyBjYWNoZWQsIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1c2VkIGVsc2V3aGVyZSB0aGlzIGF0dHJpYnV0ZVxuICAgICAgLy8gd2lsbCByZW1haW4gYXQgbGluayB0aW1lLlxuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnOmlzJyk7XG4gICAgICAvLyByZW1vdmUgcmVmLCBzYW1lIGFzIGFib3ZlXG4gICAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgndi1yZWY6JyArIGh5cGhlbmF0ZSh0aGlzLmRlc2NyaXB0b3IucmVmKSk7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGF0aWMsIGJ1aWxkIHJpZ2h0IG5vdy5cbiAgICAgIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnQodGhpcy5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICsgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdXBkYXRlLCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIgaW4gdGhlIGR5bmFtaWNcbiAgICogbGl0ZXJhbCBzY2VuYXJpbywgZS5nLiA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMubGl0ZXJhbCkge1xuICAgICAgdGhpcy5zZXRDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBjdXJyZW50XG4gICAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkVk0sIGNiKTtcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMucmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm1vdW50Q29tcG9uZW50KGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG4gICAqIHRoZSBjaGlsZCB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlc29sdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgc2VsZi5Db21wb25lbnROYW1lID0gQ29tcG9uZW50Lm9wdGlvbnMubmFtZSB8fCAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogbnVsbCk7XG4gICAgICBzZWxmLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgdGhpcy52bS5fcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgdXNpbmcgdGhlIGN1cnJlbnQgY29uc3RydWN0b3IgYW5kXG4gICAqIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBkb2Vzbid0IGNhcmVcbiAgICogd2hldGhlciB0aGUgbmV3IGNvbXBvbmVudCBhbmQgdGhlIG9sZCBvbmUgYXJlIGFjdHVhbGx5XG4gICAqIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiBtb3VudENvbXBvbmVudChjYikge1xuICAgIC8vIGFjdHVhbCBtb3VudFxuICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjdGl2YXRlSG9va3MgPSB0aGlzLkNvbXBvbmVudC5vcHRpb25zLmFjdGl2YXRlO1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKGFjdGl2YXRlSG9va3MgJiYgIWNhY2hlZCkge1xuICAgICAgdGhpcy53YWl0aW5nRm9yID0gbmV3Q29tcG9uZW50O1xuICAgICAgY2FsbEFjdGl2YXRlSG9va3MoYWN0aXZhdGVIb29rcywgbmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLndhaXRpbmdGb3IgIT09IG5ld0NvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLndhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICBzZWxmLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIHJlZiBmb3Iga2VwdC1hbGl2ZSBjb21wb25lbnRcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgbmV3Q29tcG9uZW50Ll91cGRhdGVSZWYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiBpbnZhbGlkYXRlUGVuZGluZygpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiLmNhbmNlbCgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUvaW5zZXJ0IGEgbmV3IGNoaWxkIHZtLlxuICAgKiBJZiBrZWVwIGFsaXZlIGFuZCBoYXMgY2FjaGVkIGluc3RhbmNlLCBpbnNlcnQgdGhhdFxuICAgKiBpbnN0YW5jZTsgb3RoZXJ3aXNlIGJ1aWxkIGEgbmV3IG9uZSBhbmQgY2FjaGUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFPcHRpb25zXVxuICAgKiBAcmV0dXJuIHtWdWV9IC0gdGhlIGNyZWF0ZWQgaW5zdGFuY2VcbiAgICovXG5cbiAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkNvbXBvbmVudCkge1xuICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5Db21wb25lbnROYW1lLFxuICAgICAgICBlbDogY2xvbmVOb2RlKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMuZGVzY3JpcHRvci5yZWYsXG4gICAgICAgIF9hc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgX2lzUm91dGVyVmlldzogdGhpcy5faXNSb3V0ZXJWaWV3LFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgICAgIF9jb250ZXh0OiB0aGlzLnZtLFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgICAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgICAgIF9zY29wZTogdGhpcy5fc2NvcGUsXG4gICAgICAgIC8vIHBhc3MgaW4gdGhlIG93bmVyIGZyYWdtZW50IG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBzbyB0aGF0IHRoZSBmcmFnbWVudCBjYW4ga2VlcFxuICAgICAgICAvLyB0cmFjayBvZiBpdHMgY29udGFpbmVkIGNvbXBvbmVudHMgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gY2FsbCBhdHRhY2gvZGV0YWNoIGhvb2tzIGZvciB0aGVtLlxuICAgICAgICBfZnJhZzogdGhpcy5fZnJhZ1xuICAgICAgfTtcbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBleHRlbmQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLkNvbXBvbmVudChvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZDtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RyYW5zaXRpb24nKSAmJiBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICB3YXJuKCdUcmFuc2l0aW9ucyB3aWxsIG5vdCB3b3JrIG9uIGEgZnJhZ21lbnQgaW5zdGFuY2UuICcgKyAnVGVtcGxhdGU6ICcgKyBjaGlsZC4kb3B0aW9ucy50ZW1wbGF0ZSwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJ5IHRvIGdldCBhIGNhY2hlZCBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGdldENhY2hlZDogZnVuY3Rpb24gZ2V0Q2FjaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmtlZXBBbGl2ZSAmJiB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBjdXJyZW50IGNoaWxkLCBidXQgZGVmZXJzIGNsZWFudXAgc29cbiAgICogdGhhdCB3ZSBjYW4gc2VwYXJhdGUgdGhlIGRlc3Ryb3kgYW5kIHJlbW92YWwgc3RlcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJcbiAgICovXG5cbiAgdW5idWlsZDogZnVuY3Rpb24gdW5idWlsZChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIGlmICghdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkVk07XG4gICAgaWYgKCFjaGlsZCB8fCB0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIHJlbW92ZSByZWZcbiAgICAgICAgY2hpbGQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY2hpbGQuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdGhlIHNvbGUgcHVycG9zZSBvZiBgZGVmZXJDbGVhbnVwYCBpcyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIFwiZGVhY3RpdmF0ZVwiIHRoZSB2bSByaWdodCBub3cgYW5kIHBlcmZvcm0gRE9NIHJlbW92YWxcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC4kZGVzdHJveShmYWxzZSwgZGVmZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3VycmVudCBkZXN0cm95ZWQgY2hpbGQgYW5kIG1hbnVhbGx5IGRvXG4gICAqIHRoZSBjbGVhbnVwIGFmdGVyIHJlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNoaWxkLCBjYikge1xuICAgIHZhciBrZWVwQWxpdmUgPSB0aGlzLmtlZXBBbGl2ZTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gY2I7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLTtcbiAgICAgICAgaWYgKCFrZWVwQWxpdmUpIGNoaWxkLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2VsZi5wZW5kaW5nUmVtb3ZhbHMgJiYgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKSB7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKCk7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKHRhcmdldCwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoaWxkVk07XG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9pbmFjdGl2ZSA9IHRydWU7XG4gICAgdGFyZ2V0Ll9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hpbGRWTSA9IHRhcmdldDtcbiAgICBzd2l0Y2ggKHNlbGYucGFyYW1zLnRyYW5zaXRpb25Nb2RlKSB7XG4gICAgICBjYXNlICdpbi1vdXQnOlxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0LWluJzpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kLlxuICAgKi9cblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgLy8gRG8gbm90IGRlZmVyIGNsZWFudXAgd2hlbiB1bmJpbmRpbmdcbiAgICB0aGlzLnVuYnVpbGQoKTtcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhY3RpdmF0ZSBob29rcyBpbiBvcmRlciAoYXN5bmNocm9ub3VzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlSG9va3MoaG9va3MsIHZtLCBjYikge1xuICB2YXIgdG90YWwgPSBob29rcy5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSAwO1xuICBob29rc1swXS5jYWxsKHZtLCBuZXh0KTtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoKytjYWxsZWQgPj0gdG90YWwpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzW2NhbGxlZF0uY2FsbCh2bSwgbmV4dCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wQmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xudmFyIGVtcHR5ID0ge307XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFJDEgPSAvXlskX2EtekEtWl0rW1xcdyRdKiQvO1xudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokLztcblxuLyoqXG4gKiBDb21waWxlIHByb3BzIG9uIGEgcm9vdCBlbGVtZW50IGFuZCByZXR1cm5cbiAqIGEgcHJvcHMgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BPcHRpb25zXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVQcm9wcyhlbCwgcHJvcE9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucyk7XG4gIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcHJvcHMgY291bGQgY29udGFpbiBkYXNoZXMsIHdoaWNoIHdpbGwgYmVcbiAgICAvLyBpbnRlcnByZXRlZCBhcyBtaW51cyBjYWxjdWxhdGlvbnMgYnkgdGhlIHBhcnNlclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIHBhdGggaGVyZVxuICAgIHBhdGggPSBjYW1lbGl6ZShuYW1lKTtcbiAgICBpZiAoIWlkZW50UkUkMS50ZXN0KHBhdGgpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcCBrZXk6IFwiJyArIG5hbWUgKyAnXCIuIFByb3Aga2V5cyAnICsgJ211c3QgYmUgdmFsaWQgaWRlbnRpZmllcnMuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWSxcbiAgICAgIHJhdzogbnVsbFxuICAgIH07XG5cbiAgICBhdHRyID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgIC8vIGZpcnN0IGNoZWNrIGR5bmFtaWMgdmVyc2lvblxuICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLnN5bmMnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuICAgICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBkeW5hbWljIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICAgIHByb3AuZmlsdGVycyA9IHBhcnNlZC5maWx0ZXJzO1xuICAgICAgLy8gY2hlY2sgYmluZGluZyB0eXBlXG4gICAgICBpZiAoaXNMaXRlcmFsKHZhbHVlKSAmJiAhcGFyc2VkLmZpbHRlcnMpIHtcbiAgICAgICAgLy8gZm9yIGV4cHJlc3Npb25zIGNvbnRhaW5pbmcgbGl0ZXJhbCBudW1iZXJzIGFuZFxuICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gb3B0aW1pemUgdGhlbSBhcyBhIG9uZS10aW1lIHNldC5cbiAgICAgICAgcHJvcC5vcHRpbWl6ZWRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZHluYW1pYyA9IHRydWU7XG4gICAgICAgIC8vIGNoZWNrIG5vbi1zZXR0YWJsZSBwYXRoIGZvciB0d28td2F5IGJpbmRpbmdzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZICYmICFzZXR0YWJsZVBhdGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWTtcbiAgICAgICAgICB3YXJuKCdDYW5ub3QgYmluZCB0d28td2F5IHByb3Agd2l0aCBub24tc2V0dGFibGUgJyArICdwYXJlbnQgcGF0aDogJyArIHZhbHVlLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AucGFyZW50UGF0aCA9IHZhbHVlO1xuXG4gICAgICAvLyB3YXJuIHJlcXVpcmVkIHR3by13YXlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMudHdvV2F5ICYmIHByb3AubW9kZSAhPT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZKSB7XG4gICAgICAgIHdhcm4oJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QXR0cihlbCwgYXR0cikpICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgbGl0ZXJhbCBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGNoZWNrIHBvc3NpYmxlIGNhbWVsQ2FzZSBwcm9wIHVzYWdlXG4gICAgICB2YXIgbG93ZXJDYXNlTmFtZSA9IHBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gL1tBLVpcXC1dLy50ZXN0KG5hbWUpICYmIChlbC5nZXRBdHRyaWJ1dGUobG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuKCdQb3NzaWJsZSB1c2FnZSBlcnJvciBmb3IgcHJvcCBgJyArIGxvd2VyQ2FzZU5hbWUgKyAnYCAtICcgKyAnZGlkIHlvdSBtZWFuIGAnICsgYXR0ciArICdgPyBIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSAnICsgJ2tlYmFiLWNhc2UgZm9yIHByb3BzIGluIHRlbXBsYXRlcy4nLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogJyArIG5hbWUsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVzaCBwcm9wXG4gICAgcHJvcHMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gbWFrZVByb3BzTGlua0ZuKHByb3BzKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BzTGlua0ZuKHZtLCBzY29wZSkge1xuICAgIC8vIHN0b3JlIHJlc29sdmVkIHByb3BzIGluZm9cbiAgICB2bS5fcHJvcHMgPSB7fTtcbiAgICB2YXIgaW5saW5lUHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgdmFyIHByb3AsIHBhdGgsIG9wdGlvbnMsIHZhbHVlLCByYXc7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgcmF3ID0gcHJvcC5yYXc7XG4gICAgICBwYXRoID0gcHJvcC5wYXRoO1xuICAgICAgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3A7XG4gICAgICBpZiAoaW5saW5lUHJvcHMgJiYgaGFzT3duKGlubGluZVByb3BzLCBwYXRoKSkge1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgaW5saW5lUHJvcHNbcGF0aF0pO1xuICAgICAgfWlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtLl9jb250ZXh0IHx8IHZtKS4kZ2V0KHByb3AucGFyZW50UGF0aCk7XG4gICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYmluZGluZ1xuICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICBuYW1lOiAncHJvcCcsXG4gICAgICAgICAgICAgIGRlZjogcHJvcERlZixcbiAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgfSwgbnVsbCwgbnVsbCwgc2NvcGUpOyAvLyBlbCwgaG9zdCwgc2NvcGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByb290IGluc3RhbmNlXG4gICAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2bS4kZ2V0KHByb3AucGFyZW50UGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhyYXcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmlwcGVkID09PSByYXcgPyB0b0Jvb2xlYW4odG9OdW1iZXIocmF3KSkgOiBzdHJpcHBlZDtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZyBsaXRlcmFsLCBidXQgd2UgbmVlZCB0byBjYXRlciBmb3JcbiAgICAgICAgLy8gQm9vbGVhbiBwcm9wcyB3aXRoIG5vIHZhbHVlLCBvciB3aXRoIHNhbWVcbiAgICAgICAgLy8gbGl0ZXJhbCB2YWx1ZSAoZS5nLiBkaXNhYmxlZD1cImRpc2FibGVkXCIpXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWxvYWRlci9pc3N1ZXMvMTgyXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy50eXBlID09PSBCb29sZWFuICYmIChyYXcgPT09ICcnIHx8IHJhdyA9PT0gaHlwaGVuYXRlKHByb3AubmFtZSkpID8gdHJ1ZSA6IHJhdztcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHByb3Agd2l0aCBhIHJhd1ZhbHVlLCBhcHBseWluZyBuZWNlc3NhcnkgY29lcnNpb25zLFxuICogZGVmYXVsdCB2YWx1ZXMgJiBhc3NlcnRpb25zIGFuZCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayB3aXRoXG4gKiBwcm9jZXNzZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSByYXdWYWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCByYXdWYWx1ZSwgZm4pIHtcbiAgdmFyIGlzU2ltcGxlID0gcHJvcC5keW5hbWljICYmIGlzU2ltcGxlUGF0aChwcm9wLnBhcmVudFBhdGgpO1xuICB2YXIgdmFsdWUgPSByYXdWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApO1xuICB9XG4gIHZhbHVlID0gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pO1xuICB2YXIgY29lcmNlZCA9IHZhbHVlICE9PSByYXdWYWx1ZTtcbiAgaWYgKCFhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkpIHtcbiAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNTaW1wbGUgJiYgIWNvZXJjZWQpIHtcbiAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBmbih2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm4odmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcCdzIGluaXRpYWwgdmFsdWUgb24gYSB2bSBhbmQgaXRzIGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCBwcm9wLnBhdGgsIHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcCdzIHZhbHVlIG9uIGEgdm0uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2bVtwcm9wLnBhdGhdID0gdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wKSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIGlmICghaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0JykpIHtcbiAgICAvLyBhYnNlbnQgYm9vbGVhbiB2YWx1ZSBkZWZhdWx0cyB0byBmYWxzZVxuICAgIHJldHVybiBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGVmID0gb3B0aW9uc1snZGVmYXVsdCddO1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiAnICsgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLnR5cGUgIT09IEZ1bmN0aW9uID8gZGVmLmNhbGwodm0pIDogZGVmO1xufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFwcm9wLm9wdGlvbnMucmVxdWlyZWQgJiYgKCAvLyBub24tcmVxdWlyZWRcbiAgcHJvcC5yYXcgPT09IG51bGwgfHwgLy8gYWJzY2VudFxuICB2YWx1ZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicgKyAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChmb3JtYXRUeXBlKS5qb2luKCcsICcpICsgJywgZ290ICcgKyBmb3JtYXRWYWx1ZSh2YWx1ZSkgKyAnLicsIHZtKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIi4nLCB2bSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEZvcmNlIHBhcnNpbmcgdmFsdWUgd2l0aCBjb2VyY2Ugb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZVByb3AocHJvcCwgdmFsdWUsIHZtKSB7XG4gIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICBpZiAoIWNvZXJjZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBjb2VyY2UgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiBleHBlY3RlZCBmdW5jdGlvbiwgZ290ICcgKyB0eXBlb2YgY29lcmNlICsgJy4nLCB2bSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGU7XG4gIGlmICh0eXBlID09PSBTdHJpbmcpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnc3RyaW5nJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdudW1iZXInO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZ1bmN0aW9uKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdvYmplY3QnO1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnYXJyYXknO1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdHlwZSBmb3Igb3V0cHV0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSA6ICdjdXN0b20gdHlwZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufVxuXG52YXIgYmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xuXG52YXIgcHJvcERlZiA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMudm07XG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0O1xuICAgIC8vIHBhc3NlZCBpbiBmcm9tIGNvbXBpbGVyIGRpcmVjdGx5XG4gICAgdmFyIHByb3AgPSB0aGlzLmRlc2NyaXB0b3IucHJvcDtcbiAgICB2YXIgY2hpbGRLZXkgPSBwcm9wLnBhdGg7XG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aDtcbiAgICB2YXIgdHdvV2F5ID0gcHJvcC5tb2RlID09PSBiaW5kaW5nTW9kZXMuVFdPX1dBWTtcblxuICAgIHZhciBwYXJlbnRXYXRjaGVyID0gdGhpcy5wYXJlbnRXYXRjaGVyID0gbmV3IFdhdGNoZXIocGFyZW50LCBwYXJlbnRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHVwZGF0ZVByb3AoY2hpbGQsIHByb3AsIHZhbCk7XG4gICAgfSwge1xuICAgICAgdHdvV2F5OiB0d29XYXksXG4gICAgICBmaWx0ZXJzOiBwcm9wLmZpbHRlcnMsXG4gICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAvLyB2LWZvciBzY29wZSBpZiBwcmVzZW50XG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcblxuICAgIC8vIHNldCB0aGUgY2hpbGQgaW5pdGlhbCB2YWx1ZS5cbiAgICBpbml0UHJvcChjaGlsZCwgcHJvcCwgcGFyZW50V2F0Y2hlci52YWx1ZSk7XG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2hpbGQuJG9uY2UoJ3ByZS1ob29rOmNyZWF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2hpbGRXYXRjaGVyID0gbmV3IFdhdGNoZXIoY2hpbGQsIGNoaWxkS2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcGFyZW50V2F0Y2hlci5zZXQodmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIC8vIGVuc3VyZSBzeW5jIHVwd2FyZCBiZWZvcmUgcGFyZW50IHN5bmMgZG93bi5cbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBpbiBjYXNlcyBlLmcuIHRoZSBjaGlsZFxuICAgICAgICAgIC8vIG11dGF0ZXMgYSBwcm9wIGFycmF5LCB0aGVuIHJlcGxhY2VzIGl0LiAoIzE2ODMpXG4gICAgICAgICAgc3luYzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnBhcmVudFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICBpZiAodGhpcy5jaGlsZFdhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2hpbGRXYXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUkMSA9IFtdO1xudmFyIHF1ZXVlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFB1c2ggYSBqb2IgaW50byB0aGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gam9iXG4gKi9cblxuZnVuY3Rpb24gcHVzaEpvYihqb2IpIHtcbiAgcXVldWUkMS5wdXNoKGpvYik7XG4gIGlmICghcXVldWVkKSB7XG4gICAgcXVldWVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhmbHVzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCB0aGUgcXVldWUsIGFuZCBkbyBvbmUgZm9yY2VkIHJlZmxvdyBiZWZvcmVcbiAqIHRyaWdnZXJpbmcgdHJhbnNpdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIC8vIEZvcmNlIGxheW91dFxuICB2YXIgZiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUkMS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlJDFbaV0oKTtcbiAgfVxuICBxdWV1ZSQxID0gW107XG4gIHF1ZXVlZCA9IGZhbHNlO1xuICAvLyBkdW1teSByZXR1cm4sIHNvIGpzIGxpbnRlcnMgZG9uJ3QgY29tcGxhaW4gYWJvdXRcbiAgLy8gdW51c2VkIHZhcmlhYmxlIGZcbiAgcmV0dXJuIGY7XG59XG5cbnZhciBUWVBFX1RSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgVFlQRV9BTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IHRyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcbnZhciBhbmltRHVyYXRpb25Qcm9wID0gYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbic7XG5cbi8qKlxuICogSWYgYSBqdXN0LWVudGVyZWQgZWxlbWVudCBpcyBhcHBsaWVkIHRoZVxuICogbGVhdmUgY2xhc3Mgd2hpbGUgaXRzIGVudGVyIHRyYW5zaXRpb24gaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICogYW5kIHRoZSB0cmFuc2l0aW9uZWQgcHJvcGVydHkgaGFzIHRoZSBzYW1lIHZhbHVlIGZvciBib3RoXG4gKiBlbnRlci9sZWF2ZSwgdGhlbiB0aGUgbGVhdmUgdHJhbnNpdGlvbiB3aWxsIGJlIHNraXBwZWQgYW5kXG4gKiB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gVGhpcyBmdW5jdGlvbiBlbnN1cmVzXG4gKiBpdHMgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIGEgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZFxuICogYnkgd2FpdGluZyBmb3IgZG91YmxlIHJhZi5cbiAqXG4gKiBJdCBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQgb24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgQ1NTXG4gKiB0cmFuc2l0aW9ucyBidXQgbm90IHJhZiAoZS5nLiBBbmRyb2lkIDQuMiBicm93c2VyKSAtIHNpbmNlXG4gKiB0aGVzZSBlbnZpcm9ubWVudHMgYXJlIHVzdWFsbHkgc2xvdywgd2UgYXJlIGdpdmluZyBpdCBhXG4gKiByZWxhdGl2ZWx5IGxhcmdlIHRpbWVvdXQuXG4gKi9cblxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQgPSByYWZcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4/IGZ1bmN0aW9uIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICBzZXRUaW1lb3V0KGZuLCA1MCk7XG59O1xuXG4vKipcbiAqIEEgVHJhbnNpdGlvbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIGFuZCBsb2dpY1xuICogb2YgdGhlIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHZtKSB7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmVudGVyQ2xhc3MgPSBob29rcyAmJiBob29rcy5lbnRlckNsYXNzIHx8IGlkICsgJy1lbnRlcic7XG4gIHRoaXMubGVhdmVDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmxlYXZlQ2xhc3MgfHwgaWQgKyAnLWxlYXZlJztcbiAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICB0aGlzLnZtID0gdm07XG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHRoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5lbnRlcmVkID0gdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMudHlwZUNhY2hlID0ge307XG4gIC8vIGNoZWNrIGNzcyB0cmFuc2l0aW9uIHR5cGVcbiAgdGhpcy50eXBlID0gaG9va3MgJiYgaG9va3MudHlwZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgIT09IFRZUEVfVFJBTlNJVElPTiAmJiB0aGlzLnR5cGUgIT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB3YXJuKCdpbnZhbGlkIENTUyB0cmFuc2l0aW9uIHR5cGUgZm9yIHRyYW5zaXRpb249XCInICsgdGhpcy5pZCArICdcIjogJyArIHRoaXMudHlwZSwgdm0pO1xuICAgIH1cbiAgfVxuICAvLyBiaW5kXG4gIHZhciBzZWxmID0gdGhpcztbJ2VudGVyTmV4dFRpY2snLCAnZW50ZXJEb25lJywgJ2xlYXZlTmV4dFRpY2snLCAnbGVhdmVEb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbbV0gPSBiaW5kKHNlbGZbbV0sIHNlbGYpO1xuICB9KTtcbn1cblxudmFyIHAkMSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5lbnRlciA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJyk7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgb3AoKTtcbiAgdGhpcy5lbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2VudGVyJyk7XG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5lbnRlckNhbmNlbGxlZDtcbiAgcHVzaEpvYih0aGlzLmVudGVyTmV4dFRpY2spO1xufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24sIHdoaWNoIGlzXG4gKiB0byBiZSBwdXNoZWQgaW50byBhIHF1ZXVlIGFuZCBleGVjdXRlZCBhZnRlciBhIHJlZmxvdyBzb1xuICogdGhhdCByZW1vdmluZyB0aGUgY2xhc3MgY2FuIHRyaWdnZXIgYSBDU1MgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAvLyBwcmV2ZW50IHRyYW5zaXRpb24gc2tpcHBpbmdcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IHRydWU7XG4gIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIH0pO1xuICB2YXIgZW50ZXJEb25lID0gdGhpcy5lbnRlckRvbmU7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmVudGVyQ2xhc3MpO1xuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgdGhpcy5zZXR1cENzc0NiKHRyYW5zaXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IoYW5pbWF0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlckRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW50ZXJlZCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyRW50ZXInKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gbGVhdmUgdHJhbnNpdGlvbiB0cmlnZ2VyZWQuXG4gKiAyLiBjYWxsIGJlZm9yZUxlYXZlIGhvb2tcbiAqIDMuIGFkZCBsZWF2ZSBjbGFzcyAodHJpZ2dlciBjc3MgdHJhbnNpdGlvbilcbiAqIDQuIGNhbGwgbGVhdmUgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDUuIHJlZmxvdyBpZiBubyBleHBsaWNpdCBqcyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICogNi4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBlbmQgZXZlbnQsIHJlbW92ZSBjbGFzcywgdGhlbiBkb25lIGlmXG4gKiAgICAgICAgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogNy4gd2FpdCBmb3IgZWl0aGVyIGRvbmUgb3IganMgY2FsbGJhY2ssIHRoZW4gY2FsbFxuICogICAgYWZ0ZXJMZWF2ZSBob29rLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gcmVtb3ZlL2hpZGUgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5wJDEubGVhdmUgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICB0aGlzLmNhbGxIb29rKCdiZWZvcmVMZWF2ZScpO1xuICB0aGlzLm9wID0gb3A7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2xlYXZlJyk7XG4gIGlmICh0aGlzLmxlZnQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZDtcbiAgLy8gb25seSBuZWVkIHRvIGhhbmRsZSBsZWF2ZURvbmUgaWZcbiAgLy8gMS4gdGhlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBkb25lIChzeW5jaHJvbm91c2x5IGNhbGxlZFxuICAvLyAgICBieSB0aGUgdXNlciwgd2hpY2ggY2F1c2VzIHRoaXMub3Agc2V0IHRvIG51bGwpXG4gIC8vIDIuIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2tcbiAgaWYgKHRoaXMub3AgJiYgIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAvLyBpZiBhIENTUyB0cmFuc2l0aW9uIGxlYXZlcyBpbW1lZGlhdGVseSBhZnRlciBlbnRlcixcbiAgICAvLyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gdGhlcmVmb3JlIHdlXG4gICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGVuZCB0aGUgbGVhdmUgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHRoaXMuanVzdEVudGVyZWQpIHtcbiAgICAgIHRoaXMubGVhdmVEb25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hKb2IodGhpcy5sZWF2ZU5leHRUaWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcyk7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZWZ0ID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgdGhpcy5vcCgpO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG4gIHRoaXMub3AgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYW55IHBlbmRpbmcgY2FsbGJhY2tzIGZyb20gYSBwcmV2aW91c2x5IHJ1bm5pbmdcbiAqIGJ1dCBub3QgZmluaXNoZWQgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB2YXIgaGFzUGVuZGluZyA9IGZhbHNlO1xuICBpZiAodGhpcy5wZW5kaW5nQ3NzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICBvZmYodGhpcy5lbCwgdGhpcy5wZW5kaW5nQ3NzRXZlbnQsIHRoaXMucGVuZGluZ0Nzc0NiKTtcbiAgICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IuY2FuY2VsKCk7XG4gICAgdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIH1cbiAgaWYgKHRoaXMuY2FuY2VsKSB7XG4gICAgdGhpcy5jYW5jZWwuY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB0aGlzLmNhbmNlbCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQgc3luY2hyb25vdXMgaG9vayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV0pIHtcbiAgICB0aGlzLmhvb2tzW3R5cGVdLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rV2l0aENiID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGhvb2sgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV07XG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IGNhbmNlbGxhYmxlKHRoaXNbdHlwZSArICdEb25lJ10pO1xuICAgIH1cbiAgICBob29rLmNhbGwodGhpcy52bSwgdGhpcy5lbCwgdGhpcy5wZW5kaW5nSnNDYik7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyB0cmFuc2l0aW9uIHR5cGUgYmFzZWQgb24gdGhlXG4gKiBjYWxjdWxhdGVkIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxucCQxLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCBDU1MgdHJhbnNpdGlvbnMgaWYgcGFnZSBpcyBub3QgdmlzaWJsZSAtXG4gIC8vIHRoaXMgc29sdmVzIHRoZSBpc3N1ZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50cyBub3RcbiAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gIC8vIHBhZ2VWaXNpYmlsaXR5IEFQSSBpcyBzdXBwb3J0ZWQgaW4gSUUxMCssIHNhbWUgYXNcbiAgLy8gQ1NTIHRyYW5zaXRpb25zLlxuICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgLy8gZXhwbGljaXQganMtb25seSB0cmFuc2l0aW9uXG4gIHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5jc3MgPT09IGZhbHNlIHx8XG4gIC8vIGVsZW1lbnQgaXMgaGlkZGVuXG4gIGlzSGlkZGVuKHRoaXMuZWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0eXBlID0gdGhpcy50eXBlIHx8IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV07XG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZTtcbiAgdmFyIGlubGluZVN0eWxlcyA9IHRoaXMuZWwuc3R5bGU7XG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpO1xuICB2YXIgdHJhbnNEdXJhdGlvbiA9IGlubGluZVN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdO1xuICBpZiAodHJhbnNEdXJhdGlvbiAmJiB0cmFuc0R1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgdHlwZSA9IFRZUEVfVFJBTlNJVElPTjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5pbUR1cmF0aW9uID0gaW5saW5lU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdO1xuICAgIGlmIChhbmltRHVyYXRpb24gJiYgYW5pbUR1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgICB0eXBlID0gVFlQRV9BTklNQVRJT047XG4gICAgfVxuICB9XG4gIGlmICh0eXBlKSB7XG4gICAgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXSA9IHR5cGU7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIFNldHVwIGEgQ1NTIHRyYW5zaXRpb25lbmQvYW5pbWF0aW9uZW5kIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5wJDEuc2V0dXBDc3NDYiA9IGZ1bmN0aW9uIChldmVudCwgY2IpIHtcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSBldmVudDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWwgPSB0aGlzLmVsO1xuICB2YXIgb25FbmQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgb2ZmKGVsLCBldmVudCwgb25FbmQpO1xuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gICAgICBpZiAoIXNlbGYucGVuZGluZ0pzQ2IgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG9uKGVsLCBldmVudCwgb25FbmQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuKGVsKSB7XG4gIGlmICgvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgLy8gU1ZHIGVsZW1lbnRzIGRvIG5vdCBoYXZlIG9mZnNldChXaWR0aHxIZWlnaHQpXG4gICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0aGUgY2xpZW50IHJlY3RcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiAhKHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24kMSA9IHtcblxuICBwcmlvcml0eTogVFJBTlNJVElPTixcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShpZCwgb2xkSWQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3RyYW5zaXRpb25zJywgaWQpO1xuICAgIGlkID0gaWQgfHwgJ3YnO1xuICAgIG9sZElkID0gb2xkSWQgfHwgJ3YnO1xuICAgIGVsLl9fdl90cmFucyA9IG5ldyBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHRoaXMudm0pO1xuICAgIHJlbW92ZUNsYXNzKGVsLCBvbGRJZCArICctdHJhbnNpdGlvbicpO1xuICAgIGFkZENsYXNzKGVsLCBpZCArICctdHJhbnNpdGlvbicpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0ge1xuICBzdHlsZTogc3R5bGUsXG4gICdjbGFzcyc6IHZDbGFzcyxcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIHByb3A6IHByb3BEZWYsXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb24kMVxufTtcblxuLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG52YXIgYmluZFJFID0gL152LWJpbmQ6fF46LztcbnZhciBvblJFID0gL152LW9uOnxeQC87XG52YXIgZGlyQXR0clJFID0gL152LShbXjpdKykoPzokfDooLiopJCkvO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nO1xudmFyIHRyYW5zaXRpb25SRSA9IC9eKHYtYmluZDp8Oik/dHJhbnNpdGlvbiQvO1xuXG4vLyBkZWZhdWx0IGRpcmVjdGl2ZSBwcmlvcml0eVxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xudmFyIERFRkFVTFRfVEVSTUlOQUxfUFJJT1JJVFkgPSAyMDAwO1xuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUoZWwsIG9wdGlvbnMsIHBhcnRpYWwpIHtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgaXRzZWxmLlxuICB2YXIgbm9kZUxpbmtGbiA9IHBhcnRpYWwgfHwgIW9wdGlvbnMuX2FzQ29tcG9uZW50ID8gY29tcGlsZU5vZGUoZWwsIG9wdGlvbnMpIDogbnVsbDtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIGNoaWxkTm9kZXNcbiAgdmFyIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmICFpc1NjcmlwdChlbCkgJiYgZWwuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KGVsLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcblxuICAvKipcbiAgICogQSBjb21wb3NpdGUgbGlua2VyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGFscmVhZHlcbiAgICogY29tcGlsZWQgcGllY2Ugb2YgRE9NLCB3aGljaCBpbnN0YW50aWF0ZXMgYWxsIGRpcmVjdGl2ZVxuICAgKiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIGhvc3Qgdm0gb2YgdHJhbnNjbHVkZWQgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIGxpbmsgY29udGV4dCBmcmFnbWVudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NpdGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShlbC5jaGlsZE5vZGVzKTtcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIoKSB7XG4gICAgICBpZiAobm9kZUxpbmtGbikgbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9LCB2bSk7XG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgZGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5rZXIgdG8gYSB2bS9lbGVtZW50IHBhaXIgYW5kIGNhcHR1cmUgdGhlXG4gKiBkaXJlY3RpdmVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gbGlua0FuZENhcHR1cmUobGlua2VyLCB2bSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyByZXNldCBkaXJlY3RpdmVzIGJlZm9yZSBldmVyeSBjYXB0dXJlIGluIHByb2R1Y3Rpb25cbiAgICAvLyBtb2RlLCBzbyB0aGF0IHdoZW4gdW5saW5raW5nIHdlIGRvbid0IG5lZWQgdG8gc3BsaWNlXG4gICAgLy8gdGhlbSBvdXQgKHdoaWNoIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgaGl0KS5cbiAgICAvLyB0aGV5IGFyZSBrZXB0IGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSB0aGV5IGFyZVxuICAgIC8vIHVzZWZ1bCBmb3IgVnVlJ3Mgb3duIHRlc3RzLlxuICAgIHZtLl9kaXJlY3RpdmVzID0gW107XG4gIH1cbiAgdmFyIG9yaWdpbmFsRGlyQ291bnQgPSB2bS5fZGlyZWN0aXZlcy5sZW5ndGg7XG4gIGxpbmtlcigpO1xuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpO1xuICBkaXJzLnNvcnQoZGlyZWN0aXZlQ29tcGFyYXRvcik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXJzW2ldLl9iaW5kKCk7XG4gIH1cbiAgcmV0dXJuIGRpcnM7XG59XG5cbi8qKlxuICogRGlyZWN0aXZlIHByaW9yaXR5IHNvcnQgY29tcGFyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICovXG5cbmZ1bmN0aW9uIGRpcmVjdGl2ZUNvbXBhcmF0b3IoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICBiID0gYi5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4odm0sIGRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKSB7XG4gIGZ1bmN0aW9uIHVubGluayhkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0RGlycykge1xuICAgICAgdGVhcmRvd25EaXJzKGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIGxpbmtlZCBkaXJlY3RpdmVzXG4gIHVubGluay5kaXJzID0gZGlycztcbiAgcmV0dXJuIHVubGluaztcbn1cblxuLyoqXG4gKiBUZWFyZG93biBwYXJ0aWFsIGxpbmtlZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95aW5nXG4gKi9cblxuZnVuY3Rpb24gdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKSB7XG4gIHZhciBpID0gZGlycy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBkaXJzW2ldLl90ZWFyZG93bigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkZXN0cm95aW5nKSB7XG4gICAgICB2bS5fZGlyZWN0aXZlcy4kcmVtb3ZlKGRpcnNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMaW5rUHJvcHModm0sIGVsLCBwcm9wcywgc2NvcGUpIHtcbiAgdmFyIHByb3BzTGlua0ZuID0gY29tcGlsZVByb3BzKGVsLCBwcm9wcywgdm0pO1xuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKTtcbiAgfSwgdm0pO1xuICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBwcm9wRGlycyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fY29udGFpbmVyQXR0cnM7XG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycztcbiAgdmFyIGNvbnRleHRMaW5rRm4sIHJlcGxhY2VyTGlua0ZuO1xuXG4gIC8vIG9ubHkgbmVlZCB0byBjb21waWxlIG90aGVyIGF0dHJpYnV0ZXMgZm9yXG4gIC8vIG5vbi1mcmFnbWVudCBpbnN0YW5jZXNcbiAgaWYgKGVsLm5vZGVUeXBlICE9PSAxMSkge1xuICAgIC8vIGZvciBjb21wb25lbnRzLCBjb250YWluZXIgYW5kIHJlcGxhY2VyIG5lZWQgdG8gYmVcbiAgICAvLyBjb21waWxlZCBzZXBhcmF0ZWx5IGFuZCBsaW5rZWQgaW4gZGlmZmVyZW50IHNjb3Blcy5cbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIC8vIDIuIGNvbnRhaW5lciBhdHRyaWJ1dGVzXG4gICAgICBpZiAoY29udGFpbmVyQXR0cnMgJiYgY29udGV4dE9wdGlvbnMpIHtcbiAgICAgICAgY29udGV4dExpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGNvbnRhaW5lckF0dHJzLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vbi1jb21wb25lbnQsIGp1c3QgY29tcGlsZSBhcyBhIG5vcm1hbCBlbGVtZW50LlxuICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb250YWluZXJBdHRycykge1xuICAgIC8vIHdhcm4gY29udGFpbmVyIGRpcmVjdGl2ZXMgZm9yIGZyYWdtZW50IGluc3RhbmNlc1xuICAgIHZhciBuYW1lcyA9IGNvbnRhaW5lckF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gYWxsb3cgdnVlLWxvYWRlci92dWVpZnkgc2NvcGVkIGNzcyBhdHRyaWJ1dGVzXG4gICAgICByZXR1cm4gYXR0ci5uYW1lLmluZGV4T2YoJ192LScpIDwgMCAmJlxuICAgICAgLy8gYWxsb3cgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAhb25SRS50ZXN0KGF0dHIubmFtZSkgJiZcbiAgICAgIC8vIGFsbG93IHNsb3RzXG4gICAgICBhdHRyLm5hbWUgIT09ICdzbG90JztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJztcbiAgICB9KTtcbiAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgcGx1cmFsID0gbmFtZXMubGVuZ3RoID4gMTtcbiAgICAgIHdhcm4oJ0F0dHJpYnV0ZScgKyAocGx1cmFsID8gJ3MgJyA6ICcgJykgKyBuYW1lcy5qb2luKCcsICcpICsgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArICc8JyArIG9wdGlvbnMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4gYmVjYXVzZSAnICsgJ3RoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudCBpbnN0YW5jZTogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudC1JbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiByb290TGlua0ZuKHZtLCBlbCwgc2NvcGUpIHtcbiAgICAvLyBsaW5rIGNvbnRleHQgc2NvcGUgZGlyc1xuICAgIHZhciBjb250ZXh0ID0gdm0uX2NvbnRleHQ7XG4gICAgdmFyIGNvbnRleHREaXJzO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSk7XG4gICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBsaW5rIHNlbGZcbiAgICB2YXIgc2VsZkRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVwbGFjZXJMaW5rRm4pIHJlcGxhY2VyTGlua0ZuKHZtLCBlbCk7XG4gICAgfSwgdm0pO1xuXG4gICAgLy8gcmV0dXJuIHRoZSB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gY29udGV4dFxuICAgIC8vIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHNlbGZEaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgaWYgKHR5cGUgPT09IDEgJiYgIWlzU2NyaXB0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVFbGVtZW50KG5vZGUsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUVsZW1lbnQoZWwsIG9wdGlvbnMpIHtcbiAgLy8gcHJlcHJvY2VzcyB0ZXh0YXJlYXMuXG4gIC8vIHRleHRhcmVhIHRyZWF0cyBpdHMgdGV4dCBjb250ZW50IGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAvLyBqdXN0IGJpbmQgaXQgYXMgYW4gYXR0ciBkaXJlY3RpdmUgZm9yIHZhbHVlLlxuICBpZiAoZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQoZWwudmFsdWUpO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnOnZhbHVlJywgdG9rZW5zVG9FeHAodG9rZW5zKSk7XG4gICAgICBlbC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxuICB2YXIgbGlua0ZuO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIHZhciBhdHRycyA9IGhhc0F0dHJzICYmIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGVsZW1lbnQgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbiAmJiBoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbGlua0ZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZXh0Tm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucykge1xuICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gIGlmIChub2RlLl9za2lwKSB7XG4gICAgcmV0dXJuIHJlbW92ZVRleHQ7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KG5vZGUud2hvbGVUZXh0KTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG1hcmsgYWRqYWNlbnQgdGV4dCBub2RlcyBhcyBza2lwcGVkLFxuICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gIC8vIGFsbCBhZGphY2VudCB0ZXh0IG5vZGVzIHRvZ2V0aGVyLiBUaGlzIGZpeGVzXG4gIC8vIGlzc3VlcyBpbiBJRSB3aGVyZSBzb21ldGltZXMgaXQgc3BsaXRzIHVwIGEgc2luZ2xlXG4gIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gMykge1xuICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBlbCwgdG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGVsID0gdG9rZW4udGFnID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtlciBmb3IgYW4gc2tpcHBlZCB0ZXh0IG5vZGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gIHJlbW92ZShub2RlKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSB7XG4gIHZhciBlbDtcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd2LWh0bWwnKTtcbiAgICAgIHNldFRva2VuVHlwZSgnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VG9rZW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh0b2tlbi52YWx1ZSk7XG4gICAgdG9rZW4uZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBkZWY6IGRpcmVjdGl2ZXNbdHlwZV0sXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdG9rZW5zXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgdmFyIGZyYWdDbG9uZSA9IGZyYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShmcmFnQ2xvbmUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGlmICh0b2tlbi50YWcpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZtLl9iaW5kRGlyKHRva2VuLmRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGVsLCBmcmFnQ2xvbmUpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdChub2RlTGlzdCwgb3B0aW9ucykge1xuICB2YXIgbGlua0ZucyA9IFtdO1xuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgIG5vZGVMaW5rRm4gPSBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKTtcbiAgICBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIG5vZGUuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuICAgIGxpbmtGbnMucHVzaChub2RlTGlua0ZuLCBjaGlsZExpbmtGbik7XG4gIH1cbiAgcmV0dXJuIGxpbmtGbnMubGVuZ3RoID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2hpbGQgbGluayBmdW5jdGlvbiBmb3IgYSBub2RlJ3MgY2hpbGROb2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gbGlua0Zuc1xuICogQHJldHVybiB7RnVuY3Rpb259IGNoaWxkTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoaWxkTGlua0ZuKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSAwLCBsID0gbGlua0Zucy5sZW5ndGg7IGkgPCBsOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIG5vZGVMaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRyZW5MaW5rRm4pIHtcbiAgICAgICAgY2hpbGRyZW5MaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGNvbW1vblRhZ1JFLnRlc3QodGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZyk7XG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQuIElmIHllcywgcmV0dXJuXG4gKiBhIGNvbXBvbmVudCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucyk7XG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgcmVmID0gZmluZFJlZihlbCk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudExpbmtGbiA9IGZ1bmN0aW9uIGNvbXBvbmVudExpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIHJlZiwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH07XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgICByZXR1cm4gY29tcG9uZW50TGlua0ZuO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYW4gZWxlbWVudCBmb3IgdGVybWluYWwgZGlyZWN0aXZlcyBpbiBmaXhlZCBvcmRlci5cbiAqIElmIGl0IGZpbmRzIG9uZSwgcmV0dXJuIGEgdGVybWluYWwgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5fSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChnZXRBdHRyKGVsLCAndi1wcmUnKSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBza2lwO1xuICB9XG4gIC8vIHNraXAgdi1lbHNlIGJsb2NrLCBidXQgb25seSBpZiBmb2xsb3dpbmcgdi1pZlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2LWVsc2UnKSkge1xuICAgIHZhciBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcDtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgbWF0Y2hlZCwgZGlyTmFtZSwgcmF3TmFtZSwgYXJnLCBkZWYsIHRlcm1EZWY7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gYXR0cnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgaWYgKG1hdGNoZWQgPSBuYW1lLm1hdGNoKGRpckF0dHJSRSkpIHtcbiAgICAgIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIG1hdGNoZWRbMV0pO1xuICAgICAgaWYgKGRlZiAmJiBkZWYudGVybWluYWwpIHtcbiAgICAgICAgaWYgKCF0ZXJtRGVmIHx8IChkZWYucHJpb3JpdHkgfHwgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSkgPiB0ZXJtRGVmLnByaW9yaXR5KSB7XG4gICAgICAgICAgdGVybURlZiA9IGRlZjtcbiAgICAgICAgICByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKGF0dHIubmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGVybURlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgdGVybURlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNraXAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWU7XG5cbi8qKlxuICogQnVpbGQgYSBub2RlIGxpbmsgZnVuY3Rpb24gZm9yIGEgdGVybWluYWwgZGlyZWN0aXZlLlxuICogQSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgdGhlIGN1cnJlbnRcbiAqIGNvbXBpbGF0aW9uIHJlY3Vyc2lvbiBhbmQgaGFuZGxlcyBjb21waWxhdGlvbiBvZiB0aGVcbiAqIHN1YnRyZWUgaW4gdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICogQHBhcmFtIHtTdHJpbmd9IFtyYXdOYW1lXVxuICogQHBhcmFtIHtTdHJpbmd9IFthcmddXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCBkZWYsIHJhd05hbWUsIGFyZywgbW9kaWZpZXJzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgYXJnOiBhcmcsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICBhdHRyOiByYXdOYW1lLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgIGRlZjogZGVmXG4gIH07XG4gIC8vIGNoZWNrIHJlZiBmb3Igdi1mb3IgYW5kIHJvdXRlci12aWV3XG4gIGlmIChkaXJOYW1lID09PSAnZm9yJyB8fCBkaXJOYW1lID09PSAncm91dGVyLXZpZXcnKSB7XG4gICAgZGVzY3JpcHRvci5yZWYgPSBmaW5kUmVmKGVsKTtcbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIGlmIChkZXNjcmlwdG9yLnJlZikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgZGVzY3JpcHRvci5yZWYsIG51bGwpO1xuICAgIH1cbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xuICBmbi50ZXJtaW5hbCA9IHRydWU7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSBkaXJlY3RpdmVzIG9uIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIGxpbmtlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5hbWVkTm9kZU1hcH0gYXR0cnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRGlyZWN0aXZlcyhhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIGRpcnMgPSBbXTtcbiAgdmFyIGF0dHIsIG5hbWUsIHZhbHVlLCByYXdOYW1lLCByYXdWYWx1ZSwgZGlyTmFtZSwgYXJnLCBtb2RpZmllcnMsIGRpckRlZiwgdG9rZW5zLCBtYXRjaGVkO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgIHZhbHVlID0gcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIHRva2VucyA9IHBhcnNlVGV4dCh2YWx1ZSk7XG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbDtcbiAgICAvLyBjaGVjayBtb2RpZmllcnNcbiAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdG9rZW5zVG9FeHAodG9rZW5zKTtcbiAgICAgIGFyZyA9IG5hbWU7XG4gICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kLCB0b2tlbnMpO1xuICAgICAgLy8gd2FybiBhZ2FpbnN0IG1peGluZyBtdXN0YWNoZXMgd2l0aCB2LWJpbmRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnICYmIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gJzpjbGFzcycgfHwgYXR0ci5uYW1lID09PSAndi1iaW5kOmNsYXNzJztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3YXJuKCdjbGFzcz1cIicgKyByYXdWYWx1ZSArICdcIjogRG8gbm90IG1peCBtdXN0YWNoZSBpbnRlcnBvbGF0aW9uICcgKyAnYW5kIHYtYmluZCBmb3IgXCJjbGFzc1wiIG9uIHRoZSBzYW1lIGVsZW1lbnQuIFVzZSBvbmUgb3IgdGhlIG90aGVyLicsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlXG5cbiAgICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlOiB0cmFuc2l0aW9uXG4gICAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbW9kaWZpZXJzLmxpdGVyYWwgPSAhYmluZFJFLnRlc3QobmFtZSk7XG4gICAgICAgIHB1c2hEaXIoJ3RyYW5zaXRpb24nLCBpbnRlcm5hbERpcmVjdGl2ZXMudHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2VcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgYXJnID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICBwdXNoRGlyKCdvbicsIGRpcmVjdGl2ZXMub24pO1xuICAgICAgICB9IGVsc2VcblxuICAgICAgICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnc3R5bGUnIHx8IGRpck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBpbnRlcm5hbERpcmVjdGl2ZXNbZGlyTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJnID0gZGlyTmFtZTtcbiAgICAgICAgICAgICAgcHVzaERpcignYmluZCcsIGRpcmVjdGl2ZXMuYmluZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgICAgICAgICBkaXJOYW1lID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcblxuICAgICAgICAgICAgICAvLyBza2lwIHYtZWxzZSAod2hlbiB1c2VkIHdpdGggdi1zaG93KVxuICAgICAgICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaXJEZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXJOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBkZWZcbiAgICogQHBhcmFtIHtBcnJheX0gW2ludGVycFRva2Vuc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpcihkaXJOYW1lLCBkZWYsIGludGVycFRva2Vucykge1xuICAgIHZhciBoYXNPbmVUaW1lVG9rZW4gPSBpbnRlcnBUb2tlbnMgJiYgaGFzT25lVGltZShpbnRlcnBUb2tlbnMpO1xuICAgIHZhciBwYXJzZWQgPSAhaGFzT25lVGltZVRva2VuICYmIHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICBkaXJzLnB1c2goe1xuICAgICAgbmFtZTogZGlyTmFtZSxcbiAgICAgIGF0dHI6IHJhd05hbWUsXG4gICAgICByYXc6IHJhd1ZhbHVlLFxuICAgICAgZGVmOiBkZWYsXG4gICAgICBhcmc6IGFyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgLy8gY29udmVyc2lvbiBmcm9tIGludGVycG9sYXRpb24gc3RyaW5ncyB3aXRoIG9uZS10aW1lIHRva2VuXG4gICAgICAvLyB0byBleHByZXNzaW9uIGlzIGRpZmZlcmVkIHVudGlsIGRpcmVjdGl2ZSBiaW5kIHRpbWUgc28gdGhhdCB3ZVxuICAgICAgLy8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGFjdHVhbCB2bSBjb250ZXh0IGZvciBvbmUtdGltZSBiaW5kaW5ncy5cbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZCAmJiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgIGludGVycDogaW50ZXJwVG9rZW5zLFxuICAgICAgaGFzT25lVGltZTogaGFzT25lVGltZVRva2VuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGlycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVMaW5rRm4oZGlycyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXNbbWF0Y2hbaV0uc2xpY2UoMSldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGxpbmsgZnVuY3Rpb24gZm9yIGFsbCBkaXJlY3RpdmVzIG9uIGEgc2luZ2xlIG5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlyZWN0aXZlc1xuICogQHJldHVybiB7RnVuY3Rpb259IGRpcmVjdGl2ZXNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTm9kZUxpbmtGbihkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAvLyByZXZlcnNlIGFwcGx5IGJlY2F1c2UgaXQncyBzb3J0ZWQgbG93IHRvIGhpZ2hcbiAgICB2YXIgaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGludGVycG9sYXRpb24gc3RyaW5nIGNvbnRhaW5zIG9uZS10aW1lIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT25lVGltZSh0b2tlbnMpIHtcbiAgdmFyIGkgPSB0b2tlbnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRva2Vuc1tpXS5vbmVUaW1lKSByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NjcmlwdChlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZSA9PT0gJ1NDUklQVCcgJiYgKCFlbC5oYXNBdHRyaWJ1dGUoJ3R5cGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpO1xufVxuXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dLztcblxuLyoqXG4gKiBQcm9jZXNzIGFuIGVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJhc2VkIG9uIGFcbiAqIGluc3RhbmNlIG9wdGlvbiBvYmplY3QuIFRoaXMgYWxsb3dzIHVzIHRvIHRyYW5zY2x1ZGVcbiAqIGEgdGVtcGxhdGUgbm9kZS9mcmFnbWVudCBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQsXG4gKiBzbyB0aGUgcHJvY2Vzc2VkIGZyYWdtZW50IGNhbiB0aGVuIGJlIGNsb25lZCBhbmQgcmV1c2VkXG4gKiBpbiB2LWZvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zY2x1ZGUoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZXh0cmFjdCBjb250YWluZXIgYXR0cmlidXRlcyB0byBwYXNzIHRoZW0gZG93blxuICAvLyB0byBjb21waWxlciwgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgY29tcGlsZWQgaW5cbiAgLy8gcGFyZW50IHNjb3BlLiB3ZSBhcmUgbXV0YXRpbmcgdGhlIG9wdGlvbnMgb2JqZWN0IGhlcmVcbiAgLy8gYXNzdW1pbmcgdGhlIHNhbWUgb2JqZWN0IHdpbGwgYmUgdXNlZCBmb3IgY29tcGlsZVxuICAvLyByaWdodCBhZnRlciB0aGlzLlxuICBpZiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gZXh0cmFjdEF0dHJzKGVsKTtcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKGlzVGVtcGxhdGUoZWwpKSB7XG4gICAgZWwgPSBwYXJzZVRlbXBsYXRlKGVsKTtcbiAgfVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCAmJiAhb3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9ICc8c2xvdD48L3Nsb3Q+JztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMuX2NvbnRlbnQgPSBleHRyYWN0Q29udGVudChlbCk7XG4gICAgICBlbCA9IHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgIC8vIGFuY2hvcnMgZm9yIGZyYWdtZW50IGluc3RhbmNlXG4gICAgLy8gcGFzc2luZyBpbiBgcGVyc2lzdDogdHJ1ZWAgdG8gYXZvaWQgdGhlbSBiZWluZ1xuICAgIC8vIGRpc2NhcmRlZCBieSBJRSBkdXJpbmcgdGVtcGxhdGUgY2xvbmluZ1xuICAgIHByZXBlbmQoY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjcmVhdGVBbmNob3IoJ3YtZW5kJywgdHJ1ZSkpO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24uXG4gKiBJZiB0aGUgcmVwbGFjZSBvcHRpb24gaXMgdHJ1ZSB0aGlzIHdpbGwgc3dhcCB0aGUgJGVsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSk7XG4gIGlmIChmcmFnKSB7XG4gICAgdmFyIHJlcGxhY2VyID0gZnJhZy5maXJzdENoaWxkO1xuICAgIHZhciB0YWcgPSByZXBsYWNlci50YWdOYW1lICYmIHJlcGxhY2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1lvdSBhcmUgbW91bnRpbmcgYW4gaW5zdGFuY2Ugd2l0aCBhIHRlbXBsYXRlIHRvICcgKyAnPGJvZHk+LiBUaGlzIHdpbGwgcmVwbGFjZSA8Ym9keT4gZW50aXJlbHkuIFlvdSAnICsgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLicpO1xuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgLy8gbXVsdGktY2hpbGRyZW4gdGVtcGxhdGVcbiAgICAgIGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPiAxIHx8XG4gICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgcmVwbGFjZXIubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgIC8vIHNpbmdsZSBuZXN0ZWQgY29tcG9uZW50XG4gICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8IHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykgfHwgaGFzQmluZEF0dHIocmVwbGFjZXIsICdpcycpIHx8XG4gICAgICAvLyBlbGVtZW50IGRpcmVjdGl2ZVxuICAgICAgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgIC8vIGZvciBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWZvcicpIHx8XG4gICAgICAvLyBpZiBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKTtcbiAgICAgICAgbWVyZ2VBdHRycyhlbCwgcmVwbGFjZXIpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiAnICsgdGVtcGxhdGUpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGV4dHJhY3QgYSBjb21wb25lbnQgY29udGFpbmVyJ3MgYXR0cmlidXRlc1xuICogaW50byBhIHBsYWluIG9iamVjdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0QXR0cnMoZWwpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGVsLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHJldHVybiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzKGZyb20sIHRvKSB7XG4gIHZhciBhdHRycyA9IGZyb20uYXR0cmlidXRlcztcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gIHZhciBuYW1lLCB2YWx1ZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWU7XG4gICAgaWYgKCF0by5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgIXNwZWNpYWxDaGFyUkUudGVzdChuYW1lKSkge1xuICAgICAgdG8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIXBhcnNlVGV4dCh2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUudHJpbSgpKSkge1xuICAgICAgdmFsdWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgYWRkQ2xhc3ModG8sIGNscyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTY2FuIGFuZCBkZXRlcm1pbmUgc2xvdCBjb250ZW50IGRpc3RyaWJ1dGlvbi5cbiAqIFdlIGRvIHRoaXMgZHVyaW5nIHRyYW5zY2x1c2lvbiBpbnN0ZWFkIGF0IGNvbXBpbGUgdGltZSBzbyB0aGF0XG4gKiB0aGUgZGlzdHJpYnV0aW9uIGlzIGRlY291cGxlZCBmcm9tIHRoZSBjb21waWxhdGlvbiBvcmRlciBvZlxuICogdGhlIHNsb3RzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZW50XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2xvdHModm0sIGNvbnRlbnQpIHtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb250ZW50cyA9IHZtLl9zbG90Q29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZWwsIG5hbWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY29udGVudC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlbCA9IGNvbnRlbnQuY2hpbGRyZW5baV07XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpZiAobmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAoY29udGVudHNbbmFtZV0gfHwgKGNvbnRlbnRzW25hbWVdID0gW10pKS5wdXNoKGVsKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldEJpbmRBdHRyKGVsLCAnc2xvdCcpKSB7XG4gICAgICB3YXJuKCdUaGUgXCJzbG90XCIgYXR0cmlidXRlIG11c3QgYmUgc3RhdGljLicsIHZtLiRwYXJlbnQpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gY29udGVudHMpIHtcbiAgICBjb250ZW50c1tuYW1lXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50c1tuYW1lXSwgY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdmFyIG5vZGVzID0gY29udGVudC5jaGlsZE5vZGVzO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0ubm9kZVR5cGUgPT09IDMgJiYgIW5vZGVzWzBdLmRhdGEudHJpbSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnRzWydkZWZhdWx0J10gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudC5jaGlsZE5vZGVzLCBjb250ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcXVhbGlmaWVkIGNvbnRlbnQgbm9kZXMgZnJvbSBhIG5vZGUgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2Rlc1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0RnJhZ21lbnQobm9kZXMsIHBhcmVudCkge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgbm9kZXMgPSB0b0FycmF5KG5vZGVzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChpc1RlbXBsYXRlKG5vZGUpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1pZicpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1mb3InKSkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcnNlVGVtcGxhdGUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZyYWc7XG59XG5cblxuXG52YXIgY29tcGlsZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Y29tcGlsZTogY29tcGlsZSxcblx0Y29tcGlsZUFuZExpbmtQcm9wczogY29tcGlsZUFuZExpbmtQcm9wcyxcblx0Y29tcGlsZVJvb3Q6IGNvbXBpbGVSb290LFxuXHR0cmFuc2NsdWRlOiB0cmFuc2NsdWRlLFxuXHRyZXNvbHZlU2xvdHM6IHJlc29sdmVTbG90c1xufSk7XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIGAkZGF0YWAgcHJvcGVydHksIHNpbmNlIHNldHRpbmcgJGRhdGFcbiAgICogcmVxdWlyZXMgb2JzZXJ2aW5nIHRoZSBuZXcgb2JqZWN0IGFuZCB1cGRhdGluZ1xuICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgIGlmIChuZXdEYXRhICE9PSB0aGlzLl9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAgICogLSBvYnNlcnZlZCBkYXRhXG4gICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgKiAtIHVzZXIgbWV0aG9kc1xuICAgKiAtIG1ldGEgcHJvcGVydGllc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKCk7XG4gICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgdmFyIGVsID0gb3B0aW9ucy5lbDtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArICdwcm92aWRlZCBhdCBpbnN0YW50aWF0aW9uLicsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gY29udmVydCBzdHJpbmcgc2VsZWN0b3JzIGludG8gZWxlbWVudCBub3dcbiAgICBlbCA9IG9wdGlvbnMuZWwgPSBxdWVyeShlbCk7XG4gICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgLy8gcHJvcHMgbXVzdCBiZSBsaW5rZWQgaW4gcHJvcGVyIHNjb3BlIGlmIGluc2lkZSB2LWZvclxuICAgID8gY29tcGlsZUFuZExpbmtQcm9wcyh0aGlzLCBlbCwgcHJvcHMsIHRoaXMuX3Njb3BlKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGE7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhID0gZGF0YUZuID8gZGF0YUZuKCkgOiB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuJywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBpLCBrZXk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAvLyB0aGVyZSBhcmUgdHdvIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW4gcHJveHkgYSBkYXRhIGtleTpcbiAgICAgIC8vIDEuIGl0J3Mgbm90IGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3BcbiAgICAgIC8vIDIuIGl0J3MgcHJvdmlkZWQgdmlhIGEgaW5zdGFudGlhdGlvbiBvcHRpb24gQU5EIHRoZXJlIGFyZSBub1xuICAgICAgLy8gICAgdGVtcGxhdGUgcHJvcCBwcmVzZW50XG4gICAgICBpZiAoIXByb3BzIHx8ICFoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdEYXRhIGZpZWxkIFwiJyArIGtleSArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgJyArICdhcyBhIHByb3AuIFRvIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZSBmb3IgYSBwcm9wLCB1c2UgdGhlIFwiZGVmYXVsdFwiICcgKyAncHJvcCBvcHRpb247IGlmIHlvdSB3YW50IHRvIHBhc3MgcHJvcCB2YWx1ZXMgdG8gYW4gaW5zdGFudGlhdGlvbiAnICsgJ2NhbGwsIHVzZSB0aGUgXCJwcm9wc0RhdGFcIiBvcHRpb24uJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGluc3RhbmNlJ3MgJGRhdGEuIENhbGxlZCBpbiAkZGF0YSdzIHNldHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld0RhdGFcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHRoaXMuX2RhdGEgPSBuZXdEYXRhO1xuICAgIHZhciBrZXlzLCBrZXksIGk7XG4gICAgLy8gdW5wcm94eSBrZXlzIG5vdCBwcmVzZW50IGluIG5ldyBkYXRhXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG9sZERhdGEpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICAgIHRoaXMuX3VucHJveHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAgIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZSBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobmV3RGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIC8vIG5ldyBwcm9wZXJ0eVxuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbGREYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICBvYnNlcnZlKG5ld0RhdGEsIHRoaXMpO1xuICAgIHRoaXMuX2RpZ2VzdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhIHByb3BlcnR5LCBzbyB0aGF0XG4gICAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgLy8gbmVlZCB0byBzdG9yZSByZWYgdG8gc2VsZiBoZXJlXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgICAvLyBiZSBjYWxsZWQgYnkgY2hpbGQgc2NvcGVzIHZpYVxuICAgICAgLy8gcHJvdG90eXBlIGluaGVyaXRhbmNlLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcbiAgICAgICAgICBzZWxmLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5wcm94eSBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl93YXRjaGVyc1tpXS51cGRhdGUodHJ1ZSk7IC8vIHNoYWxsb3cgdXBkYXRlc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAgICogc3BlY2lhbCBnZXR0ZXIvc2V0dGVyc1xuICAgKi9cblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgVnVlLnByb3RvdHlwZS5faW5pdENvbXB1dGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgICB2YXIgZGVmID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcyk7XG4gICAgICAgICAgZGVmLnNldCA9IG5vb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmLmdldCA9IHVzZXJEZWYuZ2V0ID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2UgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHRoaXMpIDogYmluZCh1c2VyRGVmLmdldCwgdGhpcykgOiBub29wO1xuICAgICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldCA/IGJpbmQodXNlckRlZi5zZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoZ2V0dGVyLCBvd25lcikge1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIob3duZXIsIGdldHRlciwgbnVsbCwge1xuICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAgICogaW5zdGFuY2Ugc2luY2UgdGhleSBtaWdodCBiZSBwYXNzZWQgZG93biBhcyBhIHByb3AgdG9cbiAgICogY2hpbGQgY29tcG9uZW50cy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGJpbmQobWV0aG9kc1trZXldLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YTtcbiAgICBpZiAobWV0YXMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRhcykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh0aGlzLCBrZXksIG1ldGFzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGV2ZW50UkUgPSAvXnYtb246fF5ALztcblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIHdlIHB1bGwgaXQgZnJvbSB0aGVcbiAgICogaW5zdGFuY2UncyBtZXRob2RzIGJ5IG5hbWUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckb24nLCBvcHRpb25zLmV2ZW50cyk7XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyR3YXRjaCcsIG9wdGlvbnMud2F0Y2gpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB2LW9uIGV2ZW50cyBvbiBhIGNoaWxkIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh2bSwgZWwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgIHZhciBuYW1lLCB2YWx1ZSwgaGFuZGxlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZXZlbnRSRSwgJycpO1xuICAgICAgICAvLyBmb3JjZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGEgc3RhdGVtZW50IHNvIHRoYXRcbiAgICAgICAgLy8gaXQgYWx3YXlzIGR5bmFtaWNhbGx5IHJlc29sdmVzIHRoZSBtZXRob2QgdG8gY2FsbCAoIzI2NzApXG4gICAgICAgIC8vIGtpbmRhIHVnbHkgaGFjaywgYnV0IGRvZXMgdGhlIGpvYi5cbiAgICAgICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKGlzU2ltcGxlUGF0aCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnLmFwcGx5KHRoaXMsICRhcmd1bWVudHMpJztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gKHZtLl9zY29wZSB8fCB2bS5fY29udGV4dCkuJGV2YWwodmFsdWUsIHRydWUpO1xuICAgICAgICBoYW5kbGVyLl9mcm9tUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrcyBmb3Igb3B0aW9uIGV2ZW50cyBhbmQgd2F0Y2hlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tzKHZtLCBhY3Rpb24sIGhhc2gpIHtcbiAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgajtcbiAgICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgICBoYW5kbGVycyA9IGhhc2hba2V5XTtcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcmVnaXN0ZXIgYW4gZXZlbnQvd2F0Y2ggY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm1bYWN0aW9uXShrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzICYmIG1ldGhvZHNbaGFuZGxlcl07XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdVbmtub3duIG1ldGhvZDogXCInICsgaGFuZGxlciArICdcIiB3aGVuICcgKyAncmVnaXN0ZXJpbmcgY2FsbGJhY2sgZm9yICcgKyBhY3Rpb24gKyAnOiBcIicgKyBrZXkgKyAnXCIuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLmhhbmRsZXIsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCByZWN1cnNpdmUgYXR0YWNoZWQvZGV0YWNoZWQgY2FsbHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJG9uKCdob29rOmF0dGFjaGVkJywgb25BdHRhY2hlZCk7XG4gICAgdGhpcy4kb24oJ2hvb2s6ZGV0YWNoZWQnLCBvbkRldGFjaGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBhdHRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQXR0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbEF0dGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgYXR0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbEF0dGFjaChjaGlsZCkge1xuICAgIGlmICghY2hpbGQuX2lzQXR0YWNoZWQgJiYgaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGRldGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25EZXRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsRGV0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBkZXRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsRGV0YWNoKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYWxsIGhhbmRsZXJzIGZvciBhIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvb2tcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHRoaXMuJGVtaXQoJ3ByZS1ob29rOicgKyBob29rKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsaXRlcmFsXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhdHRyXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhcmdcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3JlZl1cbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbaW50ZXJwXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtoYXNPbmVUaW1lXVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge05vZGV9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGl2ZShkZXNjcmlwdG9yLCB2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5lbCA9IGVsO1xuICAvLyBjb3B5IGRlc2NyaXB0b3IgcHJvcGVydGllc1xuICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICB0aGlzLm5hbWUgPSBkZXNjcmlwdG9yLm5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvbjtcbiAgdGhpcy5hcmcgPSBkZXNjcmlwdG9yLmFyZztcbiAgdGhpcy5tb2RpZmllcnMgPSBkZXNjcmlwdG9yLm1vZGlmaWVycztcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzO1xuICB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsO1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAvLyBsaW5rIGNvbnRleHRcbiAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gIHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gIHRoaXMuX2ZyYWcgPSBmcmFnO1xuICAvLyBzdG9yZSBkaXJlY3RpdmVzIG9uIG5vZGUgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzID0gdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgfHwgW107XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGRpcmVjdGl2ZSwgbWl4aW4gZGVmaW5pdGlvbiBwcm9wZXJ0aWVzLFxuICogc2V0dXAgdGhlIHdhdGNoZXIsIGNhbGwgZGVmaW5pdGlvbiBiaW5kKCkgYW5kIHVwZGF0ZSgpXG4gKiBpZiBwcmVzZW50LlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcblxuICAvLyByZW1vdmUgYXR0cmlidXRlXG4gIGlmICgobmFtZSAhPT0gJ2Nsb2FrJyB8fCB0aGlzLnZtLl9pc0NvbXBpbGVkKSAmJiB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgdmFyIGF0dHIgPSBkZXNjcmlwdG9yLmF0dHIgfHwgJ3YtJyArIG5hbWU7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gIH1cblxuICAvLyBjb3B5IGRlZiBwcm9wZXJ0aWVzXG4gIHZhciBkZWYgPSBkZXNjcmlwdG9yLmRlZjtcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZjtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQodGhpcywgZGVmKTtcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKTtcblxuICAvLyBpbml0aWFsIGJpbmRcbiAgaWYgKHRoaXMuYmluZCkge1xuICAgIHRoaXMuYmluZCgpO1xuICB9XG4gIHRoaXMuX2JvdW5kID0gdHJ1ZTtcblxuICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgdGhpcy51cGRhdGUgJiYgdGhpcy51cGRhdGUoZGVzY3JpcHRvci5yYXcpO1xuICB9IGVsc2UgaWYgKCh0aGlzLmV4cHJlc3Npb24gfHwgdGhpcy5tb2RpZmllcnMpICYmICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiYgIXRoaXMuX2NoZWNrU3RhdGVtZW50KCkpIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpcztcbiAgICBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAoIWRpci5fbG9ja2VkKSB7XG4gICAgICAgICAgZGlyLnVwZGF0ZSh2YWwsIG9sZFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3AkMTtcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzID8gYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3MgPyBiaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodGhpcy52bSwgdGhpcy5leHByZXNzaW9uLCB0aGlzLl91cGRhdGUsIC8vIGNhbGxiYWNrXG4gICAge1xuICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAgdHdvV2F5OiB0aGlzLnR3b1dheSxcbiAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgIHByZVByb2Nlc3M6IHByZVByb2Nlc3MsXG4gICAgICBwb3N0UHJvY2VzczogcG9zdFByb2Nlc3MsXG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcbiAgICAvLyB2LW1vZGVsIHdpdGggaW5pdGFsIGlubGluZSB2YWx1ZSBuZWVkIHRvIHN5bmMgYmFjayB0b1xuICAgIC8vIG1vZGVsIGluc3RlYWQgb2YgdXBkYXRlIHRvIERPTSBvbiBpbml0LiBUaGV5IHdvdWxkXG4gICAgLy8gc2V0IHRoZSBhZnRlckJpbmQgaG9vayB0byBpbmRpY2F0ZSB0aGF0LlxuICAgIGlmICh0aGlzLmFmdGVyQmluZCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYWxsIHBhcmFtIGF0dHJpYnV0ZXMsIGUuZy4gdHJhY2stYnksXG4gKiB0cmFuc2l0aW9uLW1vZGUsIGV0Yy4uLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGFyYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGkgPSBwYXJhbXMubGVuZ3RoO1xuICB2YXIga2V5LCB2YWwsIG1hcHBlZEtleTtcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGh5cGhlbmF0ZShwYXJhbXNbaV0pO1xuICAgIG1hcHBlZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgdmFsID0gZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIC8vIGR5bmFtaWNcbiAgICAgIHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG1hcHBlZEtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhdGljXG4gICAgICB2YWwgPSBnZXRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJhbXNbbWFwcGVkS2V5XSA9IHZhbCA9PT0gJycgPyB0cnVlIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHVud2F0Y2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHdhdGNoKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgIHNlbGYucGFyYW1zW2tleV0gPSB2YWw7XG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhbCwgb2xkVmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgdXNlcjogZmFsc2VcbiAgfSk7KHRoaXMuX3BhcmFtVW53YXRjaEZucyB8fCAodGhpcy5fcGFyYW1VbndhdGNoRm5zID0gW10pKS5wdXNoKHVud2F0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGlyZWN0aXZlIGlzIGEgZnVuY3Rpb24gY2FsbGVyXG4gKiBhbmQgaWYgdGhlIGV4cHJlc3Npb24gaXMgYSBjYWxsYWJsZSBvbmUuIElmIGJvdGggdHJ1ZSxcbiAqIHdlIHdyYXAgdXAgdGhlIGV4cHJlc3Npb24gYW5kIHVzZSBpdCBhcyB0aGUgZXZlbnRcbiAqIGhhbmRsZXIuXG4gKlxuICogZS5nLiBvbi1jbGljaz1cImErK1wiXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb247XG4gIGlmIChleHByZXNzaW9uICYmIHRoaXMuYWNjZXB0U3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwcmVzc2lvbikpIHtcbiAgICB2YXIgZm4gPSBwYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbikuZ2V0O1xuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIHNjb3BlLiRldmVudCA9IGU7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgICBzY29wZS4kZXZlbnQgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0d28td2F5IGRpcmVjdGl2ZXNcbiAqIGUuZy4gdi1tb2RlbC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHVibGljXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMudHdvV2F5KSB7XG4gICAgdGhpcy5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fd2F0Y2hlci5zZXQodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKCdEaXJlY3RpdmUuc2V0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdHdvV2F5JyArICdkaXJlY3RpdmVzLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9sb2NrZWQgPSB0cnVlO1xuICBmbi5jYWxsKHNlbGYpO1xuICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fbG9ja2VkID0gZmFsc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdHRhY2hlcyBhIERPTSBldmVudCBsaXN0ZW5lclxuICogdG8gdGhlIGRpcmVjdGl2ZSBlbGVtZW50IGFuZCBhdXRvbWV0aWNhbGx5IHRlYXJzIGl0IGRvd25cbiAqIGR1cmluZyB1bmJpbmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgb24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpOyh0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSkucHVzaChbZXZlbnQsIGhhbmRsZXJdKTtcbn07XG5cbi8qKlxuICogVGVhcmRvd24gdGhlIHdhdGNoZXIgYW5kIGNhbGwgdW5iaW5kLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYm91bmQpIHtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgb2ZmKHRoaXMuZWwsIGxpc3RlbmVyc1tpXVswXSwgbGlzdGVuZXJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnM7XG4gICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgIGkgPSB1bndhdGNoRm5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdi1yZWYgZm9yIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlUmVmID0gZnVuY3Rpb24gKHJlbW92ZSkge1xuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWY7XG4gICAgaWYgKHJlZikge1xuICAgICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy5fY29udGV4dCkuJHJlZnM7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGlmIChyZWZzW3JlZl0gPT09IHRoaXMpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW3JlZl0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcbiAgICogYXMgd2VsbCAtIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGNhbGwgdGhlIGxpbmtlci5cbiAgICpcbiAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAvLyB0cmFuc2NsdWRlIGFuZCBpbml0IGVsZW1lbnRcbiAgICAvLyB0cmFuc2NsdWRlIGNhbiBwb3RlbnRpYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgY2FjaGVzIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgLy8gb24gdGhlIGNvbnRhaW5lciBub2RlIGFuZCByZXBsYWNlciBub2RlLlxuICAgIHZhciBvcmlnaW5hbCA9IGVsO1xuICAgIGVsID0gdHJhbnNjbHVkZShlbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdEVsZW1lbnQoZWwpO1xuXG4gICAgLy8gaGFuZGxlIHYtcHJlIG9uIHJvb3Qgbm9kZSAoIzIwMjYpXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gICAgLy8gY29udGFpbmVyIGF0dHJzIGFuZCBwcm9wcyBjYW4gYmUgZGlmZmVyZW50IGV2ZXJ5IHRpbWUuXG4gICAgdmFyIGNvbnRleHRPcHRpb25zID0gdGhpcy5fY29udGV4dCAmJiB0aGlzLl9jb250ZXh0LiRvcHRpb25zO1xuICAgIHZhciByb290TGlua2VyID0gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdCBkaXN0cmlidXRpb25cbiAgICByZXNvbHZlU2xvdHModGhpcywgb3B0aW9ucy5fY29udGVudCk7XG5cbiAgICAvLyBjb21waWxlIGFuZCBsaW5rIHRoZSByZXN0XG4gICAgdmFyIGNvbnRlbnRMaW5rRm47XG4gICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNvbXBvbmVudCBjb21waWxhdGlvbiBjYW4gYmUgY2FjaGVkXG4gICAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAob3B0aW9ucy5fbGlua2VyQ2FjaGFibGUpIHtcbiAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlcjtcbiAgICAgIGlmICghY29udGVudExpbmtGbikge1xuICAgICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlKGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaW5rIHBoYXNlXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gICAgdmFyIHJvb3RVbmxpbmtGbiA9IHJvb3RMaW5rZXIodGhpcywgZWwsIHRoaXMuX3Njb3BlKTtcbiAgICB2YXIgY29udGVudFVubGlua0ZuID0gY29udGVudExpbmtGbiA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpIDogY29tcGlsZShlbCwgb3B0aW9ucykodGhpcywgZWwpO1xuXG4gICAgLy8gcmVnaXN0ZXIgY29tcG9zaXRlIHVubGluayBmdW5jdGlvblxuICAgIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgICB0aGlzLl91bmxpbmtGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3RVbmxpbmtGbigpO1xuICAgICAgLy8gcGFzc2luZyBkZXN0cm95aW5nOiB0cnVlIHRvIGF2b2lkIHNlYXJjaGluZyBhbmRcbiAgICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgICBjb250ZW50VW5saW5rRm4odHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIGZpbmFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIHJlcGxhY2Uob3JpZ2luYWwsIGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBpbnN0YW5jZSBlbGVtZW50LiBDYWxsZWQgaW4gdGhlIHB1YmxpY1xuICAgKiAkbW91bnQoKSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gZWwubGFzdENoaWxkO1xuICAgICAgLy8gc2V0IHBlcnNpc3RlZCB0ZXh0IGFuY2hvcnMgdG8gZW1wdHlcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYmluZCBhIGRpcmVjdGl2ZSB0byBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9iaW5kRGlyID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdGhpcy5fZGlyZWN0aXZlcy5wdXNoKG5ldyBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdGhpcywgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVhcmRvd24gYW4gaW5zdGFuY2UsIHVub2JzZXJ2ZXMgdGhlIGRhdGEsIHVuYmluZCBhbGwgdGhlXG4gICAqIGRpcmVjdGl2ZXMsIHR1cm4gb2ZmIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIC0gd2hldGhlciB0byByZW1vdmUgdGhlIERPTSBub2RlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cCAtIGlmIHRydWUsIGRlZmVyIGNsZWFudXAgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc3Ryb3lSZWFkeTtcbiAgICB2YXIgcGVuZGluZ1JlbW92YWw7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ2xlYW51cCBzaG91bGQgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm95c2x5IGFzXG4gICAgLy8gY2FsbGJhY2sgb2YgdGhpcy4kcmVtb3ZlKCksIG9yIGlmIHJlbW92ZSBhbmQgZGVmZXJDbGVhbnVwIGFyZSBmYWxzZS5cbiAgICAvLyBJbiBhbnkgY2FzZSBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsbCBvdGhlciByZW1vdmluZywgdW5iaW5kaW5nIGFuZFxuICAgIC8vIHR1cm5pbmcgb2YgaXMgZG9uZVxuICAgIHZhciBjbGVhbnVwSWZQb3NzaWJsZSA9IGZ1bmN0aW9uIGNsZWFudXBJZlBvc3NpYmxlKCkge1xuICAgICAgaWYgKGRlc3Ryb3lSZWFkeSAmJiAhcGVuZGluZ1JlbW92YWwgJiYgIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICAgIGlmIChyZW1vdmUgJiYgdGhpcy4kZWwpIHtcbiAgICAgIHBlbmRpbmdSZW1vdmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlRGVzdHJveScpO1xuICAgIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIHZhciBpO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LiBvbmx5IG5lY2Vzc2FyeVxuICAgIC8vIGlmIHBhcmVudCBpcyBub3QgYmVpbmcgZGVzdHJveWVkIGFzIHdlbGwuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHBhcmVudC4kY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICAgIC8vIHVucmVnaXN0ZXIgcmVmIChyZW1vdmU6IHRydWUpXG4gICAgICB0aGlzLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgfVxuICAgIC8vIGRlc3Ryb3kgYWxsIGNoaWxkcmVuLlxuICAgIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy4kY2hpbGRyZW5baV0uJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gcHJvcHNcbiAgICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgICAgdGhpcy5fcHJvcHNVbmxpbmtGbigpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBhbGwgZGlyZWN0aXZlcy4gdGhpcyBhbHNvIHRlYXJzZG93biBhbGxcbiAgICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gICAgaWYgKHRoaXMuX3VubGlua0ZuKSB7XG4gICAgICB0aGlzLl91bmxpbmtGbigpO1xuICAgIH1cbiAgICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gc2VsZiBvbiAkZWxcbiAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgIHRoaXMuJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3lSZWFkeSA9IHRydWU7XG4gICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgdG8gZW5zdXJlIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGxlYXZlIHRyYW5zaXRpb24gaWYgdGhlcmVcbiAgICogaXMgYW55LlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gICAgLy8gZG8gaXQgaW4gY2xlYW51cCBzbyB0aGF0IHdlIGNhbiBjYWxsICRkZXN0cm95IHdpdGhcbiAgICAvLyBkZWZlciByaWdodCB3aGVuIGEgZnJhZ21lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuX19vYl9fKSB7XG4gICAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlcyB0byBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgLy8gaW5zdGFuY2VzLiBwcmVzZXJ2ZSByZWZlcmVuY2UgdG8gX2RhdGEgc28gdGhhdCBwcm94eVxuICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAvLyBoZXJlIGlzIHRoYXQgbXV0YXRpbmcgdGhlIGluc3RhbmNlIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gICAgLy8gbWF5IGFmZmVjdCB0aGUgc3RhdGUgb2Ygb3RoZXIgY29tcG9uZW50cyB0aGF0IGFyZSBzdGlsbFxuICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAvLyByZWFzb25hYmxlIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXNlciByYXRoZXIgdGhhblxuICAgIC8vIGFsd2F5cyB0aHJvd2luZyBhbiBlcnJvciBvbiB0aGVtLlxuICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy4kb2ZmKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1pc2NNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAgICogVXNpbmcgcGxhaW4gZm9yIGxvb3BzIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gICAqIHRoZSBnZXR0ZXIgb2YgYW55IHdhdGNoZXIgd2l0aCBmaWx0ZXJzIHNvIGl0IGlzIHZlcnlcbiAgICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd3JpdGVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSwgZmlsdGVycywgd3JpdGUpIHtcbiAgICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGs7XG4gICAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXJzW3dyaXRlID8gbCAtIGkgLSAxIDogaV07XG4gICAgICBmbiA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlci5uYW1lLCB0cnVlKTtcbiAgICAgIGlmICghZm4pIGNvbnRpbnVlO1xuICAgICAgZm4gPSB3cml0ZSA/IGZuLndyaXRlIDogZm4ucmVhZCB8fCBmbjtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdO1xuICAgICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMTtcbiAgICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gZmlsdGVyLmFyZ3MubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgYXJnID0gZmlsdGVyLmFyZ3Nbal07XG4gICAgICAgICAgYXJnc1tqICsgb2Zmc2V0XSA9IGFyZy5keW5hbWljID8gdGhpcy4kZ2V0KGFyZy52YWx1ZSkgOiBhcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZSBhIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGNvbXBvbmVudFxuICAgKiBpcyBkZWZpbmVkIG5vcm1hbGx5IG9yIHVzaW5nIGFuIGFzeW5jIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gICAqIHJlc29sdmVzIGFzeW5jaHJvbm91c2x5IGFuZCBjYWNoZXMgdGhlIHJlc29sdmVkXG4gICAqIGNvbnN0cnVjdG9yIG9uIHRoZSBmYWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgZmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmYWN0b3J5ID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvcnkgPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICAgIGlmICghZmFjdG9yeS5vcHRpb25zKSB7XG4gICAgICBpZiAoZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgICAvLyBjYWNoZWRcbiAgICAgICAgY2IoZmFjdG9yeS5yZXNvbHZlZCk7XG4gICAgICB9IGVsc2UgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgICAgIGZhY3RvcnkuY2FsbCh0aGlzLCBmdW5jdGlvbiByZXNvbHZlKHJlcykge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IFZ1ZS5leHRlbmQocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja3NcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50JyArICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJzogJyArIHZhbHVlIDogJycpICsgJy4gJyArIChyZWFzb24gPyAnXFxuUmVhc29uOiAnICsgcmVhc29uIDogJycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBjb21wb25lbnRcbiAgICAgIGNiKGZhY3RvcnkpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGZpbHRlclJFJDEgPSAvW158XVxcfFtefF0vO1xuXG5mdW5jdGlvbiBkYXRhQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uIChleHAsIGFzU3RhdGVtZW50KSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmIChhc1N0YXRlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5nZXQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAgICogZXhwcmVzc2lvbiBpbiBhbiBhc3NpZ25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwLCB0cnVlKTtcbiAgICBpZiAocmVzICYmIHJlcy5zZXQpIHtcbiAgICAgIHJlcy5zZXQuY2FsbCh0aGlzLCB0aGlzLCB2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgb24gdGhlIFZNXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbCh0aGlzLl9kYXRhLCBrZXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gICAqIHZhbHVlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGltbWVkaWF0ZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB1bndhdGNoRm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwYXJzZWQ7XG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUoZXhwT3JGbik7XG4gICAgICBleHBPckZuID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCB7XG4gICAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICAgIHN5bmM6IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgdXNlcjogIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VyICE9PSBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhIHRleHQgZGlyZWN0aXZlLCBpbmNsdWRpbmcgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZXZhbCA9IGZ1bmN0aW9uICh0ZXh0LCBhc1N0YXRlbWVudCkge1xuICAgIC8vIGNoZWNrIGZvciBmaWx0ZXJzLlxuICAgIGlmIChmaWx0ZXJSRSQxLnRlc3QodGV4dCkpIHtcbiAgICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZSh0ZXh0KTtcbiAgICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgLy8gZm9yIHBpcGVzIGluc2lkZSBzdHJpbmdzLCBzbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IGdldCBhbnkgZmlsdGVycyBoZXJlXG4gICAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudCk7XG4gICAgICByZXR1cm4gZGlyLmZpbHRlcnMgPyB0aGlzLl9hcHBseUZpbHRlcnModmFsLCBudWxsLCBkaXIuZmlsdGVycykgOiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGZpbHRlclxuICAgICAgcmV0dXJuIHRoaXMuJGdldCh0ZXh0LCBhc1N0YXRlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQodGV4dCk7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLnRhZyA/IHZtLiRldmFsKHRva2VuLnZhbHVlKSA6IHRva2VuLnZhbHVlO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgaW5zdGFuY2UgZGF0YSBhcyBhIHBsYWluIEpTIG9iamVjdFxuICAgKiBzbyB0aGF0IGl0IGlzIGVhc2llciB0byBpbnNwZWN0IGluIGNvbnNvbGUuXG4gICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbG9nID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZGF0YSA9IHBhdGggPyBnZXRQYXRoKHRoaXMuX2RhdGEsIHBhdGgpIDogdGhpcy5fZGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGF0YSA9IGNsZWFuKGRhdGEpO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICAgIGlmICghcGF0aCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wcykge1xuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAgICogb2JqZWN0IGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBvbi1pbnN0YW5jZSBuZXh0VGljay4gVGhlIGNhbGxiYWNrIGlzXG4gICAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gICAqIG1vZHVsZXMgaGF2aW5nIHRvIHJlbHkgb24gdGhlIGdsb2JhbCBWdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgbmV4dFRpY2soZm4sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGFwcGVuZCwgYXBwZW5kV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcHJlcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5maXJzdENoaWxkLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYmVmb3JlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYmVmb3JlID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYmVmb3JlV2l0aENiLCBiZWZvcmVXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0Lm5leHRTaWJsaW5nLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpbnN0YW5jZSBmcm9tIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcmVtb3ZlID0gZnVuY3Rpb24gKGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIHZhciBpbkRvY3VtZW50ID0gdGhpcy5faXNBdHRhY2hlZCAmJiBpbkRvYyh0aGlzLiRlbCk7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBpbiBkb2N1bWVudCwgbm8gbmVlZCB0byBjaGVja1xuICAgIC8vIGZvciB0cmFuc2l0aW9uc1xuICAgIGlmICghaW5Eb2N1bWVudCkgd2l0aFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlYWxDYiA9IGZ1bmN0aW9uIHJlYWxDYigpIHtcbiAgICAgIGlmIChpbkRvY3VtZW50KSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgICByZW1vdmVOb2RlUmFuZ2UodGhpcy5fZnJhZ21lbnRTdGFydCwgdGhpcy5fZnJhZ21lbnRFbmQsIHRoaXMsIHRoaXMuX2ZyYWdtZW50LCByZWFsQ2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgPyByZW1vdmVXaXRoQ2IgOiByZW1vdmVXaXRoVHJhbnNpdGlvbjtcbiAgICAgIG9wKHRoaXMuJGVsLCB0aGlzLCByZWFsQ2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMiAtIG9wIGZvciB0cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcmV0dXJuIHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluc2VydCh2bSwgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIG9wMSwgb3AyKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFpbkRvYyh0YXJnZXQpO1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSB8fCB0YXJnZXRJc0RldGFjaGVkID8gb3AxIDogb3AyO1xuICAgIHZhciBzaG91bGRDYWxsSG9vayA9ICF0YXJnZXRJc0RldGFjaGVkICYmICF2bS5faXNBdHRhY2hlZCAmJiAhaW5Eb2Modm0uJGVsKTtcbiAgICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICAgIG1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvcChub2RlLCB0YXJnZXQsIHZtKTtcbiAgICAgIH0pO1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aodm0uJGVsLCB0YXJnZXQsIHZtLCBjYik7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgICAgdm0uX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHNlbGVjdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBlbmQoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmVmb3JlV2l0aENiKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlV2l0aENiKGVsLCB2bSwgY2IpIHtcbiAgICByZW1vdmUoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudHNBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICh0aGlzLl9ldmVudHNbZXZlbnRdIHx8ICh0aGlzLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHNlbGYuJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB0aGlzLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgY2JzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICBmb3IgKGV2ZW50IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKTtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLTEpO1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnQgb24gc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBzaG91bGRQcm9wYWdhdGVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpc1NvdXJjZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZyc7XG4gICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gaXNTb3VyY2UgfHwgIWNicztcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBoYWNreSBzb2x1dGlvbiB0byB0aGUgcXVlc3Rpb24gcmFpc2VkXG4gICAgICAvLyBpbiAjMjEwMjogZm9yIGFuIGlubGluZSBjb21wb25lbnQgbGlzdGVuZXIgbGlrZSA8Y29tcCBAdGVzdD1cImRvVGhpc1wiPixcbiAgICAgIC8vIHRoZSBwcm9wYWdhdGlvbiBoYW5kbGluZyBpcyBzb21ld2hhdCBicm9rZW4uIFRoZXJlZm9yZSB3ZVxuICAgICAgLy8gbmVlZCB0byB0cmVhdCB0aGVzZSBpbmxpbmUgY2FsbGJhY2tzIGRpZmZlcmVudGx5LlxuICAgICAgdmFyIGhhc1BhcmVudENicyA9IGlzU291cmNlICYmIGNicy5zb21lKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2IuX2Zyb21QYXJlbnQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNQYXJlbnRDYnMpIHtcbiAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2IgPSBjYnNbaV07XG4gICAgICAgIHZhciByZXMgPSBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSAmJiAoIWhhc1BhcmVudENicyB8fCBjYi5fZnJvbVBhcmVudCkpIHtcbiAgICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRQcm9wYWdhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGJyb2FkY2FzdCBhbiBldmVudCB0byBhbGwgY2hpbGRyZW4gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIC8vIGlmIG5vIGNoaWxkIGhhcyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50LFxuICAgIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c0NvdW50W2V2ZW50XSkgcmV0dXJuO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGNoaWxkcmVuO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGlmIChpc1NvdXJjZSkge1xuICAgICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAgIC8vIG9uIGNoaWxkcmVuXG4gICAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBjaGlsZC4kZW1pdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICBpZiAoc2hvdWxkUHJvcGFnYXRlKSB7XG4gICAgICAgIGNoaWxkLiRicm9hZGNhc3QuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcHJvcGFnYXRlIGFuIGV2ZW50IHVwIHRoZSBwYXJlbnQgY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0gey4uLip9IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRpc3BhdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IHRoaXMuJGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXNob3VsZFByb3BhZ2F0ZSkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAvLyBvbiBwYXJlbnRzXG4gICAgYXJnc1swXSA9IHsgbmFtZTogZXZlbnQsIHNvdXJjZTogdGhpcyB9O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHBhcmVudC4kZW1pdC5hcHBseShwYXJlbnQsIGFyZ3MpO1xuICAgICAgcGFyZW50ID0gc2hvdWxkUHJvcGFnYXRlID8gcGFyZW50LiRwYXJlbnQgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaXN0ZW5lciBjb3VudHMgb24gYWxsIHBhcmVudHMuXG4gICAqIFRoaXMgYm9va2tlZXBpbmcgYWxsb3dzICRicm9hZGNhc3QgdG8gcmV0dXJuIGVhcmx5IHdoZW5cbiAgICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAgICovXG5cbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBmdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50KHZtLCBldmVudCwgY291bnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAvLyBob29rcyBkbyBub3QgZ2V0IGJyb2FkY2FzdGVkIHNvIG5vIG5lZWRcbiAgICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICAgIGlmICghcGFyZW50IHx8ICFjb3VudCB8fCBob29rUkUudGVzdChldmVudCkpIHJldHVybjtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSA9IChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICAgKiBwcm9jZXNzLiBUaGUgcGFzc2VkIGluIGBlbGAgY2FuIGJlIGEgc2VsZWN0b3Igc3RyaW5nLCBhblxuICAgKiBleGlzdGluZyBFbGVtZW50LCBvciBhIERvY3VtZW50RnJhZ21lbnQgKGZvciBibG9ja1xuICAgKiBpbnN0YW5jZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxzdHJpbmd9IGVsXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCckbW91bnQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwgPSBxdWVyeShlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgdGhpcy5fY29tcGlsZShlbCk7XG4gICAgdGhpcy5faW5pdERPTUhvb2tzKCk7XG4gICAgaWYgKGluRG9jKHRoaXMuJGVsKSkge1xuICAgICAgdGhpcy5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgICByZWFkeS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRvbmNlKCdob29rOmF0dGFjaGVkJywgcmVhZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWFyayBhbiBpbnN0YW5jZSBhcyByZWFkeS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ3JlYWR5Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGluc3RhbmNlLCBzaW1wbHkgZGVsZWdhdGUgdG8gdGhlIGludGVybmFsXG4gICAqIF9kZXN0cm95LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgdGhpcy5fZGVzdHJveShyZW1vdmUsIGRlZmVyQ2xlYW51cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICAgKiBkZWNvbXBpbGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICByZXR1cm4gY29tcGlsZShlbCwgdGhpcy4kb3B0aW9ucywgdHJ1ZSkodGhpcywgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgJGBcbiAqIC0gaW50ZXJuYWwgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGBfYFxuICogLSBub24tcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgYXNzdW1lZCB0byBiZSBwcm94aWVkIHVzZXJcbiAqICAgZGF0YS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG4vLyBpbnN0YWxsIGludGVybmFsc1xuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbm1pc2NNaXhpbihWdWUpO1xuXG4vLyBpbnN0YWxsIGluc3RhbmNlIEFQSXNcbmRhdGFBUEkoVnVlKTtcbmRvbUFQSShWdWUpO1xuZXZlbnRzQVBJKFZ1ZSk7XG5saWZlY3ljbGVBUEkoVnVlKTtcblxudmFyIHNsb3QgPSB7XG5cbiAgcHJpb3JpdHk6IFNMT1QsXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyB0aGlzIHdhcyByZXNvbHZlZCBkdXJpbmcgY29tcG9uZW50IHRyYW5zY2x1c2lvblxuICAgIHZhciBuYW1lID0gdGhpcy5wYXJhbXMubmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnZtLl9zbG90Q29udGVudHMgJiYgdGhpcy52bS5fc2xvdENvbnRlbnRzW25hbWVdO1xuICAgIGlmICghY29udGVudCB8fCAhY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21waWxlKGNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLCB0aGlzLnZtLl9jb250ZXh0LCB0aGlzLnZtKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KSB7XG4gICAgaWYgKGNvbnRlbnQgJiYgY29udGV4dCkge1xuICAgICAgaWYgKHRoaXMuZWwuaGFzQ2hpbGROb2RlcygpICYmIGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICAvLyBpZiB0aGUgaW5zZXJ0ZWQgc2xvdCBoYXMgdi1pZlxuICAgICAgICAvLyBpbmplY3QgZmFsbGJhY2sgY29udGVudCBhcyB0aGUgdi1lbHNlXG4gICAgICAgIHZhciBlbHNlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBlbHNlQmxvY2suc2V0QXR0cmlidXRlKCd2LWVsc2UnLCAnJyk7XG4gICAgICAgIGVsc2VCbG9jay5pbm5lckhUTUwgPSB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgICAgLy8gdGhlIGVsc2UgYmxvY2sgc2hvdWxkIGJlIGNvbXBpbGVkIGluIGNoaWxkIHNjb3BlXG4gICAgICAgIGVsc2VCbG9jay5fY29udGV4dCA9IHRoaXMudm07XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxzZUJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHZhciBzY29wZSA9IGhvc3QgPyBob3N0Ll9zY29wZSA6IHRoaXMuX3Njb3BlO1xuICAgICAgdGhpcy51bmxpbmsgPSBjb250ZXh0LiRjb21waWxlKGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSh0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgIHRoaXMuY29tcGlsZShleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSk7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBhcnRpYWwgPSB7XG5cbiAgcHJpb3JpdHk6IFBBUlRJQUwsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICAvLyB3YXRjaCBjaGFuZ2VzIHRvIG5hbWUgZm9yIGR5bmFtaWMgcGFydGlhbHNcbiAgcGFyYW1XYXRjaGVyczoge1xuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmluc2VydCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtcGFydGlhbCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMucGFyYW1zLm5hbWUpO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGlkKSB7XG4gICAgdmFyIHBhcnRpYWwgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQsIHRydWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHBhcnRpYWwpO1xuICAgICAgdklmLmluc2VydC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsZW1lbnREaXJlY3RpdmVzID0ge1xuICBzbG90OiBzbG90LFxuICBwYXJ0aWFsOiBwYXJ0aWFsXG59O1xuXG52YXIgY29udmVydEFycmF5ID0gdkZvci5fcG9zdFByb2Nlc3M7XG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAqL1xuXG5mdW5jdGlvbiBsaW1pdEJ5KGFyciwgbiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgbiA9IHRvTnVtYmVyKG4pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikgOiBhcnI7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxpbWl0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJCeShhcnIsIHNlYXJjaCwgZGVsaW1pdGVyKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoc2VhcmNoKTtcbiAgfVxuICAvLyBjYXN0IHRvIGxvd2VyY2FzZSBzdHJpbmdcbiAgc2VhcmNoID0gKCcnICsgc2VhcmNoKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMjtcbiAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gIHZhciBrZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdG9BcnJheShhcmd1bWVudHMsIG4pKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaXRlbSwga2V5LCB2YWwsIGo7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgdmFsID0gaXRlbSAmJiBpdGVtLiR2YWx1ZSB8fCBpdGVtO1xuICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaikge1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoa2V5ID09PSAnJGtleScgJiYgY29udGFpbnMoaXRlbS4ka2V5LCBzZWFyY2gpIHx8IGNvbnRhaW5zKGdldFBhdGgodmFsLCBrZXkpLCBzZWFyY2gpKSB7XG4gICAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFN0cmluZz58RnVuY3Rpb259IC4uLnNvcnRLZXlzXG4gKiBAcGFyYW0ge051bWJlcn0gW29yZGVyXVxuICovXG5cbmZ1bmN0aW9uIG9yZGVyQnkoYXJyKSB7XG4gIHZhciBjb21wYXJhdG9yID0gbnVsbDtcbiAgdmFyIHNvcnRLZXlzID0gdW5kZWZpbmVkO1xuICBhcnIgPSBjb252ZXJ0QXJyYXkoYXJyKTtcblxuICAvLyBkZXRlcm1pbmUgb3JkZXIgKGxhc3QgYXJndW1lbnQpXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICB2YXIgb3JkZXIgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XG4gICAgb3JkZXIgPSBvcmRlciA8IDAgPyAtMSA6IDE7XG4gICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3Muc2xpY2UoMCwgLTEpIDogYXJncztcbiAgfSBlbHNlIHtcbiAgICBvcmRlciA9IDE7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgc29ydEtleXMgJiBjb21wYXJhdG9yXG4gIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGlmICghZmlyc3RBcmcpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGN1c3RvbSBjb21wYXJhdG9yXG4gICAgY29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZmlyc3RBcmcoYSwgYikgKiBvcmRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHN0cmluZyBrZXlzLiBmbGF0dGVuIGZpcnN0XG4gICAgc29ydEtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIsIGkpIHtcbiAgICAgIGkgPSBpIHx8IDA7XG4gICAgICByZXR1cm4gaSA+PSBzb3J0S2V5cy5sZW5ndGggLSAxID8gYmFzZUNvbXBhcmUoYSwgYiwgaSkgOiBiYXNlQ29tcGFyZShhLCBiLCBpKSB8fCBjb21wYXJhdG9yKGEsIGIsIGkgKyAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmUoYSwgYiwgc29ydEtleUluZGV4KSB7XG4gICAgdmFyIHNvcnRLZXkgPSBzb3J0S2V5c1tzb3J0S2V5SW5kZXhdO1xuICAgIGlmIChzb3J0S2V5KSB7XG4gICAgICBpZiAoc29ydEtleSAhPT0gJyRrZXknKSB7XG4gICAgICAgIGlmIChpc09iamVjdChhKSAmJiAnJHZhbHVlJyBpbiBhKSBhID0gYS4kdmFsdWU7XG4gICAgICAgIGlmIChpc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWU7XG4gICAgICB9XG4gICAgICBhID0gaXNPYmplY3QoYSkgPyBnZXRQYXRoKGEsIHNvcnRLZXkpIDogYTtcbiAgICAgIGIgPSBpc09iamVjdChiKSA/IGdldFBhdGgoYiwgc29ydEtleSkgOiBiO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IG9yZGVyIDogLW9yZGVyO1xuICB9XG5cbiAgLy8gc29ydCBvbiBhIGNvcHkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgYXJyYXlcbiAgcmV0dXJuIGFyci5zbGljZSgpLnNvcnQoY29tcGFyYXRvcik7XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnRhaW4gaGVscGVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcbiAqL1xuXG5mdW5jdGlvbiBjb250YWlucyh2YWwsIHNlYXJjaCkge1xuICB2YXIgaTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtrZXlzW2ldXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtpXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaCkgPiAtMTtcbiAgfVxufVxuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2c7XG5cbi8vIGFzc2V0IGNvbGxlY3Rpb25zIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuXG52YXIgZmlsdGVycyA9IHtcblxuICBvcmRlckJ5OiBvcmRlckJ5LFxuICBmaWx0ZXJCeTogZmlsdGVyQnksXG4gIGxpbWl0Qnk6IGxpbWl0QnksXG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICAgKi9cblxuICBqc29uOiB7XG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZCh2YWx1ZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gaW5kZW50IDogMik7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FiYydcbiAgICovXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdhYmMnID0+ICdBQkMnXG4gICAqL1xuXG4gIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdBYkMnID0+ICdhYmMnXG4gICAqL1xuXG4gIGxvd2VyY2FzZTogZnVuY3Rpb24gbG93ZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIDEyMzQ1ID0+ICQxMiwzNDUuMDBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxzIERlY2ltYWwgcGxhY2VzXG4gICAqL1xuXG4gIGN1cnJlbmN5OiBmdW5jdGlvbiBjdXJyZW5jeSh2YWx1ZSwgX2N1cnJlbmN5LCBkZWNpbWFscykge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgX2N1cnJlbmN5ID0gX2N1cnJlbmN5ICE9IG51bGwgPyBfY3VycmVuY3kgOiAnJCc7XG4gICAgZGVjaW1hbHMgPSBkZWNpbWFscyAhPSBudWxsID8gZGVjaW1hbHMgOiAyO1xuICAgIHZhciBzdHJpbmdpZmllZCA9IE1hdGguYWJzKHZhbHVlKS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICB2YXIgX2ludCA9IGRlY2ltYWxzID8gc3RyaW5naWZpZWQuc2xpY2UoMCwgLTEgLSBkZWNpbWFscykgOiBzdHJpbmdpZmllZDtcbiAgICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgMztcbiAgICB2YXIgaGVhZCA9IGkgPiAwID8gX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykgOiAnJztcbiAgICB2YXIgX2Zsb2F0ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgtMSAtIGRlY2ltYWxzKSA6ICcnO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgcmV0dXJuIHNpZ24gKyBfY3VycmVuY3kgKyBoZWFkICsgX2ludC5zbGljZShpKS5yZXBsYWNlKGRpZ2l0c1JFLCAnJDEsJykgKyBfZmxvYXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdpdGVtJyA9PiAnaXRlbXMnXG4gICAqXG4gICAqIEBwYXJhbXNcbiAgICogIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0b1xuICAgKiAgdGhlIHNpbmdsZSwgZG91YmxlLCB0cmlwbGUgLi4uIGZvcm1zIG9mIHRoZSB3b3JkIHRvXG4gICAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICAgKiAgZXhjZWVkcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcmdzLCBpdCB3aWxsIHVzZSB0aGUgbGFzdFxuICAgKiAgZW50cnkgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiAgZS5nLiBbJ3NpbmdsZScsICdkb3VibGUnLCAndHJpcGxlJywgJ211bHRpcGxlJ11cbiAgICovXG5cbiAgcGx1cmFsaXplOiBmdW5jdGlvbiBwbHVyYWxpemUodmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlICUgMTAgLSAxO1xuICAgICAgcmV0dXJuIGluZGV4IGluIGFyZ3MgPyBhcmdzW2luZGV4XSA6IGFyZ3NbbGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcmdzWzBdICsgKHZhbHVlID09PSAxID8gJycgOiAncycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGhhbmRsZXIsIGRlbGF5KSB7XG4gICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgaWYgKCFkZWxheSkge1xuICAgICAgZGVsYXkgPSAzMDA7XG4gICAgfVxuICAgIHJldHVybiBfZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFsQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFZ1ZSBhbmQgZXZlcnkgY29uc3RydWN0b3IgdGhhdCBleHRlbmRzIFZ1ZSBoYXMgYW5cbiAgICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICAgKiBjb21waWxhdGlvbiBzdGVwcyBhcyBgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zYC5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICAgKiBWdWUgaW5zdGFuY2UuXG4gICAqL1xuXG4gIFZ1ZS5vcHRpb25zID0ge1xuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgZWxlbWVudERpcmVjdGl2ZXM6IGVsZW1lbnREaXJlY3RpdmVzLFxuICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgdHJhbnNpdGlvbnM6IHt9LFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIHBhcnRpYWxzOiB7fSxcbiAgICByZXBsYWNlOiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gICAqL1xuXG4gIFZ1ZS51dGlsID0gdXRpbDtcbiAgVnVlLmNvbmZpZyA9IGNvbmZpZztcbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlWydkZWxldGUnXSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzYWdlIC8gcGx1Z2luc1xuICAgKi9cblxuICBWdWUuY29tcGlsZXIgPSBjb21waWxlcjtcbiAgVnVlLkZyYWdtZW50RmFjdG9yeSA9IEZyYWdtZW50RmFjdG9yeTtcbiAgVnVlLmludGVybmFsRGlyZWN0aXZlcyA9IGludGVybmFsRGlyZWN0aXZlcztcbiAgVnVlLnBhcnNlcnMgPSB7XG4gICAgcGF0aDogcGF0aCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBkaXJlY3RpdmU6IGRpcmVjdGl2ZSxcbiAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gIH07XG5cbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cblxuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gICAqL1xuXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIGlzRmlyc3RFeHRlbmQgPSBTdXBlci5jaWQgPT09IDA7XG4gICAgaWYgKGlzRmlyc3RFeHRlbmQgJiYgZXh0ZW5kT3B0aW9ucy5fQ3Rvcikge1xuICAgICAgcmV0dXJuIGV4dGVuZE9wdGlvbnMuX0N0b3I7XG4gICAgfVxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybignSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgKyAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjYXRlcnMgYW5kIHRoZSBoeXBoZW4uJyk7XG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50Jyk7XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvblxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc0ZpcnN0RXh0ZW5kKSB7XG4gICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgIH1cbiAgICByZXR1cm4gU3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN1Yi1jbGFzcyBjb25zdHJ1Y3RvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBuYW1lLiBUaGlzIGdpdmVzIHVzIG11Y2ggbmljZXIgb3V0cHV0IHdoZW5cbiAgICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhuYW1lKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24gJyArIGNsYXNzaWZ5KG5hbWUpICsgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nKSgpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBQbHVnaW4gc3lzdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cbiAgICovXG5cbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gICAqIG9wdGlvbnMuXG4gICAqL1xuXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIFZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFZ1ZS5vcHRpb25zLCBtaXhpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogc2lnbmF0dXJlOlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHsqfSBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgKGNvbW1vblRhZ1JFLnRlc3QoaWQpIHx8IHJlc2VydmVkVGFnUkUudGVzdChpZCkpKSB7XG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgaWYgKCFkZWZpbml0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZpbml0aW9uID0gVnVlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZXhwb3NlIGludGVybmFsIHRyYW5zaXRpb24gQVBJXG4gIGV4dGVuZChWdWUudHJhbnNpdGlvbiwgdHJhbnNpdGlvbik7XG59XG5cbmluc3RhbGxHbG9iYWxBUEkoVnVlKTtcblxuVnVlLnZlcnNpb24gPSAnMS4wLjI2JztcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluQnJvd3NlciAmJiAvQ2hyb21lXFwvXFxkKy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgIH1cbiAgfVxufSwgMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS8xLjAuMjYvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjEuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA3LTA3VDIxOjQ0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMS4wXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjBcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTAxLTA0XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczpcblx0Ly8gSUU6ICpbZGlzYWJsZWRdOm5vdChidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBvcHRncm91cCwgb3B0aW9uLCBtZW51aXRlbSwgZmllbGRzZXQpXG5cdC8vIG5vdCBJRTogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIENoZWNrIGZvcm0gZWxlbWVudHMgYW5kIG9wdGlvbiBlbGVtZW50cyBmb3IgZXhwbGljaXQgZGlzYWJsaW5nXG5cdFx0cmV0dXJuIFwibGFiZWxcIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cdFx0XHRcImZvcm1cIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdC8vIENoZWNrIG5vbi1kaXNhYmxlZCBmb3JtIGVsZW1lbnRzIGZvciBmaWVsZHNldFtkaXNhYmxlZF0gYW5jZXN0b3JzXG5cdFx0XHRcImZvcm1cIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICYmIChcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2LTExK1xuXHRcdFx0XHQvLyBBbmNlc3RyeSBpcyBjb3ZlcmVkIGZvciB1c1xuXHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBhc3N1bWUgYW55IG5vbi08b3B0aW9uPiB1bmRlciBmaWVsZHNldFtkaXNhYmxlZF0gaXMgZGlzYWJsZWRcblx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0KFwibGFiZWxcIiBpbiBlbGVtIHx8ICFkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkpICE9PSBkaXNhYmxlZFxuXHRcdFx0KTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdFx0cmVzb2x2ZS5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8gSlNPTi5wYXJzZSggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApLFxuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBpbiBGRiBidXQgZG9uJ3QgYmxvY2sgSUUgcmFkaW8gZXZlbnRzICgjMzg2MSwgZ2gtMjM0Mylcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmXG5cdFx0XHQoIGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiB8fCBpc05hTiggZXZlbnQuYnV0dG9uICkgfHwgZXZlbnQuYnV0dG9uIDwgMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWwsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdHZhbCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbIG5hbWUgXTtcblx0fVxuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gcmFmKCkge1xuXHRpZiAoIHRpbWVySWQgKSB7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICk7XG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3R3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZiBvciBpZiBkb2N1bWVudCBpcyBoaWRkZW5cblx0aWYgKCBqUXVlcnkuZngub2ZmIHx8IGRvY3VtZW50LmhpZGRlbiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/XG5cdFx0XHRcdGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID9cblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApIDpcblx0XHRcdHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSApIHtcblx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVySWQgKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR9XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2csXG5cdHJzcGFjZXMgPSAvW1xceDIwXFx0XFxyXFxuXFxmXSsvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKSA6XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICkucmVwbGFjZSggcnNwYWNlcywgXCIgXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1bmNhY2hlZCB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCJcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHQvLyBNYWtlIHN1cmUgZWxlbWVudCBpcyBub3QgaGlkZGVuIChkaXNwbGF5OiBub25lKVxuXHRcdGlmICggcmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCApIHtcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXEFwcC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wNjkyNTEwYi9BcHAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxufVxcblxcbmRpdi5tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL0FwcC52dWU/MzRjMDhlN2FcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrSkE7SUFDQSxVQUFBO0NBQ0E7O0FBRUE7O0lBRUEsYUFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLG9DQUFBO0lBQ0EsU0FBQTtJQUNBLFFBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0EsbUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiQXBwLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgICAgIGJhY2tncm91bmRcXG4gICAgICAgIG1lbnUtYmFyKHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIix2LWJpbmQ6bm90aWNlPVxcXCJub3RpY2VcXFwiLHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIilcXG4gICAgICAgIGJldC1hbmQtYm9udXModi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiLHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCIpXFxuICAgICAgICBwbGF5LXBhbmVsKHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIix2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIix2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiLHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiLHYtYmluZDpsb2NrbW9uZXk9XFxcImxvY2ttb25leVxcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIix2LWJpbmQ6bG90dGVyeW51bS5zeW5jPVxcXCJsb3R0ZXJ5bnVtXFxcIix2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVxcXCJjb3VudERvd25cXFwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cXFwiY291bnROdW1cXFwiKVxcbiAgICAgICAgc3RhdGUodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIilcXG4gICAgICAgIC8vLSBiZXQtbXVsdGlwbGVcXG4gICAgICAgIG1lc3NhZ2Uodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiLHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIpXFxuICAgICAgICBtb2RhbC5tb2RhbCh2LWlmPVxcXCJlcnJvclxcXCIpXFxuICAgICAgICB0aXAtbW9kYWxcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuaW1wb3J0IEJhY2tncm91bmQgZnJvbSAnLi9jb21wb25lbnRzL0JhY2tncm91bmQudnVlJ1xcbmltcG9ydCBNZW51QmFyIGZyb20gJy4vY29tcG9uZW50cy9NZW51QmFyLnZ1ZSdcXG5pbXBvcnQgQmV0QW5kQm9udXMgZnJvbSAnLi9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSdcXG5pbXBvcnQgUGxheVBhbmVsIGZyb20gJy4vY29tcG9uZW50cy9QbGF5UGFuZWwudnVlJ1xcbmltcG9ydCBTdGF0ZSBmcm9tICcuL2NvbXBvbmVudHMvU3RhdGUudnVlJ1xcbmltcG9ydCBCZXRNdWx0aXBsZSBmcm9tICcuL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlJ1xcbmltcG9ydCBNZXNzYWdlIGZyb20gJy4vY29tcG9uZW50cy9NZXNzYWdlLnZ1ZSdcXG5pbXBvcnQgZ2FtZURhdGEgZnJvbSAnLi9kYXRhL2RhdGEnIC8vICDliqDovb3mqKHmnb/mlbDmja5cXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogW10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgbGV0IHRoYXQgPSB0aGlzXFxuICAgICAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxcbiAgICAgICAgICAgIHRoYXQuc2NyZWVuU2l6ZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuaW5pdCgpXFxuICAgIH0sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHVzZXJCZXQ6IHtcXG4gICAgICAgICAgICAgICAgYmV0bW9uZXk6IDEwMDAgLy/pu5jorqTkuIvms6jph5Hpop3kuLoxMDAwXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBnYW1lRGF0YTogZ2FtZURhdGEsXFxuICAgICAgICAgICAgbG90dGVyeW51bTogeyAvL+W8gOWllue7k+aenFxcbiAgICAgICAgICAgICAgICBpZDogJycsXFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogMCxcXG4gICAgICAgICAgICAgICAgbG90dGVyeW51bXM6ICcnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjb3VudERvd246IDMwMCwgLy8g5YCS6K6h5pe256eS5pWwXFxuICAgICAgICAgICAgY291bnROdW06IDMwMCwgLy/lvIDlpZbml7bpl7Tpl7TpmpQg6buY6K6kM+WIhumSn1xcbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcXG4gICAgICAgICAgICBiZXRzOiBbXSwgLy8g5LiL5rOo6ZuG5ZCI77yM5Y+v5Lul5Y2V5qyh5LiL5aSa5rOoXFxuICAgICAgICAgICAgbm90aWNlOiByZXF1aXJlKCcuL2RhdGEvbm90aWNlJyksXFxuICAgICAgICAgICAgdXNlcmluZm86IHJlcXVpcmUoJy4vZGF0YS9zaW5nbGV1c2VyJyksXFxuICAgICAgICAgICAgc3RhZ2VTaXplOiB7IC8vIOaVtOS9k+eUu+W4g+Wkp+WwjyzmiYDmnInlj5jljJbnu4Tku7blho3mrKHln7rnoYDkuIrkuZjku6XmlL7lpKflgI3njodcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDY0MCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDA4XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzY3JlZW5TaXplOiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIGluaXQoKSB7XFxuICAgICAgICAgICAgLy8g5Yid5aeL5YyW6K+75Y+W5pWw5o2uXFxuXFxuICAgICAgICAgICAgLy8g6K+75Y+W5byA5aWW5pWw5o2uXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKHJlcyA9PiB0aGlzLmxvdHRlcnludW0gPSByZXMuZGF0YSlcXG4gICAgICAgICAgICB0aGlzLmdldFVzZXJJbmZvQnlOZXQoKVxcbiAgICAgICAgICAgICAgICAvLyDojrflj5blhazlkYrmlbDmja5cXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdnZXRMYXN0Tm90aWNlJylcXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93KCkge30sXFxuICAgICAgICBnZXRVc2VySW5mb0J5TmV0KCkgeyAvL+S7jue9kee7nOiOt+WPlnVzZXLkv6Hmga9cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyQ29kZUZyb21OZXQoUmVxdWVzdExpc3QuZ2V0Q29kZSgpKS50aGVuKHJlcyA9PiB7XFxuICAgICAgICAgICAgICAgIC8vIOiOt+WPlueUqOaIt+aVsOaNrlxcbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXFxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcXG4gICAgICAgICAgICB9LCByZXMgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5kYXRhKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICB6b29tUmF0ZSgpIHsgLy8g5Yid5aeL5YyW5pS+5aSn5YCN546HXFxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnNjcmVlblNpemUud2lkdGggLyB0aGlzLnN0YWdlU2l6ZS53aWR0aFxcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHg6IHgsXFxuICAgICAgICAgICAgICAgIHk6IHlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJldHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGV2ZW50czoge1xcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyaW5mbyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmluZm8pKSkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoYXQudXNlcmluZm8sIHJlcy5kYXRhKVxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LnVzZXJpbmZvT3BlbmlkID0gcmVzLmRhdGEub3BlbmlkXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldExhc3ROb3RpY2UoKS50aGVuKHJlcyA9PiB0aGlzLm5vdGljZSA9IHJlcy5kYXRhLCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMpKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2FuY2VsQmV0JylcXG4gICAgICAgIH0sXFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5pbml0KClcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcXG4gICAgICAgIGVycm9yKCkge1xcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2hvd1RpcChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd1RpcCcsIGV2ZW50KVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wb25lbnRzOiB7XFxuICAgICAgICAnbW9kYWwnOiB7XFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJtb2RhbFxcXCI+PC9kaXY+J1xcbiAgICAgICAgfSxcXG4gICAgICAgICd0aXAtbW9kYWwnOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZScpLFxcbiAgICAgICAgJ2JhY2tncm91bmQnOiBCYWNrZ3JvdW5kLFxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcXG4gICAgICAgICdiZXQtYW5kLWJvbnVzJzogQmV0QW5kQm9udXMsXFxuICAgICAgICAncGxheS1wYW5lbCc6IFBsYXlQYW5lbCxcXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxcbiAgICAgICAgJ2JldC1tdWx0aXBsZSc6IEJldE11bHRpcGxlLFxcbiAgICAgICAgJ21lc3NhZ2UnOiBNZXNzYWdlXFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxufVxcblxcbmRpdi5tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH0pLFxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG5cdFx0aWYobmV3T2JqKSB7XG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlcztcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdGlmIChtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG5cdFx0Ly8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuXHRcdGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJztcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgICBtZW51LWJhcih2LWJpbmQ6Z2FtZS1kYXRhPVwiZ2FtZURhdGFcIix2LWJpbmQ6bm90aWNlPVwibm90aWNlXCIsdi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIpXG4gICAgICAgIGJldC1hbmQtYm9udXModi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHBsYXktcGFuZWwodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHN0YXRlKHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiLHYtYmluZDp1c2VyaW5mbz1cInVzZXJpbmZvXCIsdi1iaW5kOnVzZXItYmV0PVwidXNlckJldFwiLHYtYmluZDpiZXRzLnN5bmM9XCJiZXRzXCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiKVxuICAgICAgICAvLy0gYmV0LW11bHRpcGxlXG4gICAgICAgIG1lc3NhZ2Uodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6YmV0cy5zeW5jPVwiYmV0c1wiLHYtYmluZDplcnJvci5zeW5jPVwiZXJyb3JcIilcbiAgICAgICAgbW9kYWwubW9kYWwodi1pZj1cImVycm9yXCIpXG4gICAgICAgIHRpcC1tb2RhbFxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWUnXG5pbXBvcnQgTWVudUJhciBmcm9tICcuL2NvbXBvbmVudHMvTWVudUJhci52dWUnXG5pbXBvcnQgQmV0QW5kQm9udXMgZnJvbSAnLi9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSdcbmltcG9ydCBQbGF5UGFuZWwgZnJvbSAnLi9jb21wb25lbnRzL1BsYXlQYW5lbC52dWUnXG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9jb21wb25lbnRzL1N0YXRlLnZ1ZSdcbmltcG9ydCBCZXRNdWx0aXBsZSBmcm9tICcuL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlJ1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9jb21wb25lbnRzL01lc3NhZ2UudnVlJ1xuaW1wb3J0IGdhbWVEYXRhIGZyb20gJy4vZGF0YS9kYXRhJyAvLyAg5Yqg6L295qih5p2/5pWw5o2uXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFtdLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgICAgdGhhdC5zY3JlZW5TaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckJldDoge1xuICAgICAgICAgICAgICAgIGJldG1vbmV5OiAxMDAwIC8v6buY6K6k5LiL5rOo6YeR6aKd5Li6MTAwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdhbWVEYXRhOiBnYW1lRGF0YSxcbiAgICAgICAgICAgIGxvdHRlcnludW06IHsgLy/lvIDlpZbnu5PmnpxcbiAgICAgICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAwLFxuICAgICAgICAgICAgICAgIGxvdHRlcnludW1zOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdW50RG93bjogMzAwLCAvLyDlgJLorqHml7bnp5LmlbBcbiAgICAgICAgICAgIGNvdW50TnVtOiAzMDAsIC8v5byA5aWW5pe26Ze06Ze06ZqUIOm7mOiupDPliIbpkp9cbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGJldHM6IFtdLCAvLyDkuIvms6jpm4blkIjvvIzlj6/ku6XljZXmrKHkuIvlpJrms6hcbiAgICAgICAgICAgIG5vdGljZTogcmVxdWlyZSgnLi9kYXRhL25vdGljZScpLFxuICAgICAgICAgICAgdXNlcmluZm86IHJlcXVpcmUoJy4vZGF0YS9zaW5nbGV1c2VyJyksXG4gICAgICAgICAgICBzdGFnZVNpemU6IHsgLy8g5pW05L2T55S75biD5aSn5bCPLOaJgOacieWPmOWMlue7hOS7tuWGjeasoeWfuuehgOS4iuS5mOS7peaUvuWkp+WAjeeOh1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDA4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuU2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAvLyDliJ3lp4vljJbor7vlj5bmlbDmja5cblxuICAgICAgICAgICAgLy8g6K+75Y+W5byA5aWW5pWw5o2uXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4ocmVzID0+IHRoaXMubG90dGVyeW51bSA9IHJlcy5kYXRhKVxuICAgICAgICAgICAgdGhpcy5nZXRVc2VySW5mb0J5TmV0KClcbiAgICAgICAgICAgICAgICAvLyDojrflj5blhazlkYrmlbDmja5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2dldExhc3ROb3RpY2UnKVxuICAgICAgICB9LFxuICAgICAgICBzaG93KCkge30sXG4gICAgICAgIGdldFVzZXJJbmZvQnlOZXQoKSB7IC8v5LuO572R57uc6I635Y+WdXNlcuS/oeaBr1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyQ29kZUZyb21OZXQoUmVxdWVzdExpc3QuZ2V0Q29kZSgpKS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8g6I635Y+W55So5oi35pWw5o2uXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoYXQudXNlcmluZm8sIHJlcy5kYXRhKVxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcbiAgICAgICAgICAgIH0sIHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZGF0YSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHpvb21SYXRlKCkgeyAvLyDliJ3lp4vljJbmlL7lpKflgI3njodcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zY3JlZW5TaXplLndpZHRoIC8gdGhpcy5zdGFnZVNpemUud2lkdGhcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd01lc3NhZ2UnLCBldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0dXNlcmluZm8oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJpbmZvKSkpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXNlckJldC51c2VyaW5mb09wZW5pZCA9IHJlcy5kYXRhLm9wZW5pZFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0TGFzdE5vdGljZSgpLnRoZW4ocmVzID0+IHRoaXMubm90aWNlID0gcmVzLmRhdGEsIHJlcyA9PiBjb25zb2xlLmVycm9yKHJlcykpXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjYW5jZWxCZXQnKVxuICAgICAgICB9LFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKVxuICAgICAgICB9LFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcbiAgICAgICAgZXJyb3IoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dUaXAnLCBldmVudClcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnbW9kYWwnOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJtb2RhbFwiPjwvZGl2PidcbiAgICAgICAgfSxcbiAgICAgICAgJ3RpcC1tb2RhbCc6IHJlcXVpcmUoJy4vY29tcG9uZW50cy90aXAtbW9kYWwudnVlJyksXG4gICAgICAgICdiYWNrZ3JvdW5kJzogQmFja2dyb3VuZCxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcbiAgICAgICAgJ2JldC1hbmQtYm9udXMnOiBCZXRBbmRCb251cyxcbiAgICAgICAgJ3BsYXktcGFuZWwnOiBQbGF5UGFuZWwsXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxuICAgICAgICAnYmV0LW11bHRpcGxlJzogQmV0TXVsdGlwbGUsXG4gICAgICAgICdtZXNzYWdlJzogTWVzc2FnZVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuYm9keSB7XG4gICAgbWFyZ2luOiAwO1xufVxuXG5odG1sLFxuYm9keSB7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4udGFibGUge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xufVxuXG5kaXYubW9kYWwge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XG4gICAgdG9wOiAwcHg7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiA5OTk7XG59XG5cbi50YWJsZS1jZWxsIHtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEFwcC52dWU/MzRjMDhlN2FcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9iYWJlbC1ydW50aW1lLzYuOS4yL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmFja2dyb3VuZC52dWVcIilcbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTc2NThkNmRlL0JhY2tncm91bmQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYudXAtYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDg5JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKSBzb2xpZDtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuYnV0dG9tLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiAxMSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKmJhY2tncm91bmQ6IHdoaXRlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT9iMjkwODVhZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7QUFNQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxZQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLGlEQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLHNCQUFBO0lBQ0EsdUJBQUE7SUFDQSw2QkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJCYWNrZ3JvdW5kLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgZGl2LmJhY2tncm91bmRcXG4gICAgXFx0ZGl2LnVwLWJhY2tncm91bmRcXG4gICAgXFx0ZGl2LmJ1dHRvbS1iYWNrZ3JvdW5kXFxuPC90ZW1wbGF0ZT5cXG48c3R5bGU+XFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LnVwLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiA4OSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3JkZXItYm90dG9tOiAycHggcmdiYSgyNTUsIDI1NSwgMjU1LCAuMykgc29saWQ7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9kb2NrLnBuZyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5idXR0b20tYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDExJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogd2hpdGU7Ki9cXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRiNGE2NjA5Yjk4OTY1NWE0ZDY3ZjI0NWJkNTdlNDFkLnBuZ1wiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQmxDQUlBQUFBREVoNlNBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVSa015UkRrNVJqTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNVJrTXlSRGxCTUROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2psR1F6SkVPVGxFTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxHUXpKRU9UbEZNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt5RGExSXdBQUFCeEpSRUZVZU5waXNBcnNaR0pnWUdCKy8vRWJpQjdGQTQ4QkFnd0FyN2dFdE9qSDlRUUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kXFxcIj48ZGl2IGNsYXNzPVxcXCJ1cC1iYWNrZ3JvdW5kXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJidXR0b20tYmFja2dyb3VuZFxcXCI+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZW51QmFyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWVudUJhci52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcTWVudUJhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYTVmYTUwOTgvTWVudUJhci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVudUJhci52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ubWVudSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiA1JTtcXG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XFxuICAgIGJhY2tncm91bmQ6ICNlMTRmNTA7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbmRpdi5ub3RpY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA2MCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEuNWVtO1xcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xcbiAgICBjb2xvcjogIzc4M2EzZjtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lm9wdGlvbiB7XFxuICAgIHdpZHRoOiAxMiU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICAgIC8qIGJvcmRlcjouMTVlbSBzb2xpZCAjZmNkMTllO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xcbiAgICAvKmJhY2tncm91bmQ6ICNmZjllNDA7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWU/NTQyYjk2ZmFcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7SUFDQSxtQkFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLGFBQUE7SUFDQTsyQkFDQTtJQUNBLHdCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1lbnVCYXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy3oj5zljZXpg6jliIZcXG4gICAgZGl2Lm1lbnVcXG4gICAgICAgIGRpdi5ub3RpY2VcXG4gICAgICAgICAgICB0YWJsZVxcbiAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgdGRcXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuKHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcXG4gICAgICAgIGRpdi5vcHRpb24oQHRvdWNoZW5kPVxcXCJ0cmlnZ2VyT3B0aW9uXFxcIilcXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIix2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBPcHRpb25zRGlhbG9nIGZyb20gJy4vT3B0aW9uc0RpYWxvZy52dWUnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZScsICdub3RpY2UnXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbmFtZTogJ2xpdScsXFxuICAgICAgICAgICAgaXNTaG93T3B0aW9uOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgndHJpZ2dlck9wdGlvbicpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgICdvcHRpb25zLWRpYWxvZyc6IE9wdGlvbnNEaWFsb2dcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLm1lbnUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogNSU7XFxuICAgIHBhZGRpbmc6IDElIDMlIDElIDElO1xcbiAgICBiYWNrZ3JvdW5kOiAjZTE0ZjUwO1xcbiAgICB6LWluZGV4OiAxO1xcbn1cXG5cXG5kaXYubm90aWNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogNjAlO1xcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcXG4gICAgYmFja2dyb3VuZDogI2VlYmViZTtcXG4gICAgY29sb3I6ICM3ODNhM2Y7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmRpdi5vcHRpb24ge1xcbiAgICB3aWR0aDogMTIlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogYmxhY2s7Ki9cXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC41ZW07Ki9cXG4gICAgLypiYWNrZ3JvdW5kOiAjZmY5ZTQwOyovXFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEMEFBQUEwQ0FZQUFBQTViVEFoQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSTVRek5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVJNVJETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qY3dNemcxTVVaR00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pjd016ZzFNakF3TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrbXJwNU1nQUFCa0pKUkVGVWVOcnNXMmxzVkZVVS91NTBZTHBDTnlpRnNwUkM2VmdzRmFSb0VJd1NqWWdvbUFJbDRoSmMvZ0FhLzJoaWpJa3g4WWNtR3FLb01XQVFrYUFnQ0NvcWFBeTdwVURaV2twWEtFc0RwUXVkbG5aS1o2N24zRGN6bmFtZGVhM08xSm5CazN6dGZlK2V6cDN2blh2UGN0K3RrTVhyMFlzTUppeHc0RjdDU01lOVlKZFd3aVZDTVdFN1lRZHluKzNzcVNSNkliMlE4QjVoQWtKZktnbXZGOHhldGMwYjZRakN1NFRYMUZWN0l6MjNxOEROZXFETENraDc4Rk0wR0FHakNZaE9CbUtHQTFHSnpoNDI0aHRFM3NZWFJyYy82U1o4dlF4b09oOTZkclhkMG1CdDFiNS8vRGhnV0JaY3ZNanE3cGJPSjJ4UnR5LytDWFEwSTJ3a01oNFlmWS96YWhGWmV5dVRaZ2RWUlVoRC9WbWcrVHpDVHBURnpkeTZUQmpQMDN1UklueXpnYVpFamU3Znk5U3BRT2Fqa0FrWm1sTm9vdWRWdmd1aTduandrbVpldk1hamswYlIxV0tqSXl3QmxqcW01SnR3OWhKSTgwTFBlOE95NlNrU3ptNkhLUGttZUlsYnJqQnBiaTFnMHRQVnpiWnJ4RUQ2dEhCUHdoNzkzTmRZQVhIbG1NdVR5cHhsa0dOblVZU1BEU3loemphSUMvc2dUbTBFN0YyOTY3VFZPMXQzRytqSENOWHNhbmRZMmdzeUg5TWZmT0k4bDc3TWVRcHk0dHpBRTFhcFZJd2FTMll2OXY3OUZUOGxxVXphcEpwMm0yWnBMNUNKNC9YWE8rczQ5Y2ZPSHZBWkxNZlA4YzdCYm5NOUlyYzRMZjB3clBEVDUvd3I2dm81VExldTlBblJXS1ZQdWJHeVcvLzgzZ0duSzZwLzg4M2piNlI5cldmR3VSLzBSMVU2bXI0NCtTVkUrVS9rWkZvRHo1Ykc0TEhFNlUwNlBEUXhlbGphMTFPOGZBUW8zUXA1UjM3di9kU25kTnhTUW5GOHJVS3dTYi9XdEFvSkRlWEFwUG5rdENZNnBuUUZXWGduRVM0S21RU3R6NVoyRWI5VVNCVnJvWEpab1NwKzl0NGhaMm43N1VpNmI1YVdvMllBNWdXUVNZNDEzVkNoNWQzdVRpeWNwcmVjOGd6azVBTFBleWs1QU9QTVpncFRHOExMMG16aG5vUTkrcm52ZXBubTZKd0Z4OVFYS0RWOGtCSy91TURINmVyZnRmRG9yZUQ0SnhrWmZGUllMc2xhMkoxN1QzMGVNdXVKd0JOVzJYU3NHa3RPZWJxL0dabmRKMlJTcHY3MFZ6b08vZlE1QTU5MVQ1aXJ3NlBmanF3UGprNzAzU0VHam5sL0NnNmQzRnR3SnFiSCtmcTVidjNxUFFOZmNGVHU2bS91clJPblM3Y0FJM0wxZFJ5Zkk0NStwbjFzeGtNRDRNZ3NFRlY3eUpHdDYxTyswZmVDby9ZUVFMazNid0Y1eTh1VmpudkJVZmlSUW1nWEhCd1NlSnM0T3g4eTJleVkwblJkc2dYaTRxRXdMamhxRHdDRThDZzQ1TzFZY09EL2dzTjdHQnd6RTZDVTAyTk5jOTVkZXpCTUM0NXBMMEhtUHVkNWoxL3pNRTZzaHpqMmVaZ1ZIR1Robm9ROStybnZXb25tNkZUYU13aHl4a3BLRFI4QlRFTUN5OEpLY2JyeVp3cVBIOU1xdmVYSGdtUHlVdjNCdWRKeUZoeDVLN1EzRG9FbXpHS0tVMlBKYVMvNmR3dFlhcTg2ZmM4R3BlUFE1MWM2QTUxMmMxWG56eTFnZnliOC8zbkJZZXV5ZGFoV3hDRGZCVWQ5cVg3aW9uUWMraFc3QnI3Z0tQdmVPd2VEd1ZGaXlDNURwL1ZXazdvYUZPMTdQWnphcEQ4cTZ6aGY2eHhlRFVHaEROYVd3TE9sTVhnc2NlUlQ3OS9mR0sycFdqdWJqVGVhTExWUk1aR3BHSkttblNqeTloUXY3QVdvaXVFZGtkN3o4bldhaml2WDZZUTQrTDVDVUVqOEdQV3J1YUdsT21KZWRrWnVlbVphbmpxT2RNMzNGRlp2TVhnZkxDb0ppRTVVKzFHaTdvUkdyblJyY0FmbnNmY0JrVU5SdFAvMERyRjhaRXJCSjkrOXM4WVVPVGdSTlg4QWRjWGhsM2VtM2dXa1B3QnJSMmZqeXZ5M1hqRzBXVzYyN3Z2MXlGZXFrem9RbDZvYnZrSUt6SWQ1a1RCUFMwdGJTOFJrazJsNDhlRVNTODUwc3lscGVFSW1VdTdVVGdqeXdaUlFsNUdVSGs5NlhEWEx6OVQ4K01HYmEzK2g1bFVtemI1ODlJRTlSMHR5ODh5eENjbERNNUNRRGd4TjA0NGRkbEZFczNVaEpONTFpUWhhdDVRQkptY0I0KzUzYlc5Vm43dTQrKzJYVjM5dHQ5bVpSS2xZRWhmSHBPY1RsRTlmL3VxaXZGa1A1eTBsajU0UzZvWnViK3U0dW45MzBlWXZQdnkyMEhtTHNGTWRreXlZdllyOStVeW5ja3hzbEhIWmlpZG5tS2RrVEk5UEdwSnVNZzFPRkFaK2pNRXRsSGpZS0E0M1VsaXFPWHV5cW1qam1tMkZiYTN0N3E4OHVQNnRkWjBDSnVJOEY4d0lYNkhDSHlmVUtxRHA3Vm9SQkZyNXlBeER3aFdFWTA3SHhJN012WlBQU3Q0Z0pNQjV2aXkweFVMZ2N5RmxIdjdPemRJOTYyeGU1K1RDd1NmRm96ekwwS0FWdThOWmNUN04vOVpRMjl2bTMxOENEQUFxOVd5Z3dnZEVaZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8t6I+c5Y2V6YOo5YiGXG4gICAgZGl2Lm1lbnVcbiAgICAgICAgZGl2Lm5vdGljZVxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICB0ZFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbih2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6MjYqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcbiAgICAgICAgZGl2Lm9wdGlvbihAdG91Y2hlbmQ9XCJ0cmlnZ2VyT3B0aW9uXCIpXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XCJnYW1lRGF0YVwiLHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgT3B0aW9uc0RpYWxvZyBmcm9tICcuL09wdGlvbnNEaWFsb2cudnVlJ1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ2dhbWVEYXRhJywgJ3pvb21SYXRlJywgJ25vdGljZSddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAnbGl1JyxcbiAgICAgICAgICAgIGlzU2hvd09wdGlvbjogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd0cmlnZ2VyT3B0aW9uJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnb3B0aW9ucy1kaWFsb2cnOiBPcHRpb25zRGlhbG9nXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubWVudSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGhlaWdodDogNSU7XG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XG4gICAgYmFja2dyb3VuZDogI2UxNGY1MDtcbiAgICB6LWluZGV4OiAxO1xufVxuXG5kaXYubm90aWNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDYwJTtcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xuICAgIGNvbG9yOiAjNzgzYTNmO1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuZGl2Lm9wdGlvbiB7XG4gICAgd2lkdGg6IDEyJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xuICAgIGZsb2F0OiByaWdodDtcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xuICAgIC8qYmFja2dyb3VuZDogI2ZmOWU0MDsqL1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1lbnVCYXIudnVlPzU0MmI5NmZhXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9PcHRpb25zRGlhbG9nLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcT3B0aW9uc0RpYWxvZy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtM2QyNzE0MDYvT3B0aW9uc0RpYWxvZy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9PcHRpb25zRGlhbG9nLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5kaXYucG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogMjAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKSByZ2JhKDAsIDAsIDAsIDApICNmZWQwOTUgcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuXFxuXFxuLyog5b+F6ZyAICovXFxuXFxuLmV4cGFuZC10cmFuc2l0aW9uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzUzZGRlYThlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsaUJBQUE7SUFDQSxpQkFBQTtJQUNBLG1CQUFBO0lBQ0EseUVBQUE7Q0FDQTs7O0FBR0EsUUFBQTs7QUFFQTtJQUNBLGlDQUFBO0lBQUEseUJBQUE7SUFDQSxpQkFBQTtJQUNBLGtCQUFBO0lBQ0EsMkJBQUE7SUFDQSxpQkFBQTtDQUNBOzs7QUFHQSw2QkFBQTs7O0FBR0EsNkJBQUE7O0FBRUE7O0lBRUEsVUFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLDZCQUFBO0lBQ0EsbUJBQUE7SUFDQSxtQkFBQTtJQUNBLHlFQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSxvQkFBQTtJQUNBLG1CQUFBO0lBQ0Esb0JBQUE7SUFDQSw0QkFBQTtDQUNBOztBQUVBO0lBQ0EsY0FBQTtJQUNBLG1DQUFBO0NBQ0FcIixcImZpbGVcIjpcIk9wdGlvbnNEaWFsb2cudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g5Y+z5LiK5L6n6YCJ6aG55YiX6KGoXFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XFxcImlzT3B0aW9uU2hvd1xcXCIsdHJhbnNpdGlvbj1cXFwiZXhwYW5kXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm9wdGlvblN0eWxlXFxcIilcXG4gICAgICAgIC8vLSBpbWcodi1iaW5kOnNyYz1cXFwibWVudUltZ1xcXCIpXFxuICAgICAgICBkaXYucG9pbnRlclxcbiAgICAgICAgZGl2LmlubmVyLXBvaW50ZXJcXG4gICAgICAgIGRpdi5vcHRpb24taXRlbSh2LWh0bWw9XFxcIm5cXFwiLHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiLEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEpXFxuICAgICAgICB9LFxcbiAgICAgICAgcHJvcHM6IFsnZ2FtZURhdGEnLCAnem9vbVJhdGUnXSxcXG4gICAgICAgIGRhdGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaXNPcHRpb25TaG93OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgbWVudUltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZycpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBpdGVtU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMjYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbWV0aG9kczoge1xcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gZmFsc2VcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGV2ZW50czoge1xcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gIXRoaXMuaXNPcHRpb25TaG93XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuZGl2LnBvaW50ZXIge1xcbiAgICBoZWlnaHQ6IDBweDtcXG4gICAgd2lkdGg6IDBweDtcXG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcXG4gICAgbWFyZ2luLWxlZnQ6IDIwJTtcXG4gICAgbWFyZ2luLXRvcDogLTFlbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmVkMDk1IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcblxcbi8qIOW/hemcgCAqL1xcblxcbi5leHBhbmQtdHJhbnNpdGlvbiB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8tIOWPs+S4iuS+p+mAiemhueWIl+ihqFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XCJpc09wdGlvblNob3dcIix0cmFuc2l0aW9uPVwiZXhwYW5kXCIsdi1iaW5kOnN0eWxlPVwib3B0aW9uU3R5bGVcIilcbiAgICAgICAgLy8tIGltZyh2LWJpbmQ6c3JjPVwibWVudUltZ1wiKVxuICAgICAgICBkaXYucG9pbnRlclxuICAgICAgICBkaXYuaW5uZXItcG9pbnRlclxuICAgICAgICBkaXYub3B0aW9uLWl0ZW0odi1odG1sPVwiblwiLHYtZm9yPVwibiBpbiBnYW1lRGF0YS5vcHRpb25zXCIsQHRvdWNoZW5kPVwic2hvd01lc3NhZ2UoJGluZGV4KVwiLHYtYmluZDpzdHlsZT1cIml0ZW1TdHlsZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVhZHkoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhKVxuICAgICAgICB9LFxuICAgICAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZSddLFxuICAgICAgICBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc09wdGlvblNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lbnVJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZDoge1xuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyNiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSAhdGhpcy5pc09wdGlvblNob3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5kaXYucG9pbnRlciB7XG4gICAgaGVpZ2h0OiAwcHg7XG4gICAgd2lkdGg6IDBweDtcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xuICAgIG1hcmdpbi1sZWZ0OiAyMCU7XG4gICAgbWFyZ2luLXRvcDogLTFlbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZlZDA5NSByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5cbi8qIOW/hemcgCAqL1xuXG4uZXhwYW5kLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcbiAgICAvKmhlaWdodDogMzBweDsqL1xuICAgIC8qcGFkZGluZzogMTBweDsqL1xuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cblxuLyogLmV4cGFuZC1lbnRlciDlrprkuYnov5vlhaXnmoTlvIDlp4vnirbmgIEgKi9cblxuXG4vKiAuZXhwYW5kLWxlYXZlIOWumuS5ieemu+W8gOeahOe7k+adn+eKtuaAgSAqL1xuXG4uZXhwYW5kLWVudGVyLFxuLmV4cGFuZC1sZWF2ZSB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIC8qcGFkZGluZzogMCAxMHB4OyovXG4gICAgb3BhY2l0eTogMDtcbn1cblxuZGl2LmlubmVyLXBvaW50ZXIge1xuICAgIGhlaWdodDogMHB4O1xuICAgIHdpZHRoOiAwcHg7XG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xuICAgIG1hcmdpbi10b3A6IC0wLjllbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5kaXYub3B0aW9uLWxpc3Qge1xuICAgIC8qd2lkdGg6IDMwJTsqL1xuICAgIC8qaGVpZ2h0OiA3MCU7Ki9cbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiAjZmZhOTU2O1xuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcbn1cblxuZGl2Lm9wdGlvbi1pdGVtIHtcbiAgICBwYWRkaW5nOiAuNWVtO1xuICAgIGJvcmRlci1ib3R0b206IDAuMWVtIHNvbGlkICNlODkzNDI7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogT3B0aW9uc0RpYWxvZy52dWU/NTNkZGVhOGVcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUZjQ0FZQUFBQmhyWlJwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSkJNRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVKQk1UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qa3lOMEpGUWpsRk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2preU4wSkZRamxHTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZVBnT3VnQUFLUk5KUkVGVWVOcnNuUXR3VmZXZHgvODg4eUFoUUJJQ0pJVkFKSVpFbmdHaENCUzNPZ2hVcFZoY2Q4RlJaMXVtTG5hRzdhelRkYmJhcVRyck9uYTZ6Q3hLaDdaYkhHSGFpa1hVSXJMaUZua0o4Z3FQQUEwbVBFd3dJVHdDaER3QXlaN3ZQL25kbm50eXpybm52c0s5eWZjemMrYmUzSHZ1ZVg3L3YvLzMvL3YvVC83ZFdnNnNVb1I0NU4rTnBadXh2QndyQi9UWWpCLzUvZDJUOTRnRUlXYXprRitPeFlQc3p2dEVRaER6UzIyZlVkQWtqc1ZjOVhucjhyY0kvZThVTklsZk1WK3JiVjFpV05RVU5QRXVaaUdHUlUxQmsrREVIT09pcHFCSjhHS09ZVkZUMENRME1jZW9xTDNrb2ZzYXkyQmpTZUg5N3RROFpDd3ZCQ1ZtcTZpejd4WlI5emFXOXlOOGZCZU41U3RqYVFwRjBNT001ZnZHOHJDeGpPYTk3a0lFSzJaN1ViL2dLeHlScDh4WTNqV1dGY1p5MnZwbE4wdlhkNCsyQS9tM3RsS20xSzJiU3Qxc2JuMGxuWmRHSXdCZXExR3E0VUo0MjBsT1Y2cFBsbEpKQXlKN2ZEMTZHZUUzMFZDc3p5VmZONWIvTkpZWEg1dnhvNi90Qkoxc0xHOGJ5MXo5MTVVcVkva3kvQk1rSkpJazlWY3F6VEFRZmJQbGt3K05aWUVoNmdaem94QURUbFpyTWQ5c1ZLcHlsMUxWSlJRemljR2E1RktyTnFIUkc0MzRaSTZ4clBuRDF2L3VaaGIwdnhqTGQ3VzErSElYaFV4aUgyZ1Vvb1ptbFpwbkxEOFd5OUhQZUQxbExHbnE3RDZsNnF0NXNVajhrREpJcVNIRmVIZlpXSElSb1JkcU1WODdSekdUK0FPYWhYYWhZYVVXZGI5MTY5YUR2a1lnSWZGSW0zYWg1ZTR0TFdwOHE5bSt5QXRENHJTaDJLcGRROHZqdW5mdjNpMWQvL1YxTXk4TWlVL2F0R3RvT2FON3QyN2Rlb2k4Q1lsTDJyUnJhTGs3QnllUlRnVUZUU2hvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNqcG9sdjU2aDE2aVNjbEpiODlTTmw2L3FUNHVxVlNydDV3SWVWL1lCb2s4Y2ZNZi9FOVdYdzRvZURlVy9lQWUxKzhoenJYYlRxaXhJekxWNGxtRktpZWpqK082U2IxN3FnMTdUdXRqdW12WUFEVnVlSHBRNTdKKzF5bTF2N3cyNEg3QzRlTFZablhtZkgzWTJ4bWFrYUlHcENaUTBMRW0rRUJBbUdWVm1lcGdSYTFhc3VKVE5YdGlybnJpMi9sYXZIWThlVitCK3RucTNXclY1dU1CQzR1VitxWWJlajgvZld1M2V2bnh5WDZpaHRoLzkvSFJvTGIzM3ZOejJuMjJ0ZlNyb0xkangxUDNGNnA1VTNJcDZOdUY5ZVkrL05LSG5uNkhLSXNGVm1MTlg4clV4cjJuMU5tTDE5U0xDeWM1cm85b0RtSGlOL2VQeS9GOGpJdG1qbFFwaWIyMDRPeEVIUWx5czFLMUdFTmx5K0dxc0lNRUJSMERRSmpUQ2dlcFArMDhxZTdPSCtpNjd2U2l3ZXBLdy9XUTlvT28xeWV4cDFyK3dTRS9VZU56cnhIUnJiQktBUTFIMEFESFNFRkhBRVE5K0ZRM3IvelBjKzlTK1VQU1ZObloxa2d5ZkZCYVJQWU5tNEVvS3Q1Njc0bHp0dXYxVFc3OTkzODRUcnRqblRoeW9HODdUb1ducGs3Lzl4K1YzamMyZldwbVdoSUZIUW11TmQyMHJmTE1uelUwdDJZSy91OWdhelFweU9rZjhlT0FtTU9wZXQwRUxkOGo0K0hrMWNQTkRNV2piZWlVZ3JaV3ZWSzlXajB5b2pQOEx2aTdzZG11clg1cHJWc0ZoTytTRW5yWWlzcXR3ZWQwVEtIVUNORUFOVVNvMU5VM3EwdjFUUlIwUjdMeldJMWErVkdwZnI5ZytraHRQNnhJdysycFpaLzRQb00xRWFGQzNNdmVQNlRPbkx1cTVuMXpSRlJiOUU2cHhXQ3pKTUhVRG9GcWlFQ0ZOVG1CSHJwRE1LZTNJR2FuRzRkYzcrKzNmcUdxTGpqblpQT3orMm5SWTN0b0REMDY3UTQxZFZSV3hJODVIcXQvdXlCQlFVZUJXUk55MVByUEt0Ujk0Ny9oR29XUU9YaDIvdGlBRGNBNXhVTjFwSWF3WDMxbm4zcm13VEZCcGVLODREV2xHRTZQS0N6WUd4dU9SS1ZXbVR0cFdNU3ZDUVZ0RXVLS0pUTWk1ai9ocjVGemhvMzVhUCtaMjNyandvbmthQ2hIc2lZd2J3c05kVWJvQ0NQcFBEUjQwRlVkRFAxVEV0WFNlV05kODdPd0d0R3dHNUdJNkU0KzF3ek9UWDRYS0h2aXBWRnJia3pUY29RSnFzL1RSbU90cE9Kdmc0YlFFU0hWSHhwM0VrSFErSFBxNUVDK0dGWUNyZmFNMU1TUXFsMjNxR2NuTEhQRE0xcTQ5UVJDaUxCUVlQN1VFYTZGMks2bkU0WGhsYlVIZEdONTRiMzVNVzgxWWw3UVRpTDZ5ZmVLMWZpOGRCMTVjSkZmV0xOSGl4VU5PeWN2alFZazFzSDRESzlkelBnTmZEcjI0NVQra3VPejY5QUpKMlhtRmJlTUROS1FFL0l5ZFVNWDU0Nkc4eU5UaDl0R2JIVDFvM2RVdnFzOGYwMnQzTlQ2T3dTS1VWSEk3M2M1UVNNQ3cxcmdkZGpBVlBYc2IzZjRMSUdmOEI4YW8zNzhteDNhZnRpTmZFT1V4MDJGM2NCZ0k2KzJCcitwdnRTZ2ZqaTcwREg5SlpFNTJwRTQxRFlHQkQveGprd3RUbHlmc3FvNjJ4RitxTGtRamRHR2tMRXMrTXl0RU1RcU1Uc2VHdEVYUXNHclcrb0kvbTd4QTBXdHdscC9VRmUxNW1yelAvNjRUNzlIdGVubHh1QTMwbzN0MWxFVEwwQzh6eTBZcjhVSiszRCthcE12Q2d1b3VSQ05VU3VLcFVOTmlFSWNUMktPYVVFSEE2STIvQ1NpQ253alJDa2VVQ0tOVncrNGFYK2x0aEs0eVIyZGd3MTEwRDh5TTRHaU5jU0pBVkFOVFRmVmErc082aUd5d3FQVDhyUzF3SG1qSmtQMktGWWF4cDAreStIbUp6SE9HRlVyaEF6RU8zcnRMVU4wUjI0Yk54VTMrWFprYjBLeEw4aWJ1elZDY1Y0WUgyMGVFanF0S0Z0dEw2M3kxWEtJNHJodXVHWnZmbExtT2hhY2d1NGdJRno0Uk53VXlYd0UwL1dMNkk2SWptamZrYWtxUkV5SUN3WEpiSm04NFBiWUdDTDNqbVBWUHVGaSs2aDVVRmh4ZnZLNVJIRVJOY2JHN0RwZXJhMWN2RVhxVGlGb1ZOWGJqMWI3SG92Q2pZTXdJV3hrUVI2WU1EVGdqY0hOeC9xSWRNaHVSQnV6aDRXd1VQalF3QTIySURWWU9qdHdMVENXMnp4S0VPZUV4clU1aytGa1RTQnEvQjQxSFNJL2pndmp2cG0yaXpLSVpQdkthM1dPMmh4cFJCam9NWlBVa3dnVnFUUU0ycmQ2WTRoQUJqbGhISWZjZEtjeDJWYmN1cXFkdW91M0hEbnJlMjk5ekVrS0pLS3ZXLzRZeDQxZVRUQnpkTFpQbFBXTk43U1ljUzI4RkdZN3Y0Mk1FUjR2ayt1SHpFYzg1S05qVnRDNFdVKy92dFZ2Q0tQa2U2V0tOZ3RnU3NFZ1gxVXF2bERTVU5zTS80aWJncHVNeUNNTkh4SHVoU3ZOdnNKZ3Z2bE9ZN0t0dUsxajExMk1jOXQ4NEV2SG5rdWNDNnA5UExQb0JXeG5oaEZGelkwODg3VXcrM1N2M2RjNEpuaHl1WDdJa0NEQ3h6cVlTYloxeHBXeURURjNjT2pja0VlQkVJRncwM0NURUxrUVBUQ2dmMHh1dXFjSWhIejA1MlhudE1lMnEwTEZ1M2FVZDhZNTNKbWRabXNCekJZcUVLaDFNTERLeTNIYlBZRHI5U0hZYUQyRUVESHk1OGErb0Vua2E3Mi9WbDMyaThLZGhqWkI4eUhaTGdRaWJLY1NzUTM4VjJDRWdpYUVnaWFFZ2lhRWdpWVVOQ0VVTkNFVU5DRVVOQ0VVTktHZ0NhR2dDYUdnQ2FHZ0NhR2dDUVZOQ0FWTkNBVk5TR1R4UFlLMXIrUXdyd2FKVzRxdHp4UVdqeHZOcTBKb09RaWhvQW1ob0FtaG9Ba0ZUUWdGVFFnRlRRZ0ZUUWdGVFNob1FpaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0ZIbFlkZitsQXZkbUNLTk13Zys2dU5SL1g3WUFubE55UXduTmF0RFV5RW1aR2FxSEl5K25oYUgvTmhZd1paVFA0WjdJU1VtQUJ6ZjNtdFdqeXIwUFArZ2dVVGlaNDVYeC8yZG9abXBIVFlaS1NkWHRBUW1kZnBnWVBodmVmbnRMdjV5OVlmMU8vTlV5WTdnZW1DTWNVeU9IdnhtdU5jM3hEN0U5L09iN2U5K3FZYmVxcm1uNzYxVzczOCtHUS9VZHZOOWhycytZQ3RwVjhGdlIwN3ZNNDBTMEY3SURtaHAyOStiek15dDdiZGQ4R3NJeUFDWVdMMjVSOGMwcEVYazdlN2lSbnJDUkNtMnpGZ3ptMnJvTEg5bE1SZVduQjJvbzRFdVZtcFdveWhnaW1wdmN4elRrRUhRZjZRTkQyQnVwMjNCWGJmQmJPT0djejlqVW5hRVhsbjNqV2tuY0RnZVNGMmZJL0o0dDFFS0tLZlBUSFhzYnBHMU91VDJGT3ZaeFkxUHZjYUVaMzhQY0NNc2VITUdpdHpyT01ZS2VnNDVZRUpRM1hFUFZaNXFaMVlsLys1VkcwdnJkSVIvOG43Q3RUZUwycFZldCtFZHRFWHdsL3psekw5L2p1VGhnVXNSRFYxamZvOXRoV0xaS1lsVWREeHl0UlJXZXIxcDcrbHhReGZiZWFmN2k5UWd3Y2txMGVtRGxmYmoxWnJ1NENHM1hNTHh2dUorcFcxQjlTbCtpWmQzWHV4RWJBZktBVEJOaXk5QUc4Zmo3YUJnbzRnaUpSb21LMy9yS0tkenhadmpjaXFvN1poRnlCZ2lGb3lINGp3QzZhUERLb2hGUTB4ZzRrakI0YjgyN3I2Wmwwd0tlZzRCVkZ5MC81S0xXVGNTRmdMdHh0cUZiVTBFTWVPeUhSc1ZEcGxRN3o2L0dEQmNiZzFjTDM0Y3pUTUtlZzRReUl5Qkl3R242U3EzQnBkNGkreHZtUTZFSm5kQkJTUDFUOGE1aFIwbkZGOXFjSG5lMmROeUhHMUFNaU5Iemw5VWUwOWNjNG5VRVJsTDUwazFueXhVNEZ4aXVSZUtEdDdXYjJ4NFVoRWZiZ3cxMmprU3MxRVFVZmh4bmk1OFhicndGdWFJeWx5eFZpY1VteVY1NitwbFp1T3RzczVJeTAzcFNBcnJQUllwQ041US9QTmlOWUU1bTFkYTRyOTd2cVlGYlNYRytQbHhqbXRZeFowb0s1ZFJONEplWm5xU3NOMVhSaEdaUFhWR1pGb1k5Y0RHQ2pDbzNESjd3SmxUK1QzYnZ0QnRvZGQzeEhBZkdOQ3VSRmUxZ2xHVVBEVWhVUDdxMmQvdTBOYmpJNFFkQ0RjZWdKMWQvNzdyVDJhODZlT2NLMUYwQkZrdFJJb0RHanNuamwzVmZlaXhyclZFT0p1dEIwOExQRFNwUjFwVGhzM0Z3d1owQ2Ntcm9WYnIySlNRZzlkcThBbVlUek02aTBuSEVmNG9TUEkvQjBzRnNTTTN3NGRtS3BHNWZSbmhJNFd0WmRiZTlZS0luaVJnKzJBMkxqM2xGNGlZUnVpQmF3R3hEN3hqa3p0LzlGbFgxWlZaOXQ0UllNWUFuNXg0U1FkclNGd2ZJYXNEVHFTb3BVbnA2QU5NTjRDNUEzdUc3RnRldTJBTUl2K2R0UVFvUUR4b3VNSG5UNmJEM3lwemw5dDBwOGhDcHNidHlpZ1VyQ1JpdnpKOTRwandsWjFha0hEYmtpbW9kaW9UaU9GbHc0SUdYQUUvNHhqNkp2Y1cwZTBTQkpxRi9qT1l6V3U0c00yY1g0WWRIV210bDY5dHU2Z0hwZGl6dkpnR0N6T0MyTDJNb1NXSGpvQ3JOdFo0WXNvSGRueVJqU1RBVWRvWUtFcXhzMkhMNDBVS0REUHZSbmEyTzlYMzlubm1zSkVBeEdkUjc5NHQwU3ZDekZQSzhyMnkvSWdpcU93d21xOCtVbFozRDVSRXpmRkVEZGNJZ2dpU2tlS0djTTd4Vk1pVzNCbmRwcjJvekxJUDF5ZktSRVQ1MllkRk9XMWtld1V1WGNjcS9aRlkyd2Z3VUJ5N3VZb2plT0hxT0dsWVQ5MkhhOVdpeDhvaWp2YjBUTmV4Q3lENnBGQzZvam9MR003NUtrUGM3ZTIrZVpEMU9nMURMWVh6ZXhoSVN4RXg2VVBqUW42M0Jvc25SMHlidHZja3dtL2orT2JWampJdGVESmVjbTRiMFJ6SE5mMG9zRnhrN2JyR1U5aWhxaWlmV0VSMVE2ZHVxQWpsSXp0c012RDR1YkRROE4yNE9iakdHRkxwaFFNVW1OeTA5WDR2SFJYOFd3NWN0YjMzdnFZRS9hSmZTUDZ1dVdQSWQ2UDlwL1I3MmVPenZZZFYzM2pEUzFtaUJGanZJT0pzdUszN3hvMlFLM2FmRnpYaWxod2J2R1FqNDVwUWVPSmFrbVBCUnI0RXc3d2w5WkhqaUFxTDJrckhOT2M0cUhxN2UzbHVoQ1lVM3BPaFFGQ1JNWUIzeStkTjdhZGFGRW9zQTJ2ejFOaU96T01LR3B1NU5sMTVTTTRlTzIreGpGaEZDQitnOHdTT2xnUTRSbWh3d0JQZkJ5dnZOUWhnMklrb3VWbjl3dTZheHZDK2VIc1F2MUE3SUh5QzZxaTVvcXU4clBUVTJ5UEd3VUVRb1lYdHlzczJBN1NraHYybkE2NGI2UWNVYURNNG5XeUxSQ3o5Y0haUU04ZDR2aXhST3NoaEVqVHJlWEFxaGI5cm15RDZxckV5ODJLeEhuK3RlcXlYeFR1TkZpblJ1N0tkQVV4eTNsMktoSGJ3UCtjUkNob1FpaG9RaWhvUWlob1FrRVRRa0VUUWtFVFFrRVRRa0VUQ3BvUUNwb1FDcG9RQ3BvUUNwcFEwSVJRMElSUTBJUlEwSVJRMElTQ0ppVHU4RDN1dksva01LOEdpVnVLcmYvR29IamNhRjRWUXN0QkNBVk5DQVZOQ0FWTktHaENLR2hDS0doQ0tHaENLR2hDUVJOQ1FSTkNRUk5DUVJOQ1FSTUttaEFLbWhBS21wQXVJbWpNZ0lvNXArMCt4enpkTDZ6Wm85L2JnY25sc1U0MHdIYXQyOGFFODE3Qk9TMzk5UTdiYzRzbExsNXQxdWVGMTFnbkxxWlFmV1h0QVhXd29sWlBvcjcwb1RHK3Vhd3hNMnA5MHczOTNadWZsT241dHEwM1l1MjJFM29PNzNsVGNpTitYREp2dG16N3RYVUgxZmJTS2ozcFBTYTFEd1RtM3NZYzQzWVR5cU1nWXI1d0wvenozTHRVL3BDMHFGMy9yY1oxeDdsaVh2Qm9YTWN1SjJpSWVObjdoN1J3Zi95YkhXcmh2Zm0rU2VFZm1UcGNiVDd3cGRxNDk1U2FVcERsTi9YdjhjbzYvWW9KNmFOQi81UkVkYW0reWZmM005OHBVbGNicit0Q0JMeUkyZ21JR1dMM1FrTnord0tCaVBxejFiczk3Kys5NStkMENzc1JGNEpHUkg1eDRTUmROYS81UzVtTzFOTUtCK2tJalFVQ3grZTFseHY5Zm5mbzFBVlhLM0JuZHBwdm5tOHZFWEh1cEdHK2dnVDZwU1JvUVplZHZhd2pKTGIxM0lMeHVrYUpoS2pCenhkTmRweWZHM1lsa09oUjZIQ2NUbGgvTHdWaCtLQTB0ZXdIOTFEUTBRUmlHcFhUWHgycnZLU2VlOU0vK2d3ZG1LbzI3RG10RnhIZmNXTTlBSEd0M2VZdUZpOFJzYVRpZ3ArZzdTS2tXZFJaL1pMODFvUHczOWh3cE4zdnR4eXUwZ3VZT0hKZzJJWEFETVRzSnN5SFgvcXdVelVLZThiYkFlZGs5RkY3djZnTktENElHK3ZBUDAvSXk3UmRaMmhHaXUrOTIwMUh6YkQ4ZzBOcXBFZWZLcUtXNkc4V3Z0MXhXeit6RTNRa0lpZk9BMzU5UnRGZ1h6dWtzOUV6SGc4YURSTnBuQ0RDMk4xa1pEN0EvS2tqSEt0c085SFlyVnRUMTJwbCtpVDZYNjRDbzdZd2l4R04wRFBuNjFXRElacHpodjFCZ3hXUlg0NE4yelo3VldSSU9yS3hKWVU4Tnl1VmdyNWRWSjYvcGkyR1hWWHZGb25RZ0VSMDlpcG1pY0xQUERpbTNiN0txbG9ibDhNTVd3UFJuNnE1cXY4K2UvR2FmZzNVK01JNW9HWWhGTFJhdWVtb0ZpZWl5NVAzRlhnU0tIdzJ4Q3dOSnp0bWpzNzJpNHBvWktKaENWRkR1SklHUTlURi9sRUw0RE03ejJsdWVHRzdBRkhRMnZBa0ZMUk8yYjI5dlZ5bjVSQUpJVlR4cDVLNVFFUEs2ck9SRlhITEF2Uk43cTFtVGNqeGlRMnZpeDhvVXErK3MwODMzRjU1WXJMK1RGSi9zQmNBOWdEV0l6TXRTVWRxV0lhaVllbnEyZmxqUGRrWDBzVUZEYStIRGhQa21GZHRQdTRUbjVuV0xNWUozOS9pcWEyK1dtd0Z2cmRydEUwZGxhVTdSYkN0UCswOHFSdG5rdm9iazV2dTgrOVdxaTdVdC9zTXg1cWRudUluZEtmVW9EbkxFYWlCU2pwSm94RFJEbEh6d3BYMjNhOFFxRlBHd0NwbWM0UzNBeDAxRUIxRWpiUWJhb2JXQ04yK2N5WWpOVkcvMXRVM3Q5c1hqc05hY3ppbEJyMTJvQUFVRXRKSnNod1FZVTVHKzBNMmQzZzQ1VlhkSXJOMUgvRHFzRGY0RFpnOU1kYzJLeUFOUFhOdm9XUVR0SisrYTRqZjU5YklLMW1PbjN5dldOY09ialMwZFkrUGpHSVhkMmNncmtmYlNiWUJmamFZUXVHbE5vQlhGbUIzbkpEYVFmeThSR2NVZ2tDWmpSTm52VWZtYzVmdFU0Y2tqaU0wUkdQT0dpRFA2MVF0TzQyd00zK09USVJUdzgwc0hHdVh1aG5ZQ2dnWTZ5QWpna3dKc2g2UFRzc0xlRDdpdlZkK1ZLb3RqVnR1V01TUGJuL1VBT0g0YkxGS0ZQUnRadDNPQ25YbTNGWDF5Ky9mbzIrK05MQkVsTWozZ3NFRGtuMGo0YXhlMWV4WEVZWHRCSTJocUJDbWdQZkZlWm0yZ3BQdWJYU0xRMnl3SDhobGUrbTR3TEhJQUNjTXZqTGJJYXRnUzArMzFnQklJWWJhZUJTdjM1bHo0bkVqYUloVk9rdEVMTGhCa204RzU2KzJldG1VeEY1Nm5JWVpTZm1oNTFBd2QzMmJRWVlESXNQNkdLbUhCaUlFaDFTZ2xWRnQ2VHdNR3dYNGpaZE9JTEVvVXdvR3FiekJmYlZmbDh5S1hZTldmRG9zVGpDTlNQUDFrM09pNVlnQk1INERUQzhhckY4eDBBYzNDSUp3OHNGV3JqUmNENWdiaG5na0JiaDRWcUZLNzV1Z2g2ZWlNT0U3cTFnUjdVUmtpTGFJc3VaSTcrVGJqNXkrcUY4aFptd1QwVjB5SzlaOVNDTVR2bHdHWE5rSjFoeDVVVmdsWjI2K2Z0YWh0T2EyQWh1RkhZamthU1VpSGoxenlTZUlTTllDWWpWZ0d5QVFHWjRxMXNQNlpJdzBBaVhhbXNYN3BiRTlqQXEwRzdxS1FnS0syd1pPb1FNSkJjSzZEM2grS1N4dXZuekppay9WcnpiK3pXYWhGa1BPSElWRFA5bnpXWVgrL083OGdYcWNpendsWXg0WEE5QkdRZTJHaHdZWW9hUFlHSlNSY3hLRlJPREZwcEYwa3RvS0pST0FmU3hiZjFCSGZYU3VtS09rUkZEVURtYkJTbTViUU03Nk81T0crWTVSUnRkWkc1VVFLZlpqVGdmaUZRVUhBNkZrSHpnbWFRdmdPeWRmTG85R09VVnZzVkRZWDdLeGJiUkRsaHMxRHZabHRUallkenozY01aRmhONTF2TWJQYnBoVFkrYWJMS210WU5KNFlsL2dzVVhNZGo0V1ZrSkVqb2lIYUFneEkzSWlqeXplRkdOUDNOS0tFSjlFUzRqZkRMYVBqaDJ3ODFpTkxtREFXc0NzWUlRZmtIRWtadEE3Q1N1RDQzemkyL202c0sxWU1rTWZMejdIZVRnOWo4a0lIYVhHSUNJZmJnZ0dFT0hpaTZlMDVvZjNsOWVHbEpiQ29DT0lCamdOcmtma3dyNjNINjNXdGdEaWgzZisxKytPMHlKQjJnMlBoOEZybzBwSDR4TzFDSTViSWg1K2o4WWxmZ3Z2YXBkdHdINmt3MFhFYkhkTUtCaFNtR3R0Y3RUWUY1NnpsR3YzOHVPVC9jYXR5RU1JK0I2akJ0MDZuSnpTb3hSMENCeHJxMGJGbnlLaVNIU0dVUEMzZEU5TEZnQkNRVUg0eGJzbGZ0dHk2emIyOHBTSTNIQ3B2aEh4NURPeERJamFFTFdrMTdDZXVlcVhUSTNkbUJDSVVCNEloZ2pOejA0S2lNSTQvNmVXZmVMM3VSUjRxY0hzQ3AzMVhFVFVhQ3czTm4vdE94Y1VTSE42VUJnWVpNMUhRZHVBRzRvcU96bWg5VkRSTUlKWGhKZ0FCZzJKZDRSZy8ySEdIWDY1Vm1sUTRjYktkK0VlRHhxbWR0RlZ2dnY5MWk5MEdnL0NsZU9VUW9PVUlrYjVPUlVZWkNHR0RPaWp6OVBPTTZNZ0lCSmJueFNmWWZMM01oVFdXdWpzOWdkUlkzeU1lVit3ZG1aQjQ5cWhJQVhxbm84RnVyVWNXTlhTYWlRM0tOSjVRTFR2VXVPdzI2Wkc1bjlPNnFSMDFZY0tLR2hDUVJOQ1FSTkNRUk5DUVJNS21oQUttaEFLbWhBS21oQUttbERRaEZEUWhGRFFoRkRRaEZEUWhJSW1oSUltaElJbWhJSW1oSUltRkRRaGNZZnYwZUI5SllkNU5VamNVdHoyYnd4OGdpNGVONXBYaGRCeUVFSkJFMEpCRTBKQkV3cWFFQXFhRUFxYUVBcWFFQXFhVU5DRVVOQ0VVTkNFVU5DRVVOQ0VnaWFFZ2lhRWdnNk1UQnFQeFF0TGY3MURyNHRwa3IydS8vQkxINnFTa3hjYzE4RjNXQWZ6Y1VmaWZEQkp2UnZZbjl2eEVIL2lhblpHVENhSmlkWXhiUyttUkhhYnFoZnpYV05hWkdDZW5qaGMxdTJzMEsrNVdhbGhpL201TjNlcnV2cG1OVFF6eFhhcVpmQ3oxYnYxNjN2UHp3bDVYeWlvb2JMc0IvZFEwTkZrNlVOajFJOS9zME90L0toVWpjOUx0NTB4RldMQlhOZmd5ZnNLSWphcktxS3B6SUc5YXZOeDIzVWVuWGFIcHpteGNVeFk5OVYzOXFtZnZyVmJyVmd5STJxenYwckJab1NPUVRESityeHZqbEMvKy9pbzJyUy9Vay9tYnVYTlQ4clVwZm9tdFdENlNEVnVlSHJFN003YjI3OElLSktQOXAveFBNazcxc014cnQxMlFoL3pEMmNYUnZYYUJSUGxZYXNvNkE1aTFvUWN0ZjZ6Q25YaTdHVmJxN0Z4N3lrMWRrU21XalJ6Wk1UMithZWRKN1dJWjAvTWJTZThpMWViZGEyQlFyVG8zdURzRFk2eHJLcE81UTN1U3dQY2xRUnQ5WUg5VWhKVTFZWDZkcC9Ea3pyOXhzNFBydDV5UXUwOWNjN3Z0L0RKc0JSekp3MVQ5NC9MMFlVRVViUi9TcUt0SDM5N2U3a1c4MVAzRjZyOElXa2hSVDVZbWVVZkhGTERCNldwRng2YnFHc2kwb2tGSGF3UEZLOGJDSWpadW0zNTdiV21tMXJNRUpvdUlQUEd0dk81NWhyQnp2NVlnV0RkemhHRmltTHVRcFlqbE5hK214ODBSMjFFZElqcTU0c21hKzhOMy96MDYxdmJaUnljQ3BEc0I2SjF5ZzQ0ZlM0RkIrMEQwc1U4ZEVlQmFQenk0NVBWeWsxSHRXQVJoU2ZrWmVydnFpODE2TWdNOGM0Y25lMzNXYkRBZ3lNcmcyMTVpZktoRXE4TlBRbzZnaUEvREJGRDBIZ1Z3YUd6UThScjkxa3cyWk5sN3gvU0hoeVdKaHE0MlJ3S21rUVVaRTlRV0NLWll2UnFjem9qSE12aEVqbWozZVdNREF1eUp3Q3BPK3lUZExFSUhVNDNiaUQ2SnZmV3IwamJpV2NPRkRXejAxTkNLaXl2ckQzZ2w0bkIrMGgxcnBTZHZhd2FtdDBMeDlDTUZGODJ4Y3Y2SUZvMVNKY1dkS1M3Y1pGZEtQL3FpdHAxdkZyN1dCSFh0S0pzTlc2RTh3MnN2ZHlvWDBjT0NjNmZJdW9qeHkyZE5PSzVrY05HNzJkS1VxK3dPNFRlMkhBazRIWEMvc1Q3ZTFrZmhET2VoSUlPY0RFbHpXVytNZWFXdk5lTHY2MzBLMStrUk1jSlJDMXBPMFF1YzQydzVYQ1ZYc3lZUDVNSWoxd3lmaWNkTXdKRy9vbUE0WmtoWEhQRHNyN3BocytDUktLWEV3Vm1VUDlrdjgvMmw5YzY1dWp0MWdjb2FMUWNVUWFkSG1CZ1dsSlkyNWxlTkZndjB3b0g2ZEZ2RXFVQnFtRno1TEtMWW5hZllSdFk1QmpOb05Bc2ZxRElkcnpISTFPSGF5K05KUkpNS2NpeXRRbE9nblphbjRMdUFDUXFacVFsaHJVZGN3UzE4NHgya2Q3Y2V3aUIvdkw3OTNqcTNmdU9FYkhSZGU0MHFnNmZZelJoTUdDc3Q5UFEwNjVJWEdZNTBCR0J5QWd4NVEvcDJCd3JHblFiOXB6Vzc1OTVjSXlPeEJqTDRRVUlMOUFRVVJTTVlMcStmL0Z1aVhwdDNVRXFPWjRGdmErOHRxMktIQlJTQmlBY2tJbEFZWUozUjNTSEY0WVBqc1FUTEtHeXZiU0tTbzVYUWFPS2xjSDdxTUpEeVFDOHNHWlBTSkVaZVdQclFDVDRYdndObndrcmNqdXlQbDJwSjdCVGVXaUlHVldzRE40UDFUdWVPWGMxNlAyYXgzTTh0MkI4TzkrTDhkRHcxVFYxalZya2tYNzZCRGJMYWtYa1dVbW5YRGhTaTliT0lZdzNjY0p1ZlFvNlNyNFZUNmRnVUwrSU9WQmF5NjZ4QkxzUlRFU1QvVW9yMzJtL0VCb2VvVUpuQ2RKdUdKSnFUZG1GQ2dvUUN0S0xmOWpyM0hoMXlKZEx3OVVyd2E1UFFRY0pudUhiY2F6YXp5TmE4ODVPQWxpeTRsUEhkZWFhckFvaTMxUExQdkg3UGlNMVVlOGJ6eTJpQUtFQUJIcFdFQkVaa1J0ak15QnFpS09rNG9KNmRuNTRBNDRXenlyMDFRNTJvSkE1RlJ6bW9XTU1QQVNMNS9pUXpVQUQ4TkZwZVFFekFLaitrWFU0WG5uSjluc005VFFMQU51REtCQlZDM0w2NjF3c0lqdVdpcG9yS3F0Zmt1ZElDMUVqZ3M4cEhxbyszSGRHVzQ5QUJLb3RjQnd2THB3VTB2V3p5eXYzU2V5cHJqUmMxNjllMWdmV3pxUllwbHZMZ1ZVdHJmWHhocGc4UUR2dlNFZzcybWFTamZrc0I4Vk1nb0hEUndrRlRRZ0ZUUWdGVFFnRlRTaG9RaWhvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNwb1FDcG9RQ3BwUTBJUlEwSVJRMElSRUNOKy96OWxYY3BoWGc4UXR4VzMvYU1ZbjZPSnhvM2xWQ0MwSElSUTBJUlEwSVJRMG9hQUpvYUFKb2FBSm9hQUpvYUFKQlUwSUJVMElCVTBJQlUwSUJVMG9hRUlvYUVJb2FFSW9hQi9yZDUxU1MzKzl3L2E3WDIwOHFwZkc2emNkZjE5eThvS3FQSC9OOGZ1eXM1ZlY2aTBuOU56amJyeTI3cUQ2dUtUU2RWOEE2K0NZc2QrT0JPZUJmUVk2dm5pbFp5d2ZIRzc2dFNibkN6K2phTERmWE9BbnF5L3IzOXcvTHNmM0dVUzZjZThwTlhaRXBrcnEzZFB4SnY5czlXN1ZQeVZSL2ZMNzk5ak9MMzcrY3BOYXUrMkVLcXVxVXk4dW5PUjR2TnRMcTlUVnh1dCt4MkFIenV0M0h4OVZQL2xlY1lkZTB6YzJITkhYNmVlTEpxdHh3OU1wNkk1a3c1N1QrdUk3a1p1VjZoUGZyQWs1YXYxbkZmbzMwd29IK2NTN2N0TlIvYnJvM256SDdlUVBTVk5QM1Yrb0JiYnMvVVBxdVFYajI0bC82cWdzWFNnT1Z0UzJLelRtNHdYenA0NEllRzViRGxmcDE0eTBSTnZ2VVJ2c1BYSE8wM1Y2OHI2Q1Rpbk9UaWRvTUh4UW1scjJnM3ZhMlFORVZHc1VIem93VlYxcHVLNDI3YS9VZjljMzNkQUNoQkNQbnJta0Z4UUN1NXMvYjBxdVhoOVIrSlcxQjJ4RnZYaFdvVnF5NGxPMTVpOWxmb1ZHamdPRmIvYkUzS0RFaGNKa0I4VHNWcGpOSERsOTBmTStaWnZKQ1QwcDZOc0p2T3VaOC9YdGJweGRGTGYrRFZGakFZakVUamYva2FuRHRhWEF1bi9hZVZJdG1qblM3L3VjakQ1cXdmU1JLaVd4bDkvbjhLTVFPU3pMRTkvTzkzUXVPRVlVVmllc2hkZ3VncVB3b2JCYWp6T2Nna1JCZHhCYlM3L1NsdUM5NStmWWZtLytYQ0s0M1dkdUlPSXVmV2lNZXZFUGUxVld2eVRYMytGWTdIanMxZi8xdlVmaFFlUVhwTkhhTjdtM2ZxMnJiMjdYa0owNGNtQkFnWnJGakpyRUNyWVpLTG8vL05LSEVha3RLZWdvZ2t4RzN1QytLak10cVYxalRmeHRJT0RKelRjTlZiTlRKQlhST0gzZko3R25hODF4cWI1SkwxYmNCSTF6TVl2WnJxR0xRbUVIQ2hKcUg5UWsvVklTZ3I2K1R0dWxvS1BFb1A3SmFwc1J5YTJOTW53V0txaWFuYUtTUkRtdlVVdHFES1Qya0ExNS9lbHZhUnNqbVpabmY3c2pZTlpuK1FlSFhNVXNCY0t1VU9EM0VQU1Vna0hxaDdNTE82WGw2RlFkSzhoMG5EbDNWWjJxdWVxWGtzTk5uRHRwV013Y1orbnBDenBLaXBoQlEzTnJ3M2JtNkd6SDMwSE0ybElZdHNoSnpHNlVmM1ZGdjZJV1k1WWpEc0JOUnZTUmxCajR2NE5WT3ZOZ3RTRm13U00zRzJ5akxGU1FGNGZOc05vVUtZUldtK0praTBMaDdNWFdqcU5oQTFNcDZIamg3OFptcXpHNTZlclZkL2JwdngrZGxxZGZrU0d4QTVIUmEzb3NFaHlydkdRYmlhc3ZOZWhYcDRJWGlTeVJaSG9DV1JzejA0cXkxYlB6eDFMUUhZMWRxOTFMU3g0cFBITTJ4UG9iTDl0d1c4ZmFJeWZWUHZMaFpvNjNDUjNyT25YaFc3TWx3V1JIOXBYWCt0NTdhUlFpQTRPYUpEV3BGeU4wUndKdjdOWTlic1VxcEVBNFpUQzhaZ3lzSFJobTRacHRDR29KTlBic3NpRk8yWlZnc2lOU2tDUzc4dkxqay8wOHZGMmh3WHBUQ3JJbzZJNGswSmlKY0hIeTBwSXh3RTFmZUcrK3ArT3dDdGRxUS9LeisvbGxRNXhxQXFmdm5VREh6NjdqMWZyOU13K08wWTNMUCs4NTdaanBrRjVQRk9aNDYxS1BLMEVqR29aUzdac0pWZ3hPQXBHOE5tNDZCRkpUMXhpd1E2VEIrQjNPQVFYaGhUVjdkRmM2b3FTa0ZlL09qMDZlZC92UmFsM3c0SWRSOExBL0ROaENXd05qVkp6T0RXTkUyQ2lNRXNoY0JQSjlFSmRUMmd1L2oxVGpEOTNpRW1tUkQ4YllEM1IyQktyMmtkTmVzV1NHWGgraS91bGJ1OVY5NDcraDMrUFlvOVVkTFFWbTNJaldhSXVCV3RqbnlvOUtWVUZPUDcrc2lmbmM0bkhBVTF6bG9RdHkrZ2RjQjEzTmRrdWtrSjQ2UkZySkIwUFVFQUErUjdlMEcxZ2Z3MDh4SmdSUlV3cEN0UExrNkxxWEFpTzJDQVVIMWdQN3graENHUnR0UGJkNEpLWWp0TnhrOFo3NEd4Zi96dXcwblQzQXE3V2g1alJnWHNaUGhHTXozdnlrVEZmVnVPRm9WRWxrRTFGTHBNWUFKN2VlUElua0dPUWtZMEpnV2FMQnFzM0hiUXNNeEkxOXl1akM2VVdEZlIwM2l4OG9Dam5YVFVGN2FQRGh5UTdoNmRlM09qYkN6S1BxSWdXRWpPR29HR3N0SFNMLyt0MXg3VElFWmxIakdKeUdvSnEzYSs0QThsb1FnZ0hYVFJwM2R0ZEw3QkgyTGRjTmtkdnFxeW5vQ0FzS1lwSUdEYUlLSWdsNnU2eWVFOVcrMCtENmRUc3JYTVV1RWRoY1ZjTkR3bE5LTll6UmMraGVkeEtjV2RUQitIQjQydi80NHo3SFlhdWhXZzJKL2s2Tk8zUzJvQkNad2ZYRnRZaFVvYUtnYlc0OEl1UERiVDVZeGl4REFHaGdtUzg4QnZjN05XU2s2blZLcDZHQkpoRVlRc09RVWZoYzdBOURTYTBEK3QwOHN2YldDVDBjMTVmaG55Z2tFcEZoWVhBTU9MZHdCWVh6V2JiK29INlBjN0JlRTJ1dGcwSUZ5NEV4M1RpdXpRZStWUE8rT2FMZEkyNFVkSVFhWUlpTUVvMXhveEhSMEgyTFNHaCt2czl1ZkxINXUwQml4czFIZEVUa1FtTkpiaTR5RVVoOW9WdmFyZVV2RHlFSXRaY2IvYXdUaENTV1JIeTRDQmNXWnVtOHNXcG9Sa3JZWXBiemdWQlJJTTFSZTlmeEd0ME9rRFNvZWN3MkNxMjBFeERkc2FCbVJIYWtPQzh6THNRZHM0TEcyR1pjV0lqTW1xV0F1UEg1aUt6d1I0M2htVU81K1ZMVjQ4YWhvTUNESW9wSkppSVVNRERxL25HdGc2QlFxOGkrRU1XdEFyRVdGcnZuQ3QxeThTQzliNEl1Z0dZL2pzQ0E2Q3RqcjdFTlJHQ3JmY0o3ZExaZy9NdmIyOHQxWnd5R3VXS1J0S2hkK3lHVzZOWnlZRldMZmxlMklhWU9ESkZtN3hlMW5sTnVpTXh1NHhuazJVUHI5ckNmWDd4Ym9sNTRiS0p0QkVKVVJYUkcxekc2clFQbHNxMWQ1WTlPdThQWHlKTEdyWnNQdHg2elpCNWsyK2J0QldwN21QZUI2NU9kbnFLamJUQzlxenVQMWFpS21pdTZnTUNXUkx0bk5tVGFacEtOV1VGM2RPR0o1YWhEdkF1YS96bXB6YitTemdFRlRTaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0VUUWtFVENwb1FDcG9RQ3BvUUNwcVFnSUp1dWRWeVE3L3JSbTJUT0tWTnU0YVdiM1p2YnI3ZStnaEd6d1JlR0JLZnRHblgwSEpkOTdvTFY4cjFYOGtEZVdGSWZKTGMrczh2b2VYdTVjZFB0ejRtblRxWUY0YkVKNmxEOUl1aDVaM2QzMXIrN3ArYm02NWZWTW5wU3ZVZnpvdEQ0Z3RvMXRBdU5HeG8rWVB1ZFJldm5QeDA0KzYzOUplWmhVb2w5ZWRGSXZFQnRKclorait1b1dGb3VjZGRDUWxYRHV3cTdUMTZZa0dmakt6K2Q2cTBieWgxNjZaU1RYVzhZQ1MySS9QZ0NmcnRYdzlYZlBCZnovLzJYZVB0NXoyTzdGN1o4czd2TmpiczJMeXZ2bWo4eUY1YTFIME1rNTFrV0pCdVBReHgzMUNxNVd0ajNSWmVSSEw3UUdxdVYxS3JYODRjcFZTLzF2K21XbmJrNUo5Zi9wZmxmN3oxOWExZHhwK1g4WDg1OUJlUHpmalJPT05sMUZOTEYweWFNZXZ1ZjB6cWs1akZxMGhpbGNaclRUWGIvdmZ6My8vUGY2MzkzUGp6bUxHVWFOMmJCTjNOZU1IOFhhUDZwQ1QxWExSay91UlJZL01tOVV2dk96d2hvZmVBYnQwUnJnbTVQYlRjYXZtNnVmbjZ4Ym9MVjA0ZU8xaStaL1hyNjNaZnEyKzgyU2JtZzJJaGZJSVdER0YvbzAzWXFieU1KSWE1Mmlia0wvMmN5ZCtuMnVvV2ZZbERqUVgveUd3QTJwT0s0ejdJN2VVV25JYXhYRFNXU21NNTAvYVpILzh2d0FDODFiNUhaZkt2dXdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZ1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwib3B0aW9uLWxpc3RcXFwiIHYtc2hvdz1cXFwiaXNPcHRpb25TaG93XFxcIiB0cmFuc2l0aW9uPVxcXCJleHBhbmRcXFwiIHYtYmluZDpzdHlsZT1cXFwib3B0aW9uU3R5bGVcXFwiPjxkaXYgY2xhc3M9XFxcInBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImlubmVyLXBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm9wdGlvbi1pdGVtXFxcIiB2LWh0bWw9XFxcIm5cXFwiIHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj48ZGl2IGNsYXNzPVxcXCJub3RpY2VcXFwiPjx0YWJsZT48dHI+PHRkPjxzcGFuIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwibm90aWNlLnRpdGxlXFxcIj48L3NwYW4+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PGRpdiBjbGFzcz1cXFwib3B0aW9uXFxcIiBAdG91Y2hlbmQ9XFxcInRyaWdnZXJPcHRpb25cXFwiPjwvZGl2PjxvcHRpb25zLWRpYWxvZyB2LWJpbmQ6Z2FtZS1kYXRhPVxcXCJnYW1lRGF0YVxcXCIgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiPjwvb3B0aW9ucy1kaWFsb2c+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxCZXRBbmRCb251cy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTcxMzhjMThlL0JldEFuZEJvbnVzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmZvcnplbiB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDgwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5iYWxhbmNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJvbnVzLWJhciB7XFxuICAgIGhlaWdodDogMjAlO1xcbn1cXG5cXG5kaXYuaXRlbS1iYWNrIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyBkaXYge1xcbiAgICAvKmhlaWdodDogMzAlOyovXFxufVxcblxcbmRpdi5ib251cy1pdGVtIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5iZXQtbnVtIHtcXG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuZGl2LmJldCxcXG5kaXYuYm9udXMge1xcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duIHtcXG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1udW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1iYWNrIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5jb3VudC1kb3duLXNob3cge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgaGVpZ2h0OiA5MiU7XFxuICAgIHdpZHRoOiA5MiU7XFxuICAgIG1hcmdpbjogNCU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MTdmNTY4YmZcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyR0E7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxnQkFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxrQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTs7SUFFQSx1QkFBQTtJQUNBLGdCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLGdCQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0EsbUJBQUE7SUFDQSxlQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxXQUFBO0lBQ0EsV0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJCZXRBbmRCb251cy52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLSDlsZXnpLrnlKjmiLfnmoTkuIvms6jph5Hpop0g5Lul5Y+KIOWllumHkemHkeminSDlvZPnhLbov5jmnInlgJLorqHml7ZcXG4gICAgZGl2LmJvbnVzLWJhclxcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYmV0XFxuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5mb3J6ZW5cXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvd1xcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJldC1udW0odi1iaW5kOnN0eWxlPVxcXCJiZXROdW1cXFwiLHYtaHRtbD1cXFwibG9ja21vbmV5XFxcIilcXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmNvdW50LWRvd25cXG4gICAgICAgICAgICBkaXYuY291bnQtZG93bi1iYWNrXFxuICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLXNob3dcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLW51bSh2LWJpbmQ6c3R5bGU9XFxcIntmb250U2l6ZTo0MCp6b29tUmF0ZS54KydweCd9XFxcIix2LWh0bWw9XFxcImNvdW50RG93biB8IHRpbWVcXFwiKVxcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYm9udXNcXG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmJhbGFuY2VcXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvdyhAdG91Y2hlbmQ9XFxcInNob3dNZXNzYWdlXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuLi9qcy9yZXF1ZXN0LWxpc3QnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICd1c2VyQmV0JywgJ2NvdW50RG93bicsICdjb3VudE51bScsICdiZXRzJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgdGhpcy5nZXRDb3VudCh0aGlzLmNvdW50KHRoaXMuY291bnREb3duKSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBiZXROdW0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMyAqIDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XFxuICAgICAgICBnZXRDb3VudChmbikge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldENvdW50KCkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoYXQuY291bnREb3duID0gcmVzLmRhdGEuY291bnREb3duXFxuICAgICAgICAgICAgICAgIHRoYXQuY291bnROdW0gPSByZXMuZGF0YS5jb3VudE51bVxcbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJCZXQuaWRudW0gPSByZXMuZGF0YS5pZG51bSArIDEgLy/lvIDlpZbmnJ/mlbBcXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnZXJyb3InKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZm4gPyBmbigpIDogbnVsbFxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDkubDlrprnprvmiYtcXG4gICAgICAgIGNyZWF0ZVVzZXJCZXRzKCkge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5kYXRhLmVycm1zZyAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdzaG93VGlwJywgcmVzLmRhdGEuZXJybXNnKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcXG4gICAgICAgICAgICAgICAgdGhhdC5nZXRDb3VudCh0aGF0LmNvdW50KVxcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnY2FuY2VsYmV0JylcXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuY291bnROdW1cXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvdW50KCkge1xcbiAgICAgICAgICAgIC8vIOi3neemu+W8gOWlluaXtumXtDMw56eS5pe2IOS5sOWumuemu+aJi1xcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA9PT0gMzAgJiYgdGhpcy5iZXRzICYmIHRoaXMuYmV0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyDlgJLorqHml7bkuI3mmK/mlbDlrZfml7bkuI3ov5vooYzlgJLorqHml7ZcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dUaXAnLCAn5YCS6K6h5pe26K+75Y+W6ZSZ6K+vLOivt+WIt+aWsOmhtemdoicpXFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvdW50RG93bilcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93bi0tXFxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvdW50RG93biA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8g5YCS6K6h5pe25bCP5LqOMCDml7Yg6I635Y+W6I635aWW57uT5p6cXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdldEJvbnVzTnVtKClcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIDEwMDApXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbmltZyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5mb3J6ZW4ge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmJhbGFuY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S9meminS5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJvbnVzLWJhciB7XFxuICAgIGhlaWdodDogMjAlO1xcbn1cXG5cXG5kaXYuaXRlbS1iYWNrIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyBkaXYge1xcbiAgICAvKmhlaWdodDogMzAlOyovXFxufVxcblxcbmRpdi5ib251cy1pdGVtIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5iZXQtbnVtIHtcXG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuZGl2LmJldCxcXG5kaXYuYm9udXMge1xcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duIHtcXG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1udW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1iYWNrIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1zaG93IHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGhlaWdodDogOTIlO1xcbiAgICB3aWR0aDogOTIlO1xcbiAgICBtYXJnaW46IDQlO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU5JQUFBQnpDQVlBQUFEdDJWd0pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dSREE0TkRRMlJUTkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1JEQTRORFEyUmpOR016UXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tVMlFrTkVOMFpDTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1UyUWtORU4wWkRNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtqcVRnSUFBQUdMSkpSRUZVZU5yc1hRbHdIRmVaL25wNmJzMk1wSm5SWmNtU0R6bDJJdG54Q2ZoS25NUW1KRTY0S3NGQVFZQWlxYzFpb0xZcXl3YVdLbXByZDFtU2JMR3dMTEFzeDRaa2dYVVNTRWhDc292dEhJNFBKZmhjUjBxd0xWK3lKVm0zNXREYzNiM3Y5UndhaldaNnhySmtaelQvNTNydTF2VHI2NzMzdmYvNy8vZTZXMUIrZnhOeXdNalNSeE5wTFV0ekVyOFJDS1VDUDBzWFdUckswbk1zUGM5U0pEMkQ4TmtCZGFtSGt2VUFIMlBwTVphYXFTd0pKUXdiUzBzUzZWTXNkYkwwTUV2UFptYlVaZnd0eW9wS29HZUpSQVRDSkhCTy9DN0JFVEY5Z3g1cEppa200Ukc5aUwrbThpSVFja01uNEd1TUt3TGp5dGNtV2FSZ1JObEdKQ0lRQ2dQbkN1ZE1pa2pjSHIzMmJ0UnNOQWovd3RjcFVhSlVXR0tjK2Q2cjN5ZzNwNElOeSticVA2M2pVVGxGbTRXOVlTZjJlMXJRNFcvQ1lOU0JtQ0pTMTBTWVBWWkdrT0EyZU5CaTY4TDY4ZzdVbVlhMUpSNVExMW92Zm9hdC9seUEvWHJSOHgvTzUrMW1ZV3V1SFRoaGZ0dS9FZnU4TjBJUURSRDFPZ2c2cmdvRktuM0NMSUlDUlpZaHhXUW9VaFRySEcvajN1bzNZQkJpT2Zmd2haU1h5LzlpK01ONnRtNHk2ckZTaTBRLzd2NElPbU1MWVhHWVlEU2JZVEFab05QcjR6UVNpRXlFMmNBaFJSVmtjaXlHYURpS1NDaUVONE9yTU5CZGllMzF2MWV0VlRZdzdxeGdDek1ua3NVZ0N1NWN4Ly9kd0UwNHF5eUN2Y0lHczgwS2c1R1JTQlNoMHdsRUlzS3NJNU1zczJTVkVJMVlFUElIY003WGpHY0hiOElucWw3THVndmpUbFdTU0VZbTBnelovS1BlaUF0L0NxK0JyY0lCcThNR1BTT1JRT1FoekZhd3RxMFRlZEpCTk9paFowbW5GL0hXeUJwc0RCOUhuWEVvbTUra2p4c21kV0FwZTVTaGJXd1p6QTQ3ck9VMjFSS1JCU0tVRHFjRTFZV3hDbVdRSlVubHdzZU5yK2JLTG1wR0RFNHJpMVU1cHljU0VVclVRdkcyenpuQXVhQ1ZVeCtQVmVTSVNPaHJZU1U1UnloMXk4UTR3TG1nTlRxa1R6cFoyYUF6bXFEallXNUZLYXFidjNUaEVnYjc0bU1BOHhZMXdsWnV5N25kWGVORTdkemFhVGx2KzZGM2NMN3pvcnJlMU55QTF0VTNaTTMzMG82ZHFmVzF0NjJCczZweVN1ZUxoQ1BZOWR6cmw3V1AxblhsQTcvdTlxUG4xZlhXRlUzWStza1BadDJXQzF2dlhUL2xjMTlMY0E1d0xtanhRSzk1QUwwK0hwMHJNbkNTdlBUTS9rVGxJVlY1cDlvN0VRNUZjT1JBQjNxN1IxTU5vcWs1OThDYnlXekVvdGI4ODNmOUhqLzI3andNcnllVUlrZ1Nqejc4czl6a3kyaDhuL3Z5M1FVVGU5L090cnlOTjl2NUxxZnp5RVVRL2x2NzBaK2xDREtid1RuQXVZQzhGaW1YV1V2b3hHTERuS2E2MUhwLzcwQnEvV1Q3bVVtTkl0NGdjamRHVHJSQ2lIVDhZSHVLUkJ1M0xKMnlsU21Fc0g2dlgrMHNEdTQ3bWZwOTRlSmFXS3ltblB0MW5lbExYZDl6LzdVTEd6KzRhbHF0Y2UzY3Fxem5Tcjh1M2lrVnE2K1Vqd1dhMHE1WUF3eThFVHZLeldwbG5uaTdDN2ZlUGZOU2N1K3V0OVYxZnQ3VkcxZk8yTG5PbmVwS1dkdDBzcWZMckZ6WCtNUVBYMVRYZWJra2ovSHdvdzhVZkc1dUxiTlpmWTVWNjFka3RXSWJ0cXlaTnJKZWF6Sk5XZHFwTkN6U09FUGp3aHEwSHptdk5wcmh3UkdWWEdzM3I0R2x6SlRxeWJubFdMQmtudVp4akdaVDNqSTRmT0I0YW4zamgxYmhaRWZudUhWc3JNUERqMDFzckkvK3pialUrOXhYN3I2OGhwYnhCSm1qd293dEg5K1U5eHByRzJ2eDhmdHV3Yk5QdnBaRmR1VEdkVXNYcU5abTl3dUgxUHVzZERtd2Jzc0hWTDl6YTJMdXM3dmFpY1A3aitMU3hiajE3enJiTnk0L2R4MVV5MXk5aG9ZcXJOcXdva2lKVklCRlVqRDcwTFNvUVNVU3h4OStzeHQzZlhxelNxYmhBVzhxRHllUnpXRlRwVktTTkpjcnlYaFBuenhQWFgyRjJxaWUrTGNYVTQzOGl3OXRtOWI3bXRmY3lNam5WQU1OM04rcll5UTBtZ3FUVEZ5aWJ2OW1iZXArQzRHZEVjWTc2b3ZMWUhhZi9CNUhocndUcFRUckxEaUprdVdRanRNbkxzMmFOalhscUYweHowbmxEVG9KSGxpSWhNS3FmNUdzV043SXVTVm9QL3dPWG5vcUxsRmFWK2FYU0ZwdzFaUmozODZENDlicDlsVXBzdVVNalBSUERIUTQyWFZyRVlOYmdoOTkrNytucFl5MmJsdWYxeG9tTzRYMHNrd0dhc1psM1RLVUJLWXM3ZmlPU25IYUsyNVoxbXk0RHNGQU9HNXRXT004ZDNLOHgxemMyaGkvTjFrcHVMRHlSc1RTZW1STzFPdGFGbUtZRVNXek1VNklpajAxMGQ5UnBWNUR6ZFVwSkxudyt1WDNzKzMrcldxNUh0ajlWc29uNUdXY2ZyMjhNOXJ5MFp1WjVSOUoxY1AzdnZYa3RKVHZlNVZFK1lsVXhPREV1Zlh1aVc5SU92Ym0yNm4xaTJmN1dTUGVoYUUrejRSb0UvOXRnbTlSNzU2U3J0KzRaV1hCa3V1eUxjbTk2M0p1TzMrNmV3S2h0Zks2YTExNXovWHdvL2Vyd3dZbk84Nmk3ZFZEQ1BwRE9IMHk3Z010dks0R0d6NzRnVW43Y0JJbE93L2VNWlFDdEtYZExIdmtLR21kY2trVTcyZ29xODdYS29QYXVUVjQrTEg3VlovbEY5OTlXajJHNnNzc2JsTDNNNXFOYWk5ZGNBZkFROFI1eXR4ZGw1c0FYbyt2NEx6Y1B5eWtmaGN0YmNaQTN4RDI3aHp2aU9vYUt2RGh6OTZldmJNUU5NcXVXTnVUZ01ucXBSU2tuUnBOMjNjc0ZVbGF1bnJKMU82bHdESTR0T2RJaWtRYk43ZkNacmVxKy9IbHF2VkxDejVkY2o5TnYrVUhMeFo4UEsyOFcrOVppOVkxMmpNTlh0b1J0OUJkeklKUDhKVXVqdUtGWC8xUkhTTmFlOXZxOFd2T0xLL005ZGtzN1pUWnlTTzg5VVlIZkttWkJxdlZ0RExETVQ3ejUzUFl0N3M5TGxVVzEyRDlsalVUdHZOQnhIeGxNT1lidzk3RU1UaVd2YjgxdGM5US93aWUvT0VmQ3I3bSs3NTgxOVh6a1Fwd1dkcVBkazM0dTNWRlkrcTMweWZpRWkrelRIUHhxTmhkcEpLTTJ2SEduU1FSUjZVN0h0WWVHUnhCMnl1SDFQV2FoaXFVVjloVGVYanY2aHYxNDFUSG1SVDVrdnRwWWMvTEJ5Wklubk1uemlka21rbDlJSEs2d2NtV0MwT1hodkRTYjl0eWRnenBzSmZiTHZ0Y25PUTMzOG5MMWo4aHNGTVNLTVdvSFc5UTZiMW84ajU4STc1VWoxcmhjc0Njb2ZGNW1EeTV2V2xoUFNwZEZacm40Y1JNNzdXNTVFazJaSDdlbGV1V1RwSlRrK1JUSW4raFpiNS8xOEdVTlhqZ29ZOU5KSHZhdnJ4anFLMnZuckR2WTkvNHo5UTYzN2ZNWnRVODE1SDl4L1A3VURmTVIwbVlwRklNTm5Ebk9JbWFlbmZxUG54cGc1SGxsZlpKKzdscXhzZWZRb3hVK2U2ZkQ0cGVEbHBXWDY5TnBBS1V3THhGOVNraTdmajUvNkJwUVp3c2kxcm1UN1l5UXR4WDdPc2VuQkJzVWExMEFaWWtVOXBsUTFOei9jUk9MRzFzaksrckhWbEdQWlJXc0tHSXdSdE9FbFZwWWQ2K252SGZYZFhPQ1pXdWRZeGM0TExtdnUzWlg4QmtzaGdSRGthbS9kNFdMR25DSzM4NEV1OFltSHhOV2RDTUJwMStINW1FNExMdmNySDEzclZxbWFtK0paT3YrOUw4d2p1M2JXWXBMcWwvOU8ybnhqdUpaOXF3L1p2YlVHWXZtOVdxVDN1S1VCRkx1L1NHNDZxdVROMUg5N254NkpQVFhZR2h2cUVNSDZBNnJUZjE1TDEvbzhrd1laOU1YTHJRZDNuU3BvQXk1M0x6azEvY3pLenU4QVN5Ry9tVHpGbWtsR29KTXJEMjFwV1hYYmN1MW1razczVkN1YVZkODU2WDI5SjhNTE5LOUxkZVA0SmI3OXBROVA1UnlRVWJYbjc2bFFtVm1ld05mL2ZMbDlIYkhSK0FyYXN2eDVoL0RKNFJYODdqOEx5SDkvOGZWcTIvTVdlZWpzUHZNbW4yWm01bi9VdDM1cnkycVFaUnpwMk1keEptczVINWNYUEcvYnR3UkxVVTZSMEJ2NzdNZkJ3OTV5K3BxV1hWOVlYN25Xbld1NjkzYUZJNWhKak1UWFpndDkyMVVqMHZMNXREKzAraHBzNkZPVTIxQlFWdlpsK3dvVWlSYm8wV3Q4NU5yU2Y5Q283NmVkVm9lL1ZJVmg4Z1BjUmJpTHliNnJYbGtvcGE0RkZGTGVKbWRnVDU4bDRPa1hJZGkvdGxPMzZ4ZTBMbnRaUWRsdzh1SDJsN04zVWR2Rnp2L01SdHMxZmFhWXdrb1JqbmhyZXVpSk9uWm80YlMyNXNUdDNEMW52SHA3TXNhbG1JM2MrL2tlRTB6MUh6cnIxbFJXSWRpWkg3M0dYQWd4UHB4NTNVeUNyS05MZFBrb3BtZytiNVRHeDc4djZtcVpzdHFDeTFBZzJOL1BIMXRIeXRxeGFuN3VQbU85YWcvZkNKUkgyNFVMelBHbWh6Z2IreWVHNzRKOWFzM2VSM3hPL0RraWM4U2lDVUFvTCtBTDRoL1ZYMnp1M0JRS08yUlNyMnFRMEV3clQ2Ui9sOEpPSUtnWEJGS2xqVElzbFVkQVJDUVV6U3RFaGpZVVlsbzh4ZkZBNjlUcUNQdUJCSTJXa1JTVXZaU1d5akZJc2ZSYy9mR003ZlBLa1hTQTRTeUI0Vkt1MHlndzB4aVNXV054VGozOUFVMUozNWtpd1ZnWUlOV2xUVGVCMVhURmFnZnNlTUxSbVhWT25ITFphTzNoTk9tSTA4RXBTcEJ4c0toU3IvMkg5aGlmTk9VYTJVU05hS1VPUXlMc2JhdEpSWUJpTks0dFBsVTdGSVV4aEg0cm1qektlS3FtYUxXNmlFdFdKTGtac3VDZ1Zxb2tMc3czWE9UdFE1aCtGMmVHRzN4eDlPOVBuTUdQU1dvMmU0QXFlR0YyRlVxcUhDbWs3bzRzYUFod080MnByMHhJU2lGQkpzbUxuSUFiK2dDTHRBOVdFQ2RwWGNVbkZDY1U2SlBCSklRUXNWVHQxRnJKL2JoaHNXRC9HUGtTWitIV01wL2d5UnlXNkNlMDRRUzlDSFd3UHQ2RGpweFA2dWRSaFJHcWp3cGlUVkdIRlk0MHlxS2FrZ0l6SGxBZG5wbjJ2SEw1aGZlTG9ieGkyV2FybjRad2RMa0ZoMS92L0ZmZmY4bWJIRm9SSkg4bCtBdjhzRE9jQk1laXlhcUNrOWRGWURiSFBMSWRxcjBMTGNoNWJGeitCWHp5MUJkOW1IaUJuNU9uUWhRUmhPSEVYUmVrWXZOeGRtMmtlNlVpMGFUZHhWT0VHd3BOWFNKWmV6bUZ6VnZZL2p2Z2Y1VTd0bGlQbk9ZL2hZRjJTL3pLeDFHWXcyQjBSai9GRjRLUnhCWk1pSGdYTVhvTE4zdzdtOEVYcDdBejd6NlZONC9DZTk2Sy83QXJFbGd6UXlDcmMyaGJkV1RTSnA2TEpyTU5kT3RWcXh4SGxqS1FtclNrRmRRaExPaGxmdXVicWZ3QmUyZTFRUytVOTN3SE5zQUJaWEV5cHZiSWJnZGt3dWUwR0FNdWpGeU1sTzlPM3FSUGx5RDJ3TFd2Q0ZCNzM0eFk4ZXgyRDk1MHN1SUtDU0plSFRxTXVaOUZIRWZENVNFVXhNNVFVa0orMXh3bkp4LzBxWElGZXhFU3phOVJidS95cC9Qc29GMzRtajhCejJvV2JkN1RBMDFRQ0JJQkNVNHA4U2lVbXFOaGNNZXJVUWhISW5uRGZmaE9qNWZ2VHQzdzBsZWd6MnhTdnh4ZTBEK01jZi9BbUd4dmZOZXNLb2lmMm5YT1dLVnFiNllKL3lIcC9Bd0s5UFRvK21wUGxlS3Jrd1RqSmRZb3FURHRmK3MwK0tMT09ySDNxQnJTMUU4QUt6UkVkR1ViZnB3eENyeXdIdjJMZ2wwc1VROVl1UW93cE1MdjRpRmd0aklDT1lOd0JEUXpYcWJ0bUtuajB2UUcvdGdHVnVDNzV5eC9QNDk0NDFSZmZOWC9VVjdFbkNwSk1GR3I2TWNQWGJtaGEwSHpXWGkvY3hpbVJGWkswREpZMVlRcHhZRTRnMncyUXpkTytFNDJOdUtNRmVqQnp0aGF0bEk4UXFPNDl4eDFzVFA3ZW9oK1NMUVJGOTZtY1hZeDREOUM0MUJCclB3UEtLMVE2NFc5YXpZK3lGdWNxSjhrVnVHSGIrRWJINjI5OVRKRWxhbENSUmt0OHVTUDB0RkVtRDBwWGdXNFR5OVM1UzZoVzdrNjFaa216cEJPUHJ5WWtlUXZJM0plMzN5MmdNZDdUeUYxUld3Tk4rQmdheEJwYm11VkM4M25obDhjOHNxaWNPSWhaZ0Z0WG1oMmdLSXpMV0FIMllXU3ZCekN5YUZHK2hIcSs2ci85Q0RUeHZuMFhGbWhXNG8rVWdYaHk5ZmNhSm9TNFRpa1dSbFZSOFYxRW1FaVl2U1diSmlMMWV5eUJsL2V4SkNUbXlpcExtbHhXQUpLR1NIN0FXTW41WGZhUFJYdHl3S1FTRWhoRVppc0pXMHdnd2dnaHlsSjFNZ2hTUjJVSkJiSXoxNFNZVFRKVjhIQ25JZktRZ3hycEZHQjFlOEEvTjZ3d2lCRDN6ZmlOQUdUdUdmL0FZTytZUWJsZ1J4ZFBQWElUSldaOHozcFRxUTRRMGNpUitURmZLeVdXS0ZOTWI2Q3F5QnFGb2lqUHQ4SGRTNnhBS0p4OFNmbHVPQmlYNlR6QmpaRVM0Y3doQ3pBU3owdzRsSEVLd24vMXRZSVd0eEJpWm9oRE5UaGl0ZmZBY1BnVkZFdUJvTmtDeFZDSGlHVmJyUlcrMk1Jc1ZnWVZKT292VEFWK1BBZUdMUXpBMXV5RDdPK0YzMUUzZmpSWHhKMUNudFF5dTZBbFptYVllVENjczhLaTFFaG9OUVk2SjBJbk1rNU5qQ0krTUlEQjRIblBXTmFyU0VRWS9SbzVkaE8rc0gzbyswMEhxUk1WUzVrT1ZNYklaOWVnN2VJTDVkMDVZM1JVc3Y4eldHWkU4SWZDdnRacmdRNERxYldaNnloelFUZXhMTXhOaDJyVjBsUGxDWTBPc2Z6S29NK1dWU0FpUzM0ZUtwaHFZclhiMDdIa1hraStnanA5RlIyTnd6S3VBdGQ0Qk9jeWtCWk43Q3JOVy9XMG5vWVFFdUJZMVFBNEZJRWRENnJFa21mV0xFUjg3aDU4S2VrWTF4MlNlek5vM3JiNVhJY1dZdGJsMEZqcXZoVWs0R3hSR0FvVTVQVnltdVZwYk1IeGNSbS9iS2RSdldneTkxWURBUUFDeFVKVEpOeXVUZmdMNjNqek5WSUlEdGF0V3NOOURhdDNwSkJsU05BcDlnQkd3cDRlZFl6blYyMHo0U0VJK0gwbnJUYXYwSE1TMFlneE9JQkJUTFpOTzBTSFN3NGhoWlNUUm14Rm0xcVdpMW83WUtNdDNvZ2Rtb3c1QlpvRU1qRUFXcThMOHFsNG8vakNjaXlvUUdSMVNyUmxpWWNpQk1XYWhmREFFbUd4a0JpOGdWRkM5ellTUHBPUWUxTkpUQ1YxZEJLek5VQWFZcjJUUlljd2JRM0JnQklZeVQxeGxDNHhZaXNRc2p3SFNhQUFHbXg2dWFsRU5MNHRTR0pIQkdFUzlIb0dlYnVpTkEycVVqMCtvaW80cEVFUUZKaXZMTzZnZ2FKNFBNeFgxMVpYc1doYUpoMFFWY2xxbkZhYXFCVGg4MG83Vnl3WUJrWCt0d2dTOVNZTEU1QmtQa1VkakV2TjV3ckRZalBCMEIrRVBSTlY2c0pvTmNMcE5pRERuS1JMa1k0TUNaRm1HS0FLaGlBNmlMY0lPRjhLaFkyNllxaGRTdlUyM3NwTzE0Z2I1TEJKSnV4bkJpOTJic1hycGIyRFFCUkZnWkFvT2hhRXZVeWMwSWNaOEhja1hSVzkvQkdGR0lJZmJBcDBvd0R2SThub2owT3NGaUE0RlJsR25FaW5pa2FHWXJleFlJVDdnZ3hkN3R2Q3hYc0tNU0xzOEZpbjNaRHdLTnN5SW45VDRFWnh0Zndyekcvd0lSYzBJaGN3d2pvNUFielZCQ3NYZzhVUmh0b3R3VlZvZ3gxZ1ZSR1U0cTh6d2VjUHdEMGRSeHNnVVkrU0tqVEc1WjZ5RWtWbWlTcE1QNXpyTUdHdjZDSXhVWnpNVGJOQW9WeHB1dlFZd2x0bnhyMmNlVUxzNWEzU1F5VElGSVowZG9TR3ZPaW0xd21XRTFhUkh5TU9uQm9VUURZUVJHQTNEcEJOUVdjV2tJS3ZRNEtCWDNVZTB5YkJFQjlWamZmLzBBekJhYlZUQTd6VWZpU3pTek1HNjdHNDhzdk1vdm43YjY0Z045a0F1cTBOVXJBWkdoeUg0eHFBekdLRE9CVXBwYTRYNVJqTHpuNWpQWkxSQUtLK0dhRkZnRHZTaXZFckNJMy9jQk92NzdxYjZta0dMTlBYdkk1R1BOS1B3dnY5YmVHUlhERjlmdnhjRy93VU1vUXFDeThVZkZWYkhpQkNOUUluRjFEb1FSRlpWQmtZZ214bUNrVWZ5Z2lnUERjREJETkFqT3pmQXUvWmJWS0RYMEVmU3hmdTY3UDhJVjRGTWEvOGVEKzI1Ri80eEhlYUpBekNPZFVNV0dJRXNCdWhjRlJEY0xqWHhkZjZid3JZWkE5MXFYaC9iNTZFOTk3QmovQU1WNU5Vd1NobzhtZmJYY1JFdUg2WU5mNG0vYTErTzFaMi94T2FHVHRTVURhaFZFbzRDTVNIK2ZMTmVrV0JLUER2VkZ4RHcweE9MY05qK2ViZzNyS1U2dW1yU0xwK1BSTmJubXNQZHVoYm5zQmFQdHUrSCsrd0JMQkE2VUdQc2g4TVlmNHVRTjJ4R1g3UWFaNVFXREZXdWczUHRlcmlwMks2NlRjb1RiTkRha1VoMk5lRnFYY2RLZkIwNnZLTTRNam9JSlJ6L1dMVGd0TU5VN29LNXZKSlBNcUo2dVJZa3VwS3ZVUkN1RGN5T0NqVVJpc0VlNVpzaUpOTVVJUUloeVFYUWdDeUJNTFBJLzZnNWpTTVJDRmY0cURtRnZ3bUVOQzdrc1VnMCtFb2dGTUNsSzdKSUZHd2dFSzV3UUpaZXgwVWdUSU9QUkNBUTByWGRGSDBrbWFRZGdaRGtncGFQUk1LTlFKZ0cwRnc3QXFGUVhVZXp2d21FbVhXU05DMFNqY2NTQ09OY21IcXdnWmhFSUtTNFFNRUdBbUdHb1Ixc29FbXJCTUk0RjZZY2JDQnBSeUFVNUNTUnRDTVFwa3ZhS1dSMUNJUUNqTkpVWHhCSjBvNUFTSk4yK1h3a0NqWVFDTnE0b21BRGdVQklOMHNrN1FpRWF5ZnRDQVJDSVFhSjN0bEFJQlRPSXhwSEloQm1GSG1mUjZJeEpnSWhRUktLMmhFSU0rc2thVW83RVJLVkhZSEFZRVM0QUdtWEF4WFNBUHhLR1pVaW9lVGhrSVkwdDhjL2ZabjQ5SGxtV2lpL1F5VklJRERNbC8rY2t5ZDVwZDF5cVEyS0ZLTlNKSlMyWjhRNHNJSnhJYSswaThrSTZuV3daRzZzUmk5dWpPekJjZXR0VkpxRWtnWG5BT2RDTnNnS1lpbUxGSXhnTkRVZEtDTnREajZGeGtnSGxTYWhKTkVZZVZmbFFDNStxTnhKV0NSbGNFeDMzbTZTNnJJZGlFZnU3dkg5QUs5WnQrR1llUk1VbWc1T0tBRUlyS1V2QzcrQlc4ZDJhRWF2Ky8yNjA1eERuRWl4SXozNkEvT2QwZ2R5WlJhWjlkb2MrRFdXaDEvRGNkTk5PR3RveGFoWUJSa2lsVGhoMXNDZ2hGRXVENkVwK2c0ajBWNjRwZTY4KzNEdXNJVWt3SDY5eTEwbXJ6NjRmV1NIemFqUTEzOEpoQUl4RmhGRzMvL2p5ay8xK1hVSFJaaXFoRUJVc05TVXlZWlZjNkpycUhnSWhNTHd4Qkh6NHkrOGEzcURyZlp4SXNsY3ZiMXkyamoydnJteG1xWkthVDRWRVlHZ2pUMW5qYTgrK0h2SHI5bnFHWlpHZFAzZkhPQ2UxQWhMRno3enRPT0pBMTJHZlZSTUJFSnV0SFVaOWpPdVBNazVrK0NPSkg1dHN4WC92TGVNeDhLamtpem9kaHczZCtsRmpDNnBpczIxR0dDbFlpTVE0aGdKQ2tNL1BXaDk1a3ZQTzU1alhEbVZzRVplbGhTaC94R1htcW42MjlVOGd1ZG1xWm1sK1hhVDRuNW80OWlhVGZNanJmVU9xWUg5N2RBSkZLWWpsQTVrQlpJdkxIaTd2ZUxGMTg4YTI3Kzd0K3dnKzN1UWJUckxVaWRMZkYwZGtCWDZ2K05LN1ZqOVQ5VUd0dUNSdTRaRTRodTVWVEp4UHdyMFRpRkNhWUZQcE9PdUQ1LzZIV0NKejF5OW1FaWovWC9iSDJXY1VUUHk4SGZtem55MkE1OHVWTWxTRlV0T2xtemdNOGxCRm9sUVV1QWtpckRrWjJtWXBZR0VUeFRrQmlzOVk3YkhLSGlHTVpaQ2laM01hU1FpaTBRb1JZc1VTZkFobFBoN0V2NWZnQUVBVk1XM3pOdGNiUzRBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lhrvnu5MucG5nXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU5JQUFBQnpDQVlBQUFEdDJWd0pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEZOa0pEUkRkR09UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRk5rSkRSRGRHUVROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tVMlFrTkVOMFkzTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1UyUWtORU4wWTRNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCs4Tnd2N3dBQUZEMUpSRUZVZU5yc1hYbVVGTWQ1LzZxNzU5cmQyWjA5V0VDd0xEZENMQUlXZUFLaEUxQ1VpQ2ZaMHJPTTdBQitMNGx6MmZrcnNVbU0vM1dpK0NWUjhsN2lISmFkQ0ZsNkJzdVdkYUJuQ1NUWjNBSUpCRUlDeExGYzRsaGdkNWxsajVucDdrcDlOVDA5UGJNelBjMHd5N0k3MzI5ZjBYZjFVRlcvL243ZlY5WFZHdi8xQTVBSGZwRytiS1hGSXQxaDdTTVF5Z1hYUlRvbjBuNlJYaFhwTlpIaXpoUFk2c3R5cVFIUG1jR1RJdjFRcEtsVWxvUXlScFZJZDFycGF5SWRGMm10U0wvS1BsSEoybFpOTGduMEt5SVJnVEFBeUlsZldoeFJuUWMwY0pnazNZQm5OUlgraHNxTFFNZ1BoY0YzQkZlWTRNcDNCbGlrdmpoZlNTUWlFTHdCdVlLY3NZbUU5dWo5dzRtZzM4ZitCZGNwVWFMa0xRbk9QUGZlMzlVRTdXREQzVTNhMXhXTXluRjNGbDdpOWJEYnVCdU9tSk9oQXlKZ1pNcEVBbUZZUXhVdHVoNDZZWWJTQm92VWd6Q2FYWFdYZUFCalc4YXBxOFRxOHd6Q005VnIvMTMzV2pqSVZ1UzdBQW56bXJFVWRocXRBRXdCeHBpa0pDNEloSkVDam9ZRW16YXVjQk1XS1IvRGw3UjN3UWQ2M211NisvbGJOWC9XOFlRbTFnTitEVnJkU1BTOC9qUWNoOG1nS0VnZWkwZ21jb3FsWXhYRUtzS3daWTlGSUpOTE00TkU0cHpCQnpBZkx1dDE4S2ZhUm1tdGNrRndaNTVZQkpGSUlaL0tHdkxkNXpWOUdaeEFFb21NRlVXVmR4UlVTcElJeVNNWFJDTENjT1lTdHlNRytHZEt1YVdBYVJyUXhpYkI2OFl5ZUZKOUorZTFnanVqVWtUeUN4TDZjdmxIRjNrRDdPSHpRV0dxSUpFaWlZUkxNQVdaVkVXU2lxWG9UQ0FNWHlwWnpWK1F5REJCVmNYU05HWHJOb1hFKzhDY0Q0dlpQaGpEcnVUeWs3U2tZWklkUzdtakRIdjVYR0NxVDV5c2lNdzFZTndpazVyMms0aEVoSkZDSmludmhGVkM4akJ1Z0tJcFlCZzZJS1dRQzQrenpYbmpGSm9iRXo2SGFVa1NhVWdtVlpCSmxjSU9yVkpTempHaUVXR2swQ2hwbVlUTVk4SWFTUklKYVFlcWFPRkdRbklCSUMrUm1KYk9aQ0M2V0wyMFJFZ2lUVmdpSms2WEVnOHNFamw5SS9LVENNTTUySkR5bFpnZ2txb2twWjNRYmJxSjlvWkRsMUh2Mmp1a1pXZVd5VkpoaVlRL3BQclFFZ21MbExSSGtqUU1XSm84M0lXTlpZVE9LNTJ3NjkyOU4zemR0Rm1UWVZyTGpROXR2SGoySXF6Lzl6ZnM3VFhmZmh6R05JM0plU3dmdnZ1UDN5enpXbU8ySm1PUUREYW9hSlhFRWlQV0dBcmdDVVBJTzE5ZW5xU0psQWVwQUFQanllQUNCaDB3L0oyMFJrU2U3RWI5Nm91YklYcXQvNGF2UGJUdk5LeDRPZzRObyt1Z3Fyb0txbXFxWE8velFoNkNPSW56RFVFcWo4Mkk0T3pDNFV4YUpVVko4b1liUXVZSmw0WUxDNFZkUGtVUkNWTEJCV2JKdVpSZlJDUXEyTENuekJnRG9ZcUE2N1ZYMjYvQmhTKzY1UHFtWCt5UXl4VlBMNEdXQlhmZDlPL3lCd1BRTXE5WnJ2ZjF4dURFMFl0eXZib21DQk1tajZhS3l4ZHZrQjJ5eWJhT1hUNWNNSXB6RlF6RGNMM1VWZHJKRGxpQTlFaUdaSGlkU0ZRQVQ2MSsySk5VaThmaThQcExiOXVOL0VaeC95T3pZZktNaWZiMjlzMTc3YnpxUnRYQ2ltZCt6eWI3aWFOSnNpT0pVdnNKK2NtRTFrZTZUT2pHY0RuaVcrd3JVdHJaUGhDekFnc0tJejJRaFRvaHg3N3hWNDluV0FKc3hONnNoaCtlV1BVb2RMUjMyUHRRMnJtVkw4cStGU3VYd0pHUFQ4RHh6ODVDNTlVb3pGOXl0L1NONXR3ekUrNmNPMFdlMStIdzEvcDZZdmIxWjlvdXdhWU42YzdGeGNzV2V2NjlaUVhGaWdNQXkrU0NHNUc0RzQ4NDhjYVZEQUUvZkhINkFsdzhkN2trK1hteEZnMk5kWEQ1MGtjUTdlcTNwU0hBUWZ2NG1QR2pJTjRmazc1WE52QWE1MzRrSWFHQUQ1bVNmTVZLdXdFVTRtU05jdnBKZ2tTNUdtMXhSSEkvZnVyNEdXRlJkZ3dJVm1SalhQTllxcGhTQkNDY1hDZzJhcGNVaVU2aWtYT1VDOU5uVFlMbUtlUHlIdC8waTUwWmZrMTFKT3hlNW01dzZIVE02OTdsOTBESDVVN1k4UHdtYVcya1hGdTZRUHBmS2FEMFJNdUorM0I1WGxoUTUyOHFlTSt5SkJLM21qdjNWRVlhbGRqTm8xQmd3ZGxvSjk4NVVVaXY0cU5tR05HYlBuc3FiSDludC9TUE5tM1lER2RPWHJKSjlOVHFoNlRQYy9IY3BZenJkcjMzb2JSY0xhM05ycVFuRkFkM2FjY2NDYkxXQ1Vtbi9qSTY5Ujk2UG4vN08zc2dWQm5NZTN6eHNnVUZuWDhNVXN4ZFBCczIvRGh0aGFRc2ZQcGVtRFo3NmtCVnpnbzRBVlNuaFIwbEJvV2xIUzhrTTdqekJWdUNFL21jK253NGNmU1M2L0g1UzJhN1Z0aXhReWZnODBNblpkK1FrMFNJYlp2M3dlbmo1MlN3WWR6RXNWa3loUTljejdWTnlDcVhkTGtWRGpia09TV0RSNHpLT3hjd1hMM2lLNHZkcGQwcnUrejErNWEzUUkyTGo0VDV1WlZ6ckU4UWQvOFplenRjRTRUR01UV1NvRElpWngyN3d4RnNjTXVQZU9UQmh0akxRc0VHS3NpaVVSbXVoRm1Pa1Fob01kQkt5VVl1Q0ROaGFsTUdrZEJIQ3RkVXdhbWpweTJaRmhBKzFoVFA5NXM0b3huV2ZMdmVRYVFxK1J1Y1BsRkFTTDlZZjV3cXArVHN1cGxnQTgrZU80WGdoaTF2N0ladWE3emRrMy80NE1ESHZkajIrVFRZdW5tL2ZkNjN2amRha3NFTHpwKzZBTWMrYXl0NFh1dTlzNEZNMHMyYUpPNjVmTFNDQlozdHNKSmo2dXEvZERzR3JUWlBhOHBaWGhnc21MTndLbXpmY2todUh6bDRET2JmTjllYlR4YVBaMGc3TDBUQ3NQZnBrKzF5SFpmTlU4ZEJ5N3dKU2VzVjhsT2RlclZDUlFjYkNEZUVzMjNuTTN3aEpFdyt6Snc3elNiU25tMmZlU2FTRTFObWpJWWx5eGZZMit2L1k1TzlQcVpwTkh6MzJUK1M2enUzN0xFSmpzdHJuZDN3Mk1ybFZHR2xVM2J1d1laY2tRdENIa3NoZkpJUGR4eXp0OGMzajhsZFhsYVoxdFpISkJFd1NJQ04rOWdueDczNVNvNDhjWFQ1bVBHTnJ1ZGRQSHZKSml3R0p2QmV1RDF6emxTb2JhQXhkcTdsekJ3YzRKeUNEWU9OdHphK0sxK0pTQWNBZ2pMSWdQdmRjT2ZzU1hZNGZNdWJlNFR2Y3dvV0wyMzEzTUF4Qkk1RVNjazNKM0QvMWZZT09QSkptLzJibnZtVDM0YzNmLzQrWFBqaUdyejM1aTVZc215KzdMTnlzNXlFVWdVYkNBV1I3YlBNYUduS3VWODI2RWo2cGIxcHM0UUZlbVczTGJudy9OYkZMWjd2aXlROGNmU3RuSklQU2JUSnlodnh3Q056SlVFWFBUUUhYbjFwcTMzdG1yOThUTXBBd3MzQlBkaVFIYkdqUWFzNTBUS3Z5VjZQMUZYRGd2dm55dkp5N3BmQkIrSGtWNFlyN0VlYlArZ1RWbUk1bkd1N0FGMGQwYVR6TC9hNVBmclFlbVRuNjBRd0ZJQjVpMmJCbGZaTyt6ejhUVW5aeU1WeU1peTQ5enowOThVODNhKzhwWjJ6N2J0SDczREs0cWJZZjFYa0RBUDlJUEJQb0drK1VKa3FKMEhCK2V5WVFrd2lsQUdQNUt5clhFN0haWEFEZEQwQjYySzVQOVlTK1BQZUNZV0REWmloQ2pTOGdWQ2VWZ2xoVXJDQlFMaVZ3WWJjWnhpQ2hWcjJDSEFDb1J6QVlPRGJEOFZhcE82WURuR3VRa2hUSUtqaGRGdzRBcFlZUlNnUDh5Ty9TbUdtVTBHTDVLYnNESkZCdjI1Q3dqVEJoN1B0S3dyNE5FWnlrRURLenF1MHM1MHNLK2tHRjhReUJiSHdHNXBNWG94THNsR0VrUmxvNEprY0tEcllvR1RwUlVndmRYRUQzU0liempPdUtZSllDczVpUkxRcUJ0VzkzWERYbWFNd29mMHNORnpyZ0lwWUh4akMrbmVIcWlCYVdRMW5Hc2ZENGFicGNFMnNFMjZSaitUb056VTRMejdZNEJYQ1VJRWgvb2taeWZtVDBVcXBaSzA4RStqQmc5dGg1dGxqd0xLNkZsVFRnUHJ1VHBrbVhUd05EM3l5VTVCcEd2enU3dnNnV2hHbXdodEVvQ0ZDWXhFVGJrMS93b0NFbkdtMTBPaHZ0OW00UEE3YWMrckloTTRoSWMxV2NrNUphYTNFVWxXWjYveko1WWFwNTAvQzQzdmVCcitlOFBhUUZIVncxNW5QeFhWdDhKdldwWEI0d2d3cXhGSkJTUm9EM1NJUXhnYncyMzNveXFTKzZNY0gyeUlWWW5aYy9FQTVwRkw4U3JSVVNDamtsS29rcDRNdFI4dy85akVzTzdodGdCV1N4YlJnQWNSV3JzU2FoY0RQZmdiYW9VTVp4NUY0VHdnQ1Z2YjN3SWZUVzRrRXhiaEFMQmxJUzZrcDR5YkREZTQra3ZNdHdSSzlJWXMvR0grNDAraWh4WktXUzhXSnkwZCtKYzRRdnRDeUExdHp5MTdoRjhWV3JRSWVTRTdBSDF1OUdyUzFhM1BtczFSSXd1NWdCUndseTFUNGdjNHN3dkNrdjJOeUw2VGhXVy9LRHFGRjhpUUZyZjlWekNKWXltb3BxZVVJSWxlNEp3cVBmZlIrWHQrUlJ5STJpZVIyZFRYd1lCQllmMzlPNVkxNW5hOGZDOTBVaEJoQUdoTnV4Tm9NdGtVeXJWR3dxZVV0Z0xSYXVuVXYzWmF3VWdvcWxpUlVZUGdOdGtDdC9jQ0I3ZUEzRWpkMm9Vc2tGUE42OE1BMmVHUFJINVRkMStXeGhVaXltRWtMSTVlbHE2eDBNajFhSkQ0TWVsZXhnTXlVUGJZc2wvemNoa1d1NFVDd2NIY1h6RHAvc3VUNTNuVytEWDRyOHI1ZVhWc1doSkVKZ3dIc1Z2K09JdWYrNXBaVGxscmVqZzZqNlh4U09Id3ZTUzVJazB4UmtxRjRCWWJtYzdkb2phYWZQaUs3QjBvTnpCUHovbWoyb21GcGxlUkRQMFVZSjFuQXhaZGhnMDllWjlzdlZHdUZYK3diQW1sWEVndG1WVVRPT3VBT1lsa2ZJc3dnMmlDUXpUUU1tTkIrTG5PbnFvSlpXenZBUnhwUURmWDF3TE44SktXelUwYjFVc0M4OTRwdC9QTDg3VWFTbEVWSkVjVldTekEwbHFWNGFWZnMxeWhHcXJabVZrKzEwejgwK0FDeU9RbkdtR013Y0dvZmQrd3YwQmowUkFKRzk2VG5kZEJiV3lHMlprMUdZQ0VmZXRldEcvZ3dpTVVnc0g0OWFQdjJ5VzNNRys4eDJFUktFVU11VTA5c2s2ZmZvK2FaaENsSWtoSGkxbWtwMlZHUWxhbFVKdjVzcWxHWXBuY3JuQ0tVWXIxRjdCeFYxZHNYZ3lvOVBVRko3S3RmOVVTaXZMOVBYSXQ5VFNraVlkNkpXQng4L2tEQmVKUDlER0hPYXVZWlJIRmVZNU9pdElHdTIxOXZRbWJiNTBWYnBGeGZvcUF4UCs3a0E4dHZ5MEovUXM5c1UwWUpncklaZVhDSXhoSmdoZ1poNkVnNTFydXoyOVRELzcrd2o1VDlGUU1pVW5IMVlwalFyV2hRWnlTdFV2RGxsNkVmcFYxMWNmMC9MQnFGNEVzdjJkdFJ4U2Z2QVNhOTMxSlNpNVN0ek1oSEducWMwWUkya2RSUFA0WEt0V3VCVjFSazFsOXRMZlIrLy9zWit5clJSOG9LTnJEZTNnRjVFNGFMajBSdjg5MlVPdm8wVUFOelkxRlhRa0F3QnlINitvQ0o1QWJNbTdtcEM4SWcra2pNbzQrVTQzMGt3bzFCMFZUWVV6TWF2aDQ5Vy9JaXhPckZ2UEVlVkQrRDVCOFdLRmVGU3VvV21YNmZENjVWUldDYnIvUmo0akRQYUxoVzNvTXdoTkl1bnh4STlnOWdoeGtIdTZlQW5uaEZBU2ZZREZaVXdvdlZUYkR3Nm1FSTNjaW9NQmU1MWllZWhaaG5JRlFoNzhFcDJGQWlaV2UxL1l6SlQvSkxPeVVsRFhLbEFkS09VdEZKVVJVSVZWWkFiNlFlL2pVd09xKzN5YnE2WkdlcnZSMk41aHo1bmFvM3pBdnp4THp4SGxUV2c1Znk4Z1M4aHI4cDJGQVMrQU1CQ0VjaXNQZjZXUGpQcTNINEMvM3FRQU52bWhCNCtXV0lQZlZVOHNXK2pSdnprdWgvdEhyWUd4a0xqU0pQZjZwemw0SU5neFpzb1BEM2JTUHZWS2lzcm9aSVF3TzhyZXR3OFpvR2Y2dGZob29zbWFmdDJTTlRmam5INERtdEFYWlhqNFVHa1JmbWVidU5zU01maVN6UzRGb2xudzlxNnVya0lOWURva3kvMlIyQVA5YXZ3TU84dDZEN2lhWC9QcXVBbndnU2RZZHJvRzdVS0ptWFB4VmtJR3QwbTFva0NuK1hIRXo0TWNHS0VOUTJqZ0pWVTZIcmlnOStHQTNBOC9FK2VOaThEdk40UDB6a0NZaFlWcXBMdUxHbm1BLzJzeUJzVmFyZ3NqOEVGZUd3dEVRMTlYVVFESVdBS1JSOEhid0tBKzlEaERnOXlXNXQzU2hJcGdvcHgvekJJRVE3T3FHbk93cS83cStDVi9TRWNJMU00S1pwbjZzSzhxbWFUNXdiZ1Bwd05ZUnJJMUxPK2YxK0l0RXRqdVFWWjVHeXg5bVJ0Q3ZwZ3c2Sm9FWWkwcXIwOWRTSTFBT3h2bjdRRTNFcC9SQ0tJSnZtODBNZ0ZJUlFSYVdNemlINXBFL0U2RE03dDBUYWVaRE5Rejc1U1htemlRbExvMEZJa0NJZ3lGRWxySXl1NjVKRXFmNGdmUGRKa2ttY2grZmFCQ0lNQmJzS0JSdnlISlVmR2NzVk5TZVUyanhoSDVCZkRZQ3dQVGRWb1lSU2tzYVJ6QkV5K1FtQk1QVFVLdElpcFY4anBpRkNoUElMTEdRTUVTb2dCTWhISWhBRzNVZWlmaVFDK2EvcFZMU1BaSDBpbmNMZmhETFVkcEF4c3NIa3hmdElCQUxCazdMejBDRnJab1VCU2RvUnlza2ltWTRKSXFIWVlFTytkek1JaEhLd1BqeTczWk8wSXhBR1g5cmxkYUxLZUtaVkFrbTdBYk1Ja1VVaUVHNUpzSUVYRUlvMDFvNVFyazZTdC9aUEw3TVFDQ1dBSjJuSE9iMzJRaWcvRnluMVJaTFNCUnVBUmpZUUtOaEF3UVlDWVVpRERkbmZSbkx1SXhES0FhbkJxcDQ2WkFzNVJ6Um9sVURTN3VhRERRUUNBZWhWY3dLaE5Ed2lhVWNnM0FwcDUzSDBOd1ViQ09VWWJMRGZrS1dSRFFUQ29JS2tIWUZRS21sSGMzOFRDRjY0UmRLT1FCaFVFSkVJaEpMNVNQayt4b3dEOVJ5SmZDUkNPY2s0K2Vkcy95VHRDSVFobEhZcUdGUkNCSUtBSDJMRlM3dGE0d3Awc1hISmR6Rk1Eb3lSdENPVWpiWkx5em1SSWtaSFlXbVg3KzMwcWNhUnpMTnBWQU9oWEpEVjFpY2J4MXhuY1hDVmR2T05EOFNaSk84STVXNmRETUdGM1lXbG5XNUNuNlpBS1B0Z28zbFJaTEFUOXFzUENZWmEvRk1ZQmU4SUk5OGE0VFRGTENudmtBUEloVndRcCttMlJlcUxRMWZPeVNCRmVyVHZsekJSUDJ5RkE1TWZIaU9KUnhqSkpFcDlXQXpiZkxOK1JISWdIejhrZHl5THhLLzBLS2ZEQVdOc3Jud3hjdmRNejQ5Z1MrZ3I4SEVBTFpNcUxCMlRId2tteTBRWWNTUXlVbVBzREpnYjJ3cVA5TDNpR3IxdXY2NmN3QXVRU1BxKzg5ck9TWFhHb253blkwYVA5bTJBMXZoV09PQy9IOXA4TFhBTlJvSEo2SU4vaEpFVFdQQVovVkJ0WG9YbXhHY3dKNzRkUmhubkMxNkszQkVMWVZyQ00rc2JLczBGZTcvVjhmTXFQNDlRcVJJSTN0QVRaMTMzL0tqdWE1ZXVLM3RWQ0l4aXZRa1dhcXcwZmExMzZBdXBlQWdFYi9pL2ZhSC9mZjF3WUt0WXZZVEJCdXl5dmJMdW5hcTNmOWZtZjQrS2gwQW9ET1NLNE14dmtEc2k5U3Z0Nnk2ako5VXAwdGxWRzZ0ZjJIbkd0NTJLaVVESWoxMW5mRHNFVjlZalp5enVHS2tPMlY3Y0dkUFppUysvR1BucGN6c3FYdWpzWTFlcHlBaUVOSkFULzdhejRvVXZ2Umo1aWVES2NZdEl2VEplMGY1c3ZUeXA4UWVOR0lKckVHbXFTSlBDQWQ3dzEvZjNMSHhvVXJ4bFhMVXhYbXhYS3d4VUtrNUN1Y0RrWUhUSFdQU0xxSHJ1dDIzK1EvKzhyWEt2MkVZcDF5YlNjVXZXNlVraS9VTzlmV0hqM3pmNnhBSWpkK090aEFjclJBb0FTQkpSVnl5aG5JQWRPNFlWUjBETGd5cnRuSlc2MnIvWG5oQ2NrU2RpK0R2N1lwUjdPRnlvVnFSUkl0V0pWQVU0a2h6SUloSEtDa2lpdUVqWFJlb1E2YkxsRS9XaHdYS2VtR3NXSVR5aEJ5TVIxa1ZCQjRuSUloSEswU0xGTFQ3MFc5c0Q4UDhDREFEc0VJZjdyYUJ6MUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKSUFBQUNWQ0FZQUFBQ3pmcU0yQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG93UkRBNE5EUTNNak5HTXpReE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dSREE0TkRRM016TkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQkVNRGcwTkRjd00wWXpOREV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pCRU1EZzBORGN4TTBZek5ERXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZ09ObUd3QUFNdnhKUkVGVWVOcnNmV3UwSlVkMTNxN3U4N3FQdWZNZVBaQjRDZ3dSd1E5aHgyQXJHSU5aZ0g0UUxJVEJ5OWl4MXpKUkV1SmdJRjdKU213VDR6ZzRUZ1RCNExEQUM4Y21nQVFJSXdnUjVpVWtZYkF0OFJCSWFQUit6RWgzWnU3TW5mczY5NTVuNzlUdXJqNm5xMnJ2Nmo3MzNwRm1SbXF0VXArNXAwK2ZQclcvL3ZhMzk2NnFWbmpORmZBRTNQYm85anpkbmw1b0IzVGJXMmcxMDNhWXo2enFOakR0UktFZDArM0JRcnRUdDhVbldvZlduZ0MvY2I5dUx6THR4M1Q3eDdvOVpSUG4yZUdjTTdROW90c1BkUHVlYnQ4eWJlRkpJSjFaMjZ4dUw5UHRsYnE5eEREUFk3MDl4YlJYRnY1R1RIV2pibC9VN2F1NnJaMU5uYTdPRXRkR3J1cTF1djJTQVUvak5ML2VuZ0hWTmJwOTFyaklKNEgwT0cwRWx0Zm85dXU2dlZ5MytobjZPL3E2ZlVXM3Y5RHRjN3AxbjNSdGo4MzJUTjMrbFc1dk1nTDVUTi9vQm5pVmFTVGNQNnJibitsMi94T0trYTVibm4xTUx2UTFPOWRlckhlL2JWeFlmSllIQ0VQZC9scTM5K2orL2VZcDd0Y25CaVBwSDNxcDNyM0xhSjl0MlZDM0RZeGdMWWxoUTJOeUEyUG9RQVI5L2JlK29yMkNSTzh4amZXVjZTaE1YMFdZUUYwaDFOTjlBaTFJWUVvTllVcmJmamJTZS8wM3RmVkxwQnZsZGRUMDd5Y3Q5YnNhVURjLzZkbzJCNkIvWWdEMEMxczlGNEhtWkZLREphekRpbTdycWdaSkZJR0tGRVMwVjdRbjh5djlXb05GNzJPRGhxYktYaUNpMlJOZElBejBma1B2bHhKTTMwdVNKTjFId3dTbWNRQnpxZzg3ZGRzVERWSndiV0dqRytnbTNSK2tvLzZUQnRUZlB3bWthZ0E2VCsvK1NMZGZTeTI3aVkxWTVNU3dCc2V4QVl1cUNWME5uRGlPVStERWNRVE5GRVJSQ3A0NEI1VEs5dlNWR2FpTTczZUFSRnVTWU1wcnFQZUpaaWJhRHpXUTZPK285MzNkam1sQUhVMy9Qb1JtTW9BOTJJVjlxZ2Q3NDBIS2JwdllLS0I0bWU2ZnY5TDcvNkFCTmY4a2tIZ0EwYlc4bmU0Nmt3dWFVRlFvYmJ3NkhNVldDaDZObUJROHhEalR0VGdGVUJ4bit5aktXOFpJQkNLaUlnSk45bEpaSUJxNXhCRXJZY3BNQkNCNllZTXBhOE1odFdHMkh3emhlRElGUi9XLzlSOVNVSjJqT25BZzdtc2ZOaEdvbExuQkx0Zjk5WWQ2L3o4MG9BWlBBbWtNb2hmcTNZY2h5enhQdEMxcm5YTTRhZWx3WjByL21qckVOYzA0R2pDMW1tYWhHdTBOb0RTQWFsR2NNVkdzREFzUmVLTFVQUFFhY2dDTjZjZ1JWempTV1BtL2t4UlI5REpKWDZjc1JjeEVBRXB5TUExaG9NRkVnQm9NQnJBeWJNREp3UXdjSFBSMTJMa0JGMFFkMkJrTkovblpkS085VzdjMzZMNzdUUTJtVzUvUVFOS2RRS0h2SCtqMmprbXVoUXg1UkJ2aklaeUdkdHlFV3JNR0RRSk52UWIxQW9CcWNTMEZVRlNMUnN4REFFb2RXTHBYS1dveTVyRkI0N0tSeTByMjM1SU1UTWJkcFk3UHVMMlVvVFNva2tFR3FyNEdFZ0dLOW9OK0hZNFBtbkJFdjU0WmRPRnBhaDNPalh1VCtITzY4YjZsKy9HLzYvM3ZhVUQxbjNCQTBqLytPWHIzTWQxZVdQVXpKRmtQRDFzcGdBYTFaZ3FjR2QxU0FORStCVkE5YzJNcGVESmRsSXBwcFVZYUtBUVV5NGs0OE1MOGN3NldsQnBuSXpBYXYwbDZLV1dwRVZNTm9aRzZPbXFERkV6OVBnR0s5ZzA0MkorQ2V3MmdMb2dwanF4c3czOXY5Tk92YUREZC9ZUUJrdjdCbEV6OFg3ck5WR1VnQXRDRE9BUERSak1GemJSdWpVYmRBS2htWEZrR0h0SStPWUJTMThVQlJ4VkJVbzBEVlBCd0hMdkQvQ1VKZkV0WGFmZEtnS29UcUdvWnFQckVUdjBVVUwxZVAyV3ArL3Y2WnVsMTRlbXFuUUtxSWtQOXBHN2YwWDM3THpXWVBucFdBOG00c3F0MGUwdlZ6eHhQNm5BMzdvQmV2WldDcGtYZ01RQ3ExK3VwRzB0YklaelB3bmpYVlUwR21rM2tkc2YvVjJOdzBYVVFsckxyaVZMR2l0UElMd1BWc0o1QVRVZVlEUTJvWmtPRHFhOUJwUUhWMDcvdnZuNFREdlU3OEJ5MUN2dWlTbDZMYnN5LzB2MU1vSHI3WStucWFvOGhpUGFiYk8zUFZNMzkzRG1jaGVYYWpBYU9acUJtSTJNZ2FqWGF4eWFrejZLdlhPY1VBYVJVRmVBb2dLMWdETVYvRk55bzVSelRWOFNjNUxzb3dVbS9BMnVhbmZUdnJHbEdHbWhBMVh1OWxLRjYzUmgrMEd2Q3prRWJuaGV2VmMxSi9SdmRma0wzK1M5cU1CMDdhNENrZjlDUDZOMFhkSHRXRmJzOHJOM1lBOUVjeEZNTm1HNW9BS1VnSWdacWpBQVVtVEIrTXZBb1VmK0k0Q3BEa0xJL2h4Nm0wSG8vdjlUVUEyS21yNVRDTkYwUm1SVEZzSjRGRG8xNkg3cWFkWHZkSHJSN01meDlyd1hQR0s3QVU2dTVPN3BodjZuNy9qSU5wcnZPZUNDWkVnY05sZGhUaFlWdVQrYWdYWitHcGdZUHRVWXpZNkdHY1dPVEEwZ0p3Tm1xaTFPQnYrTG9iUnkvRUVCbHMxVGFIRURWOWI3ZXJVRlg2OEFIOVA1WWZ4MHVqbFpndXB5ZG5tWEE5TTlPZFltbGRvcEJSQU83cnRWdHV1ellSNU1tM0tOMmFoWnF3a3d6WXlFQ0VvRm9MS1FkQUtVWXFRb2VWVms5VDhCSC9sK1ErOVlNV0R5b3hpeVZ2bzAyb0dnZkU1QnE5VkZhbzZ2ZDNTM2RCanc3V1liem85SlJKM1FEZjFIYjRuSU5waStlY1VEU0YwNVYrcXVoWkpBWjNWTjNKanRnb2JZalk2RldVKy9ydW1YaGZjcENUZ1JXQmlBUlBNb1J4VnR3YlVyUVEyQmxCOUFDbGdjcWg2WHl2RllSVUtxdU1vWWFBWXI2UkxPVFpxeTdOVHVkSEt6Qzg2TFZzbFFCM2NqWGFadThRWVBwcjg4WUlCa1FmYkxzL0IzdHlyNlBPNkhUbUlIcHFlYlluV2xkVk5PYUtJL0VpaXprdXpDWGZYandxTzBXMmU2SGtBT1pLZ0NMQVpWQ2xxVXlRT1V1ajl4Y2xublAzWHBlNnFHYmJMRVR3YTBhVUM5UXk5QUt1enE2b1QrbGJYUEZxUUJUZEFwQTlFckRSRUVRcldBTmJvVzkwSi9hQWRNelV6QTkzWUlwM1ZwVE9zeHZaa2xGbFZibUk4TkdiZ1phbWZwWWZoTXJXMFhudGJNUmlOVG9NNFVQRllDMitmOEFuUE9OeWkzRkt6TTNnMUtXU3gyZFlmeS9nc3RUWXpZMkFDSlgzOVEzM2JqUHB0SSt2RVgzSmZWcHlVYVpoNnVOalU1ZklPa0wvRG1qaVlMdWJDRnB3UGVpZlJCTno2UWRNVDJqTzJScUNsb3RjbWQ1WVRVMkhjK1ZNSW91akFFUUM1NFFhQndBVE5UR2NKSEI1WVBLQlJRVXI4UDVyY3BrNVhNMm9od2FNVGYxM1F3QlNyZFk5eVgxS2ZWdHlVWUhYS3R0OVpMVDByWHBDN3RJN3o1VEpxeFRVVjNibTk1VkJKeFdLM05wcEllSXV1MXNOSlFBeU00MktqNXQ3VHMyVlNYNFYwR3BqY0ozaldJMVIzU2pLcmc3ek4yZi9uOStDR0lCVE9ocEtNdmRFYURNRFJibFEyRDA2NDUrL2NPTmZmQ2N3UWs0THl6Q3lVYWZNV08rN2oxdGdHU1NqZGZydGp0MDNLRmtDdTZ2NzhrQU5KVzFWQStScUk0alJ3dTV4bGUraVBiMGorczIyTlEyRDdDSmRKSnpiblFoNW9BTGNmUUpORUN4QVVWQVU1YU9VcFlvWnlJOHlPcUpPVE9PU2tMNnY3czcrMkRZUDVHT0tpaUo1c2htTklSNTRYRUhrZ1pSdytTSkxpb0QwUU9OUGRxRnRWSUFVVlNXTVZGc1JpbEtFUm5EUWdFQUtZYXBQUE9yelNRZ3kzUTMydCtCQldBVjgxMDR6aHVoQjZpY29RaFFhaVRjVVRuc2xMdkZOSThaVy9wUm1UcmovUnQ3QVh1TGNHRzBFYnJ5aTR6dFhnclpGS25IbFpIZVoxQXR1ek5zRlVEVTBpRitJd1ZTbmhzS3VUS3ZScVltQXhBUEhpWkJvTFlBSmdNT0t5R2dDc0RpUUZWa0tRbFFJM2RuMkFrVjYrcElUOWEwSlZVckR6NnlNeitnU1NmV3pIUytDaklUMmU1UGRmc1hqeWVRZnEzc0FoYXdBZmZWOTZZZ29xaU04a1NwTzZ2bFF6d0VFQ2tWWUtHS0FGSUNjS3FVVWFvaFNOQm9HYU9ndzFnNXFLb0NhdXp1Y25lUGpLc2JnMG5WVktxbGk3TGdQaDNOMWZzTHNGOEZDZWZObEFIWDdTOGZEeURSZUtJUGhBNVkxdUhvd2RvK0xheHpKdEx1VElNb0RvS0ljMlVjQ3ltV1RUZ0FLWkZ4VkVCN3F3cDViV1huSGFGUThpaGVCaGJ5UlNvTXFKR0dRaVd5ayszcXhtQWlFWjR5azdLdjlDRHVnOGJnR094VXdWRzVaRXRhbzJCVDQ1azJHLzZUTHZvNEJNWVRVYkx4aC9GZWFCaE5sQXZyellPb0dHNnJNVGhHYktERzJxRVlhaGVPR2YwOXp6R3A0dnR1S3hORnlrb3ZGTStubEhPZVVVNnJtSktBa1RpR3dtOVJWb2E3bUJaUXRyTjIrbTMwM1lWOFU2NUh5UVprQzdKSllDTmJmZ3cyT2QxOXMwQjZwMjZYeUdVUEJYZEVlMEJOVFk5Qy9ISjNwZ3FwRlZYSUNRbXViRUlBK1VsTnh0Q2JiQzVRK2UrYkFGQ2V0aXZlT0ZENGpUS1lxSzlUTUxWYWFmK1RMY2dtSldYZUZ4cmJQaVpBSWdEOVR1aUF1M0FIZEZ1em96QS9ZNktvRkVSVzV6cDZhSlRvYzFoSUJwRE5Qa0hnY0N3RFFnS1NPUzcvWGdsWTNqVklnUExZU1ZtL1VYRy9PY1JNdXMrcFNwQXlrN1lGMmVRdW5DdXo3KytFU0dLN05CSWQvK2NRbURJOVQ5T0JXcnZTMnRtSWlad1FYd2FSRy80ekhjem9JSmY2dytLZHkwVko5YmlKU215RklVcGo3WVBGWktNUjNZaktsbnU1aHVMMFU2NmRWQzY2aS84ZUMrNXhSR2NMY05KTVNHQXlzMXNXazEwdzMrbkJlWElrRnhzYjB5akx3YWxpSkpwM0prNFpvcW5QbEhCTVJYVXJHMHVVWnF3M0F5SlZCcUpDTVZmNWQyUnhrTDkvOXhmWnFGaFNBWm1KV0daeXlpTVdJL2xzNWJwWmx5RkZkdkowRTNNekNjeVVnYWtHalZaZGU0ZHNkQVhaaUd3VjJIN00yUHFVdUxiekladThLTVl4QitQZFVFOXJabGtGUHgxVEhVZENhVUl4MVE5SkovZ2dVbGIyMjNVZklMdVRvaDV4UU9PREsvQmZFVFFldUFSUXNZQnlycm1NaVVWbWx2dVhiRUJnb3R3ZDJZWnNSTFlxbVpwSnRyN3dWQUNKcGxHTE0yQVB3elIwbXJObVZHTWpIZEVZeFRrTFJXeEpRbFZ4WDZxb2ZRcDNuNUpZamJtN21laG9QSEpBT2ZxclNnSFhMUkRuNEhJK0p3VURESXZhMXcvT3RWZGphTStidzdndnlCWlpzVGVyS0pDdERvZkxvdmtrekcwRkV2bkxYdzI1dE1NTjQ5SlNFRFhTU1luaWRLQXFkMTZoVXUvZTFheUlkVjJZR0Y0clg3Z1htTU91MzB1RFJvb1Zmb2ZWdVBNemdISURBNWRCUFRhdDR2WTh2VmdNQXFJTVREcVNheEdZdEszSVppVXU3bzI2L2RSMkF1a1BROG1WZTZPZFVHdG1JeHZwUW1OV1hMdWlWam5xVlFJUmdEK3AwYjZMbFpOckNnR295RGJLR1N1a1JPWUJscW1VTStaSmdUdThKQVFvSmJoby92ZU9BYVQ4Z01UWmUyTWhDbnFKOG5qMWRBUnFQYlVaMmE0a3RIalhkZ0dKQnUrL1FucnpCRFJnclRXWHViTm1wb3ZHMDRQNHhCbWZiTFE3WnhJUWlSRWVBeURsc29HWGcvSjFrQkwwRTFqampteFdWRkFPcU0zL3ZqSW1VbnlpMXd3N3FSa1hSL1lpMjUwSTV5REo5djkwTzREMHJwREFmckMySjQzTzBrcCtMUnNPb2h6aHlZYk9BZmZtWm03WlRtYmRtaW9Ca0dKR0x6TEp4VURPaUdVazVRSkxNZC9wQThwakordDFDRXpWM0JvM0pvdThCQTFocnBuQmNXUTdzbUdKOFA2RHJRTHBweUd3VXRxOEZtdURaaloxaU1aWTErTHhYSHZQcFhuQWtUVVNLQ1dBcUtnWlpCREtBSUlDZU56a0piREFFaHR3dzM3SEFoNEMxNkFjby9OZzhDTTZLOUlzRmR5Y1hvTFJhTXZZNkNXeUhkbHdQaXk4WDJLd3NHa2d2UzFVQm5ta3ZpdHpaMmIyS3duc2FuNWJzUXpsalRMeVFDUXhtU3RJbFMzVWxSTnVNNEo5bE51Um1JaXRyemtaYlNiVjRBS0t2VDRtZ3czV0FEOS9zSjkzOHpuSjFUSTlHcG1VUU1OTVFDVmJsaXhhK0k3TkFva0dQVjB1c3BHYUJteE5tUm13MmJ3emY1aHNpVXNyYWduM3p2TGNtVi9BZGU5eU1WMEFmSTdKS3N1QW1yam01b0xPTHRvV3dPdWxJa0M0YnNVV2FuMDN4ekd4RWpMOVhvSi9aS2UwaE5Lb3BUWWtXNUpOQTl0cklUQjRNUVNrSzZYM3laL08xM2VtYy9GcldseW42eEJGa1N5d3kxeWFCeUxnTlJFNHIwdlNCY3JKMmZoMU44NWRRVFZHY3FJOTZieDJzYlk4bkxkY20rWG1tUEpQcUErNU1WeWU4TTRuRTJUcktwQk5NVXc2VjA0S3BFWW9iN1NncGdDYlUyWlZrTmh6YWNyTHJuSXV6ZFZGN284dUIxRXhPdkx5TkFwa0FESE1ZUXRvS0dFakorcHpzK2tLQW9CaThsekZtUytWd09TUGlnREZWUXg0T3lqSHhkRjZDbVJMc2luWk5yRDlxalRNaEFYU01FbHBUSHh3Q3lFM24wck5zeEgvbTVRdzJJd2I1YWk4V2JGMnhCSmlKem14Qng0enVCbHU0S1lTS1g5S0UwZ1piVkJ5TnJzSXJoSVc4aG5GZC9PY1h2TCt5am1KVWRjVldLbVc1UURKdG9GdHY4YkdMMVlHa2hiMS8xdzYwd3JVb2RPWU51c1R4YU15Q0lkMlNXRExMczExTFl3bWNGakVkM0ZGUUxsSlMwY29DeGxxdDVpcm1PS3NtQkczQnFUNVdvL1ZOUTZZclBjbjZSdXZUMlhoN2JGU1Bac3ZSN1pkRFR5TlE4SUdCNlM5K3ZwZUpwM29hRHhydEZGdHRMd011NHhlUUdETExzMis2L3pGSW16QTJIZXlyWVc4U00wQmtPZk9BT1RTaVFxVlFudzM1d0hLaWVEc0NGUXhMcHRMekFJN2JWMTJjZVhDT3o5bnlrcG1EVTZ5N1pGWVhsVFlZT05BS1pBTWRiR1FwQ1dJbHhwekprckxWc3dBUDRLWEIrOXdkNDdrMHBUVG1jWFBlMGs1TGx5VzJFQXh3MXFMcnF2aU5HM0ZsMXRZUUVIZzJwUTk5bHc1djdNNHBBMDh2U1M0T0c1a0FHTVBDMTlSbGc0ZzI1S05oM0lxZ0JhYXU3d0tJNzFlT3NPaWFvRnE1Qm5zT0Z0bTJKMlA3LzZrd014WWRuNWE0RTZ6eWdxY08rTnlMbzdBQmNWTm0xYXkyNUlZU1hIVHMxMUE4Y0tmejQwNXlWalhsVS9ZVnhEU1NtNTlVNW5GNjJ2WjJDV3k4UWx0YTdHaWdiNU9jb0UwcXozVnBXSmRqWmJoTTJ4VXkrZm04OWRlVFJ0WkgyYnVNdVc0TVllaHdpQlNqT3ZneXlqS0dmb0JBQ1dMUm9CZHp3dWNtMDArbG9CSnVTQlJ0b3VUMmJ1YVZtTHZhWlU5QlNGbnBjV2F2RTZzd2Npc0NLVGVFTW4vTlNXM3R0cmNZUlpBejVlYmdXMWtJOS92K3pOdW5UcGNFRVJjTkZNeUM4WEtmb084YUlUSFNNRFBBZ21WUWdRdytmVTBGeVNLWGY5cHE2eVV6OUxOQnNIRnFhMEQ3cTFwc01JRFNWUFdaZElubHhUTmpLMm5penhGVlVXMkVIdUcyTWdxSzRoM1krRjRyNlFTeUJpcmtuRkNpa3M2dWhPVTNPS3NQTzdKZnkyQnFWaFVkZXRwZ291cnlFb2dUQlNWUkRmWk5rNFg4NnFuTmcrNHQ4dEVJTVdSK2prUlNQRjB0Z3d4TGZDa29rb2lXOG9iaGRpSTd3elhwWUdkNytHV0EyVEdOTEg1SmlYUEJsRXFVTzJYeG9GRFdVMFFtRWpNbnczamlleEF2NFJZU1hKNmt2M1NZU1p4Tm02SmJDNXQ5ZGpHeWdnUngxYVRBN1ZJcnFXc05tWXR0MVpGWlBNanBhUklMY3hHdkVzTGlGWW9mbFoyTVhaR2VySVNpVjJjTFIrTndLVXdpcjliT2F4cnhSYWxyQVFCVmhLY0JDTzZMZmZXbUEzbGt5NWFXRXZPOFlEVXFxdExKZk4zSUlaQnZXa2l0YmlnajZxNU5aNWQvT2dqZk5jNVA1MVpmTXNPbzdraEt1N29SRC9STjFHSkJGUWc0YW1ZNk5KTm12cnBac1d0OVRSeC96REhWM0J2SXhkbm5peEZOdS9JTTg5VXM2WXU5WUNrUVNndXBMNFNOVk9FamhmQ1VoTzVOVjlrKzJ6RXZSOWlJMWNYZVhVNWJ5UW1rOU54SmhwNkV5bkZIcmRCNTVaZ3ZOeVZPREJOK2F3S2s3QlN0WDZFQ2R6YmFIVTR3MHBrKzBEMDltSVBTTnF0dlVENndGbzhOVjRrWFVsMTNnbmRtdURmZzNlYjZBS1owUVZPd1RNMDRwSmZtOUpuSUgvNENBQTNUMDBwcGxqcWFDcmxYSGZRWlltc05Lbk9ETGszKythTURTdVI3Y1hNWkFFektTcW0zM29rcWtYcVl1a0RHN1hXYUVYVlNFbjZxRHhhazM0dWw0ZG4yYWkwTTdud0dVUWpjOU9ZckF3NFNGTzAzUkdXQUtIaHNkNTRLc1c3SS9FbWtsZ3BlRk15N3dmdjlFSnljaFRCUmFudFpTQ3BpelYyNGhHUXZ2eGJlODdSbnpsWEdudlVyYmZTWkZWYTVZK3I2S05RYmxKNUkwaEFsYStrcHFDTWpSVGIyUXBLaHUweWJCR2Uyd1oraE1XT05uQytqeW5HK296SnNGSkp5WWwzYno3VGlSa2g3ajdPRno3VmpXeVBzbXM3OTNOWDdqNHdBdEw1TytOL0pIMVBSOVZBVWRvOGl0aEhWVlhTUnlXYVE3NGptWTR1cFhZK3M4c21BQ0U4eGpyQVIrd1ljTCttQm9HbkZLaHFybDNRaG5JZmxQVzNLbG5RZmd5bTFPYmE5b1FCYWJ0b2YrMzVJeUJOMWRVelJMZW02cVBudjRZdmIvUDZpRDFTUVJBa01odHgrU3JHelFqckRwU3VBZUFxSGVGOHlodEl4dVIzSkZZS2dVMlZyYnE3R1ozRXY4NmYrVXNZa0RhTm5ZdEdRR3JFOEV6cHdHNlVBYW40YVBQS2ZxM0N6d1RnS2kxS2NHdENoQ04yb0p0M3NhTTBFTVlHRmRmQTltcHNDcGo1YWZ6eVBFcjUycVRLRGFXODdEMnZtOFNVeTBRVzRTSzQ4YnJlMUFnRGNtSVNucDRDS1JYYXNYcTZkR0F2cXBtMW5GVkZWZ2tKN1VrWEFRMDlEMHY1MkdQQ1k4WE5RaEFuYVNvZVBDQ0JpbDlSalYyN2tnM0xGWU9KNmcvZjRlSjNWZWJpS2dqdS9MZEdaa0lsWVVBVTNMRjZLbUdJR0lsVTl6N3B3SDdjR0MrUU5lRlRHQlZiRzFSQ0NLb0NKd2k4cHhqbTRoS2dYTmxBUVdCRnVJRFlCbWxGTmZES1Fkemp2eFFIR2RHOU1TekU1YlFnM005QndTMUVlSG1tbXpBUTJQWm11anRiOVVRRTBwQWU5MlJBSkQ1UVdGV256YktqVklDQm9PeTlvRHJneG4rN29IYUx0MUlubDN5K3JFSmZLWFFLdjZlMktDcktNekRLUE1ZK1NqRVFTRXJ1R3dOSnlTdjJKMUcyVEdxazFLU09keE0vU2dHVUxqRWhwdEhLczc2Y3RKVHFiK0FNTFdFWDVPSW1LaW9tTnhQS09pdmhobElRV2lvaXZHanE5aGlLM0JwZDR6Q2drUXgyVWlDUlJ0b2hNbEpjY3hKdllYQlU4ZFNiSXErUXFGUVZIeXZxWmNCWnRXV1BjUFRxdUlvTjJvSFZhK1UvVG81UUorMlRTUTVUMVdTNVNkSW1jWWlSVXV4a1FGTENZTGFVa1ZRTVd3elVxdFA1UkNkWEF1dVhyS2RkWWpCL1BVcWg2bDhDOExJWVNnVTE0YmJkY1pNYml5bjVZY0MxYWZBMDA3U1RTUUdJTTI3SEQwczVoZHZFbW1nckhTMmRXM0ttWWpJaXdCNXFpOWNIRTJ1bVUyV1dDdDRvVHIwZy9VL3owclRNU0pGRmM2ZjQycmNOTUtyeUdWUjUxS2xVYWRTakpnd3FUcVcyMlk0ZUxRSW9VVkZJYkUvbFFDcTllcVZPRDlpY0t0Q0ZEeFBpSTdYTjMzdTY5bG8xMjZkUVU4TUUxbVhlUWpnN050emtZY2kvZ2R2OHZhZnhGc0tBeHM1R0RpVDdtU3dWN3ljOHpjR0JsYzlRY2c3NkgySzRrMHJPVS8yNjhMVHMwWkxIKzZSUHBVZ1pLVUdVbjhHVURCOG5QT0FXK2hhcnZZOGg1aGs5RzN2VVFzZlpMM0dMMXhmNkNENzIrQXRnUUdPbk8yS2svaERXcEFOck9OUTM1Rll2SGlmc1RLeDJUcXpLRENpY0ZYbHNZUkVrNk1NSlViQXJDbWZIYXRlSkUvejJiZXZyOEtGa2U4S0F0R25zdEhOR3d0NEFWMFFnNVdpa3pzUHlINERCRHQydS9rR3Y3eXM1dWNMQnlCb1ZiVENoUXp6b2dHaDBQREpZd0NESXd0ZVAyM2UvbGNKWXVLNzA5Nk9OQVdZejJNa2U0TlhwdzVJb3RKSkJlbExjVmdyRndOOHg2R2d3eEM3b3VDenpiMlRwQSsxalJ0WXN1alR6SCtMNHRjT0k2SnlIK3c1MHJzZStQaFNrUFRJUWQyOGhQS1ZhSzhNU1FwVEl6N2JKc1pNeVVtZUFJcERxd3o3Z2xseitaQ0lVTjZXWnNJTDhkUmpUQWdIWVlNSVNJMkhKNTRVN0hpZHhQU1dhQ0NlR0RHN3VMZjFlUTJOQUJOSUFsM05Hd3FYMVpGNDZzREhzV1RRM01UaThXd29aWEdDZ00wdmVReFR1WmdkVWhlOUh6eUJvZzhHSzF0ekdIQWMyWTZQSGhzaENIRjJMaVQ2Ni9EMFBkeDc3YlFKMFJzNFFCcVJ0dFpNY3pZR1VIRjlMSGhFWktlbW5KMHdRS3pPQlRDM01mVnBCZDBrZGlLd3VjWURLM1FBSWpIQkd5ODI1am96OU94YU1pSnpGME5ZY25GdERMazZjZ0oyY2ZneXJVeXc1RjdvUldYcmVGQVBDZG13MXhVNlNBdW1CRThORDBvRlRHbzBKSmxuQ0FKTXQrK1JTVWNtd2tIMlRTYUtmdStzZDFpaWNHejB3WVZFWVdNeGpnNmR3ek1pZG9jTjh6bmVnRGNWU0tZeG9zU2lHMkFtcnhva1R5bkhEUm1UenFRQWpQWGhpK1BBSVNGOCsyTDFmT3JDcDBhaUdsQUpJZ3NuZHNwdW1TZ2RhUjZMUWdZSjdzejZEcnR0QjM4VjVZQUpHVERQTkVlTWduTTk2N1JtZnUxNFVzdXBTaElvVmIxV3NUUGJvU2NFa3RYMHp3RWpYLzdCN3o4aTFmZUgyN3NKR0gwK0lPcW5YU1drT1M4c0VVZ29BSy9BU0Nya1Z2cFBkcUlidmVHUmNIRHF2SFVNN0VacmZjTXhDQmFEYUlFTG5OZGppWEFJSlNIMk1yQVRnKzZDc3Z3T2hQOXBIa2MzSjl0SkdtTG4ranU1eG9JRzA5RDlLQnl5dDQ0TWlLL1hYQVJNY3RVbThHM0p1eTR1WU1RaE0yNzF4MU82eWt1TjZYS09Pd0lUMlp5MUFCY1EyT2lLM2NDNFdSSTZ1d3FJMkVuNFBWdEU4VXBvRC9kQU9KNGpZVXJjMnpHeE50cGMyZzVtK0JhUWpLMFBSdmMzMDF0TUg2eUtFU2dwVkJYZUZkS1hYMmJ4cjgrOUlSOEF5a1JPeWVtWWNvVmdNRmVJa0JDZWF4Wkx2c1YyYW56T1Q5SlBkRHlpd1U3aytxaXEweDlkRU5wL3V5VUF5bU9sYVFMcDlmdkFENlFQVGd3Mk56bVNVbUN0VlFadlFTYVdkV1NRdWtaVThCZVBjOGJ5UkVaMFU5Z2hVQlhBVi9nM084Zmt4M1BrOXhyU3VEY0pzaExJK2xGMzdwUHFJUDRaRU50bDhackFoQXVtTytjSHRoSjBVU092dlBaZENzZDRudjcxeG0zUldFbHRSdjZzUm1uaXVEYXZxcExLc00vTSt5MHFJZ1FnSG1idStvSHRjWXpzUmx1WHVTaldIQ3lCenJaeitjb0JWQkxnWWlXSUpHMDNRajFYMFVmRXdUQi90bnFRMkR3aHR2T2JiRzk4ajdCQ0c4cUZ2ZzYvZXBiMWJCOFhFNU16R2NucnlWSFJYMGttU3lBVGVIWlV5Ri9KYWlXWEVJZ2lkbkUrQlVkQVIza1Z3b01kS1BrT0JvNyt3cUxrUXZkeVVyOThZSWV4cG84MzBEM004VnF2anBTRy9BZExNaGxpQ0JjSUtZWWF3azVkSXdQeGo0K0hGNGZlbEQ4NTIxeUFaSm55Q2o4c3BWM0Z2V09heXdxemszYzNvaFBvRjQyR29ybWE1TEFqcUkyOFVBS0xueXRCSmR0cWc5dk5QYnQ2b0doc3hMaEJ4azI3TjBVY0VKbTNyMmU2cUNDU0RsWTRMSk9LdmpWc2U2djJEOU1FZC9UYmdZRGhLVWszcTN2ajh6aVQrM1MzWTJ0ckhDN1BSQmhNd1lMTDFqakd6d3o3RmlNMWpKdXM2ME5hUVZzYmNUakg0YVFuMEkwRTNxVHFCemdTdUhGVFZyUm43a3EzSjV0Sm1zTEp1c0dNejB2dSt2bjZyWmpYV0tVYjY1TlByU3hxcHc0SytxTzdlUVBoSjRHWnhBNnpFSHUrVklSeGpZVEh2WTcrMkFXV0g4ZUdCYldnWGI1bk1PUCtkRHNnWkJrR20xRlBPUmhoZ28rcHViYVNQdEkzSjFwRlF5U0NNRUZZSU14WWphYkZFa1Z2bnJxT0R4Zm5sNFVHUmxUYVdZRGpNQkRjaVZuSnZZZEVkcnREN0hZS0NpME0vR2NpNEdPQmNuVnRmUXdkWVRCNEowUjVhWWdNSWdpem9nOGgyelp3Z0Q2YzdaRGJpcWdVaHQ0WkcvNUtOeWRiU3BqSHlROElLWWNaZ3g1clBSbUZjKzlhSCt6ZExKNWpyclduS0c3QlpibDg2WVZCMGgxaUp1eHVSZFhGbFlISUVNUGhNWWJrNFJMWkE2LzVuWGJjTEttUyt5MzB0Z0FpQlNhS0tyRnpPUnJ6SVJ2YSt6cmRoNnRZR3FhMmw3YnVIQm45SFdER1lBUTVJYSsrN1lmMG1BcVhrM21aWGo2ZlVaNmNDdG91Vm1PaURkWEY4MFpRdlRUakZVNHMxbkRJSCtMcElhallqdWVVVnNNK040RnhqSUVqdzNQUG0rbW96YkVRQ20yeExOcGJjR2gzMndadmJOeEZXSkNDUk5tcC82NEhlc2NNbmg3ZExhTnkxZm5MczNxQmFUc2wyMTFnaGduTXl4dUFMYVhTSFRuaGdDdFhVa0FFVVYyc0xzSkxqL254M0dhckJ1U0RpaXJudTJDY01zM2VRamNwRmRxcDlORG1RYmNuRzB2Ykk4dkQycjkzZG16ZU0xUGVBWkJLVEpKN2FOOXpUKzJvb3kxM2ZXSU9oeVhSWEV0MklFN0VTdW9WV0lYUzJFbnN1TTJFeDYxeU1yQmhBRlVDRlVKR1JpbnprakE1QWk0WGNhd0NHaWV6Znc2VXdpdjJCQ0JPeVVUV1JUVFlsMjA0SHN0bGZ2YXYzRlFPaURZTVpqNUhBMUUxVy91UG5WbS9xQmlZRTdGNDVxcEU3ek9wdjZJK3FkdUtRY3EzRUNGQlJQQ015NHB0eGN3d2IyQWxEY0Z3VDc3YTR5ajh5UTB1UUE1RElpcjQ3ODhTMTQ4b3I5VTJKTmtMSlRpWUpTVFlsMjBxYnhzU3F4Z1pwNkJXREZaQ0FSRDV2ZGJHZHJONTJlSENUS0xvN0t4QjFUZjJ0WkpDU3BKVThBRWd1RHR4eDF1Q05hbVR6UTE0MTNnM1ZpOEFCSHpic0NBQzM4dStBeHdVUUFuc2RHQUFSTXNWZGpxMVpsOGJsamFUNnVlZldocWxOeWJiU3BqRnhJMkdETUZMVVJ4NlFUQ2hIdExYNi9odmIxNk9RSGxYNno3dVdjbGJ5UlRjQ1U3U1U4a3FzaXhQcVo1NExLTG81ZEZ5YXJadFlRRG5zQmpoaGljUWQ3SVk4Z0NUaGo0VWNFM29nOGd2UDZDVXRPWmNXaXRRRU5ob21xUzNKcGtxY25nUkltREFnSW93a0lVWUNrL1plL3ZSM093L2VkM3g0aStqZU5oWUJPeHRaMlVRYWpPVlNLZ3F6T0R3WEIvN1FqQklXc2pQWkxqTUlnQUkzVXoxWmlRU2R6M1BudFVvcHdLVWxvSlNkeE5HWG9UNWtiMDUrY0JLQkNEdWQxS2JTcHJGd0syR0NoaUdaL0JHV0FZa29pNmFZckgza1crdWZrMDZzOUsvWnN6UXZzeEpXRTk3SUZEYTVpQXRZbDhaa2pMRW9nTUhSS2phZ3JNbzlDR1dRUUFNUFBEN1RvUXNhdE5NRGJBYmVUV1J5a1ora3Qwb0V0bjJUanRsb3o5S2pxVTJsVFdQaE9oUHlMN3R1alFXU1VlSkVYVXZ2L1ZyNzl2bmw1R0FvRmFEVzIyTld3ckppTHVmaUhHM0V6YnhndzJXM2h1Vm9IMjVJTEFNQTEyWDVaUktoY2VPVUdFQzZPU2FRa3BSU05wd2RjY2xOeklSU2djMzFQNEdJYkJnSytRa0RoQVhEUnUxaXRCWmlwRHg2U3ovMDRiOWR2MFprSlgwbCswOGVHckZTc0ppTEZWeWNXeW9BWVhnc0N5YS8ydTVuc3dINEVZNTJ1RjJKa1VBYURDZVBBUyt5a095YW5TRXY3R0E1ZVphdzU5S0s0SE9LczBNdHNNbDJaRU1WbUhkaU1OQTJtT2l5eVdyaHN3TVQ0aTI5KzB0cnR4MWVDZzh2YWF3c1prbEthNndTRjVHRmdJVmVVaTQ0UE5iTEQwa2xDbURMSS9hd1diN2FMekVST3hxQU9ZWUhrUE0rSWo5V0tqRGlzaHlFWEkyV3I2bVI3Y2lHMHFadGZ6dGh3SUJvSlMvU1ZnS1NFVkkwUklCbWxyVGZkOFA2SnlFd2Z2eUFSblRTNjVseDNTWENXNXljQ0VJaUxqeldPalFXU0FhVUUzVnhJVDNJVE1TbkN2emtwZ1FnYVV4VTlkOVhCaUtubnptQlRSNUUyNHhzRjloUTIvNXF3MGFreE5kZGtWM0dTSG5KaElUVmtnNzc3dnpoL0VBczV0TGM4RjBuRHNPUXhpc2xHQmJlSlg1YkdrdFUxdG5vdXBnU1FGbWdBb0dSV0ZKaUdBbjRjb3NFSUh1VTVpWkFoS0hsSmZ3cWdpdXdhWVlJMllwc0ZwclhmK2VSd1RmSTlvYU5sb29sa2NwQU1zaHI1NnowOXMrc1hETklRSnprdEh0dEFXcnQ1UXpwMW1SS1h5aUczRm9vbkdjVGU1NTdZL0kwREtEWVVvakhOM3p0WDhxSWkrZDN4ejI1ckFpK1lQZW5TMkhGL25KMWtYT2o2cHQ4b0xVUjJZcHNKbTFrNjdkZHUzSjFFUU1TRzVVeFVwNEtJRXBidlBHZTNwRWI3dXArVmhiZUFPY3NQQUJKdDV1TitiV0VONitYS29HSkMrY3hRT01ZeW1hN2pBSkNJUlpLYW0zQUYzamR6ekVBQXNEZ05DWSthUW5NQ2lnaG9lM3JvckhBVGxJYmthMUNTL3A5L2U3dWRXVHozUDVjeUY4WlNBVldvdG1VcTIvNnk2WFBuMXhQSHBKZFhBLzJMRHc0Y25FVXlZWDBrbDlPUVQ0VklIU2FsNi9oc3N4Y2pnajhqRFlJT2tqOFR4VG5qS3Zra3BUU05aZmRYR3gvbFBkdkNpSWRvWkZ0OW1vYmhWWVlJUnYveXY5ZStwekpZaDh2WTZNcWpKUnJKVUxraVpVT3R0OTEvZHFIS1k4bEhieHovU1JNbnp5U1pVdFIwa3ZTM2VpSzVUQ1lwTHViVFQ0V005WXNhSUFGbDlpa0Jia0M0OEJ0QUpXd2FJQ2h1Y0lzMzY5MmxFYjVQckxOWENCblJMWWxHNU90alV0YkRHbWp5a0FxUkhESEtQejc0TTNyOTN6emdkNy9EWDJHSW9Gb2JVVk1WRllHVTZCVFEzcURuZmdZR0xRdkQrNlhtU2lVTHJEQUl3S29vcTdqSXJ3SlFGUk1QSkpOU3FJMDBMYjlQTm5ZaFBySFFwSGFwSXlVNTVXV3pJbmJWL3o1MHFlT3J5VVBoTW9uNXg2N0Y3QzdrZVlxZVBFdGdjbEoya0hWRUZvQ0ZQb1RIME96UVlTY1VTaTM1TTQrQVhhdUhNb0FxcEs2QUg4OGVCVVFwZUthdklPMkJka2tWQVlobTJyYmZ0ckltV1BHNW9NcUFLa0VKSVBJRFhQeXhhWDFaRjByK3ZkclpkK1ZQa05MQmg2WXZ3ZUcvZDQ0NjEwQlRGWlZHekd3b2xwQXpBS0liSUFZbnArMm1jYk5oL08vRDJRQVNTekVaYWt0Rmk0SFVacTkxallnVzlRRG9UN1prbXhLdGpYdWJNRU1Yc050QTFKaGlBblJIU241bFU5L3QzUDQ2bHMzUGhMNnpGUnZIZmJQM3dzRG1qQlFFVXplR0c5M1JiWFFMSkFLZ0xMcmE4QVdYNnV0azgwSmVRZ3pZQm1BbUJJUG0yd1VFNzAraUtqdnlRWlRnY1VnYUNOYmtrMExObDdPWjRoc0s1QUs2UUFTWURTTWJ2M05IMSsrNmJ1SCtsOEtmV0IyWXhuMnp0ODNHdWRkRFV6SWdNbGxKeWFrTHdFVVYxdnp5eVJRY1R3UzhPVVJyL1pXRFVCRjUrVzdNcTZ5SHdaUlB2NTY3L3o5cVExQ0c5bVFiR20wOEZGajQ5NGt3SmdJU0lWMHdGRVRGdlplL1djbi84L1JsZVR1ME9mbTJvdXc2OGo5bWErdUJDWW5uOEs2T2tjN2hRQ0YvSkkwM0RTa2FtT1IwQitiNFFLdDRrUktLQ1k0T1JaeTlaQTdKbHNBRWZYMWJ0M25jKzBUUVp1UzdjaUdCampIalczYlZWM2FaaGtwZDNFa3dtZ213Y25samFSeitZZFBYcVhEeGFPaHorMWFYVWpCTkN3QkU0TGZVV0YycWdBb0MxU09saEdtYWsvVWdGbFRhWVFoTEwwMkYwQWNDeUV6VzFsbUlnTFJmYkJ6ZFNGb1M3SVoyWTVzU0xZME5sMmF4S1Z0R2tpRjNOSng4OFdyM3puVVg3cnlFOHQvM0IvQ2VobVlkcE5tR2c1RU1ObEx3M0N1anBsRHhnQUtRY2d5ZTdOcEp4aURCS0VSQVZBNkN4ZTgyU29DZ01RVjRRcGxENUdKQnJEbjBYczBpSTZIRGFodFJUWWoyNW5FNDd5eGFYOHpnTmdVa0FwUjNCRnpBZTNQM3RhWi8yOWZYcnRxR0lqa1VqZTNkZ0wySDc1TFJ4SjlRWUQ3QTdxS3JnN2RnWEhvekV0bEpqMkNCeXAvR1dRL054VENUbWhFQUpQVTlPcHpMb0RBV2tuWFlpSGtsNzJ4K21vVW5mWFR2dDNSWGd6YWoyejA3aSt0WFVVMk0xSmwzdGh5WTFLWHRsVkd5a2RTNWtpbXRFRG52M3h4N1k3MzN0RCtuNVM2Q0gyVzFsbzY1OUFkZ04wT0E2YXdxL1BtcG9GZnpmZFl3alUxVjB2ejVyQldtclF0NUp2OGM3anM1NDBXQUh2UUhUZnZuM3NVUmc0aTZrdnEwNWtTWVUyMklSdjkxNzladXdPeThmbkhjcy9Dalh3ODVVQnk5TklqSnUvUSs5M1ByMzd2UTk5WS85TlFHWVcybGc1SHozLzRkb2pXbGtkSlM3czI1N282ZjU2VDk5UUF6dVdCUDVXSUJVWnBvVll1NEhMQUErQmRwKy9DWERmbWpRRGtYUm1PUlRYMUlmVmxxeVRFcDQrUWJjaEdSbHd2R050dFNoY1Z0L2lkVjF5OGxjL0Q4MTkwN3ZEYXJ5L1NSUkVLNkluTHJiKzVzM3RrejB4MDZKS24xbjlTS1Jtc05MOThoL2JsZlJWRHJ6a3pldXlsQ2p6cVhIbFBvbGJPczQ2NVI0YXFTay9ZM3RKVytyZ3RmZ28xc2dWWE55THpXU2k5OGZRTk9IWHlDSnh6OUY2SVM1NnJSMHlrUWZTK3QxMjdja3RCNDlKaTY4YzBpSHBiL2ZrUmJNK1dvL3R3WHVSN3gyZFdibm5QMTlxbG1vbFM5dnNYSG9UZFdpQmlyOGVJY0ZjNzhlNE8yQlZwSFUzanJmT0JvbXNxYjNMcHhJb0pVV0lmZjJLbDdNWWNFTkdzSGQxWDFHZlVkNnJrcVVOa0E3SkZBVVNMeGxZTGsrYUxUaGtqM2RWdHdPdGV1Z2MwS3czTVJlWE0xTHpoN3Q0eC9adnZldkd6NnBmRWtXcUV6dFBzYmNEMDZnbm8xS2RoVUcrT09pL0VUdGxid25QdXZTZXloeDV6cmlTdXFrWkFiZ0FndkNlekQvRERRaGdBMFhpaW1uWmxCeDQ1Q0ZPZDFmSTdmSWp0UC9waSswL2VkZjNhN2FadVJtSCtJYU9MTmkydVR4VWp3U2YrODBYNUtJRjVjNkYwd1lNLy92TGF3VGQvYlBtZHExMDhWbmFPK3FBTDV6MXlKK3ljdngrUy9qaEZrR29uN2c3MVNoSVNTM0ZyWjh2c1VybSt4azdubHZKVVBQdUFtNDVnSXJJMElLR20rMlR1eVAxcEgxRmZsVzNVNTdydmY1OXN3SUhJMkF4T0t5QVpNQ1VGTUQyY3U3bFBmcWZ6NkdVZldQeTlzZ3g0M29rN1Y0N0NlUTkrRCtyTHgwZXpVMEx1Ymh5NENVc2JGMEVsQXF0cW5TMmNBUzhDUndhUE82d2s0TVl3SzNWUVgxQ2Y3Rm8rV3VrYXFhK3B6Nm52Qys3c1lXT2JkV09yYmRzVVhuUEZsazV3M2ZLczk3YzMvdjY5Qk5CcDNjN1Q3VUxkZHV2V21HdXArUHAvdmVkTlAzNWgvUldWSThPcE9UaDU0T21RVE0xQUZHVzRqK2hSdkt6L2NWeVVxdUtvdGlpNkt6eHVWQmJRZ29zenMzSFN0YTQzMnJENzJJTXdIVmlxbUt1ZHZlb0RpeDlkNmFRUG84MUJkSWdEMFd0MnJwMitRQ3FBYVVxM2MzVzdRTGU5QkNiNnpnLzk4czVMMy9qQ3FkK0lvMVJMVmJDVmd0VzVmYkM2OXdKSW1pMGJVQ3dBbUJoTmJXZUlOaG5Lc01wVEx3dmxGQUtRNm5aZzdzUmgyTEZ5UERoNTBSWFZIN3RsNHlOWGZtTDVadk1GZVpIOWNKNXdkSm5vdEFlU0FaTXlZTnB2d0VUN0ZuM3Y2MzY4ZGQ1Vmw4KzlaZDlzOUl6S1p0Rm9XSm5iRDJ0N25tSUJpdElHdmlndkFZNHFFZUtiQlUyUW1QaUgrdVVUSlZJRzBnQ2FYWHdFNWxZV1NxT3g0a2FEMG1nODBhZS9tMmFyMFNRYkZ3clJHYXVKemdnZ0ZjRFVOSXowRk4wT1VIS2JDSVZjM2JWdjNuM0ZpNS9SdUV4aklaNEVVTzJaM2JDNjUzem9UKzNRZ0ZLakhKVE1VaE9DUnZsSFYzbVFZeWx3SFBiSkY3bXFiNnpDanNWSFlhWjljaUlBMFpqK2J6N1ErOExsSHpyNUtlUEs4clVianBsa0l6RlNWeExXWnd5UUNvQWl0N2JMNkNacU8zU3IwWHRYWGpyOXpOOTkxZXh2N3A2T25qYnA5M2ViTTdDNmN6OXNhS2FDV3MxbnFjcllVVnRtb3lxSEZOa0hCZ09ZMHN5elkza0JtdDMyeE45S3N6MW9vUDRIYjE3UG4yeEZrVmxldGtvcitScEF3VHpSR1Fja0E2YllBT2hjQTZiZHVXNmFhYWo0NDcrKzY5VXYvWkhtYTJ0UjZ2NG0yaExOUk9zenUyQjl4ejdvem1xOHhuRUdwanhiUGpHd3RpZlRuUU5uRk9MVEV4blhsbUI2OVRoTXQrVkYwVU1iVFY2a09ZYS8vQmRMWDJqM1VoYks5UkNGOXhTbFVXaTNxa0ZVV3ZZNEk0SGtpUEI5Qmt6N1RJU1h1cmFmZVdaajEzdXZtSHZEeGVmVkx0MnN5Wk1vaGcwZDdYVTBzRHF6dTJGWWIycVhwMkVVRlVzdGhYTE1ab21KZWFxbHRmUk1rajJGTWU1M29iVjJFbG9hT0ZNNitvcVNUWmUxa0tiTy85dFByVno5dC9mMzhoWFZoeWJsa2cvck9jNko2ck1PU0FYZFZEZXU3aHpUNW5KMm9tUGU4cEtaaTM3cnBkT3Z2MkJYL1B5dC9zaCtyUW5kcVZuZGRrQ3ZOUXVEaHNadExSNEpkS1c0S0U4Sm1rUjRtSEZlbnRHTVUrdXVRNk96QmsydGU1b2JhNVdTaDJVYnJRcENpM204LzhiMnZRVVlFd3V0R0FhaWxzN1BueVRSZUVZRHlYRjFNMGFJazd2YlkvNDlFdDcvN3VVeno3M3kwcG5YbjdjemV1NTJlcDYrWnFsK2ZTb3R4MUFqMWtwcWRSakdkY0NvcGx1a1JYMlU3dE9Pb3BDY0hoWk0rMlFBOGJBUDBhQ2ZzazNOdEhwL1E3ZnVkbDVtdXNqVkIyOXVmL0pQdnRJdUxuaVdyL1c1YU1MNmRHNStGVmQyVmdLcHdFNE53MGdIVElwZ3Awa1RqREx2Yi8zNW1lZjh4b3VtTDN2V3Z2aUZTajJteWFESGZDTTVSV3MyZnVSYjYxOTQ3OWZheFdwQVlzTDZmUExpTWZPNnQ5bHl4MmtEcE8zYXB0OTZKRGJhYVpjQjB6NGp6QnRGNWZLYUY3VE8rZTJmbi9tRkg3Mmc5clBObXBvN213QkVhNXZmZG5qd2pmZDhyZjNsNjc3Zk9lcW9zUjZNNStJdkdEZTJzZFZ4Uk51MW5UWkFNbUJTSmlVd2JkemN2b0s3c3dDMVp5YXF2L1BWczVlODRubk5sMXl3TzM1K05FRWU2blRhYUlBalBiTGpTM2QyYjN6bi8xdjc5bUxiZXZabkRxRGNqUjAzZXhMWGcrMnEzSjkxUUhJQTFTZ0FhcTlKRlV5YnYxdkY1aGM4cFQ3N3RwZk4vTlNMbjFuLzZmTjN4cy9Wb0txZDV1QVpQTG84UFBqTisvdC9kOVZYMi8vdy9VZjZybjlKRElEV1RVaC9vZ0NnM3VrRW9OTWFTQXlnWm96TDIyUDI5TzltVVpUbjI5UDJ4QzBkOFYzOHM4K3EvK2d6OXRVdW5tdXA4MDZIMzBMUGdIM2crT0NPYjl6WHYwMUhYbmM4dERqa0ZpMGpOOVdGOGNLZmkyYmZQbDBCZEVZQXlRRlUzVERTbkFFVHRWa2p5dXNnREluNWlRdnJjNzkwU2V2Wmx6eTEvcHdMZHNWUDJ6Y2JYVGpkVUx0UDVmV3U5L0RrOGJYazBDUEx3NGR1ZmFoLzl6WGY3dHp6blVOOXFYeFA3Tk0zSW5vTnhzdnNyUmdHNnAvT0FEcWpnTVJvcUtaaHBaMm03VEJDdldYZUQ0NnpJbGY0OHVjMnpuLzJnZHFCcCs2Tzl4L1lFZTNYNEpxYnJxdlpWaDEwVTdOVSs0dVVxdFhNQ0FWYVpDRkJIRkJ0cTlQSHRVNGYxdGIxWG9ObTVkaHFzdkR3eWVIQ1BjY0d4NzV5c1BjbzQ2bzQ4QXdNZURhTWlGNDJyVzFZYVhBbUFPaU1CSklEcXNpNHZaWUIxUTdEVmpsTE5ReFR4UUNQZTdvQWpkdnFHKzJUczg4S2pKL3QwVEh1S3prVDdhR216cnYwYklpY1l3T2NwbUdtSEZqVDV0ODVxR3JtMk9nVWdnc040d3dONitUZzJUQ3VLZ2ZPaG1HZW5qbjJqTjVxY0hac1EyT1lEWE9YMXcxNGNzYWFNcUJxRmRpcUNLcDhIeFZBbGdOTkZRQ1M3M093SkFYUUZNR1RzMDdIZ0djalp4elQrZ0NRd0ZtMDFlRHMyeEp6cDNjTGJGVXJNRkt0QUxLR3cxWTFCMVRLQVJJNjRCazRyRk5zeGZjR1p3UHJQTkdBeExIVkVPeG5hT1FzVkd4cWs0eUVoZThZRnRqcENiWDlmd0VHQUZqQXdNd25nTlhKQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDlsZXnpLrnlKjmiLfnmoTkuIvms6jph5Hpop0g5Lul5Y+KIOWllumHkemHkeminSDlvZPnhLbov5jmnInlgJLorqHml7ZcbiAgICBkaXYuYm9udXMtYmFyXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJldFxuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5mb3J6ZW5cbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93XG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cImJldE51bVwiLHYtaHRtbD1cImxvY2ttb25leVwiKVxuICAgICAgICBkaXYuYm9udXMtaXRlbS5jb3VudC1kb3duXG4gICAgICAgICAgICBkaXYuY291bnQtZG93bi1iYWNrXG4gICAgICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tc2hvd1xuICAgICAgICAgICAgICAgICAgICBkaXYuY291bnQtZG93bi1udW0odi1iaW5kOnN0eWxlPVwie2ZvbnRTaXplOjQwKnpvb21SYXRlLngrJ3B4J31cIix2LWh0bWw9XCJjb3VudERvd24gfCB0aW1lXCIpXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJvbnVzXG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmJhbGFuY2VcbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93KEB0b3VjaGVuZD1cInNob3dNZXNzYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cImJldE51bVwiIHYtaHRtbD1cInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi4vanMvcmVxdWVzdC1saXN0J1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2JldHMnLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcbiAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5nZXRDb3VudCh0aGlzLmNvdW50KHRoaXMuY291bnREb3duKSlcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBiZXROdW0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMyAqIDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8v5q+P5qyh5byA5aWW6YO96YeN5paw6I635Y+WIOWAkuiuoeaXtlxuICAgICAgICBnZXRDb3VudChmbikge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRDb3VudCgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoYXQuY291bnREb3duID0gcmVzLmRhdGEuY291bnREb3duXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudE51bSA9IHJlcy5kYXRhLmNvdW50TnVtXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LmlkbnVtID0gcmVzLmRhdGEuaWRudW0gKyAxIC8v5byA5aWW5pyf5pWwXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbiA/IGZuKCkgOiBudWxsXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyDkubDlrprnprvmiYtcbiAgICAgICAgY3JlYXRlVXNlckJldHMoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJybXNnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnc2hvd1RpcCcsIHJlcy5kYXRhLmVycm1zZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzTnVtKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcbiAgICAgICAgICAgICAgICB0aGF0LmdldENvdW50KHRoYXQuY291bnQpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duID0gdGhpcy5jb3VudE51bVxuICAgICAgICB9LFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpXG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50KCkge1xuICAgICAgICAgICAgLy8g6Led56a75byA5aWW5pe26Ze0MzDnp5Lml7Yg5Lmw5a6a56a75omLXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPT09IDMwICYmIHRoaXMuYmV0cyAmJiB0aGlzLmJldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5YCS6K6h5pe25LiN5piv5pWw5a2X5pe25LiN6L+b6KGM5YCS6K6h5pe2XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd1RpcCcsICflgJLorqHml7bor7vlj5bplJnor68s6K+35Yi35paw6aG16Z2iJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY291bnREb3duKVxuICAgICAgICAgICAgdGhpcy5jb3VudERvd24tLVxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5jb3VudERvd24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWAkuiuoeaXtuWwj+S6jjAg5pe2IOiOt+WPluiOt+Wllue7k+aenFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdldEJvbnVzTnVtKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5pbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LmZvcnplbiB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiA4MCU7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5iYWxhbmNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDgwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuLmJvbnVzLWJhciB7XG4gICAgaGVpZ2h0OiAyMCU7XG59XG5cbmRpdi5pdGVtLWJhY2sge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuZGl2Lml0ZW0tc2hvdyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG5kaXYuaXRlbS1zaG93IGRpdiB7XG4gICAgLypoZWlnaHQ6IDMwJTsqL1xufVxuXG5kaXYuYm9udXMtaXRlbSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuYmV0LW51bSB7XG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XG4gICAgY29sb3I6IHdoaXRlO1xufVxuXG5kaXYuYmV0LFxuZGl2LmJvbnVzIHtcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xuICAgIHBhZGRpbmc6IDAgLjVlbTtcbn1cblxuZGl2LmNvdW50LWRvd24ge1xuICAgIHdpZHRoOiBjYWxjKDMwJSAtIDFlbSk7XG4gICAgcGFkZGluZzogMCAuNWVtO1xufVxuXG5kaXYuY291bnQtZG93bi1udW0ge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAyZW07XG59XG5cbmRpdi5jb3VudC1kb3duLWJhY2sge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5jb3VudC1kb3duLXNob3cge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgIGhlaWdodDogOTIlO1xuICAgIHdpZHRoOiA5MiU7XG4gICAgbWFyZ2luOiA0JTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBCZXRBbmRCb251cy52dWU/MTdmNTY4YmZcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IFZ1ZVJlc291cmNlIGZyb20gJ3Z1ZS1yZXNvdXJjZSdcclxuVnVlLnVzZShWdWVSZXNvdXJjZSlcclxuICAgIC8vIOiOt+WPluW8gOWlluiusOW9lVxyXG5tb2R1bGUuZXhwb3J0cy5nZXRCb251c1JlY29yZCA9ICgpID0+IFZ1ZS5odHRwLmdldCgnZ2V0Qm9udXNSZWNvcmQnKVxyXG4gICAgLy8g6I635Y+W5Li76YWN572u5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldE1haW5Db25maWcgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldE1haW5Db25maWcnLCB7IHBhcmFtczogeyB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF0gfSB9KVxyXG4gICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XHJcbm1vZHVsZS5leHBvcnRzLmdldENvdW50ID0gKCkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRDb3VudCcpXHJcbiAgICAvLyDojrflj5blvIDlpZbnu5PmnpxcclxubW9kdWxlLmV4cG9ydHMuZ2V0Qm9udXNOdW0gPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5nZXQoJ2dldEJvbnVzTnVtJywgcGFyYW1zKVxyXG4gICAgLy8g5Lmw5a6a56a75omLXHJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVVzZXJCZXRzID0gKHBhcmFtcykgPT4gVnVlLmh0dHAucG9zdCgnY3JlYXRlVXNlckJldHMnLCBwYXJhbXMpXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5nZXR1c2VyQ29kZUZyb21OZXQgPSAoY29kZSkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRVc2VyQ29kZScsIHsgcGFyYW1zOiB7IGNvZGU6IGNvZGUgfSB9KVxyXG4gICAgLy8g6I635Y+W55So5oi35L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldHVzZXJpbmZvID0gKHVzZXJpbmZvKSA9PiBWdWUuaHR0cC5wb3N0KCdnZXR1c2VyaW5mbycsIHVzZXJpbmZvKVxyXG4gICAgLy8g6I635Y+W5YWs5ZGK5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldExhc3ROb3RpY2UgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldExhc3ROb3RpY2UnKVxyXG4gICAgLy8g6I635Y+W5b6u5L+h55So5oi3Y29kZSDnlKjmnaXlkI7lj7Dojrflj5bnlKjmiLdvcGVuaWRcclxubW9kdWxlLmV4cG9ydHMuZ2V0Q29kZSA9IGZ1bmN0aW9uKCkgeyAvLyDojrflj5bnlKjmiLdjb2Rl5YC8XHJcbiAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXnwmKVwiICsgJ2NvZGUnICsgXCI9KFteJl0qKSgmfCQpXCIsIFwiaVwiKTtcclxuICAgICAgICB2YXIgciA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLm1hdGNoKHJlZyk7XHJcbiAgICAgICAgaWYgKHIgIT0gbnVsbCkgcmV0dXJuIHVuZXNjYXBlKHJbMl0pO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqKirlkI7lj7DnrqHnkIbnlKgqKiovXHJcbm1vZHVsZS5leHBvcnRzLnVwZGF0ZXVzZXJpbmZvID0gKHBhcmFtcykgPT4gVnVlLmh0dHAucG9zdCgndXBkYXRldXNlcmluZm8nLCBwYXJhbXMpXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3JlcXVlc3QtbGlzdC5qc1xuICoqLyIsIi8qIVxuICogdnVlLXJlc291cmNlIHYwLjkuM1xuICogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yZXNvdXJjZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm9taXNlcy9BKyBwb2x5ZmlsbCB2MS4xLjQgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vcHJvbWlzKVxuICovXG5cbnZhciBSRVNPTFZFRCA9IDA7XG52YXIgUkVKRUNURUQgPSAxO1xudmFyIFBFTkRJTkcgPSAyO1xuXG5mdW5jdGlvbiBQcm9taXNlJDIoZXhlY3V0b3IpIHtcblxuICAgIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cblxuUHJvbWlzZSQyLnJlamVjdCA9IGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3Qocik7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDIucmVzb2x2ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXNvbHZlKHgpO1xuICAgIH0pO1xufTtcblxuUHJvbWlzZSQyLmFsbCA9IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQyKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChpdGVyYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHg7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZSQyLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblByb21pc2UkMi5yYWNlID0gZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQyKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZSQyLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxudmFyIHAkMSA9IFByb21pc2UkMi5wcm90b3R5cGU7XG5cbnAkMS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHggPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB4ICYmIHhbJ3RoZW4nXTtcblxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5yZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gcmVhc29uO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICAgICAgd2hpbGUgKHByb21pc2UuZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcHJvbWlzZS5kZWZlcnJlZC5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICBvblJlc29sdmVkID0gZGVmZXJyZWRbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSBkZWZlcnJlZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGRlZmVycmVkWzJdLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBkZWZlcnJlZFszXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlc29sdmVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZC5jYWxsKHVuZGVmaW5lZCwgcHJvbWlzZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnAkMS50aGVuID0gZnVuY3Rpb24gdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9taXNlLmRlZmVycmVkLnB1c2goW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH0pO1xufTtcblxucCQxLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59O1xuXG52YXIgUHJvbWlzZU9iaiA9IHdpbmRvdy5Qcm9taXNlIHx8IFByb21pc2UkMjtcblxuZnVuY3Rpb24gUHJvbWlzZSQxKGV4ZWN1dG9yLCBjb250ZXh0KSB7XG5cbiAgICBpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBQcm9taXNlT2JqKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IGV4ZWN1dG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlT2JqKGV4ZWN1dG9yLmJpbmQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblByb21pc2UkMS5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLmFsbChpdGVyYWJsZSksIGNvbnRleHQpO1xufTtcblxuUHJvbWlzZSQxLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLnJlc29sdmUodmFsdWUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2UkMS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoUHJvbWlzZU9iai5yZWplY3QocmVhc29uKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmoucmFjZShpdGVyYWJsZSksIGNvbnRleHQpO1xufTtcblxudmFyIHAgPSBQcm9taXNlJDEucHJvdG90eXBlO1xuXG5wLmJpbmQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgaWYgKGZ1bGZpbGxlZCAmJiBmdWxmaWxsZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgZnVsZmlsbGVkID0gZnVsZmlsbGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEodGhpcy5wcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmNhdGNoID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEodGhpcy5wcm9taXNlLmNhdGNoKHJlamVjdGVkKSwgdGhpcy5jb250ZXh0KTtcbn07XG5cbnAuZmluYWxseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VPYmoucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG59O1xuXG52YXIgZGVidWcgPSBmYWxzZTtcbnZhciB1dGlsID0ge307XG52YXIgYXJyYXkgPSBbXTtcbmZ1bmN0aW9uIFV0aWwgKFZ1ZSkge1xuICAgIHV0aWwgPSBWdWUudXRpbDtcbiAgICBkZWJ1ZyA9IFZ1ZS5jb25maWcuZGVidWcgfHwgIVZ1ZS5jb25maWcuc2lsZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbVnVlUmVzb3VyY2Ugd2Fybl06ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayhjYiwgY3R4KSB7XG4gICAgcmV0dXJuIHV0aWwubmV4dFRpY2soY2IsIGN0eCk7XG59XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBpc09iamVjdChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybURhdGEob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodmFsdWUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbnMoZm4sIG9iaiwgb3B0cykge1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBvcHRzID0gb3B0cy5jYWxsKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlKGZuLmJpbmQoeyAkdm06IG9iaiwgJG9wdGlvbnM6IG9wdHMgfSksIGZuLCB7ICRvcHRpb25zOiBvcHRzIH0pO1xufVxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IpIHtcblxuICAgIHZhciBpLCBrZXk7XG5cbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtrZXldLCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IF9hc3NpZ247XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcnJheS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzaWduKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcnJheS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX21lcmdlKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoZGVlcCAmJiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIWlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgZGVlcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcm9vdCAob3B0aW9ucywgbmV4dCkge1xuXG4gICAgdmFyIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICBpZiAoaXNTdHJpbmcob3B0aW9ucy5yb290KSAmJiAhdXJsLm1hdGNoKC9eKGh0dHBzPzopP1xcLy8pKSB7XG4gICAgICAgIHVybCA9IG9wdGlvbnMucm9vdCArICcvJyArIHVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBxdWVyeSAob3B0aW9ucywgbmV4dCkge1xuXG4gICAgdmFyIHVybFBhcmFtcyA9IE9iamVjdC5rZXlzKFVybC5vcHRpb25zLnBhcmFtcyksXG4gICAgICAgIHF1ZXJ5ID0ge30sXG4gICAgICAgIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICBlYWNoKG9wdGlvbnMucGFyYW1zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodXJsUGFyYW1zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcXVlcnkgPSBVcmwucGFyYW1zKHF1ZXJ5KTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT0gLTEgPyAnPycgOiAnJicpICsgcXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBVUkwgVGVtcGxhdGUgdjIuMC42IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3VybC10ZW1wbGF0ZSlcbiAqL1xuXG5mdW5jdGlvbiBleHBhbmQodXJsLCBwYXJhbXMsIHZhcmlhYmxlcykge1xuXG4gICAgdmFyIHRtcGwgPSBwYXJzZSh1cmwpLFxuICAgICAgICBleHBhbmRlZCA9IHRtcGwuZXhwYW5kKHBhcmFtcyk7XG5cbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhcmlhYmxlcy5wdXNoLmFwcGx5KHZhcmlhYmxlcywgdG1wbC52YXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlKSB7XG5cbiAgICB2YXIgb3BlcmF0b3JzID0gWycrJywgJyMnLCAnLicsICcvJywgJzsnLCAnPycsICcmJ10sXG4gICAgICAgIHZhcmlhYmxlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFyczogdmFyaWFibGVzLFxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7KFteXFx7XFx9XSspXFx9fChbXlxce1xcfV0rKS9nLCBmdW5jdGlvbiAoXywgZXhwcmVzc2lvbiwgbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5zcGxpdCgvLC9nKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCB0bXBbMV0sIHRtcFsyXSB8fCB0bXBbM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHRtcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciAmJiBvcGVyYXRvciAhPT0gJysnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gJyYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmxlbmd0aCAhPT0gMCA/IG9wZXJhdG9yIDogJycpICsgdmFsdWVzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc7Jykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyAmJiAob3BlcmF0b3IgPT09ICcmJyB8fCBvcGVyYXRvciA9PT0gJz8nKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IgPT09ICc7JyB8fCBvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPyc7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG5cbiAgICB2YWx1ZSA9IG9wZXJhdG9yID09PSAnKycgfHwgb3BlcmF0b3IgPT09ICcjJyA/IGVuY29kZVJlc2VydmVkKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVJlc2VydmVkKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlIChvcHRpb25zKSB7XG5cbiAgICB2YXIgdmFyaWFibGVzID0gW10sXG4gICAgICAgIHVybCA9IGV4cGFuZChvcHRpb25zLnVybCwgb3B0aW9ucy5wYXJhbXMsIHZhcmlhYmxlcyk7XG5cbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtc1trZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBVUkwgdGVtcGxhdGluZy5cbiAqL1xuXG52YXIgaWUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbmZ1bmN0aW9uIFVybCh1cmwsIHBhcmFtcykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICBvcHRpb25zID0gdXJsLFxuICAgICAgICB0cmFuc2Zvcm07XG5cbiAgICBpZiAoaXNTdHJpbmcodXJsKSkge1xuICAgICAgICBvcHRpb25zID0geyB1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gbWVyZ2Uoe30sIFVybC5vcHRpb25zLCBzZWxmLiRvcHRpb25zLCBvcHRpb25zKTtcblxuICAgIFVybC50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdHJhbnNmb3JtID0gZmFjdG9yeShoYW5kbGVyLCB0cmFuc2Zvcm0sIHNlbGYuJHZtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm0ob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXJsIG9wdGlvbnMuXG4gKi9cblxuVXJsLm9wdGlvbnMgPSB7XG4gICAgdXJsOiAnJyxcbiAgICByb290OiBudWxsLFxuICAgIHBhcmFtczoge31cbn07XG5cbi8qKlxuICogVXJsIHRyYW5zZm9ybXMuXG4gKi9cblxuVXJsLnRyYW5zZm9ybXMgPSBbdGVtcGxhdGUsIHF1ZXJ5LCByb290XTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cblVybC5wYXJhbXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBVUkwgYW5kIHJldHVybiBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKi9cblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuXG4gICAgaWYgKGllKSB7XG4gICAgICAgIGVsLmhyZWYgPSB1cmw7XG4gICAgICAgIHVybCA9IGVsLmhyZWY7XG4gICAgfVxuXG4gICAgZWwuaHJlZiA9IHVybDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IGVsLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiBlbC5wcm90b2NvbCA/IGVsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIHBvcnQ6IGVsLnBvcnQsXG4gICAgICAgIGhvc3Q6IGVsLmhvc3QsXG4gICAgICAgIGhvc3RuYW1lOiBlbC5ob3N0bmFtZSxcbiAgICAgICAgcGF0aG5hbWU6IGVsLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gZWwucGF0aG5hbWUgOiAnLycgKyBlbC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiBlbC5zZWFyY2ggPyBlbC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiBlbC5oYXNoID8gZWwuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGZhY3RvcnkoaGFuZGxlciwgbmV4dCwgdm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh2bSwgb3B0aW9ucywgbmV4dCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKHBhcmFtcywgb2JqLCBzY29wZSkge1xuXG4gICAgdmFyIGFycmF5ID0gaXNBcnJheShvYmopLFxuICAgICAgICBwbGFpbiA9IGlzUGxhaW5PYmplY3Qob2JqKSxcbiAgICAgICAgaGFzaDtcblxuICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXG4gICAgICAgIGhhc2ggPSBpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICBrZXkgPSBzY29wZSArICdbJyArIChwbGFpbiB8fCBoYXNoID8ga2V5IDogJycpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY29wZSAmJiBhcnJheSkge1xuICAgICAgICAgICAgcGFyYW1zLmFkZCh2YWx1ZS5uYW1lLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzaCkge1xuICAgICAgICAgICAgc2VyaWFsaXplKHBhcmFtcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHhkckNsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbmRXaXRoKHhkci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhkci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGRyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHhkci5hYm9ydCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhkci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmdldFVybCgpLCB0cnVlKTtcbiAgICAgICAgeGRyLnRpbWVvdXQgPSAwO1xuICAgICAgICB4ZHIub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHhkci5zZW5kKHJlcXVlc3QuZ2V0Qm9keSgpKTtcbiAgICB9KTtcbn1cblxudmFyIE9SSUdJTl9VUkwgPSBVcmwucGFyc2UobG9jYXRpb24uaHJlZik7XG52YXIgU1VQUE9SVFNfQ09SUyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5mdW5jdGlvbiBjb3JzIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoIWlzQm9vbGVhbihyZXF1ZXN0LmNyb3NzT3JpZ2luKSAmJiBjcm9zc09yaWdpbihyZXF1ZXN0KSkge1xuICAgICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5jcm9zc09yaWdpbikge1xuXG4gICAgICAgIGlmICghU1VQUE9SVFNfQ09SUykge1xuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnQgPSB4ZHJDbGllbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgcmVxdWVzdC5lbXVsYXRlSFRUUDtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGNyb3NzT3JpZ2luKHJlcXVlc3QpIHtcblxuICAgIHZhciByZXF1ZXN0VXJsID0gVXJsLnBhcnNlKFVybChyZXF1ZXN0KSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdFVybC5wcm90b2NvbCAhPT0gT1JJR0lOX1VSTC5wcm90b2NvbCB8fCByZXF1ZXN0VXJsLmhvc3QgIT09IE9SSUdJTl9VUkwuaG9zdDtcbn1cblxuZnVuY3Rpb24gYm9keSAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QuZW11bGF0ZUpTT04gJiYgaXNQbGFpbk9iamVjdChyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IFVybC5wYXJhbXMocmVxdWVzdC5ib2R5KTtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgIH1cblxuICAgIGlmIChpc0Zvcm1EYXRhKHJlcXVlc3QuYm9keSkpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdC5ib2R5KSkge1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpO1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnRlbnRUeXBlKSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDApIHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBqc29ucENsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIG5hbWUgPSByZXF1ZXN0Lmpzb25wIHx8ICdjYWxsYmFjaycsXG4gICAgICAgICAgICBjYWxsYmFjayA9ICdfanNvbnAnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpLFxuICAgICAgICAgICAgYm9keSA9IG51bGwsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgc2NyaXB0O1xuXG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDA7XG5cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnbG9hZCcgJiYgYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDQwNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbmRXaXRoKGJvZHksIHsgc3RhdHVzOiBzdGF0dXMgfSkpO1xuXG4gICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LnBhcmFtc1tuYW1lXSA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHdpbmRvd1tjYWxsYmFja10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBqc29ucCAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnQgPSBqc29ucENsaWVudDtcbiAgICB9XG5cbiAgICBuZXh0KGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PSAnSlNPTlAnKSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZSAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ocmVxdWVzdC5iZWZvcmUpKSB7XG4gICAgICAgIHJlcXVlc3QuYmVmb3JlLmNhbGwodGhpcywgcmVxdWVzdCk7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xufVxuXG4vKipcbiAqIEhUVFAgbWV0aG9kIG92ZXJyaWRlIEludGVyY2VwdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1ldGhvZCAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QuZW11bGF0ZUhUVFAgJiYgL14oUFVUfFBBVENIfERFTEVURSkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJ10gPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSAnUE9TVCc7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBoZWFkZXIgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHJlcXVlc3QubWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXF1ZXN0LmhlYWRlcnMgPSBhc3NpZ24oe30sIEh0dHAuaGVhZGVycy5jb21tb24sICFyZXF1ZXN0LmNyb3NzT3JpZ2luID8gSHR0cC5oZWFkZXJzLmN1c3RvbSA6IHt9LCBIdHRwLmhlYWRlcnNbcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKV0sIHJlcXVlc3QuaGVhZGVycyk7XG5cbiAgICBuZXh0KCk7XG59XG5cbi8qKlxuICogVGltZW91dCBJbnRlcmNlcHRvci5cbiAqL1xuXG5mdW5jdGlvbiB0aW1lb3V0IChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICB2YXIgdGltZW91dDtcblxuICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9LCByZXF1ZXN0LnRpbWVvdXQpO1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB4aHJDbGllbnQgKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aCgncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLCAvLyBJRTkgc3RhdHVzIGJ1Z1xuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiB0cmltKHhoci5zdGF0dXNUZXh0KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyLmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICB4aHIudGltZW91dCA9IDA7XG4gICAgICAgIHhoci5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICB4aHIub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZXF1ZXN0LnByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaChyZXF1ZXN0LmhlYWRlcnMgfHwge30sIGZ1bmN0aW9uICh2YWx1ZSwgaGVhZGVyKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeGhyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoc3RyKSB7XG5cbiAgICB2YXIgaGVhZGVycyA9IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaTtcblxuICAgIGVhY2godHJpbShzdHIpLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gKHJvdykge1xuXG4gICAgICAgIGkgPSByb3cuaW5kZXhPZignOicpO1xuICAgICAgICBuYW1lID0gdHJpbShyb3cuc2xpY2UoMCwgaSkpO1xuICAgICAgICB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGkgKyAxKSk7XG5cbiAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0pIHtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaGVhZGVyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdID0gW2hlYWRlcnNbbmFtZV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuZnVuY3Rpb24gQ2xpZW50IChjb250ZXh0KSB7XG5cbiAgICB2YXIgcmVxSGFuZGxlcnMgPSBbc2VuZFJlcXVlc3RdLFxuICAgICAgICByZXNIYW5kbGVycyA9IFtdLFxuICAgICAgICBoYW5kbGVyO1xuXG4gICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xuICAgICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDbGllbnQocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjKCkge1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHJlcUhhbmRsZXJzLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKGNvbnRleHQsIHJlcXVlc3QsIG5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgaW50ZXJjZXB0b3Igb2YgdHlwZSAnICsgdHlwZW9mIGhhbmRsZXIgKyAnLCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbmV4dChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzcG9uc2UpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzSGFuZGxlcnMudW5zaGlmdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZXNwb25zZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXNIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHdoZW4ocmVzcG9uc2UsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UpIHx8IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoZW4ocmVzcG9uc2UsIHJlc29sdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgQ2xpZW50LnVzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJlcUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59XG5cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIHJlc29sdmUpIHtcblxuICAgIHZhciBjbGllbnQgPSByZXF1ZXN0LmNsaWVudCB8fCB4aHJDbGllbnQ7XG5cbiAgICByZXNvbHZlKGNsaWVudChyZXF1ZXN0KSk7XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEhUVFAgUmVzcG9uc2UuXG4gKi9cblxudmFyIFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHksIF9yZWYpIHtcbiAgICAgICAgdmFyIHVybCA9IF9yZWYudXJsO1xuICAgICAgICB2YXIgaGVhZGVycyA9IF9yZWYuaGVhZGVycztcbiAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYuc3RhdHVzO1xuICAgICAgICB2YXIgc3RhdHVzVGV4dCA9IF9yZWYuc3RhdHVzVGV4dDtcbiAgICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2UpO1xuXG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzIHx8IDA7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJyc7XG4gICAgICAgIHRoaXMub2sgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgICB9XG5cbiAgICBSZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHk7XG4gICAgfTtcblxuICAgIFJlc3BvbnNlLnByb3RvdHlwZS5ibG9iID0gZnVuY3Rpb24gYmxvYigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt0aGlzLmJvZHldKTtcbiAgICB9O1xuXG4gICAgUmVzcG9uc2UucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiBqc29uKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVzcG9uc2U7XG59KCk7XG5cbnZhciBSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZXF1ZXN0KTtcblxuXG4gICAgICAgIHRoaXMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuXG4gICAgICAgIGFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5nZXRVcmwgPSBmdW5jdGlvbiBnZXRVcmwoKSB7XG4gICAgICAgIHJldHVybiBVcmwodGhpcyk7XG4gICAgfTtcblxuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5O1xuICAgIH07XG5cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kV2l0aCA9IGZ1bmN0aW9uIHJlc3BvbmRXaXRoKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHRoaXMuZ2V0VXJsKCkgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBzZW5kaW5nIG5ldHdvcmsgcmVxdWVzdHMuXG4gKi9cblxudmFyIENVU1RPTV9IRUFERVJTID0geyAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcgfTtcbnZhciBDT01NT05fSEVBREVSUyA9IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonIH07XG52YXIgSlNPTl9DT05URU5UX1RZUEUgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04JyB9O1xuXG5mdW5jdGlvbiBIdHRwKG9wdGlvbnMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSxcbiAgICAgICAgY2xpZW50ID0gQ2xpZW50KHNlbGYuJHZtKTtcblxuICAgIGRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHNlbGYuJG9wdGlvbnMsIEh0dHAub3B0aW9ucyk7XG5cbiAgICBIdHRwLmludGVyY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGNsaWVudC51c2UoaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xpZW50KG5ldyBSZXF1ZXN0KG9wdGlvbnMpKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5vayA/IHJlc3BvbnNlIDogUHJvbWlzZSQxLnJlamVjdChyZXNwb25zZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cblxuSHR0cC5vcHRpb25zID0ge307XG5cbkh0dHAuaGVhZGVycyA9IHtcbiAgICBwdXQ6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBvc3Q6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBhdGNoOiBKU09OX0NPTlRFTlRfVFlQRSxcbiAgICBkZWxldGU6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGN1c3RvbTogQ1VTVE9NX0hFQURFUlMsXG4gICAgY29tbW9uOiBDT01NT05fSEVBREVSU1xufTtcblxuSHR0cC5pbnRlcmNlcHRvcnMgPSBbYmVmb3JlLCB0aW1lb3V0LCBtZXRob2QsIGJvZHksIGpzb25wLCBoZWFkZXIsIGNvcnNdO1xuXG5bJ2dldCcsICdkZWxldGUnLCAnaGVhZCcsICdqc29ucCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgSHR0cFttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcyhhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHVybCwgbWV0aG9kOiBtZXRob2QgfSkpO1xuICAgIH07XG59KTtcblxuWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgSHR0cFttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcyhhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHVybCwgbWV0aG9kOiBtZXRob2QsIGJvZHk6IGJvZHkgfSkpO1xuICAgIH07XG59KTtcblxuZnVuY3Rpb24gUmVzb3VyY2UodXJsLCBwYXJhbXMsIGFjdGlvbnMsIG9wdGlvbnMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSxcbiAgICAgICAgcmVzb3VyY2UgPSB7fTtcblxuICAgIGFjdGlvbnMgPSBhc3NpZ24oe30sIFJlc291cmNlLmFjdGlvbnMsIGFjdGlvbnMpO1xuXG4gICAgZWFjaChhY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uLCBuYW1lKSB7XG5cbiAgICAgICAgYWN0aW9uID0gbWVyZ2UoeyB1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXMgfHwge30gfSwgb3B0aW9ucywgYWN0aW9uKTtcblxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsZi4kaHR0cCB8fCBIdHRwKShvcHRzKGFjdGlvbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIG9wdHMoYWN0aW9uLCBhcmdzKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgYWN0aW9uKSxcbiAgICAgICAgcGFyYW1zID0ge30sXG4gICAgICAgIGJvZHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3NbMV07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgICAgaWYgKC9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB1cCB0byA0IGFyZ3VtZW50cyBbcGFyYW1zLCBib2R5XSwgZ290ICcgKyBhcmdzLmxlbmd0aCArICcgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgIG9wdGlvbnMucGFyYW1zID0gYXNzaWduKHt9LCBvcHRpb25zLnBhcmFtcywgcGFyYW1zKTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG5SZXNvdXJjZS5hY3Rpb25zID0ge1xuXG4gICAgZ2V0OiB7IG1ldGhvZDogJ0dFVCcgfSxcbiAgICBzYXZlOiB7IG1ldGhvZDogJ1BPU1QnIH0sXG4gICAgcXVlcnk6IHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgIHVwZGF0ZTogeyBtZXRob2Q6ICdQVVQnIH0sXG4gICAgcmVtb3ZlOiB7IG1ldGhvZDogJ0RFTEVURScgfSxcbiAgICBkZWxldGU6IHsgbWV0aG9kOiAnREVMRVRFJyB9XG5cbn07XG5cbmZ1bmN0aW9uIHBsdWdpbihWdWUpIHtcblxuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBVdGlsKFZ1ZSk7XG5cbiAgICBWdWUudXJsID0gVXJsO1xuICAgIFZ1ZS5odHRwID0gSHR0cDtcbiAgICBWdWUucmVzb3VyY2UgPSBSZXNvdXJjZTtcbiAgICBWdWUuUHJvbWlzZSA9IFByb21pc2UkMTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyhWdWUudXJsLCB0aGlzLCB0aGlzLiRvcHRpb25zLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJGh0dHA6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS5odHRwLCB0aGlzLCB0aGlzLiRvcHRpb25zLmh0dHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRyZXNvdXJjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5yZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRwcm9taXNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZ1ZS5Qcm9taXNlKGV4ZWN1dG9yLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYm9udXMtYmFyXFxcIj48ZGl2IGNsYXNzPVxcXCJib251cy1pdGVtIGJldFxcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1iYWNrIGZvcnplblxcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1zaG93XFxcIj48ZGl2IGNsYXNzPVxcXCJiZXQtbnVtXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJldE51bVxcXCIgdi1odG1sPVxcXCJsb2NrbW9uZXlcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gY291bnQtZG93blxcXCI+PGRpdiBjbGFzcz1cXFwiY291bnQtZG93bi1iYWNrXFxcIj48ZGl2IGNsYXNzPVxcXCJjb3VudC1kb3duLXNob3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvdW50LWRvd24tbnVtXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIntmb250U2l6ZTo0MCp6b29tUmF0ZS54KydweCd9XFxcIiB2LWh0bWw9XFxcImNvdW50RG93biB8IHRpbWVcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gYm9udXNcXFwiPjxkaXYgY2xhc3M9XFxcIml0ZW0tYmFjayBiYWxhbmNlXFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLXNob3dcXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiPjxkaXYgY2xhc3M9XFxcImJldC1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxQbGF5UGFuZWwudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNWZlYmQwYjAvUGxheVBhbmVsLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ucGxheXBhbmVsIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZykgNTAlIDUwJTsqL1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGhlaWdodDogNTAlO1xcbn1cXG5cXG5pbWcuY2hpcCB7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi50YWJsZS1wYW5lbCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDUwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmRpc3BsYXk6IG5vbmU7Ki9cXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIC4zKTtcXG59XFxuXFxuZGl2LnNpbmdsZSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LmRvdWJsZSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcXG4gICAgbWFyZ2luOiAzJSAwJSAwJSA4NiU7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LmJpZyB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5zbWFsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2Lm51bSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbn1cXG5cXG5kaXYuYm9udWRudW0ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9kZmMyNDA0YVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK05BO0lBQ0Esc0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtJQUNBLGtCQUFBO0lBQ0EsZ0NBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO0lBQ0EsZ0NBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO0lBQ0EscUJBQUE7SUFDQSwrQkFBQTtDQUNBOztBQUVBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLDRCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGtDQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiUGxheVBhbmVsLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOS4u+a4uOaIj+WMulxcbiAgICBkaXYucGxheXBhbmVsXFxuICAgICAgICBkaXYudGFibGUtcGFuZWwodi1lbDpwYW5lbCx2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5zaW5nbGUodi1iaW5kOnN0eWxlPVxcXCJzaW5nbGVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NpbmdsZScpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmRvdWJsZSh2LWJpbmQ6c3R5bGU9XFxcImRvdWJsZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnZG91YmxlJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uemVybyh2LWJpbmQ6c3R5bGU9XFxcInplcm9cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5vbmUodi1iaW5kOnN0eWxlPVxcXCJvbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50d28odi1iaW5kOnN0eWxlPVxcXCJ0d29cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMilcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50aHJlZSh2LWJpbmQ6c3R5bGU9XFxcInRocmVlXFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDMpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uZm91cih2LWJpbmQ6c3R5bGU9XFxcImZvdXJcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5maXZlKHYtYmluZDpzdHlsZT1cXFwiZml2ZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg1KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNpeCh2LWJpbmQ6c3R5bGU9XFxcInNpeFxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg2KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNldmVuKHYtYmluZDpzdHlsZT1cXFwic2V2ZW5cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5laWdodCh2LWJpbmQ6c3R5bGU9XFxcImVpZ2h0XFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDgpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0ubmluZSh2LWJpbmQ6c3R5bGU9XFxcIm5pbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoOSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5iaWcodi1iaW5kOnN0eWxlPVxcXCJiaWdcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2JpZycpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNtYWxsKHYtYmluZDpzdHlsZT1cXFwic21hbGxcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NtYWxsJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5mb3JtdWxhKHYtYmluZDpzdHlsZT1cXFwiZm9ybXVsYVxcXCIsdi1odG1sPVxcXCJib251c051bVxcXCIpIFxcbiAgICAgICAgICAgIGRpdi5udW0uYm9udWRudW0odi1iaW5kOnN0eWxlPVxcXCJib251ZG51bVxcXCIpXFxuICAgICAgICAgICAgICAgIHRhYmxlXFxuICAgICAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkKHYtaHRtbD1cXFwidXNlckJldC5iZXRudW1cXFwiKVxcbiAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcInRhYmxlUGFuZWxJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICdiZXRzJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHRhYmxlUGFuZWxJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcnKSxcXG4gICAgICAgICAgICBjaGlwSW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nJyksXFxuICAgICAgICAgICAgaW1nU2l6ZToge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUyOFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIC8vIFRPRE8g6YeN5paw6K6+5a6a5Lit5aWW6KeE5YiZXFxuICAgICAgICBib251c051bSgpIHtcXG4gICAgICAgICAgICB2YXIgbnVtcyA9IHRoaXMubG90dGVyeW51bS5sb3R0ZXJ5bnVtcy5zcGxpdCgnLCcpXFxuICAgICAgICAgICAgdmFyIHN1bSA9IHBhcnNlSW50KG51bXNbMF0pICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKVxcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1zWzBdKSArICcrJyArIHBhcnNlSW50KG51bXNbbnVtcy5sZW5ndGggLSAxXSkgKyAnPScgKyAoTWF0aC5mbG9vcihzdW0gLyAxMCkgPyBNYXRoLmZsb29yKHN1bSAvIDEwKSA6ICcnKSArICcoJyArIHN1bSAlIDEwICsgJyknXFxuICAgICAgICB9LFxcbiAgICAgICAgc2luZ2xlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZG91YmxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB6ZXJvKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB0d28oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdGhyZWUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZm91cigpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmaXZlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2l4KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V2ZW4oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBlaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG5pbmUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBiaWcoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgOCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc21hbGwoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JtdWxhKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDIyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gVE9ETyDpgY3ljobkuIrmnJ/kuIvms6jorrDlvZXvvIzorqHnrpfnrZvpgInmmK/lkKbmnInkuK3lpZblj7fnoIFcXG4gICAgICAgIGJvbnVkbnVtKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgYmV0KGV2ZW50KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hlaWdodCcgKyBldmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0KVxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXaWR0aCcgKyBldmVudC50YXJnZXQub2Zmc2V0V2lkdGgpXFxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgLy8g55So5oi35LiL5rOoXFxuICAgICAgICBkb2JldChudW0pIHtcXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyaW5mby5tb25leSAtIHRoaXMudXNlckJldC5iZXRtb25leSAtIHRoaXMubG9ja21vbmV5IDwgMCkgcmV0dXJuXFxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnREb3duIDwgMTApIHJldHVybiAvLyDlgJLorqHml7blsI/kuo4xMOenkuaXtuemgeatouS4i+azqFxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnTlVNQkVSJ1xcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcXG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpZyc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmJldHMucHVzaChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVzZXJCZXQpKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIGNhbmNlbEJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuYmV0cyA9IFtdXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5wbGF5cGFuZWwge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA1MCU7XFxufVxcblxcbmltZy5jaGlwIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LnRhYmxlLXBhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpO1xcbn1cXG5cXG5kaXYuc2luZ2xlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuZG91YmxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuYmlnIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LnNtYWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYubnVtIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XFxufVxcblxcbmRpdi5ib251ZG51bSB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFZ0FBQUJKQ0FZQUFBQ2VzV0RpQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGUlVFNVJUazROek5HTlVReE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZSVUU1UlRrNE9ETkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVkZRVGxGT1RnMU0wWTFSREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tWRlFUbEZPVGcyTTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrVXYySElBQUFCRHhKUkVGVWVOcnNuTEdPRkRFTWh1UE02QkRGRmJSWDh3UjB4eXZ3S0R3UGo4SnJVQ05FVFVkMUJUcHBKeUdadFhQL2VEUEw1SVRBSUVmS0p1ek1MY21YMzQ1M0ZROTkrSnhES2V1TGwyMTVmLytXWW5tNWNSUzc1U2FXbDF2bnNGdHVLNkFYem1HM3ZKaDc3LzU0OXpwTVJHdWRTNDNjajlDbmNsL2tscmkxVktwVHpUbXZiZUoyS1czaUt2MFQ5MnQ5K2ZIcnhlZDBBUW1ZS2NZK0pJSERmWUZrQ2xDRlVzYVV1RjloMURFTG5NaHd5c1ZBS2UxK3ppNmdDbWRtS0ZnUkZLb25HZ01rcW1tZ1JEVzhvQXZmdDQ2NnpEWHZRT29DUWpCelQwVU1abUlvMGFLSk1aUXkwTE5pZUp5aUh1SWFDcGcxeGluWDhsRkFVVXdNL0JDcUJ4V0VjS3lZV1ZVTlFrTFRhcW9Ca05JdUl5WVdGWnllaVVWbFhtUklQV0ptQW9mQXBCWjFiK1k1THlNS21qbzdsL2dta1dzRWN5TkxnTGpXc1luUEVYKzVzSytSZXlZR2xIYlV2d3NvZGt4SzRDQzRDS1psQVZLRzcwMFo0Wnh0cnpua1NadzU3TXBEdTFoVTdVVy9ZMkpXZHJMRXZpWnBRQXhKTnBmTS9RVHZIUUpFb0NKQ3RmU3FDaFF0S0VqTWhoaVNWcGRVd3BndTV6RVRrMGxqMU55RFl6R2F4dmduOEZhdkFTVlFqNGhnVEVIZ1c1b3B5ZnZTMTF1OUFVaXJNaUE0akF4Sm5IWm1WVWxNdE1LQlhlNFlJTmlWTmhEQTVNam85ekdTYlI2M2VGWjdoc1VWZU1Sd2FGUkJCRTQ0ZFB3TFFpRkR3V0lXTlRBa1V2NkZPcjZXcnZpZ2VHaFZRRkVYZ2FHeFNKcDJ4aGJWSEk2T2RYNk9oTHV0a1doYWRpZFJrcGhWZnViWVl2RGlnQnlRQTNKQURzZ0JPU0FINU1VQk9TQUg1SUFja0FOeVFBN0lpd055UUE3SUFUa2dCK1NBSEpBRGNnUU95QUU1SUFma2dQN1pNbncrS0hmYTlmd05uK2F5a052WlVoRjJ4dnpiRlNSNVYzaEN0UDJIZkEwSFpnWU9qQzJwT1J3ZDY3eW5Fc214eW5CVUxYZnV3YU8yWkFVU0xpcEE2czFobmFPNjU5ZUFlT0x0QStSSWJYZzZSaXVuU1RkSGJZMGNBdzRxMDdBdE50ZWtyMTlaMkYwRlNhWmV3SlNpOEhRSU12RkE4S2d0WFZtSnY2V2d4RWwwTXFlazNRUmNQd3lvMFpZRU5FZ3AydVE5ZEk3YW1sQVF1Z21CcEtya3NLTEN4aFFrZVo3YzN4eWhWZmVLcDQ5R2RyR1d6SUlxNmtGU3dBNERFdFZnZXhZTU8rU3d6Y25DbmNKVU9wUlNrT1NzTHFvdjdaQ0pKZldIYTZaZVRVYUxzVG5CSERvNVdWWjhVTS9FZUE0SlVzRlJVVU9BRmxhREpIcEl1dUthak1hbTFCSkR4Q1VaQXRRenNVVzFHdFNZaWRVL0RHR1R3N0RtWWlrL0pRNjhtYUN4U0JvaExRclNTZjE3U0VFbm1iUUNGT0JyeFFSK3FxVThHbEtSTE53aURqbUU3aE1YVHFNS2FrOGtXR21sYzlESVFCS2taMkw4WS9yQkFxQWdWTktpSUUwakprYnNrTE55Zkp0Y0swaEdNL2xvQ2doNEV6anNDeFdWdVM2amdNUWhCNldlOW5BVE1LMXIrVlpXb3VrakR6YzViR0w0RkpUTU85anluLzdlTThIRzR6K1krUytLRHVpUEZ3cXY3dTlLKzZiVU84ZXhLZDlLL1ZTZDlHT3AzNTNIUmFsTUhpdWdoMUsvQkgvWW15NVZPQTgvQlJnQTNWMk10bFduUitzQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmdcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g5Li75ri45oiP5Yy6XG4gICAgZGl2LnBsYXlwYW5lbFxuICAgICAgICBkaXYudGFibGUtcGFuZWwodi1lbDpwYW5lbCx2LWJpbmQ6c3R5bGU9XCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc2luZ2xlKHYtYmluZDpzdHlsZT1cInNpbmdsZVwiLEB0b3VjaGVuZD1cImRvYmV0KCdzaW5nbGUnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzaW5nbGUnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmRvdWJsZSh2LWJpbmQ6c3R5bGU9XCJkb3VibGVcIixAdG91Y2hlbmQ9XCJkb2JldCgnZG91YmxlJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnZG91YmxlJyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS56ZXJvKHYtYmluZDpzdHlsZT1cInplcm9cIixAdG91Y2hlbmQ9XCJkb2JldCgwKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0ub25lKHYtYmluZDpzdHlsZT1cIm9uZVwiLEB0b3VjaGVuZD1cImRvYmV0KDEpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMSBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS50d28odi1iaW5kOnN0eWxlPVwidHdvXCIsQHRvdWNoZW5kPVwiZG9iZXQoMilcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAyIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnRocmVlKHYtYmluZDpzdHlsZT1cInRocmVlXCIsQHRvdWNoZW5kPVwiZG9iZXQoMylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmZvdXIodi1iaW5kOnN0eWxlPVwiZm91clwiLEB0b3VjaGVuZD1cImRvYmV0KDQpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNCBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5maXZlKHYtYmluZDpzdHlsZT1cImZpdmVcIixAdG91Y2hlbmQ9XCJkb2JldCg1KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDUgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc2l4KHYtYmluZDpzdHlsZT1cInNpeFwiLEB0b3VjaGVuZD1cImRvYmV0KDYpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5zZXZlbih2LWJpbmQ6c3R5bGU9XCJzZXZlblwiLEB0b3VjaGVuZD1cImRvYmV0KDcpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5laWdodCh2LWJpbmQ6c3R5bGU9XCJlaWdodFwiLEB0b3VjaGVuZD1cImRvYmV0KDgpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOCBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5uaW5lKHYtYmluZDpzdHlsZT1cIm5pbmVcIixAdG91Y2hlbmQ9XCJkb2JldCg5KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uYmlnKHYtYmluZDpzdHlsZT1cImJpZ1wiLEB0b3VjaGVuZD1cImRvYmV0KCdiaWcnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdiaWcnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnNtYWxsKHYtYmluZDpzdHlsZT1cInNtYWxsXCIsQHRvdWNoZW5kPVwiZG9iZXQoJ3NtYWxsJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc21hbGwnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmZvcm11bGEodi1iaW5kOnN0eWxlPVwiZm9ybXVsYVwiLHYtaHRtbD1cImJvbnVzTnVtXCIpIFxuICAgICAgICAgICAgZGl2Lm51bS5ib251ZG51bSh2LWJpbmQ6c3R5bGU9XCJib251ZG51bVwiKVxuICAgICAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZCh2LWh0bWw9XCJ1c2VyQmV0LmJldG51bVwiKVxuICAgICAgICBpbWcodi1iaW5kOnNyYz1cInRhYmxlUGFuZWxJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ2JldHMnLCAndXNlckJldCcsICdjb3VudERvd24nLCAnY291bnROdW0nLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFibGVQYW5lbEltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZycpLFxuICAgICAgICAgICAgY2hpcEltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZycpLFxuICAgICAgICAgICAgaW1nU2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MjhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgLy8gVE9ETyDph43mlrDorr7lrprkuK3lpZbop4TliJlcbiAgICAgICAgYm9udXNOdW0oKSB7XG4gICAgICAgICAgICB2YXIgbnVtcyA9IHRoaXMubG90dGVyeW51bS5sb3R0ZXJ5bnVtcy5zcGxpdCgnLCcpXG4gICAgICAgICAgICB2YXIgc3VtID0gcGFyc2VJbnQobnVtc1swXSkgKyBwYXJzZUludChudW1zW251bXMubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtc1swXSkgKyAnKycgKyBwYXJzZUludChudW1zW251bXMubGVuZ3RoIC0gMV0pICsgJz0nICsgKE1hdGguZmxvb3Ioc3VtIC8gMTApID8gTWF0aC5mbG9vcihzdW0gLyAxMCkgOiAnJykgKyAnKCcgKyBzdW0gJSAxMCArICcpJ1xuICAgICAgICB9LFxuICAgICAgICBzaW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHdvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDMpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiA0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZml2ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2l4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXZlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5pbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogNCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJpZygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDQyNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtdWxhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMjEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDIyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETyDpgY3ljobkuIrmnJ/kuIvms6jorrDlvZXvvIzorqHnrpfnrZvpgInmmK/lkKbmnInkuK3lpZblj7fnoIFcbiAgICAgICAgYm9udWRudW0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNDAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYmV0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGVpZ2h0JyArIGV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2lkdGgnICsgZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoKVxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOeUqOaIt+S4i+azqFxuICAgICAgICBkb2JldChudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJpbmZvLm1vbmV5IC0gdGhpcy51c2VyQmV0LmJldG1vbmV5IC0gdGhpcy5sb2NrbW9uZXkgPCAwKSByZXR1cm5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA8IDEwKSByZXR1cm4gLy8g5YCS6K6h5pe25bCP5LqOMTDnp5Lml7bnpoHmraLkuIvms6hcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdOVU1CRVInXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdTSU5HTEVfT1JfRE9VQkxFJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmV0cy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudXNlckJldCkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBjYW5jZWxCZXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYmV0cyA9IFtdXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5wbGF5cGFuZWwge1xuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcpIDUwJSA1MCU7Ki9cbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDUwJTtcbn1cblxuaW1nLmNoaXAge1xuICAgIHdpZHRoOiA1MCU7XG4gICAgaGVpZ2h0OiA1MCU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG5kaXYudGFibGUtcGFuZWwge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNTAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAvKmRpc3BsYXk6IG5vbmU7Ki9cbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpO1xufVxuXG5kaXYuc2luZ2xlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LmRvdWJsZSB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xuICAgIG1hcmdpbjogMyUgMCUgMCUgODYlO1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LmJpZyB7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LnNtYWxsIHtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxZW07XG59XG5cbmRpdi5udW0ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XG59XG5cbmRpdi5ib251ZG51bSB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aYvuekui3nuqIucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFBsYXlQYW5lbC52dWU/ZGZjMjQwNGFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFvQUFBQUlRQ0FZQUFBQVJxOTlnQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGUlVFNVJUazRNek5HTlVReE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZSVUU1UlRrNE5ETkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVkZRVGxGT1RneE0wWTFSREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tWRlFUbEZPVGd5TTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrdmNsaEpRQUFYU05KUkVGVWVOcnMzWG1VSE9WOTcvK25laFpwdEk1Mk5FS0kwVWhDRWdJRXdrSmd6Q0lqZ3NFbUFYT0liY0RZTitjZUhBZHdFbzdqRGZzUFg4ZEo3S1BjWHdBbjVwZGpZNExCdVZ4c3gyQXdObVlUQWduRll3a2hKTFJydEl6UU9qUFNqR2J0N3R2ZnA2cDZ1bnQ2cWVxMXV1cjk0alNqMlh1cWEvblVzM3dmUTAyNnZFWXBGVkltUXdFQUFNQ1BvdGJiaUJFTGdHTmkvNmkxUWlBQkVBQUF3TDhCTUJKN0RFa0FuQmI3UjcwVkFtdllOZ0FBQUw0VWx2QVhld3hJQUd5Si9VTmFBVWNSQUFFQUFId2RBUHRqanpPMVZ2aWJFSHMwS0xNVkVBQUFBUDRqclgrOXlncDhvNnp3SjBHd2ptMERBQURnUzRQVzIzNTczRit0RmY3cTJUWUFBQUMrcGJPZjhZUDNvMUcyQlFBQVFMQlNvUHJKNzk1bVN3QUFBQVRBNTY2L0xGNEFHZ0FBQUFGQkFBUUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDaVIybXlmdlBPSzg5aEN4VXpiTlRWc0JBQUFNb2lFNnRnSVJmVFQxOS9KTHdDSzcveWZWOWlDUmZLdHo2eFNxNS8vQXhzQ0FJQTAvdVlUbDZ2dnZyS0hEVkVFWDE4NU4rdm42UUlHQUFBSUdBSWdBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBR1l6WjF5OXVtLzVPYTYvNThuUExGTVBYdDJpL3cwQUFBQ2xhcjMrQkcrYU8xbDlaa1d6dW1KaGt4bzd1azQ5dS9VRDFkWTk0T2g3NzcyeVJhMWFPa2MvN3IvcElyWCsvY05xdys2ajZxWDNqNmkzajNUejZnTUFnS0s0WSs0NE5XbDBqWm85c1M3cDR3ZTZCdFVqVzdzSWdFNUpxOTNLSmJQVWtqbFRSNFM2TDcrNExlZjNTNHZmYlZmTVMvcllpb1V6OWVQK201VDZ4T3JmRVFJQkFFRGNqVTBOT3NUWmRuWU9xQTBuQnpKKzdkVnp4cXBsczhlcUpVMWpzLzdjZXk2ZnJyN3ltNFBxaGZaZUFtQTIwdW9uTFhacE4vaXlPWTRDb0FSRmFURk01L0ZYdGhIK0FBQUlzT1dUNjlXcWM4ZXFEODBlcDFxbWpsYlR4cWZQREh1UDk2bEgzanFxbnR4ajVvWjdGMDlVZDF3eVJUWEh2c2NwK2RrL3ZyMVovWStuOTNvbUJIcHlET0R6ZTA2cXZVZlNONWRPbXpoR3R3NW1jOW1NY1NOYS8ydzlmWVBxa2JXNzJmTUJBQWlnYjF3eVNmMys5am5xMmMvT1UvZGROVk90YUI2Zk1md0pDWHFyYno1SGY1K1FMbDQzNFMvUlAzM3NiTTlzQjg5T0FubnVEL3N5ZnU0dlBybzQ2NlNPK3o5NlhzYld2eCs5dk5YeEdFSUFBT0FmY3hwcTFQOVlNVDFubDIwNkVoYWwxZkRuMjAvbC9mc2xhTnBCa2dDWXdST3RCM1JyWFRvUzdyNjJhbUhhejBucm4wejZTT2RZMXhuMW5kZHAvUU1BSUlqYWVzTnEzWjdUZVgvLy9jdW42akdCVzlwNzh2NFoxODZiUUFETStpSjFENmhuM3RvMTR1TVNDbVVNM3orODlINXlxaDlYcis1YWNwWmFNRzJjL3J6TStKWEFsK2huYTNleTl3TUFFR0MvMlpGL0M5N2xjOGZydDYvdXl2OW41TnQ5WEd5ZUxnTWprejJ1T3I5Sk5jK1lxTi9mMG5aYzdXanZWRTJUeDZqSDdsNmhQNTZwcXplZFJiTWE5ZmhCeXNBQUFCQk1NcG5qcTZjSHM0Nzd5MlJzdlRsRCtLZmJUdW11WlB2OVk3R2Z0M2IzS2JWMmY0OWFlN2hYdHpUdS91SjU4YytuK3hrRVFJdk0vSjA4cGw2dDJYY3lQa1pQQ2o4ZjZUZ1RENEJTRWlhMUxJd2J3elVCelRENTJPczcxQk5iUHVCb0FBQWdRQ1NzM2JKMFN2ejluZ0d6YS9oUTE0RGFmS1JQWFhuTzJLVFBwN0s3a2krYU5WYjk1OGJqNnUvLzJESGlhMlQyY0Q1akRRTVhBQi80MkpKNHVKTVp3SGJvS3hYNVhhcy9PMVY5ZU4wdTlZVmZidVpvQUFBZ0lCN2IzS0VEbnJUY3BRdHdGODdJM1UzNzBJYmphc1BKOW95Zm56RSsvV1RWUXNZUCtpNEF5c1NOeEphOVVvZS9STGRlUGsrTmI2aFRkenpWeWhFQkFFQUF5RVNPaDljY1R0dHlKODZiM3BBenZHVXFFQzFrdG5DbUx1YnUvb2dudG9FbkpvRjgvb3E1RmYzOTBpMzgvUnNXY1VRQUFCQVFtY0tmaERlcERaak96cU45em5MTmhabEx2V3cvNm8xQzBKNW9BZnpJNHFhaS9KeVhOcldwOXBQSk0zK1h0VXpURTBWeXRTcEs0V2duSzR3QUFBRC8rdVI1bWN1MHZPY2dBRXF0d2VzWE4yYjhmQ0YxQkgwVkFHWHloNnp1a1kyVWM5bTA5NWphZHFoVGZlTFNjek9HT2ZuOHlEcC9acWlUYnVhSDdyd3M0L2RLU0pSSkp3OXYyTS9lRHdCQUFFbDR1KzNpOUpNL1pLTElJMXU3Y3Y2TU94ZE55RGpUVjhZY1p1czZEbFFBdkdiQmpJeWZreGE5cDlidjFVdkQyYVNVUzZZUU43RWg4K29nVXZibC9wKytyWjU3NFBxTVgzUE81TEhzL1FBQUJDRG9DWm5ObStpTFN5ZGxERysvMjlycDZPZEtlWmhNWHRqYTRabHRVUEVBS0YyMG1kaGxXK0xwdTI5UW5la2Z6UHF6dm4rRFVsMjlBNnJ0UkkvYWNhdzdxZDZmL0Z0Q1phYVZRczVyYXVTb0FBREE1NlNWVG9MYWo5Y2ZqWThGbExGL2QxK1dPYnpKek9GY3NnVklhVUg4MTAwRXdEZzNNMzZsbXpaYjRlZlVPb0gvNjVrL2pDajRuRHBHTU5HNGhqcU9DZ0FBZk81RHM4ZnBvQ2JyKzM3cTRxbTZGRXkySmRwKy8zNW56cTdiWEFIeW1ZMG5SclE0QmpvQXVsbkp3NjNPTXlOZnJNMEhPOWp6QVFBSXNNUlp2bEt1UllKZ0p0SnlKelgvYlBjdW5xaXVtejlCL2ZlQmJyMGlpQjNxL3VYR3M3UCtEQysxL2xVOEFNcmF2UUFBQU9VaUFjNk5kdytkU1dyOVczSE9XQjBnNVNIQmNmM2UwNnE3UDV4MWpWK3Z0ZjVWUEFEbUlpdUNySG12ZmNRNFFhZkx3YVZiNXUzQ3N5ZXg5d01BRUZBUzRGeDlmU3pvZmZEWGkzWFErN05mSGRETHY2VitQaHVaK2Z1VmRjYzl0eDBxR2dBbG9LM084bmtaSHlnQmNPVVAxaVI5L09qM2JzMzRQWSsvc2szdFA5bVRka2F2Rkh1V2VuK1pkUGNPY21RQUFPQmpxUUhPS1NuZ2ZHTlRROFlWUHJMNXQydG1xRlA5WWIzT2NFZGZXTDNRWHZsaTBCVnZBWlFhZjlucUFONjkwZ3h0MGhyWXV2dVkvcGpNQnM0MmRsREcvc25qd2F0YmRHbVlwc2xqMU5MbWFUbnJEVzV2NytUSUFBREF4Lzd4MWNQcXE5Zk9kQjNrRG5RTnFxdm51QStQOG50azNlRlVEenk3WHoyNXB6dTRBZkNGMWpZZDhyS1JzSmM2d3pkYllNeUhoTXBIMXU3bXlBQUF3TWNrZEhYMEhWUS92cjNaMWZkdCtLQlgzWEhKbEtJK2owcXErRnJBc3Z5YXRPNVYyai8vK2gzVjFqM0FrUUVBZ0k5SnNlWnZycHpwNm52c0ZUelc3RDZsLzEyb0xlMDlGZDhPSVMrOEdMYy8rb2JhMGxhNUFaSVBQZjhPUzhBQkFCQUFQL3JFMlZsbjdPNDlQbks5MzkzV3gyUXl4OGVmMnFQTHVoUmlwNE0xaFV2TkU3T0FwZVZOSm5ySW1MMVBYemsvNTFpOVlwSFF1Zm8zVzVLV21nTUFBUDdWZXFCSExXbEtQNWJQbnVrcjdwZzdUbDA0WTdTYU1LcEdIVHcxM0VQNEw5YzNaVnp0dzZuRW54Zm9BR2o3enV1NzlVUHFBMzU0L25TMW9LblJjY2tYSjJTY256Mlo1Sm1OQjBhc0VnSUFBUHhOV3ZGbVRheFgxeTFNWHY1Vld2Nis5THYyK1BzeVJpOTFuTjVQYjJqS1d2WkZXZ2EvOWVJaEhSelBtOTZnV3FhT1RqdlpaT01IdEFDbUplVmhFbXY0WFRaam5Gb3diWnorOTV3cFkvWE0zbXlUUGFRVWpMRFhCQlpyOXAxa2pCOEFBRkIzdnRpdS9tdFVUVHpNU1hEN1g2OGN6bHFzV1ZvRVUwTmpLZ2wvNllLamZPK2swVFZxOWtRekRGSUd4aUZwcWZ1Z1owQmRkZTVrSzlCbEh6eVpXamhhNmdtbUt4c2pRVkVtb1FBQWdHQ1IxcjcvL09RY05YMUNuYnJ2di9ibkRHVVM2dTQ5M3BkeC9PRGpieC9OT0xPMzBqTitQUjhBcFZDek9LK3BVWTFycU5PaFRjS2JXOFhzTmdZQUFQNGpyWDJmK25tYitrVHpPTWN0Y3ZMMUVocFRRK0R2MysvMDVHb2ZWUk1BcGVXdW5PRk5Da1FEQU9BcjBXakMyMmpzamZuV01HcVVDb1hZUGlraDhKR3RYYTYrL2tzdkhGUS8rMVJ6ZkNLSWpCMlVMdVZxRStnOVllYWtzZXo5QUlEcUZ3bXJTRiszQ3ZkMHFzaVpVN0ZIbDRyMHh0NzJubGJSMk1lamZUMHFHaDdRUVJDRmtYcUEwbVVzNHdZbC9FbXJZRFh5VkF2ZzRZNGV1bThCQUhBcEtzRXVHbFdHOVo3OHc3RGVHdzZKRWJOVjBERFlZQVdTTHVOSkx4NVNhdy8zWnAwNFFnQjBxUDNrbWFMOEhGbGZXSmFZeTJiendRNTE4Z3l6Z2dFQTFjOHdRc3FvcVZXSm1jOUlDb2lTL2NJcUdnbkh2bzV1NEdMdzRzU09xZzJBd2w0UnBMdDNVRzF2NzlUL1Rpem5JcUZOQ2pmZnQvd2M5YzNiTGszN000NTBubUYyTHdBZ1NBbFFxVmdBTktLUldQREwwTTBiaWFob2VFaXBVQzJ0Z1BCV0FEUkRtN1BnMWhrTGduWlkzQkVMaXFkamdkRU9panVPVWVBWkFCQ29CT2dnSXhxNkJURDJ2OWc3Tld3eUFtQjFTaTBXRFFBQU1zZkRhQ3dBR3BHb2JnV1VMbU5hQVlPTmdRQUFBQVFwQ1VhR0ZMT0JRUUFFQU1BMzZTNXp0RFBzcjRqSVpKQUltNHNBQ0FBQS9KRC9jcmJyR1ZaeEdHa0ZqTklLU0FBRUFBRFZud0FkVGdaUjRTRmRGZ1lFUUFBQTRJY01tT3ZUMGdvb000SHBCaVlBQWdBQW42ZS9wQzgxOUZoQVhSSUdCRUFBQUZERitjOElPZnN5K1lkMEEwZm9CaVlBQWdDQUtnNkFzVXQ2VFozRHJ6WE1GVU1JZ0FSQUFBRGdpeVRvTUFOYTNjQ0VRQUlnQUFBSVNFVFVBZEJhSHhnRVFBQUFFS0FnS0JOQnFBbElBQVFBQU5VYjZhTG02RDVuWDYwWENZNFNBQW1BQUFDZ2l2T2Y0Mm93aVRVQm94RzZnUW1BQUFDZ3lsT2dDOUw2SitNQVBWSVRzQ1prOEJJU0FQMWpWRjB0R3dFQTRMMjRxTHVCSTU0SWdPRllHRzBjemZXU0FPZ2pFOGVOVVlOaHB0b0RBRHdVL3F3RUtLTUc5V3pnQ284RjdEb3pvRnFtak9HRklRRDZSMHZURkhXcWQ2QzYvd2c5VU5oYVA1SzZVUURnelVobjVIbHA5OERTY0h1UG5WSVhOWTAzV3lWUlVyU3psdU53ak8zSkZ6YzNxYmJZanUzNWpEYzBHRHNKREZsNXo3NFRqQ3B6U2xsME9BakszMVZiRjd1RnFJbjlmU0g5RmdCUThRdU9Vald4ODNIVWVaZ3o0dmY0RWIwMG5GSEI4L21XL1Irb1M4NmRxaTZaTlVHMUhqekY2MGtBckc3THo1dWpwb3h2VU05djJ1dmRKeW5GUUlmNnpRRG84S1FSSFl6b2swM1VpSVZBT2VGSUVJdzlqQnAyS3dDb1lBbzBnNkNiM2x3OUd6aHFyZzBzTi9rVmFvSTcyZFd0M3RsL1FsMDNmNG82Y1daUTdUdlp5OHRaSW5RQmwxaEwwMVIxM2RKNXNSMzZtRHArMm9NN3N0enhEUTJveUVDdmZxc3JTRW1JQzRWVUtPT2pScjgxckJPR0NnL0d3bUFzUE1yUHNCK3hqd0VBS25ScWo3ckxmMVpzMU4zQTBRb1A4Vm56N201MXNLTkgvZmxGWjZsTHo1NUFkM0NKMEZSVHF2dXYyQjU3NllKejFLcFkrRHZVY1ZxOXR2V0E1ODRPVXZkSnQvaEpXSXU5YjlpaFR0ODk1ajVWNkx0Ris2NHhmc2FKNkRDbzVPZldEc1VlOVJYdFRnQ0FBRjZCOHZvT2ZUNjNsNGFyWUU5T09QWWNmclh1UGZXUkMxclVxZ1ZUZEhmd3h2YlRhcytKTTZxamQwaEZLRnBOQVBTYXVycGFOV25jR0QzaFE4YjhTYmZ2dXdlT3ExZGo0UzhjOGNnT0syRk51bmlIQnVMZHZUcjBXZUhQbkEzbU9PWEczeHJ5NXhtSlFUQnFCa0c1azVRUUtDY1Rnd1pud0l1azlkK2MyR1dZNDNybHBpM0U4VnJWK1U4bnVyeGFMNGJIRDFid25DMGg4TFYzZHFwMzloNVdGNXg3bGxvV0M0RWZuVGRaaFdnT0xFOEFETlhVcUc5OVpoVmJ5WVhCY0VTZDZ1M1hFejVrekorbnVuMTFkKytnTmRFanJJL3p4T0NYejMyamtmQ1BxTmwycVA4Zk5heWxoYVE3UWJxRVl3SFEwSzJCdFlyMmZNQmI0VStPMFhqNWo5aEZQeHF5eHZYR2psY2RCamxtcXpRRjV2TWRoamtaSkR5a3o5bVYxbkdxVzYzWnZFdXQ0UVYxN1lHYkxzMC9BSXJWei8rQnJlaW5FLzFndjNtUWh3eXo1Uy9QNEpjckRKb3hVRmVXR2c2ZTBzSlFVeCtmUFF5ZzB2ZUU0WVJ6UXNnS2dWRTlobGVQNDVVYk5nbUNjZ1BIelp1dncxL2l0eG9SY3g5UUhnaUFLQjI2Z0lNa0VqRmI2S1RWenhyblY2clR1V0gvVDNjUGgzUkpHZjBZN0RQTEROU1BNaThvQUNwNFRnaVBPQ2ZJVGR2d3VGNEppRVBtTW1FU0JuUVFES25TblRuZ2hSQW9EUU5ScXdlSG0zVUNJUHh3T3BCdUhSbmI0V2FjWHhGT1FWRzdwZEVlR3lpdEMvMFJhMnhnSFdPTmdJcWRGR1Q4cnhFZk1oWS9hbzJVU1Y3U2lpL2R4SExUVnNlWVhyL0hSbk15U0ZUMzNCajFCRUMvNGdnTzJNbStuT0V2OFlSaVdIZVZNb0JYbDVDeExpaVJ3VDVXRlFFcWRyRzNadjFuT0Y3Tmgxa1dTcmY4UmMweHZaR0JQaytzRzRzYzUvdENUOXl5S0FDdk13RVFLRW9RdEdjYzI1TlBkQTNDUGwyU0JrQzVyd0FoRmMzU2ttZkU3eHV0bXpmN0JsS08yLzR6NXJLUThHYjRLNkNWMXA3TXAxRnloUUFJN2dpTEhRVHR3dEtHMUNPVUVCZ21CQUxsUFJoRGpvWmdKTjY4MmNldHRBNUYrbnM0YnIxOXkxM1F0K3Z1WUc3T0NZRHd5d25CUTZjbXUzdEpqemNKczRJSVVBMW5FT3U0RFJuV1VJNitXQWlVMWtDNkNqMG5xdklyQlpqMEUxd3NEd29DSUx4OHQrK3hnZHVKdFFqdGNZRzZLQzJBTWgyRU5hN09DMGJTY1JzeTZ3YnJMdUZleHZQNkxPenJ3SzhuN3ZHNkVnQlI1YTkyU0VWcjY3T08rYW5ZaWNZZUZ5Z25HK2tPbGxWRUFKUmVUYTB1L0p6ZmNXc2tkd25MRFJ4ZGh0NjZ3eTd3Ky9XUGtPb1JUdHNTcGJXUWNZTlZnVEl3Z1F1QlV0ZzFZamJySys4Y3BIYlhraDZQRkxIV0U1WjZaTFdqS0Q0TGxKcFY5eStmbFlDaTF2cmhJUlV4QzB0TFMyRDlhTFBFRTZvL1ErcjhOeGk3U2FnMXkvK00zSG5NYzdaTUNKTHgzTmFTZ2tuMUltdFlVWVlBQ0crYzYwTjFPZ1FhWVJkM2RaVUtnYkVMazFFM21oTUhVTklid3hwci9kZG9Yc2R0VkU4WWtBdCt4Rno1UjhyRTFFVTlzWlFZOGEzQThLZUdhMEVtaFQ3NW1JUys4SkE1ZGx1My9LbjROU1VhVGxocFFGYWhNcXk1eGJXMVZ2MVg2Z3NTQUZHQmM0S2hvald4RTNPa1R4L1luanRkV2JNTkkzS0NrZkdBRWdMclIxTjRGaWpaZ1NmSGxqekNCUnkzMXMrSldNcy9TbzFQZlFNM2l1MWJxWk5wTWRmNDFFc0QxcGdyaEVpZ2s4Q255d0JGVlh3bCtGQnlYVWt6RDFyTEMxb2xnNklENFZnWUhORDdpdXdiWmxGeGJ2QUpnQ2pyQ1Q4cXpmSWU2d29lYmxHSXR5ZVlkNWR5dmlBRUFpVmpMZjVXVUdhdzF4bFhVWVp5K0NVQjJqOUJ1bloxN2Nkb05ENHIySWd2TGhDeVh0NkVWcitvZldOZ0RTK3dXZ2VqOFVBbzViOGlldnlwVVZ0UEVDUUFvcXhDZGJHREw2SkxzSGc1Qk1vemkwZ0lIQXlaSVJCQTBXOEk5ZmpneUdEQkEvZ1p5bEZCTWdaVGh6T3I4N1pZaGJwMWxRWTFYQTVHcngxdGZUd2g5Qm5wa21QU0o0MzRPdE9HdlQ2OGpDK1VhMUJ0blRsa2dLNWhBaURLY2RJMzlLeGdOZFJ2aFVEdjNiOUdyWlVIZEd1Z2RBZkwrM1FwQVVVL0Y1ajFYSXAzN0NhRlFLdTBrejUyYWNVdkR1bG10OGR4Mit1c3l3eHNDWDNHY1BDU21kckZ1VWVROEJZYWZvWFRoYjVzKzBQaXZoWVBsVllJdEliN1NCQTA3RFhpdVZrZ0FLTDBkLzR5dTB0T0pvWUhwKzRuaGtCRHVnMFN4eFZ4Z2dDS0ZDYWllakIvTVhzQzBvN25sUS9WTjdDOW5iOHc4WmZFSEhNWFRoNVRKNjlaL0x4dGRlSEhnM3hVMTJrczJtdHBuWXVkaGo2blA4OTh2c01CVnNZSXF0b0k1M2dDSU1yQ0NvREZ2Z0FVT3dUcVZrQTVTVWlYa200SnJGZGVXdDBFOEVVUUxPSkZkOFJRamlGeklvRlJXOGV4bTJuNzY3ZG1TUjFsdGZEcGorcndGMG42V25NTW5yV3Q3YkNYRk5LS3U0MkwvWW9OOXhJYlZxZDF5R29OdE1hTzBtSk1BRVNwRTViTUNxNHpUeWdlTGVJYXY1QWt0aWJZdGFVQUZPVThVSW9XbDR5dCtETDhKT2d0UEhaNUZYdGloWlJVc1lOZ1pDaHBQS2FSdUszc2xqUERTQXBScFE1c3BUNi9HMWEzc0htalB6QThkalJFQ0NRQW9vUkhvRGtyMk93S2puajZKR0czQk9vN1lnSWdVSlFnVXNyMVhwT08zVWhpaVpqNkFMWHdST05kczFHN2ZFbzRiTlhRaThhN2R1ME5acFpWQ1kxb0pVdjRncW9LZVU3MkVaV3duK2lKNUxyY1RGU0ZaTmdBSVpBQWlCS1NNRldrbVlBbHYxUFViUWtBaXBOTlNyOThWL3pZalU4TUNVQTNuejFleng1anFjZTVoZE8zN2hrSjNiaktHRmxXUmZrcjhPVSt4eXV6eHlkMlBZb09HdWJZVWNZRUVnQlJ1a052dUJYUWU2VmhrcDRwNXdHZ0tpL3VTUk5EN0JJeGZxdnhLZVZZNUswdWNSSVpIcjhYVFppb1lYZmoydHNrelluTkNQQitNcnpFb05TQ0hkTERmaGcyUUFCRVNZKzhrRGtlVU5lUUNudjM1QkMvdXdaUUtPbUcxRU0veW5CeFRab1lJa0ZReHZOS1YyYzFGNHVPejJLMUptMVlNNTdOaVhVSjQvZVM2dWNsQno1aVRicWJCYjNSSkZHcmlGMVV2STVhc0FSQWxFNUlabUxWbUJjRVFoYmdiN3BMTWx6V0FKTFV3aU05d3ZyaWJsUmZDNDgxZGxLM1VFbllDdy9FbzF4U0sxOTgvSjcveHU2VlkyZXhCLzNvWUIycU5WY05BUUVRSlRyaVlnZVpkRjE0dGl0WXIxekFCQkNnNEF3elpMWCtKVTQ0S0ZzSXRDL3V5dXdPbHVlZ2V5QzhIL3lrdFUrUFl3eUhFNVpHQ3lXMTd0SEtWN3liaGZnRW9vRmVaWXdlUjFjd0FSQ2xERmplN1FxTzNRdktpWmE3UUtEQUlHT05UNnZReFRUcDRxNWJ5encrRHRCZXVrekNxaTZaWmJmd2hhd3FPdGI2dTdUeWxXUS8wUk9JckpuVWJGMENJRXBKZHdYWFd1dEplcWNWVU1ZTktla3FBbERZc1NTRm1XWFNWMUtKa1FwZDNKV0h3MS9VWE01T2J5L3JmR2pvMEdja3JZZExKQ250ZmhLL1VkRUZ5OWttQkVDVTlwQ3JxVFh2dFhUSkJvODhKOTNOUWswb29HRDIyRDlQWEV3OU9OVEVYcU5XYXZWWlBTR0dWYTdGU0NpY1RSWXBiOE1FM2I4RVFKUXBjRVd0OFhaZTZBcVdsZ0s5ZGpHQXdvNGxYWUE0N0sxcnFaY21uVW1yMzJELzhCckd5dXppSGJFQ0I4cDRPWktoUC9VMEFCQUFVYjQ3cnByWWVibk9xZzlZeVJPME9UbUZ5UjlBNGVGR1NWMDFPWjdMUFBtak9qYlBrSW9PbU9QOENINGVlVTNrT2lUajBta0FJQUNpekdva2RNWHV2Q3JZRlN4ai82Sk0vQUFLUDVic3NXeGVhdjdUS3hGNW9HVkh6elR0MDEyK29ZVGdaOTJDb3B6N3FkNzJOV1lqQkpVZkNJQ29GS3ZyMVJpc3lGckI4YTVmbXY2QlFvOG1hK3lmTlpIQlErZVlpa2VzcUJRYzd0WERYV2oxcTJEbzA3MDlOV1kxQ3YzV0Evc0dBUkRCem9DeFMwYXQyUXBZOXE1ZzNmWEw3Z29VZklFZEhEQURvT2NHMGtlOXNXM0NRMWI0QzNsd1p1L0loWUdqNlQ1bnRaeEpyNGtPc3pMZXMycENYNDNWOHNka0R3SWd2RVZDV0UxRXIzRlpyZ0hiOGJFZm5BeUF3bzRsV2ExQ3h2NUpiUEJhNjErRlcvZjFNbTZ4ODFySU0rSFBNRXRlamRndWhobzVkZHZRUmJXVGdxRHVUamZpYXhKN0x1NWJMWHptYzYyUjltaENId0VRbnIrSWhPck1CZHoxT3BjbERvRjAvUUxGT25KMStETnIySG5zSW12T3RLanN4VCsrbWtkNWEvb2xqMjFMckNCdFZXQ0lieE1qZVhzNWZZWVZibGlOMnM5Zi95MDFLWDliS0g2ZUJ3RVExVUJDbWJUSVNkZENLVnNCN2ZCSDF5OVFjUGd6dTM2SHZEbXVMZW9pMEpRc2cxb0J0TWpoTDVvNGZzM3Uya3dJZWxHakp0NWFWN0p3WGM0d2EvOVNReVhWYkdVU0J3RVF2Z21CSVRPY1JRWkxGZ0tqOW5KMDNCMENoUjFMNGJDdWFSZXlsaXZ6Vk9rL095UlYrampYWGIvRlNWeEpyVjRKclh1VkdkdG1sT1Juam5qTjlQdTFDWCs3d2VRTkFpQjh5MW9yV0pXZ0s1aFp2MEN4RHFaSWZOeWZkOWZhOVVBQXRMb2xEZnRzSnM5SGhycm9HOXhvenZPVjd0NjB2MCtQYVZNK1hiVkllb0JxcklMOHFRR1E4elVCRU1GZ2R3WHJBdEdSNGswSzBTZlFRZ3QrUm9mUDJkNVo2d29vZS9pVGxqL2Q5V3N0b2VYSkk4RUxMVVh5SEdycnJkT0dFUStBNmFzZUpMU0FXU0V2YXJmMGVTMEVGVGxZbXkyMkRNMGhBQUs2bTdiZVhDY3pHclpDWUxTQWJtR3o1Uysvcmw4cjlNbEZUMW9sN2VkUVV4dTdPYThoQkNKZzRjOWF4emIyc0FzYWUvTUlzRmI0OFVBWHNIUmhqb3c3T1VLZjUxdTlpcjFkcGRkbndGcVRseFkvQWlDQ0xXVFdtMUxSV3F2TEpHS1dWTkN6NnR5RVFVT3Y5S0VEcGRPTGdmeHMrWDN5Yi9tZFVzVS9FZ3QvNGJCMThyWXVlcUVhOGgrQ2xmOGlZVDN4STc2YWhXZnppZUdORlVBeWhKMTRkN0NlckZHcnV6K3I3V1FTMWVmQmFMRittRzVSanNxaUFIWDEzRmdUQUlIaEdYUlJWYU5iM1hRWWxJdVFCREs3eElJZDJ0S0ZQMGYxL3V4V3ZxaDVhaDRhTkJlMXR3TmcvS2xZZCtsV1FOUnZtVXdDMXhlN2hCc01leXhZNHY0clk4YXNtbkZtbDZIeXhuNW1qL3VMSHd1c1pwSDNlUzEyVGpKbnNKWndwbTZwQTNiOGRyZzRtMFQvc01GK2ZjNDJXSjZUQUFpa0M0VFJtcEE1V1VTM0RJYk5sa0U3cUNXZWt1TGhMNVRoSWh5MWdtUlVCejVaeTlSSUdOc1h2OGhaWTRuaW56T2lLcUpiUW5wamUvc291b0xobkxRbUQvWHJNWFRSYURSaEtHbkMvaE9xaVhjTEdsYU5NeU4rRTJOVVp2eXBIQ015N2srSy8zcDUzSjkxQm9ncUQ4OFVOUXhyc2x0VjM4VWtwTGJpNUQvZC9hMnNCUUhpUzdXQkFBaGtPSkVtRFJ6V05RVERLbDRRTkxFK2xOM0NJaTB2MHNJbndVOFdyazlZZ3pnVUdpNGdhcVM4VGI1Uk5jd3U2ZkNRTG9VaEozUGRiVUU5S21TOVprWlVwTDhudm1SYXhpNVVQZHdoYWwxbXpaYm9hTWhxa2RhdGcyWkx0Q0ZMS01adlNrb1lDdlc0UHpPMHlqRmlWRVBMWDAwdEFhTGtOK09xdUlVYURITndqVDQvNnpIV2RXeG1BaURna0M2VFVKTjBJZFV0THZFSkhKR2s3bHNqUHZnNmUrQkxuejBsTEVhR0I4WExqTWpZQmRtOEtIUGh3Y2dRRmVucjBmdGVLR01MbW5sRjFXMHIwV2k4blNYZVphdy9GbzdQS05XdGlISTdJamNnVnBrUVBUa3BNUkFXSVJqcS9YdkFEbitoNm1qclppSkJlVUpnc1grYVlmYXc2SDFPenRFMWxPMGlBQUxPTGxYbXhWSzZaNlBtRWxYUmVPaXpMcHRXT0V2dXhuSlhxVjlmcGcwckJGbzF2WFRJSE96VFFUTTBxb0dURnRMc04xR3I1Uy9ibXJBSkJXL1Y4UGhXTXhUR0k2RVZCaTB5ZkNIeEtERE1HYkQyUG02MmtNZCt0NTRWNis3Q3JWdGpZdnUxRVRMaXk1bFZSZmpqSnF6MDU5cFN2WHpTczZON1Y0Ymk0d0YxYXlBOUxBUkFZQVFKZkxJZXFRNWlVVDJiTFBVZTFValR2VnZJUGV6d0d1bjJXQ09ybFNiMnV5TzkzV1pyWVAxb1hodFlRYXBmdDh6cElPVzJYY1ZJWHN0Vi96KzFoVEFsRkpvWFVQdTlmbk1pbGRXbFp0Z0JTWTZGMnJxTVI0RWVGenZZcXo4YnFxSkpIMmJ0UEFKZzZUYXdPV1phSnVNVmV6TWIxZzJNUGw5SHpNb1BaaENVc2FmbThuYUVRUUlnQW52eXNickM1S1F3TkRnOGhrKy9UV2pKeTlLdFcwandTM3V4dG1ackd0R1FmbTVSZTh4VTdPUVZHaldHMWdnVVBHTThZeWhNdkpsSkNJVkcybEE0YUxVbURxK1FZZDg0eGJ2YXJCWVhmZEVkNk5NL3grdVRQcEkyczk0UVRDQW81WDRjNlQ5amhyOVFhU2JheE0vYklldDhhcC8zaHlMbWpZeE0xcFA5VllZK01GdVlBSWdzRjUwMDRhZnEvZ3dadjJmTjlOVXpmdTJ1M3NSdVhUMDRYZzIvbjlMSFZ1b3RFTDl6dFN2OXk5MXI3SUlyZy83TkVFaVhjTkNQeFZKY0xnMjNvZEF3a2xzTncwUFcwNHZFZjJMVVhxNU1tZUhQcUtweUx3YmhyMFQ3cjEwQVhFK2VDNVYybjBnOG54clI0WEd4MGZod213R3pFVUJ1V0dycm1EQkNBRVR5QVdzdTE2UlA4REtHd2c1Sk5iWGVQa25xTVh0cWVKYXVESE5Qbk1DaFVzYnhwYlQ2bFN2d1piMFlKOXk5Um1MUFhRYi82eEJJdDBWZzZkaGxsSGsvekJnS3pmOGxqaXRNckVrWWpSMTNoclVQVjEzNG8zeEk4Y1gyaDhoZ24xa0NTSjkzamJMVWdUUlM5MkU3RE1yMXdiQ0czQXpaWGNRRDVsakIyanB1dGdtQWlJY3BhL1dNYU1MZHZUMldJbjdDMUFkMUJVK2NkcmV1THM5aXRmQlo0Uy94UkpCcEhGK2xBbC9PdTlmWWYzb3hFMTMrNDR3ZUU4aWRhbkFqWUNrSHpyc0xoZllxRGlvK2hpRXBGS3FVWVJUVmNycVQvNHdxTGF6c3lRMXF0L29OV3FXTFZQeW1vTnpuWFB0M21hMkNzcXNhT2dUR1d3WERabWt2ZWI2NmtVUEdZSFBEVFFBTTlBVW5kakswYTl0RkUrN3U1WkdRcXN3TFU2ak9ITk5oRjU0dDhYcVVlanhTeE94MjB0MEtkbUNOUnVQMW9NeHJrT0g1d0pmeGhHVlkyOWVxTnhnZDZGV3FMcHAxNEQxOFNvNm5TTFNpSVRCaklFd05oVlZ5akdVNjU5RUNXSXg3OHZCdzRXOVZ2bFkveC90dHZNeVJrVkNKSVdvK2IybEVrRjRqWFphTEZrRUNZRkFqWUdMSmlmaWdjUHRlV1EzWHhGUG1MTVhoUUdqT3BETVNXd25semkvZk95cTdqcGs5anMrYXhCRy9HTm8xK2RSd3QyNzhIRjVGb1MvakNTc1VHaDRYT05Cbi9uMjF0QVFHNjZ3WWU3MkhJZ2tyMW5oMFg2M3lHMTd2cnY5YlJlRlB6Lzd1MStkbyt4cGlsd0F5dkxpLzJzSFU3aDYyS3pMb0lWQ0RadmtqWFVxR2FFSUFERXo2czArS3c5MDV3MHVLR3NrRHd0WHdBTnQ0blRFNUNZUVREN0NRdVdpNWtkQmRiSzlacXNjM2haSUNuMWwvVDViMUNTZjlPOTZ0bXppdW8wcGIrZHk5Rk5iaTlOWlNZRHJvMGtVUm9PTXhaSlluaVIwSFJqVEs5aWgrYklrdm40Yzg2WEphNWpyb3N0SlJ2THZYNDBNQjBuWVAyeUhRWHExSmVweG9FU1FBQmlvQkdsbnU4TzFBbVBCKytqSVMxc2sxUGdOWG1lTnNySm0yMFpEVmNoZGZxMVNaczdQQ1lhdExOekw4ZE96UWFQKytsT2RwK1B2VlNBaUJZZk1rUzNkVnNFaExoQjRPTU1TMktIcjhzOGN6Y3p6bEZaN2xSbDFQOUJpS0wxT1l2V0M1ZDRQZ2lMSmMrayswQ3ZYTGlrMDFkY25YS3hBQWZSdzduSDgyTVJRbXpoaFUwVFJkeDFIelBldGFwZ05mL0h3UzFkK29JMTRvRkE5NmhxRktWbyt2cWtLZ1hlaytSTGRFc0E3SGtGN2oxR3dGakxBOWlucXpTNHQ2WHF5YjBmaEVEM3ZtZDVWTkFFcDNyazB1STJNTXJ3TXYxNnJhc05raXlFMDRBUkRaUXFFMU9EemRiTUhoT2hMSlMxUHBHbEdoK1BlVXN4NWZkWVRBa05rdEx0MFNsSzBJRmowZVNWcGNCdWdLTHBLb2RiR25hOC9kVmh2UjZsY2xYYjZ1cjJYMitNWEVRdjNXR0VjWm0ydXUzODYrUXdCRTdsQ1lwb1NFL24vU3hTd1kzYm9GTlZoSTk3azFPMWpQdkVad0xyM1M4cXR2QUJJbVFxSEFZNG9MdU9QOXo1b2xhN2I2RGZtbTFTL1hOU3l4VVAvdyt1Mzk1dnQxbzlpSENJQisyK3VOa2gxTUkwNHFQcHk4VWRwQUxmODNCeW5IWjFzak1NZWxYcGRYdW9JVDZsMmlnUE1jM2I4T2twODFsdHZIclg2T3JsdnhsYUtzeWd3eVd6aDJMSWJxR3dpQkJFQmYzdnVVNytDQ3U1ZkZyRnZBQmd6YzZ5K3pnaVVFRGxyakFRbUJCUVZBTHR6WlJhd1pzVkx1S3hvT1JLdGYxbXVWUGFUSlhyRnBhRkJGWW05WnRyTndiRDN2M2ZQQWs2K093ZkMvSUt1cFZkSGF1bGdRcEFVNFg5THpFR1VjYlk3d0Y5WXJFVVVIenVpYmpaQXNFQkRROERjeUNKcXpuZldDQ2RheW5mWUNCU0FBQW1XSTVyVCtCUGRzR1F1Qk5mV0V3RUtPcEJDZFR1blRzYm1VbXhscWhzeUN6cUZRRmE3eFhOcnpzTmtEYm9aQUNjaVJ2dTdoOG1VZ0FGYjlIVEtib1JwU0lBSjd4cXhSMGRwUlprc1duSi9iN0lPSUxydVJJdWI2NDFGWmd6eTJwU1RjaEVLMCttVThGU2VzYzZ6TFNNdnlwTXpTend1M1l3UU1PRDNybEhqTlpWVEx2aENLaGNCNnBjS0cyVnJEeGNmeERTNFNONGdaWHVLeld4TW1lckNsSEZ3dTQ2czFEVkNubFFCWTdYdDBqUmt3d2pSbmU1Sk1BcUQ3Q3FraE1GSnIxb2lrWUhUTzdhVnFXRk03VGxyOTlBemZRYk5yTTJRRVpvWnZVVU9nWGFkVnl1WFVzTG9NQWJCcTkyWnJmRXpVMjR2UUIvSkdYYnI5NUxXaEJRT3BseURaTnd4aitMalZnOUpaUXpqOStZMXU4M2lybjlUMWt4bStTdEhxVitBaGFIVUVVNkdCQUZqbDVHSVN0UXJQY2dIeHhObEZCdnpMd0gvZDNRQ2szVTFDWmt1RWJzV1BtSmNqSFFidEc3bG9vQU5oVkc4UnJzeDZLYmZCQVhObEdhWGlwVjFvOVNzby81SDZDSUIrQ29HMSttN0drSUd0cU95RlMwcC82SVhJQ1g5d2NqVXk5RkFPSGZXc01EaThNMFdHdjBiQ29Jd2RERXBMdi96TkFSK2ZwZGUxbGJwK0VhdlZ6N0NMT2hOZkNyOW1oc3o5aXg2YXlnVEEvKyt6MTdJbEFRQUF5dUN2LytOVmJ3UkE4VDhmL2dXdmlJLzkrMzIzcW50K3ZwVU40V09QZm5JeHh6SEhNVGlPVVFYSGNUSFF0d1VBQUJBd0JFQUFBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQUNJQUFBQUFpQVNIVFQzTW42QVFBQVVLMXEyUVRwWFRaam5GbytaN0k2Wi9KWXRheGxtbXFlTVZHTkhWMlg5RFU5ZllOcTc1RXV0YU85VTcxM3FGTnRhRHVwM2o3U3pjWURBQUFFd0dvaExYdWZ1T2hzZGZGY00vRGxJb0Z3eVp5cCtuR3I5VEVKaEJ2M0hGUFB2WE5RUGIvbkpCc1ZBQUFRQUwxbXpyaDZkZStWTGVyR1pYUFV0SWxqQ3Y1NUVoemxjZXZsODNRWWZPNFArOVFUclFkVVcvY0FleHNBcERzUE45U29MeTZkbFBQck5oL3BHL0d4Si9mUTYrTDFhK3hqZDY5UXJidVBxYzBITzlRVFd6NWdveEFBdlJIOGJydGkzb2l1M1dLUklIai9UUmVwdi9qb1l2WE1XN3ZVSTJ0M0V3U0JQTWlRakgrNDdaS2tqOGtGSlozOUozdFU1NW1SeHhrWEh1KzZjbWFEdXZ1eTZYbDk3K3FVOTdlMDk4VC92Zk5vbnpyVkgwNEtqenM3QjlTR2s1eUh5K1hteFdmRmU4ckV0L3NHMWJ2N2pxdnQ3WjNxdFIxSHN2YVUzYlhrTERWbnlsZzFzYUZlbmRmVXFNWTExT25yZGE0ZXVpMXR4K1AvUHR6Um85cFBuakgzZ1ZnQTNYR3NtNkZhUVE2QUQxN2Rva05acVlKZkt2azlkNjljcEZzWmYvalNWdlh3aHYzc2VZQUxDNmFOaTE5QWJLbnZ1dzBLcVJjSzBkMDdxQzlNaWVTaWtXak52cFBjeUJYWmhUTkdGKzFuTFdrYW0vYmZxWG9Hd21ydmNUTVV0aDdvaVlmRWpyNndlcUc5bHhlbFNNNmYxVGppZXJoaTRVejlrT3VpaktWLzYvMTJ0ZTJRZWR3dGluMzl2Sm1Oam9aaFpkd0hFczRObWM0VDY5OC9ySS8xWnpZZUNHd2dERlFBdEp1aTNWNDRpa1c2bUw5NTI2VnExWkpaNnI2blc3bUlBRTREd3RtVFN2SnowNTBMNU1Ma1JxYldobHl0R3hoMjN2U0dzdi9Pc2ZVMThZQ1lMaWphQWZHRFU0UHFVTmNBNFRCUE1xWStWd1BKcXFWejlLT2NFa1BvUzV2YTFGUHI5d2J1ZUExTUFKUUpIbzk4N3NObGEvWEx0ZU85OEtXVjZ1OSt0b0VMQk9CQTArUXhubjF1bVZvYlVsc09rVm5MMU5HZWUwNTJRRnpTTlBKekVneVBuQjVVZi9hckE3eDRPUlRTa2xjdWRnRDl4YnBkNmg5ZWVqOHdqVE9CcUFNb1hiNlBmZUVhVDRRL203UUdTaUNscGlDUTI4eEpZOWtJUGpadGZGMVZQZC9tV0dCZDBUeWVGeTRIR2NOWFRXVHk1dFAzZkNRdzEyWGZCMEFKZnpJUnc0c2trQklDQVgrMElxUTZlWVloSGs3Y01YZGNWVDd2eE1rbVNLOVVRemRLZmE0SnluWFoxMTNBOGdJV0d2NTZFbVlzSmM0dWJCeFRyNHRFeTh5a0M4NmRtbmZyb2gwQzFVL2VwRHNZU0VQRzducXA5ZDRwam1lSElXSEc2S3A4M2pMREdObko5YkVhMmRmbDR6OTQxZGNUUkh3YkFPV2lvWU5WSG81MW5WRnZiRzEzVmN6WkxpTDlrY1ZOcnVzSnlzNzJyVnN1VmxzZWZZT0pJVUNLcTg2bGhkelBaazJzcjhybmJaZVhRV2JTT0ZLdDVMcjgwSjJYcWN0V3YremIxOGUzWGNBeTI5ZHRxNEVFdjRlZWYwZWQvL2N2cWkvOGNyT3JPM2o1V3ZrZStWNzVHZkt6M0pCbTUrL2VmQUZuRENCRk5YWWpTYzhCblBIaUJCQW4waFdseGpDcDNWbU5MZmVwMStYdjM3REl0NitSTDFzQTVRVnpXK3JsOFZlMnFTKy91SzBvdi84N3IrL1dEM2tlTXNYY0tabUZkTmZtUXhTc0JSS01iNmkraTRpc0FnUm5Ibm5ycURxM3NVNU5HRldUOUhGNWYvNzA1SENZcmE1ZnViRUNTWGJMNTB3dStURzI2M0NuT3QwN3FDZHZsSXBjdy8xYUs5QjNBVkM2Zm1WMUQ2ZWtwYTVVNVZna1VFb3RzTzk5ZXJuamJ1R3YvdW5TV0FCOGtiTUhZRGw0c2tlWFoxaVFNcDVvUnVPWW9pemZpT29NVXNzbjE2djVqV2IzOGFUUk5XcjJSUE5HUWJxVXo1cGcvbHRtNjBvNWwySTdkcG9XM2x4a2pId3AzVzRObWJwditUbnFWZ2RmTDYzeStiWkkzbmJ4YlBWMmtScUlDSUFsSk11N09YMlI1UTdpOWhLUHU1Tmd1ZVZmWHRGVHk1M01aSlFMbXN4Y2xoWkVBTXJWc1pCYWRzSmVSaXJSc3BacEpRK1NzcUlJU2t1V2MzT3pwSnM5MjlodWJVeHNZWFRic3JqN09OMi91YVFlWjA2dnlVNnVrN0tLaDMzZFhqSFAyZSs1OXlkdjZyY1BmR3lKNng1Q1djWHJ5d1JBYjNQVCtpY3RmN2VYYWRLRi9BNzVYVkw4MmNtRjV0Tlh6aWNBQW5sd05ueGlXODd6U09yRWs5UnhpUGE2cERhNWFDWGVlS1l1SjRmS2M5TFNlR05UZzI1TnRHY20yNjJKTThiWEo5VXEzSDZVMVVCeWNWcTZTVmJTZVdYTElmVkU2d0gxdFZVTEhYM2ZodDFINC85ZTJwdzdBRXJybjkzTDkvd1Axcmd1RHlmWGJabm82YmVaL2I0S2dHNWEvNlRidDV3emJ1VjN5ZStVZ3RST2RqWmFBWUhLa0dOMVJKQmtYRzRnMk11OFpRcUxkcmZ6MnNNRXdHeWNUZ0NSSmRqdWVLbzEvbjZ1WmVQaU4zcXRCK0sveDBtamlxdzFuTWkrdHJvSmdkY3NtT0c3QU9pcldjRFNUT3VFVFBpb3hBc3B2MU4rdHhNcmw4emlMQUlBSGlKZHpoSU8yM29wQVpQTmdtbk9pbnZiNjJiYlljNXQ5KytxaFRNYy9aNXRoMGEyeUVzSWRIbzlGdFZhMHpBUUFWQ2FaNTNjQ1VqWGJ5WDc4dVYzT3lrUkkyTVU1SUFBQUtDYU9DM2RsTGhldHRNd2w5ajl1MmlXczFEMjB2dEhDcm9laXhtVC9EZmh6RGNCVUlvd08vR3p0VHNyL2x5ZFBnZVplUVFBUURWcG11d3NMSzNaTjl3VHQ3eGx1cVB2c2J0L3hieVp1UU9nQkx4c0pWeWNYbytyY1RuS3dBUkFKMk1IWkNDb0Y4YlZ5WE53VWlnMm4xbFVBQUJVMHN4SnptWlZKNDdEZDdKcWlNd1N0cjlISm1zNUNXV2I5aDdMZVQxMnltKzljcjZZQk9KMFIwZ2RDRnBKOGx5azhITTJicWVxbzBUN1YwT051bkptUTlhdnlYYzkwNitzTzg0R0J1QXJUcTdITXZ2WEprTzRuRXdhMmJobk9NdzVYU0l5M2ZpL2RNSFN5WE9Xc1kxK0tnanRpd0I0OCtLekhIM2QrbDNIUFBPYzVibmtDb0JDNnBxeE1raHhnbHRxU0R0dmVvTWFOeXE1RWJ6Y0t3MFFBSUhDMktWYlJHSkJhTnV5MmVtUGFiZkgrZ1BQN21mMUQ0ZmNGbHkrZUxhek1ZUHZKWVE1cCtNTU54N295UGsxUnpyTytMS0xOeEFCMEduRjhZYzM3UGZNYzVibjhzM2JMczM1ZFhvbkp3Q09DSFdaS3YrbjF1c0NVSDNzY2l1SngzbmlEVnNsbG9TVEcwZ0NZRzdTbXVkRTYrN2hCaG1ua3ptZTNUcDhMWFF5S3pleC9sODJVcmR6eGNLWmdic2UreUlBT3RrUkVwdWJ2VUtlVTY1dVhqOU9QUytFaEwvVk41L2pxOVlMdS9ZWUVHVC9kczBNZGYzaXhwSXMzWWJ5bVR5bTN2WDNPSm5Na1RqK1Q5L3NPNWlWeTVyYzJmbGlFb2lUSFdHSEJ5dnpPM2xPZnB4NlhvaWRuUU8rK252c3Jpc2c2R1JaTmkrSFAybUJSRzZ5L0tKYlRycGZFOGYvT2YyZXhGWkcrRFFBT3RrUlRudHdiVTRuenltSTR4S3ljYlAyWnpXUWRVa0J4Rzd1am5wN2ZkM1U4Y0pJTDNYdDdVenNHb0RTWmV5a0tzYkJrejN4ZjZldStaMUpWKytBcStjU05MVkIrVU85K0FJSGRhY3IxTEhUZzc0WjV5Y0wwZ05RNmxTL3QxZlhhSjQ2bWhlcEJHU00zdlBmZWs2WFdKRmkwREllVUxxRVV4cy9uRXptU05WMm9vY05UQUNFbnh3NVBjQkVEOEJuRG5RTmV2cjVNVGF4dEtTOFNtS0pGU252SmhVK1pKS24xTVJObk13aGxUSFdmUHZYdWhTTVRNeVF6NmNiVDA4RkRRS2c1c1haTzA2bnNTTlpkMy9FTjMrTExsRkJLUmhBZGZSNWYzMWRKbTNsNW5RVmtGeGt3c2R3NVk1dGFUK3ZBNTYrcnB1ZmwrN2theGJNMEpNbnh6WFFTQkNJQU9oa05tMnhkc3BpR3U5Z0IvWGk3T1ZLMjM2MFY2MW9IcytHQUh4azdXSHZCeXNtYmVYbWRCV1FVdERkeVE3S3ZzRGtpMUd0aHp0eTkvTTdtV1plYms2V3IzUHl0NkY2U2QxQ0FFcTE5WHEvQlREZkZYOEFML0pGQzJEN3lUTTV2MFlHbE1xWWdzUTZRcFhrZFBrNkozOWIwR3crVXRyWmdqTEpSTVlacG1vOTBGUFI1d1g0M2Q3amZRVk50dGpTM3BQMW1KV0pKdnM2MDQ4MWxCSlRmcXN5VUFuZHZZTnNCQUpnR1FPQnc5bTBNcURVSzZ1Qk9GMis3clVkUjloTFhlb1pDT3NMU2FhTFFHSlFrM0ZIak9rQnZIUHNaanFXcFV5TVBWUFlQb1k1ZnIzSDZhb2ErZFFMTEpXZ2pzZjNSUUNVZ2FDckhYemRpbm5UUEJNQTVibmtQQms2WE1ZbWFHU3MwT052SCtWQ0FQak1QNjg5cXNmWnlURmVEVjNDeUovVDVkOUFBTXhwL2Z1SGM5NTFyRm82UjgxNTl0Mktkd05MOTY4OGwxemUzY2NFa0hUa3d2QVZaczRDdnNOTlhIQXNiWjdtbWVjaVpXU0N5RGVsemJjN1hPcnQzaXRiS3Y1Y25UNkhEYnVQY3BZQUFGUU5wME95cGswY294Njh1dkxYWTJtUXlWVkZ4TzNmUmdBc3MyYzJIbkQwZGJkZE1VKy80SlhjMmVRNTVDTGR2MCswSGxBQUFGU0xOZnVjRDF2Nmk0OHVydWoxV055MWJIWkovallDWUJsSkJYSHBCczVsN09nNjlkMmJMNmpZODVUZkxjOGhsN2ZlYi9mTWpHVUF6bS93WkozU3hBY1FKSExkT3RibHJIcUZYQXVmdnVjamVobTRTaDJ2bjc1eXZxT3ZsYi9KYjlka1g2MEU4bjgzN0hVMCswakczOTIzNjFqWko0VGN0L3djUjJQL3hGUHI5M0ltQVVwTVZnNllQR1prQzBTNldZSHBWaGR3MG5XMFkvWHZrcGE0Z3JjdG4xeXY1amM2YjVXaWZNeEltL1llYzN5dGszSm8vL2xYMTZwbjN0cWxIbG03dTZ3aDYrSGJsK211YUtkL2s5LzRLZ0RLYk9DdnhsSzZreGYwYno5K2tkcHp2THRzczJ6bFFpTy8wd2xaL1lQWnZ3Z3lhUkZZTUcyNFZhQXhGdEprVGRCc3NpMy9KQmNaSnkzdnBTQi9Cd0d3K09ZMDFLZ3JaemJFM3orM3NVNU5HRFc4VW9mOGUvNzBrVFVGcGZoNk1kY1NsOXFEMXozZHhndVNZUDB1NXdGUXlMRjU5OHBGZW5qVWJ6ZTJxVGQzSGkzcE9yN1NNbi92bjV6dnFCYXZiZHVoVHQrOVRyNWJDL2dmZjdWSnJmN3NGWTUydUVjKzkyR2xmdkpteWNPV2hELzVYVTR2UUkrOXZvTXpDQUx0dG90bjZ3dUNIelNPWWJVWHQ0RXVjY1dOODZZM3FIR2p6TkZLVWlSNmJEM0xzWG1kOUs1OVlkVml4NjFyaWRmbFd5K2ZweCtycmNhUUhlMmQ2blR2WUh3Q2hvekRjOU5LS04yOFY1MDdXYmZxeS9LcnNnS1htK0JuOCtPWWZOOEZRTGxyK0x5RHRZRVRRK0RGTDI5VjMzbDlkMG1lajh4eWtvR3VUc1BmUzV2YVNucm5BMVNEL1NmOXN3UmlycGJMb1ByR0paUFV0Zk1tVkgyb0syVGxFajk3b2JXdDRKczR1WTdudXBidlBkS2xKMDJtKzk1aWtma0ZmaHlUWCt2SEhlOXJ6L3hSanlsd0VycmthKzYvNlNLMXZHVzZ1dS9wMXFLOXlITFhJZU1Mbkl4SnRNbE8vUFZuMytYTWdjRHJQTU9ZS3IrVEx0b2xUZFVmam1tUlRFL0c4OTI0Ykk3clZrRFhBVHlQMWp5M1pINkJINFg4K0VmSmVKc2Z2YnpWMWZkSVVIdnQ3LzVFZmYrR1JRWE5TSkx2bFo4aFA4dE4rQlAvL090M21Qa0x4SnowVVFBTWFwSFpYUHkwZHJaMFh5T1pYTXRrU0ZhMWsyNW92L2JLMWZwMTU1TXVYVmxxSnArQnFQS1FKbDhweFB6UyswZHlEdUNXMExkcTRRemRpdWcyOU5rZWYyV2JaNWFwQXlxTlNWQ29Kakoyc1cwUEUzMVNTWENhOC93N3VwZXRHa212blBRbytsV3RuM2UrTzU1cVZhOU1HcHZYV0FBSmN2SzQveWF6L3MvdXcxMGpWaHVSV1ljdE15Y1czTVF0NC82Ky9PSTJ6aGFBRDVXamk2b2F5WHEvOEQ5N2ZIMDFoa0RwU2ZUekRQNWF2Kzk4bjM5OHZTNDBXY2hKV0FLZVBQSnQzY3NWL2lTb0FraTJ4ZUZrTHErclZQa1pyNU0xdmYxQ1ppMC9TUXRnMWhEWTFUdVkxOHpnU25ubytYZEtOam5VSzBKKzMvRmtITUpscTEvV1FjdHJmckZ1RitFUENJQktyWFRnZFQwRFlUWkNRTWdRcHh2LzVSVTkzQ25kckYydmtCNi9CLzdqTGQrSFAxRWJsSjFQZ3RiM1Q1N3hSRzB4MmZsL1ZNTFNNNEFmSE83bzhXd0xvTFJPSnJKcmxkbWtqRTNpVEdZS1FhZTM5M2lmTDJZQ3o1cElyVWNucEVGR2hqdkpER0ZaZzdlUWNmT2x1QzVYWWpVU0FtQ1p5STczMm80ajZsdTNYRnl4Y1RseTRaQkJwVndRZ096YVQ1NHA2UHZsVHY1SVovcWZrUnJZTWdVMzRiYndMTHhMVnUxSVorZlJQbldxMzFscjVJR3VRZFhSbC95MXFlOGpkeERVRFNDeGg1Uk11M254V2VyOFdZMXFRVk5qV1cvNnBJYmdyc09kZXVXU0lFN0NyQTNhSHl5ekM1OWYvYkl1MEN5TFFKZHJQSUpjakg3NDBsWm0rZ0lPUGJQeFFMejZmem9VVEs5K3JRZDZYTFVBU291aDNXMzh3YWxCZGFocklHTXdrMGttZmhwbjZPY3dhRjRYaDYrTjlsS1FpV3R5RjFKT0tmR0d6ejZuY1A0SVlBQzB5ZDJIUEVvZEJPVU80N2svN0tPN0YzQkpXc2xwS2ZjL3UxVXVNZEFsaGprbVZ3VDQyRThLYVZUS0lBQ1dLQWpLZXIyZldkR3NsalpQS3pnTVNtdmZHMXZiMVhQdkhLU2VHUUJrOEpWMXg1VmFkNXdOQVJBQUswZDNEVnRoVGNMZ05RdG02RHAvRjV3N05XY1poOFE2Z1RMR2tOQUhBQUFJZ0ZVY0JvVU1VcjNxM01sSjR4RzZlZ2RVMjRrZUJvZ0RBQUFDb0I5SndOTURSaGswQ2dBQWZDREVKZ0FBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQkFBQVFBQUFBQkVBQUFBQVJBQUFBQUVBQUJBQUJRWExWNWYyYzBxcUtSb2RoYk5pSUFBRUFnQW1BMEVsYlIvbDVGQWdRQUFBaElBSlFXUUlQd0J3QUFFSndBYUJpR1VpR0dFQUlBQUFRbUFNWVNvQmtDQVFBQVVGVUthTUl6RXY0UEFBQUEvd2RBa2g4QUFFREFBaUFKRUFBQW9Db1ZOQVl3bWhBRC8vMitXOW1hUHZmb0p4ZXpFWHlPNDVqakdCekhJQUE2U1lIS3JnTjR6OCszc2pWOWZ0SDRudy8vZ2czaDg0c0d4ekhITWFyL09QN0JHM3ZZRUQ3MlZ4K1pXNVNmVTNBZEZ5b0JBZ0FBVkpjQ0F5RGpBQUVBQUlJVkFNbC9BQUFBQVF1QUFBQUFDRm9BcEFrUUFBQ2cyaFEyQzdpMlRxa3dJUkFBQUNBNEFUQlVxNklHdmNnQUFBRFZwUEQwUmdBRUFBQUlXQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFBQUVRQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBQUlBQUlBQUNBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQkFrTld5Q1VwblRrT051bkptUTE3ZjI5RVhWaSswOTdJUkFRQ0JkczhGamVwdzk1QjZzLzJNT3RFZllZTVFBQXV6ZkhLOW10OVluL1N4QzJlTUh2RjFFMGJWcVBuVFI2ZjlHYzFUUjZ1eDlUVWxlWDViMm52VUMwKzNzWWRXS3J5UHExZFhuVHRaUGJIbEF6WkdsYnF4cVlHYktLREt0VXlvVTUrOFlMTCs5NzJ4eDRIT2ZyWDFTSi82b0h0UXJUL2NxM2FmR21RakVRQk4zN2hra2pwN1F2MkkwTGFrYVN5dk5uSzZhZTVrOVprVnplcUtoVTM2L1RYN2ZxdmF1Z2ZZTUZYb256NTJ0bnA0VkVpdDIzTmFyZC9mb3g3WjJzVkdBYXJNZFhPU3I5MnpHMGZwaDdnNzlqalJNNlQyZC9TclBiSEhNenRPMFVJWTVBQjQ3YndKdmdoN004YlhzM2VXMFlOWHQ2aFBYSHF1YXA0eE1lbmpkeTJicmI3eittNDJVSlc1ZC9GRU5XMThuWGtCV2Rpb0gzOXp6Vm1FUWFES0xKK2QvWG8rWld5dGZseDg5bGoxKzdZZUFtQ1FBK0RPbzMyK0NJRDJ4UXVsYzltTWNlcnpWOHhWZjNMeEhEVjJkUHJ0L2VrcjV4TUFxN0hWWVA2RUVSK1Q0UnAyR0x6bjh1bHE3ZTVUNnJrZHArZ21EcWo3bHArajloenZWcy92T2NuRzhDanAvclZiKzNMWmVMQ0g3dUNnQjhCVC9XRmVWV1Fsclgwcmw4eFNTK1pNelIzRUo0N1JYMDhJcktJV2c4bjFha1h6K0p3M1dMY3NuYUlmeDA0UHFvOC90VWUxOVhMdUNJcnYzN0JJM2IxeWtlcnBpd1dHbjd4SkNQVHFqZHdjNTQwNW00OXdJK2NXWldBODdJNjU0OWdJSmJCb1ZxT2o4R2VUVmtCVWowK2VOOEhWMSs4KzNrZjRDNUFuUDdOTWh6OGhMZitQZk83RGV1d3ZQSGd6Tjl0NUFIeHhYemNiTE9nQmNQT1JQbDVWWkQ5UmJEN2s2dXZ0VmtCVWh4c1hUM0wxOWIvZmVZcU5GZ0F5cy8vdEJ6NnFWaTJkay9SeENZSGZ1dVZpL1hsNGg5dnVYOGIrRVFCOVpkTG9HalpDQ1VocGwyTmRaMXg5ajdRQ2NvR29ndkRYMU9CcS9LeDAvekloeFAra2hlK0ZMNjBjTWNuTEpoOS83TzRWYkNnUG9mdVhBT2phems3L2xPeVlQWkdKSUtYeXM3VTdYWDI5dEFKK2JkVkNOcHpIZldLQnUrN2ZGN1oyc05FOHJCZzNYVExaUTdwNTVSak9Sb2FGU1Bjd3ZNRk45Ky9LbHZIcWdXVlRkTUZvZWR6Y1BFNWQyOVRBUnN6QmQ1TkFOcHdzYndCOC9PMmoxaDFJN3E1bkNhZmxmbjVJVHlaMVNLdGVyb3RDb2xzdm42ZWVlK2NnQThZOTdNb1dkd0h3NTl2cC92V3loMjlmcGk0NGQ2cmFlNlJMdGU0K3B2YWY3RkhQYnYzQWNXMU9lN0tIVTlJOS9PQ2hUaVo5VlpBRXR3VlRSam51L2hXSnRRRVRmVTBsMXdtVU1qSE1GUFp4QUJTeWlvYnRnOWlMZmFocitHUWhzNFQzZFE3dkFLbExydjNUNVZQVjNaZE5kL1I3MXU4OXJiNnk3amg3VVpXU1ZzRDdiN3JJMWZmSVdLRnIzbXNmOGZHbXlXUFV6RW51eWcrOXN1VVFGNW9pY3R2OUs4ZHZLVy9JN05XR1pJVWhDWnJjL0xranJYOHJGczdVLzViV09YdmkxamRqRHhuQ3NXbnZNZFYrOG96YWZMQWo3WW85ZHkwNXkxWDRzOGs1WWVPQkRtNzB5bURLcUpENmNOTVlOWC95S0hYdXBIcDEzdlRpdDlvbDFnbVVGVVVrRUw2MjV4UmgwSzhCOExvQ2xsQzd5a1VMd244ZllOYVJsMG1kdndYVHpKblVjNmFNVlJNYjZ2TU9hellaSzVScEhKRmIwcUtCNG5IYi9Wdm84V3V2OVMxamRXVzRocjFzcEJSeFR3Mmkwa05BQUhSSGlyQm5JaTMzaVpNNVZzY2VuLy9oYTBtaFRVTGhoYTlzeXlzRWZ1L1R5OVdXZjNtRlZZQktHUGd1alFVeUNXWmxmdzZ4M3lsQlVCNXJZemVCVDc3WEdkZ2dXTXN1bVh6SEx1djdPdlhUYlhRZlZlemlFTHU3VHd4MXkxcW02YmN5bzY5WUFhM1VKSWlpZUphZTdUelU5d3lFMWQvL01mdjRQMmxSbEhCM2JxTVo3dXlBSndXbDNad25CQk82OGpnZnQweDMvbnIyRGFadHNmdnlpOXYwY1pZNjh6Y1hDWmpTL1h6emo5ZnhRaFJJWnZQS2hJNGxNeHBLMHNKWGlDdWJ4K3ZIejk4OXFSNTl0NU1BR0dSdTZvZEo5eEcxd3lybjgxY3ZjRlhMejR2eWJZVkU0VGR2ZTQvMzZUcWIwajByN0hBblNyR1NFQk82M0Vucy9uWGl0eHN6OS9yYzhWU3JlbnRtbytzYlEvbjlNb1pRUWlUY3V5TjJQWlhKR1c3RzhsWHMybi9CWkRWalhKMzY5cnBnOWNvUUFCTzQ2ZjdkZnBScDUwQ2wyYTEwZHBCelNrTGU2cHNKNEY2VnJmczNIWm1jbGMzdGo3NmhYdnU3UDhtNDVHTW10MTB4VDcyMjR3ampBZlBRTW5sVVZZUS9tN1FFM3RNOUdLaVdRQUtnZmNmWjRLNWI1MERYWU5xVk9wanBXeDQ3Mmp1cnZnV3cycDkvcVgzamtrbnEybm5KTjJYcHh0ZFZBNjkxZlhtZG0rNWZtUkNTSzZESldMNXZQZjNmYXZWbnIzRDFQT3dpMGMrdmZwa1h4YVVqM2RVM3JrNWFBb00wT1lRQWFMbHprYnNCNUE5ZVB5djdTZW4wb0Y1aVNnYWF2N1N2aDFCWVpLZDdtY3J2ZHgrYVBhNGszYkdWTUc0VU5mY2QzNHk3N1A1OVkydTdvNi9MZDFLSWRCM1RGWnpIVGZxSi9xcDgzbmVjM3hpWXJtRE9Tc3BjYy9makxwZVB5a1ZhS1dSQit2dXVtcW1lL2V3ODlWOS9PcHUxZll0STZvSDVBV3VRWnVhbllSYlNjZ2xuaXQzOW0waEMzSlkyOTZXN0pEUnlyTHJ6YW50MUhyL0x6ZzdPMEpCQXRnREt1S0dyNTR4VnkyYVBMVnNMZzRSQmVYeSt2VWQ5L2ZlSGFSRXNVT2NaZjJ5L3lXTUlCa0ZRamQzV2xWTHM3dDlVbjM5OGZWN2pBZWtLZHU5QVozOUp4Z0ZLTGI5UC8yci9pSS9Mak9Oenh0V3E4YU5xMU16WTI3bVRSdW42ZjI0MDFJWFVzcW1qVk92eGZ0Ky9Qb0VKZ0JMNnBFNllyQlJReVpPeEJNNmZmYXBaL1hqOTBaeGxLSkRaam1QK3FNRW9wV3lRbnBQVmRlQXZwZXIrVFpUdmVFQzZndDFyNnhnb1NRRGNscUYzUU1idXBZN2ZrOXFEZjNYSkZEM0p3NmtKOWNIb0hQVjFBUFJLNkVzbGRjU2thMWdRQXZQejloSHZCVUJwalRqU2VZWVhCMm5KRUpBbjkxQThQaHUzM2I5djdqeWExKytSOFlBZlhyZExMKy9vaG5RRk15dllPU2NUUVdTb3g1WWp2YTdxQkc3NndIbjM4b24raUI3VDk2dXp4K3JXUFFRZ0FQNys5am1lSDBBdUlYRGpCMzFKUzlIQlhlQnlzNVp2S2xsZlZBckkybEpYNXBCeGhxbGR6ZEx5Nk1YdzZVZHJEMWYzY1NHMUJxWGdkT3VCSGwvOFBlWGd0dmh6dWlYZ25QcUhsOTVYSDFuYzVQb2M4c0RIbHFqbmY3Q0dGOHVCZEJOQmVnY2pxdlZnanc1eGI3YWYwUUZOL0dwaG82T2ZLZC8vN043U25vTlBEVVFJZ05WTTFnQmUwdVQ5NS9sUEh6dGJ2ZmZVSG9wSzUzTjMyWmtjQUJNRFhXS1lrN1ZDRSsvOFVSMnE0Wml3MXgyM1E1NTBXMU1LS244WG5PdThOTkpiNzdjWHRuOTFENmkvKzlrRzlkZ1hybkgxZlZLK2lhNWdaelpiQVZER0FtNk5IUnV2dFhXbkhWc25ZKzZjdHM2OWY4VDlqWlIwQXp2OStUSytNQWpqLzN3ZEFKL2EzS0d1YzNoSFVVblNOZjNGcFpQVVY5WWQ1MnpoMHVyZmJORnY2WTd4TDJsRmM3dnNXakYvdDdUZ2RmZEg0ak9TN1hHSmRPVVczMzNMejNFMU1XUDlyc0pMZGNpNTQvRThTc05JZ2VoSDF1NW1yZUJjWVNwMjdQemxydy9rckt0MzZVem5kVEkzNXhFQWJ6alhlUVdPYlFGYTVNRzNBVkM2VmFVV1h6WE12cnZ0NGlucVh6ZDEwQXFZeDhrYi9pWUJySmprbkhEa3RIblJsbDZDUTEzbXY2V3dlMGRmbUhCWFFTdm1UWE8rWC9RTnFvYzM3Qy9LNzVXV3ZLdk9iM0sxVkp3RTFlL2VmSUZlWmc3Wk9TbXF2SHkyOCtGYUwrNXpmM3hlT01ONXdIUXp2cEFBNkdGcmQ1OVN0eXlkNHZubktaTkNwQkExRTBLSzc3SVo0OG8yWnErY3Z5c29zZzNsa081WGFSMlU0OGVKbS85akYxMnpIcmEwMlhrQUxMVDdOOVVqdjMzUDlhemdWVXZucUp2VzcrVkd0RURTUGV0MHByQzB4TnRqQnQxWTZEQUFsbU44SVFHd1RKN2JVYndBS0MwUjYvYWNqcmNZMkYxQnNnNnB2ZEM3MUJWMGMwRktKS3NlS0FKZ1VVbmgxa2MrOTJGMXRPdU0rdll2TjViMFJQM2taNWJwQzhKTG05clUxNTk5bDY2aElubG93M0gxbTloeExCTW8wcldRdTVuc1Jmano5ckhxWmpMR3RrUEZYYTgxMzFuQlRBZ3BuSnZ1MlMxNWRQOWUyOVJRMHZHRkJFQ1BLbVkzc0lTL08xL01jZGRwamVPN2QvRkVkY2NsVTF5TlhXcXAwRGdudjVKNll0Lzc5SExkVmRNOGVxSWU2UDJMMkFsZVp2NFZPNXpaNGM5dUZaZzNzN0hrZ1RNb0pMUVZJN2pKZUQ1NDF6VUxacmdMYkswSGl2NGM4cGtWTEJOQ0hyeTZSWDNuOWQyOGlIbHkwejByNi9TNmRjbE01Ni9uNW9BRlFOOFh4WkZ1NEdKWXY5LzVqdmZJMWk3MXFaKzN1YnJvc0ZKQWNUMTl6MGRHbk1qbDd2NkZMNjFVZHkwNXEyZ2hNekg4MldRc2tiUThGdXYzSU1zRjJHSHJYN0hIRXFLNFpBeWU0M1B4KzRkTDBzSXVQL09ITDIxMS9YMmZ2bksrUGhjZ1AwNjdaMlYycnBQeGhLa1d6M0RldUxMK01BSFFWNlFiT0IxcEdYVDFjMXlPQzVEdXFsOXZwVXUzRWlTVVpSclFMYUZReHZyODhKWUxDenBweS9kS3lFd05melpwZVpUZkk2MERxTHp1L2dnYndhTms3S3liQ1JqYjJ6dEw5bHhrWW9uYnRZTGxuSEx2bFJ6bitYRFRQZnVIZys1Yi85eU1MNVJTTmZrRVRBS2doMGszc04wU0o2MEF2OXgwUWc4R2Y4RkZPSlBCNXZuTTBQM3B0bE1jNFdVbWdTdFRLRXNrcllHeUhxaVVuc2czL0RtNWFOMS8wMFdFd0JLWjArQjhyTzMyb3hSaDlxcFZDOTExL3o2ejhVQkpuOC9YbnZtajYrK1JzakMwQXJybnBudjJqNGZkcjdMa1puemgxZ0F1UFJtSWRWR2tKZTdoTllkVnk3OXVWMy81MmhFOXBtaVppMm5uZHBGWHR5anJVbDR5a0Z3Q2wxUFNTdmZOMnk3VkxSQnVmb2QwSTd0cHNTQUVsc2FWTG1xSHdidmNyUDRoeGQ1TFBkTmVmcjdVQm5SRHppVmZXN1dRRjlNbHA5MnpNanYzMVR4V3pHcVo3SHdkNG53Q0pnR3dDa2g1bGRRU0syNldpWHU5clljajFlUHNTUjl1eVluZXpRWGxXN2Rjbk5meWM0UkFJRDAzcTM5czNIT3NMTTlKaWp6TFVwTnVTSytDbTV2Sm9IUFRQWnZ2N054RjA1M2ZKTDRhd0NWWkE3a3lzaXpLN3BTTUZTekhXcjF1eHlRaTJjTzNMM01kekdRd3VkdmxuRzUvOUEzWFk0UUlnVUI2TWxIS3plb2ZiKzQ4V3BibmxlK0VFTGZkMlVIbXBudDJjNTdMdjAwWjY2elFTVkNIaUFReUFGN29ZbGJRTzRmeWIvMXpFelR0MVFuZ25xekx1V0xoVEhlQk8zWjNmOS9UN3F2NHk0Vmg1US9XNkhwLytZWkE2VVpHZVUwWVZjTkc4S0FQejNmZS9TdXJmNVJ6TFc4M0UwTGt1VDMwL0R1VWczSEJUZmRzUHJOelA5emt2RUZneXhFQ1lHQmMxVExCOGRjV3NpNmdGSWwyYXVkUjZwVGxRN3BjWkFDMlcvLzRxMDBGbFpLUUphRGNqaE95U1lrWXVvckthLzUwNm14NjBjVnpuYS8rOGU2KzhxK1gvdGpyT3h5RnYzdC84aWJoejZWbFp6c2JocFh2N055WjQ1eVhPVDdjUFVRQURBS1pPZWltUUhNaE0zblBkM0hST2RYUGhKRjhQSFRuWmE2NmtJUUV0MkswSkVqM3NkejF1eVhQVjU0M3N3YkxwNWxDNjk0N0Y4ZjJmemVUcVRic1BscjI1eWpuaVd5dC9USXA1WnJ2L1phaTcyN0QzOVJSanN1LzVEczdkNG1MQXRPbkEzcjlEVndBL0VTejg1WVhLUjlUeUV6ZXBXYzduMml5K1FndGdHNUoxNitiQzRoOXduWTc3aThidWV2UEp3VEs4NWJGNUpHL25aM09XM0JsZVVaWm9RZmVjZGV5MmE2Ky9xWDNqMVRtSnZQbDdlbWZUeXdZeXBoZ2xuMTA3MUlYTS9qem5aMDdkYXp6aG9ITkovcXpmbDdHRXhJQWZjQk5xOXltZy9tUC8zUGIwdmprbm03T0NpN0lPTHE3Vnk1eS9YMnlSRnV4NVJzQ3BWNWhQblVJWVhLN1JKd3N6MWdPY3V4TDJQenBEVTJ1eGdFSHphSlpqYTV1M0VwZC9pV1RkR1ZoNUgwWkJrTDR5NC9UMXJsOHk3L28wRGJXZVJkd3B2R0NFdnp1dWFCUmZXN0pKRisrRHJWQjIvSGN0TXF0M1o5L0FMeHprZk54aHF4VDZwNlVZM0ZMVHRxbDZxcXh4Lys0cVVNby92YmpGNmtOYlNjcmRuR3JkbkxzT0wzUmtxK1RVSlp6VFcrWFlVL3FFY3JFc2xrVDYvV2Ezb25QNTFEWEFEZDNtYzdGemM3SC81V3IvRXNtVWhiR0htdjh6NzkrUjA4UVFmN09jMWllNWYweVRjNzQwMFVUMVhzbnpMR0dMUlBxMVBsVFJxbWxaelhvY1lyU1ZTM2pFQW1BVmE2Y3JYSWZtdTM4enQ5dWFieXhxU0ZwNG9oMGNibHQ1UWlDZkxwK1pkWnZNYnQraXhVQ1pUemdQOXgyaVo1WkRQZmsySEZ6VEYrM3NGR3RpMzM5azM4OG9kZnNkc0krTHM5dHJOT3ppU1hvblJXN1NNanZsYTdsYkhUQitYWEhlYUZTU0F1K203Sk41U3Iva29tMDlEM3oxaTcxMm80ampQY3IwTTNOcFMzL2tnK3BSL2h2SDUrZDlmUFNHbmpDWjB0S0Jpb0F1aDMvSjkwMzlray85ZTVsWElZeEFVNHVDcWx1V1RwRlAxSTkvdlpSdFlHTHg0Z0xSejVkdnpMcnR4d2tCRTVzcUhmMUhKZk1tYXIvTGk0czdyMTN0RS9kNHZKNzVCaDk4UHBaNm0rdU9Vc2Y1eklEWHlaaDJjRk9CL1A2bXFKTUhKa3hub2srNlZ5endGMjl2SEtXZjhtazFEZVFRVEcveE9WZlNrWHFGajY1M1YvTHUvb3VBQzZmWEsvbU41b24zZFR3NW1iNU56bjVyNzY1c3VPenpwdk9VbGVwSHZqWUV0ZmZJNE8xeTNrQmtRdEYwK1F4anRZa0ZqSitrUENYSDJuRmt5RG45cWJMRG5teUlwQ2JWWUhjbWphK1R2YzhzQ3hreXJtdHlmbjRQeW5ZRHY5d3V2eGJ2dVZmRXIvZjZVb2pUcmlwVzBnQXJJQi91bnlxdXZ1eTZiNzVlOGFOQ2lrTWs2NWZhUzF6UTJwMGZmM1pkOHYrWEdXQStOc3pHN04yVmN0eis5SExXNmtmVnFCbk5wN3c5SEV2WXdUYkdBZVl4TTN5Yjl2Yk85bGdQaUhqNjV5R3NxMEZWc2FRN3k5bUFGemt3d1laWHlVTXY5WFNvL3NvbVF6RWR0c2FJT04yS2pWVFQwcEVTTWpMRlA0b0hsc2MvN3FwUS9VTWVQZllkN1B5VUJDNFhmNU54dDNCSDFhNEtQK3k4MlJoRXkvK2EyZHh1MnRsVm5ITGhEcGZ2UjYrQ29EN092MjFucTUwSDJHWUJMbWJmN3hPeitiTkZLd1NGYnZtWHo3UFYwSmVwdkJIdDIrUnRuTnZXUDN2MXo3dzdQT1RzWVZJSmpkeU1qRXJGL2thamhQL2NOT04rdXpld2xyTnBmdjR0OXU3aXZyOHI1c3oxbGV2UnkyN0pLcU5oRHBwRlpCU01ObTZXQi81N1hzVmY2NXk4WkxBYWs4S2tWQks4ZGppazdHQVV1TXozV1NxaWwvMFdJVWtpWXpIdGNma3lwS0l5K2RNVnVmUGFsUUxtaHBIRFBIWXRQY1lHOHhIbkhhamJqOWFuTWtmcTF0UHFMSDFJWFZsOC9paS9MeTVrL3cxRHRCWEFWREt0cXoyMlFFak01R3BJNVkrV0QyLyttWDF3MXN1VkxkZVBpOXRDNE1YWmc3YWdWVUd2YytZTklid1YwSi8rZG9STlg1MGpTNzE0aVVzUTVlWjFMODBhMkFPMTlXVEdmRXlTMWdtVXEzZlJRRDBDK2srZFZxY2VVc1J5Nzk4ZTkweGRVLzNvUHJrQlpNTC9sbEhlL3kxWmpBdGdLaHFYL2psWmwwajdLdC91alNwcnRqZlAvK3VwNTduZlUrMzZyZUV2OUtTSXMvMzd1L0plMlp3c2EzZmU3cG9yUm1CdXJtajI5ZDMzSXovKzBPUnk3ODgrbTZuK24xYmo3cmovTVo0Y1djblpDVVNLVVl0OVFoZjNOZE5IVUN2YzdNeVFEV1FBZVMwQUdZbkxYMXI5cjJpSHI1OW1WcXhjS1l1KytLMWxUVUlmdVVqM2NIUDdlMVdYMXc2U2QxMjhaU3lCVUU1OSt5T1BXVDFEMW5ibStNV0dDWTE5Q1JFWFRobGxGb1FlOGh5Y09sS25Vbm9hajFlL0pVM1pFeWd0QVlxZFV4ZDI5U2duME02M1FNUjFYNTZVTzN2SGlxb0RBMEJzQUxLTVJ0d1MzdjZKZUs2WTNjSFR1NzJaYmF5MHdrcmJoYThEeko3Z3NpRFY3ZW9KMW9Qc0VHQ3ZqLzBodFZYMWgzWEQxbVhWOFlIeWpLUWhkNGNTc2lUYzR4ZFBGcUNYa2RmV0wzUVRpc2ZrSXUwb01uYXZucDkzM2ZOOGo1MkdKUHhkUXRqb2JBY3k3L0ZuMFBBK1M0QWRtZHBvclZQM3JiV0E4bEJibk5LM1NGTzdOV0hzaXBJcFpkOFMxajJUY2JWaW16bFdWSnYwbWpOQThvVHhxWlEvNVlBbUsvLy83K1BxLy83YmdjQkRrQmFkcGdqMUFIZTQ3ZHhkZ1RBTWlMd0FRQUFaRWRiS3dBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQVFIV29MZFlQZXZTVGk5bWFQdmZ2OTkzS1J2QTVqbU9PWTFTL3YvcklYRFlDeWhNQS8vby9YcTNPdno0OHBJendnREtpa1lKL1ZOUUlLUldxVWRHYWVxVU1nejBMQUFENE93QldyWnBhRmRWQnNMQVFHSTBGUHhXcWk0Vy9XdllvQUFCQUFQUitDSXlGdDJqc0VaWW9HSFVYL0tTbHo2aFIwVnBwOVdNNEpRQUFJQUJXQ2NQc3RvMUdsUkVKT3d5QmhobitwQVd4cGs2L0R3QUFRQUNzcWd4b1dFRk84bDlFR2RGc3JZR3hydzJGeks4UHNma0FBQUFCc0hySkJJN1l3d2dQeFRMZ1VFSVFUTXArc2EreFd2M284Z1VBQUFSQWY5QVRPZVFoSVZCM0NWdkp6ekRmNmdrZmhEOEFBRUFBOUNGcDZhT0xGd0FBK0RIbXNBa0FBQUFJZ0FBQUFQQ3huSDJjRDl4MEtWdkpoWEFrb3JyT0RLaTl4N3JVdXdlT3F4T25lOWtvQUFDZ3VnTGdkMTQ3d0ZaeXVqRkRobXBzcUZVdGswYXBwVTFUMUNYTk05UzcrNCtwVjdjZVVFUGhDQnNJQUFDSHBveHZVRXZPbnF6T25UcEJUV3lvVnpVaE9pM2RpSVREaFFWQU9EY1VpYXJqUFlQNnNlRlFkeXdFVGxEWHo1dXVHc2VPVnIvWXNFT0ZJMUUyRWdBQVdkU0VESFhOb3RucXduT21xR05kUGFwMXh3RzE2NE1UcXF1bmo4WVVGeDc4ODVVRXdFcVFFb0liRDUxU0hXY0cxYWN1bWg3Ym1jOVJMNy9YeG9ZQkFDQkwrTHYxUS9OVlUrTVk5V0xyRHRXNjYxRHNla3JqU1NuUW5scGkrenA2MWU5M2RhZ0xtMmZvNW13QUFKRGVOWXRueDhMZldQV3oxemVwUCt3OFNQZ2pBRmEzMWtPbjFQRXpZYlhrbk9sc0RBQUEwcEJHa292T21hWis5OGZ0YXUrUkRqWUlBYkQ2eVEzTXB2YlRxbm42SkRZR0FBQnBYREI3cWpwK3FrZTE3bTVuWXhBQS9XUDNpVE5xNHBoUmJBZ0FBTkpvbmpaUmJZeUZQN3A5Q1lDKzB0azNwRUloZ3cwQkFFQWEwa2l5cy8wWUc0SUE2QzltQ1JnQ0lBQUE2Y2dNNE03dVBqWUVBUkFBQUFTSnJLWUZBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQkFBQVFBQUFBQjBJMmYzdENrYm14cTRGVUVBQUFsZGRtTWNiNzZlMnFyOVlsLzQ1Sko2cnFGamZweDdQU2dXcnY3bEhwdXh5bjFRbnN2ZXlrQUFDaUttK1pPVnQrNjVXSTFmZUlZZGU5UDNsVFA3emxKQUt5a2p5K2VGUC8zdFBGMTZwYWxVL1RERG9QLytQWngxZFliWnM4RkFBQjUrZjROaTlSdFY4eFRZMGZYNmZjbENHNTU5QTNWMWoxUTlYOWJWWFlCUzdkdjg5VFJhVDhuWWZES2xnbUVQd0FBa0pjNTQrclZLMzkxbGJwNzVhSjQrQlBOTXlhcTc5NThnUy8reHFvTWdKKzVjRkxXejcrd3RZTzlGd0FBNU9XRkw2MVVTK1pNVGZ1NVZVdm5xUHVXbjBNQUxIc3FiNmpSNC80eTZSa0lxMy9kUkFBRUFBRDUrZG5hblZrLy83Y2Z2MGkzRWxhenFoc0QrTVdsMlZ2LzNqMTBSbDA1czBIZDJWaW5Kb3lxeWZuekRuUU5xa2UyZHJHM0F3QUE3VHV2NzFhTFpqWHExcjUwcEZ2NGE2c1dxaS84Y2pNQk1GL0xKOWVyK1kxbWlyNXd4dkM0UGdsdjg2Y1B2eisydmlianVMOUVLNXJINjRkVFc5cDdDSUFBQUNESjE1OTlWMTJ4c0NscERHQ2lXeStmcHg1N2E0OTYrMGczQVRBZjM3MXVwbHJTTkxaaXYxK0NKUUFBUUNLWjZmdlB2MzVIZmZPMlN6Tit6ZjBmUFUvZDhWVHJpSTlMOTdBOVdVU0NwQmRuRFFkK0pSQW5yWW9BQUNCNEh0NndYMjFwTzU3eDg5SkNtRG9XVU41LytwNlA2TzVqZWNpL3ZUaGVzT0lCY09mUlB2WXdBQUJRVms1WDluanM5UjBaUHlmZHcvZGUyUkovWDRwR3l3eGlLUmRqazM5N01RUldQQUNlNnE5OHZiNDc1bzdqU0FBQUlFQWV1dk15ZGZSN3QrcDZmeis4NVVKZDJpVmRLSHhpeXdkWld3RnZYR1pPRkpIdmYrUnpIMWJUSm80WjhUVjJDQ1FBZWl3QUFnQ0E0SkNnWjdmU1NiMC9tZEFoWS8yZWUrQjZ2ZnBIcW15dGdCTDQ3bHB5bGxveGIxckdDU04yQ0h6eU04czhzdzBxUGdsa1grZGd3VC9qOSs5M3FrTmRJd2RZYmo3aXJIdDVaK2NBUndNQUFBR3hhdUdNakovYmY3Sm54TWVrRmZDclhXZlN0dTZKR3k2Y3BTZURQS2xVeHRJeHl2cmM5MCtlVVY5K2NSc0JVTUxYNDI4ZlRSdmE1SE1iVGc2b2RYZk96VGhaUXdvLzMvbGlPM3N6QUFCd1JHcjhaU0lUUDlLUjR0RDMzM1JSMnM4dGJaNm0zem9KZ2JLODNPYURIVHBVQmpvQVNzRGJzQzVMMzNxV2RYL0ZNeHRQc0NjREFBREg3TUNXS3R0WXZ5ZGFEMlFNZ05JeUtOM0tVaE5RUXVDem8rdlZpb1V6TS82c2I5LytJYlZtMzI4cldoN0c4MlZnY3EzNysvUHRwOWlUQVFDQUl4TFVNblhsdHU0K2x2SDdKS3p0UFpKNTRZZ0YwNFlua056M2RHdldyNVd4Z28vZHZhS2kyOEhUQVZEVy9iMThidVpWUFdUc243UWdBZ0FBT0pGdC9KOTB6V2F6Y1UvbWdIamgyWk9Td3VMOVAzMWI5ZlNsbitjZ0gxLzlteTBFd0V4azNkOXNLM1g4WmdldGZ3QUF3TG16SjJkZWZTelh1THpUdlprbnJvNXZTSjRCTE4zQnNwSklLbWtaL05RUFhsWFA3emxKQU16a3hzV1p1MytQblI1VVQrN3BaazhHQUFDT0xXaEtQd0VrMi9nL1c3WVd3blEvVnlhVS9HTGRydmo3TDIxcVU3Yy8rb1luMWcrdTllb0xKTVdacDQzUFhFL25QemNlWnk4R0FBQ3VTTjIvZEhhMGQ1Yms5MzNobDV2VnhYT25xVFh2dFh1aS9Jdm5BK0RIRmt6SSt2bFBYVHhWblQyaFhqMjJ1WU54Z0FBQUlLZHN5NzhkVEZQL0w1VjBFYS9PNC9kS3ExOGxaL3hXVFFCY1BybGVYYmV3TWV2WFNPdmdMVXVuNk1mZTQzMXF6ZTVUZWtZd1lSQUFBS1NUT0ZNM1ZkdUpub0orZHFhV1JmMnp1NzJYVFR3WkFEOTUzZ1JYWHk5MUF1Vng5MlhUOWRqQXRiRXcrTjdSUHZYSTFpNzJkZ0FBb0NYTzFFMVY2Y0xNQkVDVmZmSkhMdkdXd2RpL0g3eCtsdHJTM3FOMnhzS2dCTUlOSC9UU1FnZ0FRRUExVFU1Zi95OWJ6VDRDWUpuY3UzaGkxc2tmYmkxcEdxc2Z0MWp2eTlKeDBtVXNvZkJVZjFndlBkZlJGMVl2dFBkeVpBQUE0R01QdmJ4ZGJUdlVxVXZCeU1TTTVoa1R6V3pRTjBnQXJMUS9XOUpZMHA4dmRRWHRVR2lUYnVNWGZyU1RJd01BQUIrVDhpdXBKVmp1V25LVzQrOS84T3FXako4NzFuV0dBSmd2bWZ5UkdNeEdiTnhZVUJzektwUzFPSFErM2puVXcxRUJBRUFBcFk3OSsvNE5pOVQra3oycTg0dzVaR3pOUHJOZzgxM0xacXUvK09qaWpEL25TQ2NCTUcrZno3SHVyOVQrKy9zL2RxaHZYREpKWFR0dlF0YXc2TWFoTHNZRkFnQUFwWmExVEZOM3IxemsrdnNPZDFSWFk1Sm5BcUNzKzN2OTRzemR2ekoyVDhLZmtMZnlrQlpEbVRGOFZjc0VQUXM0WDYrMzBRSUlBQUR5SjJNTENZQjV1SFBSaEt4ZHU3L2JPbkxEeW96ZURldU9LeFY3U0lDVW43Rm9lb082Zk81NFY5M0VUQUFCQUFDaWRmZXhyRFg5MHBGSkpFKzBIaUFBNXVQak9VcS9QTGZqVk5iUHQvWGFMWVJtSytHTlRRM3E0ck5HNjBEWVl0VUpURWZLeEFBQUFPVHJtYmQyZWJMWXMrY0RvSFRsWnV2Q2xiSXRibHZwNU92Tjd4bGV1RmxDNGR6R2VqVjdZcDA2THhZTXg0MEtxZFlEQkVBQUFHRGFmOUpkTG5ocFU1dW4xdml0cWdBb1hibVhQYnBkZCtGK2FQWTR0YUo1Zk5MblpabTNZdENCa081ZUFBQ1FnVDM3TnhjcCsvTERsN2FxaHpmc3I4cS8wek5kd1BFdTNEU1RPMlNOWHdBQWdGS1RzaStQdjJLMjZNbU00RlE3Mmp2VmU0YzZxemI0ZVM0QUprcWMzQ0Zoa09YYkFBQkFPY2hZdnVFdTNXMisvVHREWG4rQ2hEOEFBSUNBQlVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQTFhWTIxeGQ4ZmVWY3RsSVJQWERUcFd3RUFBRFNlUERQVjdJUnZCQUEvK09Ocld3aEFBQUFuNkVMR0FBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQ0FZakIrOEg0MHltWUFBQUFJVUFCVWt5Ni9MUFoyVXV3eE52YW9aNU1BQUFENDBrRHMwUk43ZE5URy9oZU9QWVppajBHMkN3QUFnRzhOV3BrdkxBR3dQL2JvdFQ1Unk3WUJBQUR3cFNFcjgvVkxGM0JMN0I5allvOVJzVWNOMndZQUFNQ1hwTmRYR3Y3T1NBQ2Nwc3l4ZjdVRVFBQUFBRjhIUUdrRkhKQUFPTVlLZjFJU3htRGJBQUFBK0pKVWZvbElDSlFBV0tPRzZ3RVNBQUVBQVB3YkFFWGsvd2t3QUNRbVNtTU5mT1F1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQWxDQVlBQUFBcVhFczlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVSa015UkRrNU56TkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNVJrTXlSRGs1T0ROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2preU4wSkZRa0UyTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxHUXpKRU9UazJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtFVndjR1FBQURldEpSRUZVZU5xY1dHbHdYTldaUFcvdGZWRjNTeTIzSkcveUppOVlYbkVNamdOTUlFT3dJV1Jxb0dxV0tnZmI0MUNWZUFLa1pxb3lxY0daTUtsVWpSTThnY2tVV1VqK0pBWFlDVEFzSnNaT2pHMkNqWTBzZVpHRVpPMnRyZmZYeTl2Zm0rODl0YWR3aGdCSnk3ZTYzZEs3OTl6emZkLzV6cjJNc0RXR1ArWDE3ei83WjM1WUdkNTVYL3dMNnphSE45K2ltbXFIbC9VR0dEQ1FMZGtJQ0lIZW83blh6NzJhZi9Wc2g3L2ptTWlJT2MzVW9ObmFqUlBaYzI4SGRuLy9ocS81VHdyazhaODhzbnBhbjlsenNYTHhDOTF5ZDl2TjBTMklCQ0xRcWhwVVc2WDViU1NFQkZnUHUvVmk3ZUxXQzdVTERrQXB4c1YrbFJTU3owYjR5RnVLcFVDM2RUamcvOWlMK1RpR3Z2dnNONWhSZGZUSkVXM2txeFc3QXBpQVdsWEIwYzlQMXY0VTdiRjJRSEZtb3VFQlRreWV3R05YSDBXTWo0SHhNYkI0Q3o3NDBjYTMvcUxkMy80WXgzQlRWYk1LeG1ZK2xDR09hL1A5VVRBSGZ2cm81cDVxejdFaFkrZ2UwelRCMXdUd0pnYy82MGRaS09PTWRnWWV4Z09UTVRHdFQrTzEzS3Q0T3ZNVVJFNkUzL2FETlZod0dnZUxmcDloTW1zS1d1R2hFQk1haWZMUks5ZERlUExsZHo0WlE0Lys5NTR2dmxKNDViRE4yVmhrTDRLdUd1QkVEbnlJZzJSTFlHc3NNYVhCdG0ya3hCUk0yOFFNZ2ZKemZwY3B6YThoekllQktuMnVhZkI2dlpqbFpwSFRjdGdlM3Y2dm5jSE9iNVdNRWg3Zi9iMlBaNGpBN0x3aVgvbjEvY243MFlKV3ZGL29SeVFSUVpFdndpNEJTOVZsNExNOGhLS0F1SmJBZkxZTkNTc0JzZUtCVnRBUlZzSll5QzFFUlNrakkyWVFpOGFRTCthUjRsTjRzUFZCVENnVHQrVzBmTG5GMC9MNzM3eDA4cU9UK3A4T1BkenlRdjY1bHg1dGV3eDdGdThGS0czdVpYWmlvRENBRGRwR2VNdGVzSlF3NnhMcjBCSnV3WUxRQXNSOWNUZFJpMW9SWStVeHBLVTB4bkpqYU5LU2FBdzFvbGU1Q2lrczRXRGJRV3hLYllaVUx1Ryt5L2NkRE1CL2laWTg5bEdBbUdFTXZjSFFralBWR1VoVkNmMXFId3FGQXRZV094RTBnNWdYbjRmTk5PbWRDKzhFQkhyQ29BcldiVGQwTE05aWk3Z0ZzSUMzeDk3R3FZbFRHSnNkd3lwbERTNzR6K09jZGc0cmxaVzRrTDhBMVZCbzd2ZGYrdG9UZTVMZi84YVB5aCthUXcvLzRHLzM5Mmc5VC9vTlAwcVZFcExKSkNaS0UxaFZXZzNCRU5BNXZ4UDcxdTl6SzZva2xXaGRxMTdDYkgwR3l5MS9wNEtpd2FnTCtNaVZJM2k5NzNVRXhTQk9lMDZocmFrVjJaa2NQSUlIbHQvR0VyNzl1Wi90LzlXRC95K0hObTVmSzVoTHRPT2FwZkdRZ1VBNGdCRjVCQjNWbFFnWUFXeGJ2QTI3TnV4Q3JWSkRXWmJBc0F3dDNRREw5THIxYnRPd0xDOXMxZ2VXMVNDckZiY1ExczFmaDZnbmlxNnBMamNmdTdWdU5NVWF3Y29zV0k2aGpLaXN2dWV6ZHo1Lzl0akY3QTJBL3ZLcjIvZFAydW5QQzZyZ2lxZ1pNcEdVbWhFdFI5SFp1aGE3TnU2Q1ZKU2dtVElZcmdHbTVxZGQ5c0lmZWdOZTRWWDYvQlk4dm10Z0xCdWF1cERDNTZjd2xxSElLbGEwckVCQkxtQWtNNEtVdHhWVDRpUkVRd1JqTUZCNEdhVDAwWjdmOVAvNmc0QzR4WGVrL3JQS1ZGTzhRZFhqRTVHVGNsaXFMVVBFRzhGRE4rMkdhSWxRREtwaExnYURGZ2tGZndoZStUYXMyUmVoei9iQXlIVlRBUndIYjc4QlR6QURwYktXUWticFlGY0p2RVhKdkFsWGkxZVJ6V2VRTmJNSU40UnBIc05sMnJLdCthdmFPbjdZZC9HYTZnWi85UmNYTCtzMWV6ZVVha1dZQmtteHgwS2IzWVpDS1kvMTg5YWpzYUVSSmFWRUQvdElVemlFZkUrQUxSMUFkWkFqRnY0Q1l2UXVlQnZ1Sk9ZK2k5cDRBbmIrYWZxYlIyRFVhdlJka0RZaXUrV3pKckhHemEvMXZnMG9Ha1d3Tmd1RHdqcUVvZWcxdS85ejF4bGl2cnpqb1FjK3ZlVFd1MVZaeDZBOEFObVcwY210UTV5UFkydkxWbGY0bkVrdEpncWYrQkxwelJPb2pYV2lZZlVkRUpwallIVVNBbGFBa0d5Q3QzRUo1QkZpV1h3VFhDQU94ZHdDamxHb0VvRkdYd0lUbFRSbXE3TklXMm5VMkJwc0N2SGR6WGRqRTd0bCtzM2Z2ZldHd3hDMzk5TjdOdTFMZmhrLzcvdzUvbTdSMzJOYW1zRnNjUmFOZ1Vhc2JGZ0pTYU1rZGxxRXBvUFhEa09mOWlBOG4wTEM2ekFuU3NUU05HeG1HbnBhSWhtb0lqUi9CZFNKSklYd0JaanFKSUVOb1diVWlPa21KQUlKRE9XSFlPb21vdDRvRG5VY3dvSDUzOEkvYk4yN2piQUlEaURCMHMydHMvS3NtOXhmWC9SMWZDcjBLVnd1WEVMRUUwYkFGNEJ1MGZhNEVPM21DdFNaYnJCTU95eFZRclgvUEd4dUdKV2h5NmdPOTRFVlJ5R1B2Z2NsTnduQnZ4U1FCaUVLbDZpdGlIUE5sN0xCTC9nUkZhTXdMQU5mYWZzS05pWTNvYUFVVUpRS1RVNjVPb0JFbHVXYUhUM0pLQmxhR0xndGVodXlhcGFhcE1lZHlCRTlSMnBzSlExa3JnR0VqMlYxNklVc2pFd3Z0WXN5dEd3UlZxRVB5dXdNaGNpQWJSS2J4U3hZWlpxYWI5My9XSmpUTGZxM3pMY01HME1iS2M4TUFrZC95d2tCaHh4SHFVbStiR0hPTTludWcwNG45dkJleUU0eVduVUZaV3dZOW53WWVYb3ZFVXZrYmFod29ZMUl4RFBuNWtKdG9BYk9ReG9qalVPZUduZDhDdFJZR0VLY3BpRTF2NzY1c2w2R3ovYTVNbnJkcTdFc0l6cnA0d0RpTE10MkdvQW42VTI2cmVDMTdHdFkxYkFLRW9VbFg4bURaM2dLVVFsc3d4b1lnWTB3cDA1QktoRWNnY3haeFFUbmlDUXR4dEppdkRlTkVySEVtcE9Rd3d1Z1IrNkFSNWNwV25PTGx5a2ZUUXBYajlTRDg5SjU3SnkzRTF5SmN5ek1IQzVuODRGUW9KZ01KVkdqSFgyNzk5L1FyL2RoVVd3UnBzcFQ2QzMwSWlKR1lKb3FmQ1JaY3ROK1VHK2trRWhRaWliVWZCV0dicmxNMXVpelhORElGV29nbFlDYzNBOC9NV1RReGh4Yk1wNGZwd3JMWUdsOEdaVTNpLys2OWpST2pwMUUzQnRISkJ4UnJwZDlVUE5WN3hqd3ZML2d5YkZET0RaMXpIV0JUbU5WeW9wYkZaMHRuZFF1S3JSckRXeHFBN0taUEt3cnArRHh5dUNDRFdSaktaOUlNc1Jna0ZncVFwNm9vclR3cnhIY2RoQ0NWb0p1YUlpSDR6ZytlaHlueDgvUU15eXNnSVY4SVVmUmVCMlRUQnBkWFYyWkU2Zk8vTmdCNURzOThkdWJMa1Y3TmdqTlBCcjBHR2tZanlsakdzdTl5NUdwekdKRnBBUEpRRFBLRkRZdjlSOSs4YjBvYUQ1STZWNVVNeFFlV1lPbDZGUXBOYklnQkhEbHc0aC83a2NJY0NvQkxjRlBqZFd5VEJ3Wk9FTGxYMFczMlkyd0dDTDk5U0xVRU1TNTlEbjg4b1huenJNRjd4RUhrQ2NjRGtibkpadDJKT2Nub2RkMFZ5UDhZUzlLTkZsQUMySzhObzd0QzdkVG1Heklpb1NBd0NCeTArMHcydjRHRlRKbmRxUU5adU42S0sxL2hkRHRoNURhOWdBOHBEdHFwVUJaS3JnRzdabnVaekNZSFVUTlYwUEZUN3BHanRPMkxRVGpBV2pET3BScnhtRzFhSjUyQUhGYXhWSjRuN1V6M0J3SythSmVhQlVOSWdsaGpzMGhpQkEwWW1CWUdzYTJoZHVvVndrb093bFNxeUlhYTBEVFRiZkEyN0VEd1ZVN2tWcTdEWkZRR0hvcEExMVRxT242RUkvRzhXTGZpM2huL0IyWWdvbExkby9iQVp5VzRRbVIyS29tSnQrYjBnclhhdDh4Vlh2TWJSMlVTejZXUjVEM3NsdGlpOGhTR0piYitCUk9BUjFwMEVMV1U2UC9uOCtjeDhhbWpVaUVFNVFYQnJGVmhrbjlpbFdwWjFGQkdOVUtOS1ZDTWlDZ0tkeEVrL3J3VE04ek9ETjJCaVpyNG9SK0hJSkhnRnFtNXV3SlVmL3pJdE9id2ZTbDJUY3JVOFpod3BGeEFEbEt3NnNsczhBSStqM2VpTmNmYUE0aVY4N2g3dGpuc1cvRlBwd3Nub1JHaVNsWGE3aVV2K1FLNkR6L1BLU2lLUVNGSUlVdzRJNmdoL2owRTZPNmhxT2pSL0h5OE11NFBITVpCbStneSs3Q1A2NzRHcjZVK2hMU3RVbWtTUjZzb28zeHN4TW9EcW4vWW1yMklPRW84blZkcWpqb3FsUEdmNlRmbS95TzFXQWoxaGpITjFkOEUzeWNKKzBvWTgvRlBiakxmNWQ3aXBnWW1NQkFkb0FTUFVuSkdRYlB6amxoNStSUjAydXUvZTNQOTFNenRtQjZEUHhlZXdlTElvdXdPN1ViaUFEajVnUk85SitBZUZaRVpVWjlWcXVZdy9TNDVFeHgzUStaamg3cFZVdmpCRHRtVkxUbDNoWXZ3b0V3UkZuRTgwUFB1K3F0K2xYUW9SR3RvVllVMVFMZW5Ya1hFNlRLdmJrKzlPWDdNRmdjZE1OYW9xTUphUnZJRGlQbnpTSHBTVUtTSk1oazdsVDZPWnc1aktFelE2aU95TjJGUWZVSHRMWURLTzgwbHc5NmFzZUxMcUN4UExIYzkzaWcxYmN1Y1VzQy9vQWZsWHdGWVN0RWVXQkI5SXNvbWFRdE92VWZpeWRSTk54VEtwa3NTQ1NXQVUrQVNDUWFlUVl4b2NHdFd0dWdwa1FrVm9Oa2F3MGRoZk1GMk1NWW43cFNmb1RXRzZCeHJSNmxHODVsNXR3WmdnNm9PZU9xSUdLaGtwVmJ4S0NJWkNwSmxwU0JTWWx0YXFiYmh4dzc0ZVRNcnZaZDJOR3lBN2MwM1lJR2Z3TzZ5bDEwdXVVUnRrTXdGTU5OQ0RFa0lCQ25BMlNCYURpWEkwZWdqT2F2S1FjczAzYVlHWEU2eXZYcmh6ODhLT3Ixd1RtZ2VHcGk4a3gxaFVrbDZpVTU4Q1g4NE1peFZQV0tDK3hneC9kdzc0SjdzVmhZakhaZk8yNU4za3E2RmNEUnFhTUllWU5rWlQzd05WQVRwZGJpVk5QRStRbFVaK1MzYzMzcWR3bk1LSzB6UkNOWEorTkRUNjRPU3BXR2MvQm1sSUl4eHJEc3FGeXNwaXFaU3RScEQ0NGp5QWs1N0YyNkYvZW43a2U2bElha1N5anBKUmlhZ1p2ak4yT0VHOEZWcFJkY2hVTmh0RUJsUFkzcys3bU1VclNlS3c2cXY2UzUwM1V3bVRvQkgza2Q0NFF0VzBldGxkT3FXazdqVWxUQjdiV3N2SlVQY0V2elFoN05EelNUZWpsNndic2VoMkhJaWxpMGp4QjVIWGtabm5yekthU3NGR21PTmtGOStWeGhVUG1mZWlVNVlNWWNadHB1aldyanA0dWY2SDdJcUdlOWc1NHlGUE9LdzhvcjlQN2I0RHl4UXpiMUplLzJYRmorbWZiYllyS2lCRVJCOERpQURNUFE4NlY4N1hkbjN5cnBnM1ovMmFNTlMrTktGejFYcTg4M1RXT0tSb25BR0gvTy9aRHJLT0dxQnhwcEpPcWZmZlh2K2ZyTjBBZHZvS3c2dTg1bTVEb3IyWHA0SERvVS9KL3Qrek11ckQ0QXpKR0ZJSTB3M01BZ01IZEY1WUppNjZDc09ydGFuZGx5SFZDNURzVDh1SVdZUC9HT2thMERFT2VzN3cxZ3JoZUZYUWVsMTRIcEg4WElINzcrVjRBQkFBbUgxM0ZXY2QyVEFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicGxheXBhbmVsXFxcIj48ZGl2IGNsYXNzPVxcXCJ0YWJsZS1wYW5lbFxcXCIgdi1lbDpwYW5lbD1cXFwidi1lbDpwYW5lbFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cXFwiPjxkaXYgY2xhc3M9XFxcIm51bSBzaW5nbGVcXFwiIHYtYmluZDpzdHlsZT1cXFwic2luZ2xlXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdzaW5nbGUnKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGRvdWJsZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJkb3VibGVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2RvdWJsZScpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gemVyb1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ6ZXJvXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDApXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBvbmVcXFwiIHYtYmluZDpzdHlsZT1cXFwib25lXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDEpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB0d29cXFwiIHYtYmluZDpzdHlsZT1cXFwidHdvXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDIpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB0aHJlZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ0aHJlZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCgzKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gZm91clxcXCIgdi1iaW5kOnN0eWxlPVxcXCJmb3VyXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDQpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmaXZlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZpdmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNpeFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJzaXhcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNilcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNldmVuXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNldmVuXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDcpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBlaWdodFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJlaWdodFxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg4KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gbmluZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJuaW5lXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDkpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBiaWdcXFwiIHYtYmluZDpzdHlsZT1cXFwiYmlnXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdiaWcnKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNtYWxsXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNtYWxsXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdzbWFsbCcpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmb3JtdWxhXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvcm11bGFcXFwiIHYtaHRtbD1cXFwiYm9udXNOdW1cXFwiPiA8L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gYm9udWRudW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYm9udWRudW1cXFwiPjx0YWJsZT48dHI+PHRkIHYtaHRtbD1cXFwidXNlckJldC5iZXRudW1cXFwiPjwvdGQ+PC90cj48L3RhYmxlPjwvZGl2PjwvZGl2PjxpbWcgdi1iaW5kOnNyYz1cXFwidGFibGVQYW5lbEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cXFwiLz48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcU3RhdGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wY2U3NDE5MS9TdGF0ZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5zdGF0ZSB7XFxuICAgIGhlaWdodDogMTclO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYm90dG9tOiAxZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxudGFibGUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuc3RhdGUtaXRlbSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMuMzMzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2Lm1vbmV5LXN0YXRlIHtcXG4gICAgcGFkZGluZzogMCAxZW07XFxufVxcblxcbmRpdi5wb3J0cmFpdCB7XFxuICAgIHBhZGRpbmc6IDA7XFxufVxcblxcbmRpdi5wb3J0cmFpdC1pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL3RoLmpwZ1wiKSArIFwiKSA1MCUgNTAlIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYucG9seWdvbiB7XFxuICAgIC8qY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwLCAxMDAlIDI3JSwgMTAwJSA3MyUsIDUwJSAxMDAlLCAwJSA3MyUsIDAgMjclKTsqL1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAvKiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5aS05YOPMS5wbmcpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cXG4gICAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG5kaXYuYnV0dG9uLnVuZG8ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBoZWlnaHQ6IDQwJTtcXG4gICAgcGFkZGluZzogNSU7XFxufVxcblxcbmRpdi5idXR0b24gc3BhbiB7XFxuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cXG59XFxuXFxuXFxuLypkaXYuc3RhcnMtYnV0dG9ue1xcbiAgICBwYWRkaW5nOiAuOGVtO1xcbn0qL1xcblxcbi5tb25leS1pY29uIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xcbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICAvKmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7Ki9cXG59XFxuXFxuc3Bhbi5tb25leS1pY29uIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblxcbi5tb25leS1udW0ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWU/NDZhOTFmNjhcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzRkE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxnQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsNERBQUE7SUFDQSx5QkFBQTtDQUNBOztBQUVBO0lBQ0EsMkVBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBOytCQUNBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0Esa0RBQUE7SUFDQSw2QkFBQTtJQUNBLHlCQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0Esc0JBQUE7Q0FDQTs7O0FBR0E7O0dBRUE7O0FBRUE7SUFDQSxvREFBQTtJQUNBLDZCQUFBO0lBQ0EsaUNBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLCtDQUFBO0lBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiU3RhdGUudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g54q25oCB5Yy6IO+8jOWxleekuueUqOaIt+eahOS4gOS6m+eKtuaAgVxcbiAgICBkaXYuc3RhdGVcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLm1vbmV5LnRhYmxlXFxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVcXG4gICAgICAgICAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5tb25leS1udW0oY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIixAa2V5dXA9XFxcImNoZWNrRGF0YVxcXCIsQGJsdXI9XFxcImNoYW5nZURhdGFcXFwiLHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjM0Knpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD1cXFwidXNlckJldC5iZXRtb25leVxcXCIpXFxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5wb3J0cmFpdFxcbiAgICAgICAgICAgIGRpdi5wb2x5Z29uKEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiLHYtYmluZDpzdHlsZT1cXFwiaGVhZHN0eWxlXFxcIilcXG4gICAgICAgICAgICAgICAgc3ZnKHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIsdmVyc2lvbj1cXFwiMS4xXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoKydweCdcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodCsncHgnXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGRlZnNcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuKGlkPVxcXCJpbWFnZVxcXCIseD1cXFwiMFxcXCIseT1cXFwiMFxcXCIscGF0dGVyblVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCIsdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIsdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uodi1lbDppbWFnZSx4PVxcXCIwXFxcIix5PVxcXCIwXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbih2LWJpbmQ6cG9pbnRzPVxcXCJoZWFkYm9yZGVyXFxcIixmaWxsPVxcXCJ1cmwoI2ltYWdlKVxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZSh4PVxcXCIwXFxcIix5PVxcXCIwXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiLHYtYmluZDp4bGluazpocmVmPVxcXCJoZWFkYm9yZGVyaW1nXFxcIilcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnN0YXJzLnRhYmxlXFxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvbi51bmRvKEBjbGljaz1cXFwiY2FuY2VsYmV0XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyQmV0JywgJ3VzZXJpbmZvJ10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgY29uc29sZS5sb2codGhpcy56b29tUmF0ZSlcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuJGVscy5pbWFnZSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaGVhZHpvb206IDEuMixcXG4gICAgICAgICAgICBoZWFkYm9yZGVyaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZycpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHdhdGNoOiB7XFxuICAgICAgICAndXNlcmluZm8uaGVhZGltZ3VybCc6IGZ1bmN0aW9uKG5ld3ZhbCkge1xcbiAgICAgICAgICAgIHRoaXMuJGVscy5pbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICd4bGluazpocmVmJywgbmV3dmFsKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgaGVhZHNpemUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE0MiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLngsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTY1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBoZWFkYm9yZGVyKCkge1xcbiAgICAgICAgICAgIHJldHVybiA3MCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxNSAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTI4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDExMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyA3MSAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxNDYgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDQ4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxcbiAgICAgICAgfSxcXG4gICAgICAgIGhlYWRzdHlsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwcHggJyArICg2NDAgLyAzICogdGhpcy56b29tUmF0ZS54IC0gdGhpcy5oZWFkc2l6ZS53aWR0aCkgLyAyICsgJ3B4JyAvL1xcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnKSdcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJywnICsgdGhpcy5oZWFkc2l6ZS5oZWlnaHQgLyAoMTAwOCAqIDAuMTcpICsgJyknXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KSAvLyA15Luj6KGo6IOM5pmv5pWw57uE55qE5pyA5ZCO5LiA5Liq77yM5Y2z5pi+56S65YWF5YC855qE6IOM5pmvXFxuICAgICAgICB9LFxcbiAgICAgICAgY2FuY2VsYmV0KCkge1xcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjYW5jZWxiZXQnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNoZWNrRGF0YShldmVudCkge1xcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKC9cXFxcZCsvLnRlc3QoZXZlbnQudGFyZ2V0LmlubmVySFRNTCkpXFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxcXEQrL2csICcnKVxcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXFxuICAgICAgICB9LFxcbiAgICAgICAgY2hhbmdlRGF0YShldmVudCkge1xcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcXFxEKy9nLCAnJylcXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5pbm5lckhUTUwpIHtcXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IDEgLy/mnIDlsI/lgLzkuLogMVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bW9uZXkgPSBwYXJzZUludChldmVudC50YXJnZXQuaW5uZXJIVE1MKVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4uc3RhdGUge1xcbiAgICBoZWlnaHQ6IDE3JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvdHRvbTogMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbnRhYmxlIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnN0YXRlLWl0ZW0ge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgd2lkdGg6IDMzLjMzMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5tb25leS1zdGF0ZSB7XFxuICAgIHBhZGRpbmc6IDAgMWVtO1xcbn1cXG5cXG5kaXYucG9ydHJhaXQge1xcbiAgICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5kaXYucG9ydHJhaXQtaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy90aC5qcGcpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbmRpdi5wb2x5Z29uIHtcXG4gICAgLypjbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAsIDEwMCUgMjclLCAxMDAlIDczJSwgNTAlIDEwMCUsIDAlIDczJSwgMCAyNyUpOyovXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICBtYXJnaW46IGF1dG87XFxufVxcblxcbmRpdi5idXR0b24udW5kbyB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aSpOmUgC5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA0MCU7XFxuICAgIHBhZGRpbmc6IDUlO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHNwYW4ge1xcbiAgICAvKmZvbnQtc2l6ZTogMS41cmVtOyovXFxufVxcblxcblxcbi8qZGl2LnN0YXJzLWJ1dHRvbntcXG4gICAgcGFkZGluZzogLjhlbTtcXG59Ki9cXG5cXG4ubW9uZXktaWNvbiB7XFxuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcpIDUwJSA1MCU7Ki9cXG4gICAgLypiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cXG4gICAgLypiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyovXFxufVxcblxcbnNwYW4ubW9uZXktaWNvbiB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG5cXG4ubW9uZXktbnVtIHtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5O1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBWUFCZ0FBRC8yd0JEQUFvSEJ3a0hCZ29KQ0FrTEN3b01EeGtRRHc0T0R4NFdGeElaSkNBbUpTTWdJeUlvTFRrd0tDbzJLeUlqTWtReU5qczlRRUJBSmpCR1MwVStTamsvUUQzLzJ3QkRBUXNMQ3c4TkR4MFFFQjA5S1NNcFBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDMvd0FBUkNBRXNBU3dEQVNJQUFoRUJBeEVCLzhRQUh3QUFBUVVCQVFFQkFRRUFBQUFBQUFBQUFBRUNBd1FGQmdjSUNRb0wvOFFBdFJBQUFnRURBd0lFQXdVRkJBUUFBQUY5QVFJREFBUVJCUkloTVVFR0UxRmhCeUp4RkRLQmthRUlJMEt4d1JWUzBmQWtNMkp5Z2drS0ZoY1lHUm9sSmljb0tTbzBOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFEaElXR2g0aUppcEtUbEpXV2w1aVptcUtqcEtXbXA2aXBxckt6dExXMnQ3aTV1c0xEeE1YR3g4akp5dExUMU5YVzE5aloydUhpNCtUbDV1Zm82ZXJ4OHZQMDlmYjMrUG42LzhRQUh3RUFBd0VCQVFFQkFRRUJBUUFBQUFBQUFBRUNBd1FGQmdjSUNRb0wvOFFBdFJFQUFnRUNCQVFEQkFjRkJBUUFBUUozQUFFQ0F4RUVCU0V4QmhKQlVRZGhjUk1pTW9FSUZFS1JvYkhCQ1NNelV2QVZZbkxSQ2hZa05PRWw4UmNZR1JvbUp5Z3BLalUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2Z29PRWhZYUhpSW1La3BPVWxaYVhtSm1hb3FPa3BhYW5xS21xc3JPMHRiYTN1TG02d3NQRXhjYkh5TW5LMHRQVTFkYlgyTm5hNHVQazVlYm42T25xOHZQMDlmYjMrUG42LzlvQURBTUJBQUlSQXhFQVB3RDF4alRkMURVbEFDNW96U1VsQURzMFpwdEZBRHMwWnB0RkFEczBacHRGQURzMFpwTVVZb0FYTkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYVRGR0tBRnpSbWt4UmlnQmMwWnBNVVlvQVhOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05QRFZIaW5DZ0JEU1VwcHRBQzBVVVVBRkZGRkFCUlJSUUFZb0hwUjBySzhSNjdGNGYwdDdrNGFadmtoVFAzbVA5QlFCWDhTZUtyUHc3R0ZjR2E4WVpTQUhISHFUMkZZT2ovRXlLV1FSNnJiaUFrLzY2TEpVZW1SMUZlZjNWMU5lM2NsemRTTkpOSWNzN2RUVVdLcXhOejN5R2FLNWhXYUNSWkluRzVYVTVCRlNZcnhydzE0bnV2RDEwQXBNbG81L2VRRS9xUFExNjdZM3NPbzJVVjFiU0I0cEJrTU9Qd0k3R2swTk1zVVVVVWhoUlJSUUFVVVVVQUZGRkZBQzBsRlkzaWJ4SkI0Y3NQTWJFbHpKa1F4Wis4ZlUrd29BczZ0cmRsb3NBbXZaMVJUOXhCeXpuMkZjVlA4QUUrZjdjalc5Z2kyZ09HRHQ4N0QxejBGY1pxT28zT3EzejNWN00wMHJIcWVBQjZBZGhWY0NxU0piUGN0SDFpMDF5eVc1czVBdzZNcCs4aDlDS3ZFMTRsb0d1VDZCcWFYY09UR2VKWSt6clhzOW5jeFgxcEZkVzdCNHBWREt3OURTYUdtVFVVVVVoaFJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQUFaTmVXZUxicWZ4SDR3VFQ3VEpXSi9JangwM2Z4Ti9uMHIwalViNlBUN0tlWnlBMGNEeXFQb1A4U0s0RDRiV1p1OVl2TlJseXp3cmdFLzMzNi9vRCtkTkNaMlVYaFhUVTBSZEtlM1dTRUx5eDRabS92WjlhOHg4VGVHN2p3N2RBTXhsdEpEKzVteHdmWStocjBmVXZFUXRaZFl0MUlFdGxaaVZUNnNjOGYrZzFQWjJjR3RlRXJTRzhVU1JTMjZiaWV1Y2RSNzVvVEJvOFk0SXJvdkIvaWQ5QnZqRmNzVFlUa2VaMzh0dXpEK3RadXU2TE5vV3B2YVQ1SSs5SElCdzY5aldkM0djNDlxcmNrOS9WbFpReUVNckRJSVBVVXRlZmVBZkZRVlYwZS9mSDhOdEkzL0FLQWY2VjZDRHg3MUxSYVlVVVlvcEFGRkZGQUIwb29xT1dXT0NKNVpuQ1JvQ1daamdBQ2dDdHErcXdhTnA4MTVkRWVYR3ZDanE1UFFDdkdOVTFXNDFpL2t1N3BqdmM4SjJRRG9BUFN0THhkNGtmeERmZ1JFcll3a2lGZlgxWS9Xc0ROVWtRMkxnSHZpdWo4TGVFSnZFRW5uVE8wRmlEdDh6SHpTSHVGL3hyUDhQYUxMcjJzUTJjWkt4bjVwWC91b090ZXBhcThla3BvMFZzQkhDTHhJbFJlZ1Vxd29iQkl3UEVuZ0t6WFJ6THBDTkhQYnJ1S0Z0eGxIZjhhYjhNdFg4eTN1TkxrYk93K2JGbjBKNUg1OC9qWFpXTi9GZmlkb3lOc016eE43bFRYblRRRHd2OFNvdkxHMjNsa0JIcHNmajlDYVc0ejAraW80SmttajNJMjRCaXBQdURnL3lxV2tVSlJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQndQeEl2M3RybTJoVW5iUGF5UmtmVmxQL3N0WGZobkVGOFAzTXVSbVM0SS9JQVZsZkZPUC9TOU5rL2hNY2k1SHJrZjQwbmhiVy83SDhJQzV3V2lnMUFMT282N0hYcitCNS9DbjBKNm1KNHN1NVU4V2FzRmNnU2Z1bUhxTUQvQ3ZRdkF0MnQzNFR0Qm41b3QwUkgwUCtHSzg0OFdNa25paTlsaGNTUlNzc2lPdlFnZ0d0MzRjYXVMWFVadE9tK1ZMckR4RS8zd09uNGorVk5nanJmRm1nSnIra3VpQWZhNHN2QzNmUDhBZC9HdkhTcktTcmdxdzRJUFVHdmZoZy9TdktmaUZwYWFmNGg4K01ZanZGOHpBNkJodzMrUDQwa3dhT1d4am5uUFhnNE5lZ2VHZmlFa2NLMnV0TStVR0V1QU03aC90RHJuM3J6K2s2VlRRa3oxSzUrSmVsUnNSQkJkVEQxQ0JSK3RaNy9GRmMvdXRMSi8zcHNmeUZlZlVuV2xZTG5mSDRwemY5QXlQL3YrZjhLa2orS1M1L2U2VzRIcWsyZjVpdlBzVVlvc0Z6MU8xK0pXa1NuOThsekJnZFNtNytWY2w0cThZemVJRyt6MjZ0RFlML0FmdlNIc1cvd3JtTVpwYUxCY0tROGZXbHJhOEthSTJ1YTVGRTQvMGFJK1pNZTIwZHZ4UEZNRHZ2QU9pZjJab2EzVXlZdWJ2RG5QVlUvaEg5ZnhxaDhSZFQreFM2U2tmTHh5bTR4OU9uOWE3WmlrU1pKVkkxR1NTY0FBVjR4NHExa2E1cnM5eEhrUUwrN2gvd0IwZC94T1RVb1ozSHcxbGFiUjd3eUVsamRNeEo3a2dHcUh4T3QvS24wMi9qNnF4ajQ5UWR3cUx3cnFRMFR3UmMzQXcwOXhjbUszVHUwaEFBL0FWcmZFRzNQL0FBaUVSYzVhR1dQSlBjNHdhT29kQ3o0RXZHdmRBYVZ6OHh1WlNRZmM1L3JYUzVya3Zod29IaGNrbkJlNGNnZlFDdXNwTXBDMFVVVUFGRkZGQUJSUlJRQVU0VTJuQ2dCRFRhY2FiUUF0RkZGQUJSUlJRQVpvNTdkY1VacE9sQUhsWGl1NzgrTzRzSnorL3dCUHZYS1ovaWpmbjlEK2hGVXZEVXd1TFBWTklkZ0Rld2xvYy84QVBST1ZIMVBOYkh4SzBvd2FwRnFLQStWY0RZK096ai9FWS9LdU1qZG9aRmtqWXF5RU1yRHFDT2hxaUJxdG5CSko0OWVsYitpeVdPcEpEWTN0eDlpdklEbXp2VjZBOVFqL0FJOURXRkpKNXNydVFNc2NuSHJUUHlwZ2U3MlRYS1dDSFVQSkVxajU1STIrUi84QWE1Nlpyelh4L3JsdnEycFFRV2JMSkZhZ3FaRjVETWV1RDZWeTV1WnpFSW1ubE1ZNkp2T0IrR2FqUE5KSWJZVVVVVXlRb29vb0FLS0tLQUNpaWlnQUdNODV4N1YzUGcveFJvdWphY0xhZEpvcDVHM1N6RlF3WTl1bklBK2xjTlJtZ1o3THFGL28ycmFSSTgycFJteEEzVENPVGFXSDkwOS93NzE1UHE5N0RmNmpKTmJRSkJhajVJWWxHTnFEcCtQZXFPTXJnOWFYdGowcEpBMmRGNFNqTi9xOXNicVlKWTZhR3VHTGNJdk9mMWJINVYxbmlUVWwxandCZVhpcHRnZVZSQnU2c29ZRGQrSnpYbjJsMnQxcVU4ZW1XcGYvQUVseGtEcGtkejdBWnIwZnhyYnBZZUI0N0MyUWtlWkZER3FqazRQWWZoUXhvei9BVTVsdWJXMVFueXJLMmVTVWpwNWtqZFB3VVYzWkdUV0Y0UDBIK3dkSTJ5LzhmVTU4eWJIT1BSZndyZXBNWVVVVVVoaFJSUlFBVVVVVUFGT0ZOcHdvQVEwMm5HbTBBTFJSUlFBVVVVVUFGSFdsNlZUMUc1dW9MZkZoYW00dVc0VldPMVFmVmo2ZTFBRlB4TkxwUzZOTkZyRXFKREtNQWZ4azlpbzdtdkdKTmdkaEV6TkdEOHBaY0Vqc2NWMGZpVFRaWWJ0NTlkMWVPVytma1c4STNsZlFkZ29ybXVoSXhWSWhoUlJSVEVGRkZGQUJSU1V0QUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQVNXOXpQWnlyTmJUUEZLdjNYUmlDSzdQUmZpRHZsZ1RYWUJPSWptTzRqVGxEakdTdmM4OVJYRVVnd0RrZ242VVdIYzk3czd5MXY3ZFo3U1pKWVdHUXlISXFVMTVINGIxR0N5dWcxcHFFdW0zRGtCbG5IbVFTK3pZd1I5YTlXczVKcDdkWG1pVkpDT2RqaDFiM1U5eFV0RkprOUZGRklZVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUNaL0t1TDhRK0xMdTRhYXg4T3h5U2VXQ0o3eFI4cVk2Z0hvUHJYWVhNY1VsdklzNXhFVk80azRHUGMrbGVWZUsvRkkxSS93Qm5hV29nMHVJNENvTm9sSTdrRHQ2Q21oTTV0eXp5TVpHM09TU1dKeVNmclRUeFIxb3FpQW9vb29BbjAreG4xSzlqdGJWQTBzaHdvTEFmcWE2KzIrRjk4NmY2VGV3UlAzVlZMNC9sWFBhUG9VbXFZZFp4Q0ZPY2lKNUcvSlFjVjNHbncrSnJLSEZucVVHb29vLzFOekc4Ylk5aXcvclNZMFpjM3d0dkZHWXRTaFkrakl3SDlhNTdXdkMycDZDaXlYa2FHSmpnU0kyVno2SHVLN1VmRU5iS2MyK3RhVmNXY3kvZUNuY1BxQWNjVnN3MzJsK01kSHVyYTJrODFHWGE0WlNySVR5RGcrNEZLN0haSGpGQjRxVzZ0M3M3bVczbUdKWW5LTjlRYWlxaVJhQ2FRYzFaMCt3azFQVVlMT0Faa21jS1BZZHorQW9BbHNORTFMVkZMV05sTk9vT0N5cngrZlN0QStDdGZBei9BR2MvL2ZhLzQxNjFwMWhEcGxqRGFXeWhZb2wycjcrcC9HcHBwb3JhTXlUekpIR09ydVFCK1pxYmxXUEVicncvcTlraGU1MDY1UlIzTVpJL1NxQjQ2akI5RFhzMDEvYWEwaGdzdFhualhveldxbm4vQUlGamo4RFhQYWg4TVlwVWVTejFHYnptNS8wZ0FoajdrZEtkd3NlZENpcldvNmJkYVJmdmFYc1JqbFhzT1FSMklQY1ZIYVF4WEU0U2E0UzNVZy9PNkZnRDJISE5Na2dBelMwNTFXT1Fxckk0QjRaU1NEV3RkV1Z2YzJJdmJMUzc2Mmo1SG1Cdk5pSkhYdGxmMW9BcWFiZVcxcEx0dmJLSzd0M1B6S2NxNC8zV0hTdlVQQ2NWcWxzc3VqNmhKTnByY0cybjVhQnZRSHQ5T2hyeUlIUHA2MTNYZzN5TG1ZWE9reWZaTlNqWDkvYUZ2M1Z5bnFNL2RQOEFJMG1OSG8xR2FSYzlUMzlUUzRxU3dvb29vQUtLS0tBQ25DbTA0VUFJYWJUalRhQUZvb29vQUtLS0tBTWJ4TmJHOTA1NHA3dzJ1bnFDOTFJbytkMUhSUjlmV3ZINzJXQ2E1SnM0UEl0MU9JMHprNDlXUGNtdlEvaUROZFhrUnNMUlQ5bmdqKzBYa21jS0IvQXVmVW50OUs4MDZjWUF4VklsaFIxeDJ6VXR0SEhMTUJOT0lFN3R0TEg4QU90ZFBwZDU0WDA1Y3l0ZFhManFKYlZDR1BwemsweEhKaXJXbldFMnFhaERaMjIzenBTUXU0NEZHb1g3YWhldlA1VU1BSitXT0pBcW9QVGlqUzc1dE0xYTF2RkdURElISTlSMy9TZ1I2VnB0enIzaHZTMGd2Tk5TOWdoWEFrczNHOEQzWHY4QVdzNjcrS0k0RmpweEo3bWFUSDZDdTMrMnExaXQxYUo5b2paUklvalBMS2ZRZC9wWGp1dkpaUWVJcEpiVnZNdEpKUE44dkJWbDV5eUZUeURuTlNpaTdyZmpEL2hJYlR5YjdUb1JNbk1jeU1jb2Z4NmoycXA0VDFoOUc4UVFTNUl0NUQ1VXdKNDJudjhBZ2NHdEZQRE50SGVycUF1OVBuMGZKbFBtVGJXMjlkcFVjN3E1WnNiMjJqYXJNY0QwSGFtSTZQeC9aL1ovRmM3Z0RFNkpLTWU0d2Y1VnpXSzMvRTE2TlN0ZEd1eWYzcHRURkovdkt4RllOTkFGZHY4QURHd1dXL3VyNGovVUlFUW4rODNYOUIrdGNSWHFQdzBpVlBEa3JnZ3M5dzJmYkFGSmdqZTEzV3JmUWRNa3ZMajVtR0ZqakJ3WFk5QlhrMXg0Z2wxUFZWdTlhVjdxRkRrVzZ2dFFlZ0hvUFd1MStJVWtVU3dTTXBublJDWTBiL1Z4WlBMdDZrOEFENjF4bWlhWGI2M0hjMjV1b1lMN2NKSVRNY0xJT2R5NTdkcUVOblN4ZkV1UzBTT050RldLSGFOaXE1WEk5Z1JqRmJGbjR4dTljakthTHBNcnlqaG51SEN4Um4zUGY2VnkrdDZXMWhvdHBwazEydW9hdkxNdmxSeHVXRUtZeHRCNjhrMTZEb0drcm91alcxaUNwa2pYTWhIZHp5eC9Pa3hvOHg4WDZYckZwZUxlYTFKRkk5eGtLMGJmS01mdzQ3QVZoVzF3MXJjeFRSSEVrYkIxUHVEbXUzK0tGNnIzbGxaZ2d0RWhsYkhZdHdQNVZ3dU0vZDYxU0pON3hJUmN1dHlsenAxeXJjczFzbmx1TTltWHY5Um1uZUdMZ3hwY0NXNjFhM3RsSHl2WkVrSzNmY3YwcTlxTzF2RE9uVGFsbzRNUmdBanY3ZVRFaW50dkdNZm4rZFpQaHJVN2pSdFdTN2lXZDRFTzJmeTFKeWg5ZjUwZ0k5WWlna25hNXRMOWJzSDcrNkx5cEIvdkwwUDFGYS9ndXhUVVJLYk9UN1ByRm13bWdjbjVaVVBCVmg2ZHZ4cS9xdW8rSE5makpTN1dHWHFyWFZ0dDUvMzE1SDQ1ckEwYTVsOE4rSmJhNGxJOHNQdFprWU1qUnR3U0dIQkhmOEtBUFkwZG5pUm1YWXhBSlgrNzdVNmpyemtFSG9SUjFxU3dvb29vQUtLS0tBQ25DbTA0VUFJYWJUalRhQUZvb29vQVVVaG96bWtIWEdjVUFjUjhTOVJFR253YWRIZ05jdjVzbVA3cTlNL1Uvd0FxODRVRmlGVUZpVGdBREpOYkhpM1Uvd0MxL0VWek1yWmlRK1ZIL3VyeC9QTlZOSzBtNjFPWW1CbGhpai8xazhyYlk0eDd0NisxVWlHYm1rYUxwbHFxeTY1Y1dzVG41dkprbDNFRDNSZWZ6UDRWVDhVNmxaWE4wbHRwTWNFZG5DbythS1BiNXJkeWUrUFN1djB6d3RwV2thUExxRWNaMUc0U010RzhrWnd6ZGdpbnJ6M3J6N1U3SjdHOE1OeTRlNzZ6cXZJalk4N2MrdnI2VUlHTTA3VHJyVkwyTzFzNFdrbWMvZEhRZTVQWVZOcm1reWFIcWt0bE5JSkpFVldKVVlCeU04ZTFkUjRUbGVDWk5OMFVKOXJtRysrdm1YY0lWSDhLZzljZnorbGJQanJ3NGRSMG1POHRRMGwxYUQ1cy9la1R2OVQzL09pNFdPWjhJK0xMN1I0emJQYlRYZGlEeXFLUzBXZlErbnRYYVNXV2dlTUUzUEF4bEErK1VhS1FmajMvQUZyeWl6dnJteG1XZTB1SklaRjZORzJEWFZXUGp6VVhBVy8xVXhvT3ZsMmF1eC9ISUZEUTdteEo4TDdCbkxSYWhjeGowS0sxVWRWK0dyVzFsSlBZM3JUeVJydU1jcUFiZ091Q0t2V2ZqZno1QmFhUFpYdW9YTDlYdUhBSDFPT2dINFZQNGs4WkpwT21tMGl1SXJqVkhUYTVpSHl4RTlmeTdDbHFHaDVnWExJRTNaVlNjRDB6U1VZNEdjWjlhS29rSzc3NFlhaUZrdnRQYitJQ1pCbjA0UDhBU3VCR053SkdSNlZ2YUt4MFRWOVAxYUlzOWs4bmx0Si9kend5TjZFWno3aWhqUjNYaWZRcmp4SHFWcGFMTDVGckdobW1sQXlTZWlqK2YwcUFmRFRSdGdEUzNwT09mM2c1L1N1cW5mQTJRbU5wMlVtSlc2UGpuRlk4SGllTy90bkZpa1p2NG0vZTJNNzdKT09vQlBCUHAyK2xUY29tMGp3dnBHaG56TE8zeE9SanpwRzNQajJQYjhLcDY3NHowL1NJbmpoSXU3MDhMRkh5QWY4QWFQOEFrMVN1dkd0dXNoakU4MWhjcjkrMnZiVWxmekhJck5uK0pEMjRJWFRyR1poMGRIWUQ5UURSWURpdFF1THE4dkpicThEbWFZN3lXR00vVDJxYlJkR3VOYzFHTzF0VlBQTHlkbzE3a21yRFJhdDRyMVo3bExhU2Q1VzVLakNLQjBHZWdGZW0rR05CazBTdzJ6dEVKWEh6SkN1Rlg4ZXJIM1A0VTJ5VWcxRFJyaUxURmkwaVJUNWNRak5yUDgwTXlnZFBWVDc1cnpIVE5YazhQK0lQdE1FYnhSb3hTU0JpU2R2ZFQ5UDZWNlpxR3V6ZUg3K05kU0htYWRjTnRpdXdPWWovQUhYQTZqMElybFBpRm84UzZoYWFyQ3lMQmVIWkpJT1ZEZG00OVIvS2toblRhMXBHaGFqWXJkVFdNcnBJZ2NUMnNmekFIbkp4L2dhOC93QlI4UFJyRTgyalg4ZW9XeVpMb3B4TEVQZFA2aXZRUEJjbHhiNkpKWTNpTjU5ayt6YXZPNUQ4eWtIdU1IaXFlcjZkb25pT2NpMnVvN0xXRVBESDkzSVQ2TXB4bjYwSmhZMHZCdXEvMnI0YnQzWnQwMFA3bVQxK1hvZnl4VzdYbkhndWU1MEx4VGM2UnFLZVcxd081NDNqa0VleEdhOUh5RHlLR05CUlJSU0dGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGWTNpelZoby9oKzVuVmdKWEhsUmY3ekRyK0hXdGs0QTkvU3ZLL2lEcmlhanFvc29XekRhZkx4ME1oKzkrWFNta0pzNVRra0t2SlBUM05kNzRkMGUwMDFvRTFRdGU2aVJ2aXNJdm1FSCswNDZBKzU2VnllZzZiZDZycTBWdnA1eEtQbU1uYU1mM2ovbnJYcHRtMmcrRDdNd05ld3JNZVpaR2JkSklmZkdUK0ZOc1NScmFqZWpUdEt1YnlWUURCQ1pNZGVjY0N2REpKV25sZVJpV2VSaXpFOVNUWHFIaXJWMDFEd1pleTI4TndJWkNpckxKSHM4ekxEN282bjhxODB2N1UyTjQxdVQ4NkFDVDJZakpINGRLRURQUVBCelduaHJ3aE5xMThRdjJoaWY5cGdPRlVmVTVOZFBvTTk1ZldYMjYrWHl6Y0RkRkFEeEduYlBxU09UWEFSS2ZFR3M2TG9neWJTemhReUFkQ2NibUovbFhhK0l0WWF3RnJwdGpnWDE2d2lpQTZSTDBML2dPbEpqUm42LzRCc05WbGE0czNGbmN0eXhVWlJ6OU8zNFZ3T3ErSEpkSmxlT2E5c1hkZjRVbU83OHNWN0Q1c05sR0lNL0pERDVqTVQ5MVIzUDE1L1dxRjFCWmFsb3NWeHExcERNWlFHQ3V2SUxINVFEMTdpaE1UUjQydHhOSEcwVWNyb2pmZVZISURmWDFxSUQ4NjZieHI0Wmk4UDNzTFd1NzdOY0E3Vkp6c1lkUm51T2E1cnBWQ0NpaWlnUWd4MzZWdWFMT3RpRDlwQm0waTgvY1hRWHJFZXg5bUI1Qjdpc1RGYWVrM0RhZTVubWg4L1RaejVGMG5VRWYwWWRRZmFnWjY0TlBhNzBTRzJtbUprRWE3TGhEOHdJKzY0UHIwTmVUZUlicTdtMUY0dFRoUVg4RGJIblFiVElCMEpIUThZd2E5TzhNK2JhV3AweVNVVFJRS0pMU2YvbnBBMzNmeEI0UDRWeS94TjBuWkxiYW1pNDMvdVpzZW81VS9sa1ZLR2NoYVJTYXBNc1Z4cU1jSlg3clhUdHQvUEJycU5JOEJYVXN5M0VHc1dXMUR5OElFdVA2Vkw0VThCdzMxbEhxR3FNNWlsK2FPQlRna2RpVDcrbGVnV3RwQll3TEJhd3h4Uko5MVVYQUZEWUpFV25XTDJGdjVVMTFQZE54bHBRb0g0QUFZcHVvdmVXOFJtc1lsbktETFFFNExqdnRQWnZyMXEzSUNVYnk4ZVpqNWQzVFB2VkRTdFpoMVV6UWJURmVXNUszRnU1K1pEL1VlaG9LSzZUNmY0dzBLYUdKaVVkU2pvd3c4TGRzanNRYTRLS2VkL0MrcTZCZjh5NmNSTENUMUFWc01QMXorTmJIaVZwZkNIaW1EV2JJRVcxNWtUeEwwWWo3dy9FY2ozckw4YmxMWFg0OVF0U0REcU5wbkk3NVhCL3BRaVdkYjRDMUQ3ZjRhaTM0TTFzZkpZOXlvKzduOERXanEybGFWNGdWb0xzUnlTeERobFlDV00rM2YrbGNSOFBkWnROSlMrVFVibExkWkFqUm1USURIbk9LNkxXTGJ3LzRxVlREcVVFZDZuRWM4TWdERDJQcUtHTTVQeFJwT3JhQzl0Sk5NOTFid09QczEyMzNvK2NoVzcvaFhvMmk2cEZyT2syOTdFUVBOWDVsSDhMZHgrZGNMYzNQaUx3M2J2YmF0RC9hZWx5Zkt4ZjUxWmZaeHlEOWFyZUQvRWR2b21xeVdwa2IreTdsc3FaT3NUZGlmNUg4NkhxSkhxV0tLRllGUVZPUVJrRWRLRHpTS0NpaWlnQXB3cHRPRkFDR20wNDAyZ0JhS0tLQU9lOFU2dGYyZG0wT2wyTnpQY1NqYUpVakpXTWV1ZTVyeXA5TTFCQ1RMWlhXVDF6QzMrRmU3TUN5RlFjWkhVZHE1TFc5SzhWcHViUzlaZWFNL3dETE50c2JqOGNZUDZVMHlXamdiYisycmF3ZTJ0WUxxQ0dRNWxaSXlyUDZaYjA5cWdzTlRsMGk0THhXMXE4d1BEVHhieXY2NHEzcVZsNGtrZkdwUWFqS0FlamJtSDZjVlZqak9uc0pOUTB0NUZKK1ZaaTZBL2xqTlVJNjd3OWY2MzR5MU9GTDExT20yOGl5U2hZd3FzeThxdjU5dmF1TjFTUXphcmVPeDVhZVEvOEFqeHIwWHducWVzYW9zWmdzTFBUOUxqNERxaHkvc296K3ByZ1BFTnFiTHhCZlFIQjJ6TXdLbkl3VGtmenBJYk9tK0djWSszNmhlU0VmdVlSbGoyQk9UL0twUEMxMC9pUDRnVDZqSm5iRWpOR3A2S3YzVi9RbXNUUmI4V1BoVFhBcllsbU1VSTljSGRuOUFhMVBoNUl0dEZyVjEzaHRnUitwL3BRd1JzZUlOUjNlSDcyVlR6cU40TFNMQi81WnFkdkg1TitkYUhpVzVFZW8rSDlPSEN5M2Fzd0hvZzRINS95cmtmRUU1Z3N2QzlvVDl5TmJoaDdzdy84QXIxcGVMTDNiOFJOSVUvZGhNZjhBNDgxSUN0OFQ3c3ZxVm5aanBGRVpEOVdPUDVDdUlGZFA4UkdKOFd5ais1R2cvU3VYelRRaFRTZldsNjQvcldycDMyZTI1azFOSUdQYUsyODEvd0F5TVV4R1lrY2ovY2pkdjkxU2ExdkQ5MmxqcUhrYWpFMzJDN0FoblYxS2pCNk45UWVjMTFOaGVaQUNhcjRsY2Y4QVRPekFYK1ZkQmF6RnlGazFDNmRPbXkrc1FBZnh3S1Z4MklmQ3lTYWJOZDZKY25mTFluZmJ5SCtPRituNjFjOFlXSXYvQUF2ZkovR3FlYXYxWG4rbFRYZHNWMVhUcjlCbGh1dDVOdkFLTU1qOG1BL09yVjNJcXFrVWdHTGhqQ00rcFUvNFVpaXZvRDU4TTZlLy9UcWgvd0RIYXNRM2YyalRVdWxVa05HSk1LTW5wbmdWbDZkYy93Qm0yZWgyRW5XVzNkVG50dFRJcGZCdHcxeDRWdEhKNVhjby9CalFCclEzTVZ4Ykpjd3lLMExMdVZ3ZUNQV3VMOGNSejZMcTFsNGlzRHRmY0lwY2NoL1RQcUNPS210TDQrR1BHTXVsM0IvNGwyb041c083cEd6ZFFQWW5JL0tvOVdKT25heDRldVNXYUNIN1ZaTVQxakJ6dC80RHlQcFFnWlk4WFN4YTk0Q1cvZ0dVVXBNUFVjNFlmcVIrRmNMZjNadXZEV2xJVDg5dEpMRU05ZHZERCtkYkhoKy9hVHdMcjFpeDVpakVxQStqSG45Uit0YzlwVnMrcDZsYVdDWi9mVEFFRHQweWZ5Rk5FbnBsbnBPbXplRHRNczlXVkZCZ0JWeWNNaFBQRGR1dGNENGs4SjNuaCtiY3krZlpzZjNjNC9rMk9ocnQvRk9zYXA0Y2VPU09HM3ZOSmxIbCtYS21DaHg5MGtkdlRpdVp1OWJraHRHdjlBdW5pc3kyeTRzSmdKRmhKNllCejhwb1F6bmJiVnRRc0FSYTMwOElQOEt1Y2ZsMHE5YWFScS9pT1lQRGFsODlaU2dqWDZrNEdhc2FkNHBlQng1T2k2WkxLeDZwYkhPZnpydXRKdVBFMnE3WHYwZzB5MUg4S1I1bFllZ3lUajhhR0pGL3czbzF4b1dtTGIzVjdMY3R4Z2Z3Uit5OTYyS2FCaFFQU2xxU3dvb29vQUtjS2JUaFFBaHB0T05Ob0FXaWlpZ0FGUTNmMm55R05vWUJML0Q1MmR2NlZOU1l6UUJ4T3FIeDArNFFyYnJHZTlxeTUvTmptdWZpOExlSjdtOEU4OWo1MDJjNzd1VU1QMU5lcjlldFZ0VG4reTZWZHpqckhBN0Q2aFRpbmNWanlHODF2WEw2NEZrOTlLNUQrVUVoWUtoT2NBREdPS3QrSm9OR3NiSzFzTE56THFOdmtYRXFjcXhQTEFudVFlbGM0a2trYjdsWmxjYzdoMXpUYW9ra0RrUnRIbjVXSUpIcVIwL25YUWVHWnZKMFB4R3ZjMllJL1BIOWE1c210RFNya1F3NmxHeDRuc3BFeDc4RWZ5b0F2K01KZitKeGJScjkyQ3poVUQvZ0lQOEFXazhYWC8ybnhGOXJqLzU1UXVwSHJ0Qi9uVkxYcHZPMWVSMVAvTE9OZnlSUldlenRKamNjNEFIUG9PQlFCMEhqVzRGOXJNVjZuM0xtMWlrSDVjL3FEWFBWTEpjUExERkc1eUlsS3I3REpPUDFOUmswQVQyY3R0RklIdXJaN2xWNklKTmdQMU9NL2xXL2ErT0pkT0FYVDlJMDIyWDJqTE4rZWMxekpOQm9zRnp0WS9paHFRUDcyeXRYSCt6dVgrdGErbi9FNnluWUMrdDU3Zkp3WFg5NHYrTmVaNXBwNjByQmM5L2pkSjRrbFFoa2NCa1BxT3hybi9GdDU5am0wVmM4dnFDSDhCeC9XdGJSVC94STdBdC96N1IveXJnL0dlcEM5OGFXRm5Hdzh1MWRBM3B2TEFuOGhpa2lpLzR4MVlXSGk3VEJrQkxXR1JteDZzQ1A2Q3Rqd0NoWHdkWmh2NGk3Yys3R3VIbHRwUEczak81K3o3aEFaT1pEMFNKZU0vVTQ0K3RlcVcxdkJwOXBGYndLSTRZbENxTTlCUXdSeC94TnNmTTA2enZsR0hnbDh2STY0WVovbVAxckkxL1VHdk5HMFRYRi93QmVGZTFuQS9pNHdRZnJ6K2RkajQwZ1c0OEpYK2VxS0hIMUJGZWJXODVsOEczOXV4NGd1NHBWOXR3S24rVkNFelBzTHcybHRmUktUdHVJUEwvOGVCL3BYUytDclZkTnVvTlJ2bGFKTDB0YldzL1pIOVNQZm9EWEg4OVFjVjB0cHFEM3ZnTy9zcFhKYXhram1oUGNBdGpBL0grZE1TTnJWOVlPbzZaY1IzYXFzaXViSzlRZEZjWk1jb0gxR1B4cmtmRGsva2VJTE1NcVBGSktzY2tiRElkU1FPUit0R3FhaTF4cU41S3A0dTFYZW8vdllVL3pGYk5scE9kVDhMVFJyajdXb1p6N294NS9JQ2dEMUdHMHRyY0h5SUlvcy8zRUMveXFYclFmUTBBVkpZVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJXYjRqVm04TmFrRjZtM2YrVmFOUjNVSDJxem5nSjRsalpEK0l4UUI0eHF0aWJIUzlJRGNTWEVUWERuNm5BSDVBZm5XVlhiL0VPd0tYbWpRUmpyQ0lGSTlRUUIvT3VZMTJ6WFQ5Y3U3UlB1UXliQitBRldpR1VLVUhCcEtLQkRwWkRKSVhQZkg4cWFLS1RGQUMwVVVVQUZGRkZBQUtEMEo5cUtrZ2RJN2lONWtMeHF3WmxCeGtEdFFCNjdxT3N4ZUdmQzFzOG0weitRaVF4OTJmYVAwSGV2S2JTMXZkYTFSWTROMHQxTTVZdG52bkpKUGFyc2t1cWVNTllHRk1zNzhLbzRTSmY2Q3ZUdkRmaHEyOFBXbUVLeTNVZy9lelk1YjJIb0tuWXJjbDhQNkJiK0h0T0Z2RUEwcmN6U2tjdTMrQTdVenhWY05aK0hMdTVqKy9Ec2tIMURxYTFETW1aUG01akdXOWhXRDQ3bUNlRDd3OGZQc1VmaXdvUXkzNGdsV2J3bHFFbys3SmFsaDlDdVJYa050TjVlbTMwWC9QVHl2MGJOZWk2cmVCUGhmRzdINXBiV09NZlU0RmVYazhZQjROTkNZbmFyTnJkZVJhWGNRYi9Yb0V4OUdCL3BWY0NsOGx6RVpRaFpBNFRJL3ZZemltU1g3clNqQm9lblh5Wkp1bmtRLzd5a1kvVCtWZXNXR2hyYlJhTnVBM1dFREorTEtNL3dCYXAyM2huZHAzaCszbVViTEVtYVZmN3pFY0Q4eitsZElhbHNwSUtLS0tSUVVVVVVBRkZGRkFCVGhUYWNLQUVOTnB4cHRBQzBVVVVBRkZGRkFCUlJSUUJoK0pkTiszUzZWT0Z5Ylc5Um0vM1NlZjF4WENlUE5QMmVNU1FNQzg4dGdmYzRVL3lyMWNqanRYSytPOUxOMVlXbW94cnVsc1pWWmdPdmxralA1VTB4TkhsazhMVzl4TEMrUThibFNEN0hGUm11bThlNmI5ZzhSdmNLUDNGNFBOVnNjWi9pSDU4L2pYTTV6VkVpMFVVVUNFTmJtaTZaWjNXaGF2ZTN1Ly9SVVh5OWg1M2s4RDhheERXM3BiaHRMaHNjLzhmT3BSZ2oxVlFQOEFHZ1kvVS9CMnBhWmF3VHplUzZ6bFZWVWI1dHpkRjI5elZPNThPYXZabEJjNmZOR1pIQ0lNZmVZOUFLOURta0dxZkVhTzNQOEFxTkxnTWdYc1pELyt2OUtmWXlIWFBHMXhjTVNiVFNWOG1NWjRNcCs4MzRkS1Z4MlBQaDRVMTF6eHBWeitLNHJUMDM0ZTZ2ZHpMOXNSTFMzejh6T3daaVBZRCt0ZWlXZXFMcUdzMzF0QWN3V1FDTTM5NlE5UitBSDYxb2tZNEZLNFdLT2o2Slk2RlppR3ppVkFSODdubG5QdWY2VmVIV3M3V0xveGkwdEUvd0JmZHpCQUIxQ2o1blA1RDlhMHV2STQ3VWlqQ04xL3hOTmZpSjRndFl6bi9nRFZ6Zmo3VU4zaGJTYmNuTDNLcEs0ejJWUDhUUStvK1phZU1iMVRuenBFdFl6Nm5sZjYxemZpTytUVk5iaWpELzZQYnBIYktlMkY0WS9ubXFTSmJOZnhkZG0zOE1hSHBQOEFHSUZta0hweHdQMU5jYmpGWDlhMU50WDFXYTY1RWJZU05mUkY0VVV1aWFMZDY3ZnBhMm93T3NraCs2aTl5ZjZDbWhGUmJhWnJTVzVFWjhtSXFyUDJ5ZWcrdGVnYUI0VVlXK2tSM01lQXJOZlRnOTJJQWpYK3RhMG5oaTIvNGxtbHhSa1dGbTMyaWNucksvUlFmVW5rbjZWMG82NS9LcGJHa0hTaWlrQXpTS0Zvb29vQUtLS0tBQ2lpaWdBcHdwdE9GQUNHbTA0MDJnQmFLS0tBQ2lpaWdBb29vb0FLYTZMSWpJNmhsWUZTRDNCNmluVVVBWW5pYnc5SHJtaEcxakFFOFB6VzVQWWdZeG4wTmNQQjRjZlcvQy9tV3NSajFYVDNhQ2FJOVpBT1J4L2V3Znh4WHFkVkZzSTR0Umt2WWZrZVZBc3dIUjhkQ2ZjZXROTVRSNFVReWtxNmtNRGdnakZGZW5lTXZCbzFKVzFIVEUyM2dHWklsNlMvL1pmenJ6RWdobVZnUVFjRUVZcWt5V2dxMXA5MTltdjdPUnZ1eFRySWZ6R2FxMGg0RkFqMHJ3NWNBZUx2RkZ5M0pUTEErd0ovd3BmQ3Q3L1puZ1MrMVJqbVo1SlpjbnUzUVZ5M2gzVTJFMnNOSzM3eTVzWlB4WUQvQVBYVndYbVBoV1loMUY0SXo5TTdxVFJWenB2aHhHMy9BQWo4MXc1M1BQY096TWVwNlYxcDQ1SkFBNUpOYzE4UFIveFNGdjhBOWRKUDUweng1ckwyT2tyWlcyZnRWOGZMVURxRjR5Zng2ZmpTNmo2QzZCTyt2K0lMN1dDTTJzSCtpMm1laEhWMkgxclU4UjZxdWo2SmRYVEVCd3UyUDNjOEQvSDhLazBUVEUwalJyV3lURzZKTXQ3c1JrL3Jtdk9QSHZpRWF2cVF0TFovOUV0U1JsZWp2M1A0ZFB6b0F6THE1TUhoYXpzZ3hNbHpNOTNMNjQrNm44aWF5TW5PN1BOT2VWNUNESTJTQUZIc0IwclMwSHcvZWVJYnZ5YlZkc1NrZVpNUjhxRCtwOXFva2owWFJidlhyMWJlMGo5M2tQM1l4NmsxN0JvbWkydWhhZWxyYkx4MWVROVpENm1uYVBvMXBvZGl0clpwaFJ5N0g3em4xSnE5VXRsSkJnWkpwYVNpa01LS0tLQUNpaWlnQW9vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQTF5SGpEd1lOVVY3M1RVQ1h3R1hqSEFtL3diK2RkZURtajYwYkJ1ZUFNclJ1VWtVcTZraGxZWUlOTk5lcitMdkIwZXVvMTNaS0V2MUhUdE1QUSsvditkZVdUUXkyOHpRM0NHT1ZEaGtZWUlOV21RME5qa2FKOTZFaHNFWjlqd2F0dzMyM1I3cXhKK1NTYU9WUHFNZy9vZjBxbjFvb0VlcS9EZVRkNFdBLzU1enVQendmNjFqVzgzL0NUZkVzU01kMXZaRTdSMklUcCtiR28vQWVxZlk5RTF4VDk2Q1B6MTUvMlNQNWdVendKY1I2VG8ycjZ6Y2NsQXNhZzlXYnJqOFNSVWxHNTQrOFROcGRwL1o5aytMdTRYNW1VOHhwNi9VODE1YU9CejE5YXNYdDdMcU43TGRYRGw1cFdMTWY2ZlN1aThKZURadGNkYnE4RHhXQVBYb1pmWWUzdlQyRVUvREhoUzY4UTNJYkpoc2tPSkpjZGY5bGZVMTYzcCtuMjJtV1NXdG5Fc2NTRGdkY24xUHFha2dnaXRZRWd0NDFqaWpHMVZVWUFGU0NrMlVrRkZGRklZVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCVGhUYWNLQUVOTnB4cHRBQzBVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBQ3ViOFcrRVl0ZWdOemJCWTlRUWNPZWtnL3VuK2hycEtQb2FOZ1BBcG9aTGFaNExoREhNaHc2TU1FR21acjFueGo0VWoxMkQ3VGFxRjFDTVpIL1RWUi9DZmYwTmVUTWpSdVVrVXE2a2hsSXdRYXBNaG90Mk4rMWw5cENnbGJpRm9YSHFEMy9BNHFXZlVHR2dXbW5JU0VFanp5NC9pWThMK1FINjFuMTAzZzd3d2RmdVRQYzVXeGhJM2Y5TkcvdWordE1DeDROOEdIVjJTOTFCQ3RrcCtWRHdaai9SZjUxNmdpTEdvU05RaUtBRlZSZ0FEdFFxckhHc2NZQ29vQVZWR0FCU2lwYkxTRm9vb3BBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGT0ZOcHdvQVEwMm5HbTBBTFJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFuc1JYQWZFTHcydXc2MVpKaHNnWENqdU9nZjhBb2E5QUZNbGhTYUo0WlFHaWRTcktSMUI3VTA3QTBlRzZUcGsrc2FwQlpXNE8rVThuKzZPNS9DdmJkUHNJTk1zSWJTMmpDUlJLRkh2Nm44NjVmd1Y0YmJScjdVNVplU3N4Z2hZaitBYzUvSEkvS3V3b2JFa0ZGRkZJWVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGT0ZOcHdvQVRGSmluNG94UUF5aW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMERGTFMwVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTklwMUxSUUIvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy90aC5qcGdcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTFFBQUFCVENBWUFBQUEyakMwSUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwQ05rTkJOa0pDT0ROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGTmtKRFJEZEdNak5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa0kyUTBFMlFrSTJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rSTJRMEUyUWtJM00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzBZMWxMUUFBSGY5SlJFRlVlTnJzblFsOFZOWFZ3TTk3Yi9ZdGU4aE9nRUJJU0lLQWlJQ3lxVmgzckh1clZkdGk3VmQvVlZ2MTkzMUZhMjIxN3JXZldqK3JyVm8zQk5GaXJidXlDc2dta0FBU0lHUlBTQ2JiSkpuSmJPKzk3NTQ3azBuZU1wTUVnM1hpdTNCK00zbHo1NzdsL3UrNTU1eTdEQ091WFFBbk1TVVFtVXZrVkNMVGlFd2drazBra1lnTnREU1dVeStSTGlKTlJJNFJPVUJrRjVGdFJGeWpkUkxtT3Fma2J4MklvMzRqT1VTdUl2SjlJbk9JY0ZyZGZpZVRMU3pJdzJtRGp2TkV0aE41bThpYlJPcEc4NlE2R0QyaVVkWGZTZVE4RFdJdHhVakl4cnl3UEV6a0F5S1BFZGs0R29Xem8xREdJaUtid2hkMG9RYXpsa1lJTnpLekljelFvcSt0b2NVVFY5Q1pnZ2lQc1F6OFlLaU1kYzRnN0RubWg4Tk5BYWhyNDZHeFBRaGRiZ0U4UGxHcjBqR1lMRVlHRXEwc1pLZm9JQytWZ3lsWmVwZ3gwUUI1YWJwWVh6dVR5SHJDMU91RXFUdkkrK1lUc3FtRnQ4OFk4WmQ0QWE3a1dIZ3U3UFNwcHFyalFmajN6ajVZWCtHRjQxMjhWc3RhZ294RURoYVhtdUNDVTgxUWtCa1RiaGRoN0NiQzJPb2hUWXpyMjBjRzlIMUhuNDI4djdmZ1pnTnBRWDhpTGVnWGFubFIyMityOU1HTG4vVkNSVzBnY3R4Z1RvQ1VyRkpJVEM4RWEySTJXT3pqNkRGT1p3U1cwMnMxUFlhU3dBZUFEL3JBMytjQ1QwOEx1THNhb2F1MUV0cWJLdWl4L2xRNlhnODNMTEhCdktsR1lKZ29aWW53RjhMYXI0MVhiZmYxSC9PdG1qTUUwRy9GQnZwM1lhQi9WM0N6blFDN2xweDhpVnErUTQwQmVHeHROK3l2QzRHc045a2hlL0ppeUp5MEFCTFNKdUdwdE5yK1RpY1JYTTRxYUs3YUJJMUgxa1BBMjBPUGx1VHA0WTVsRHBpYXJhN1lDSE9iQ1hQTGpGZHY3NkJBdnlFRCtnWUYwUE5qWHNhOVI1NkYreWJmbkVZSy9wQVVQRlArdVQ4b3dqTWY5TUxxTFI1c1VXQzBKRUYrNlRMSUxWcEtOTEJKcTBjdEtVMVdvc0ViRDM4R3gvYStCVDVQQnhBdERKZlBzOEF0NTl2QW9HUFVvQzRuN0oxdHZIcUgwL2ZHYVRLZ082UkE4ME1BalhZeUFYVURPZWtwOGcvcWlZTjM5MnRkY0tRcENBekx3ZmlTaTJEU2pLdUEwMnNnYTJrWVlBZThVTFZuRmRUdWZ4ZEVnWWZKV1RxNC80ZUprSnZLcVprZit3aURDMEUyS01NcGdGNHpMOVk1RGNRNC80Z1k1NHB3Q3BvV2Q3emtnbTZQQUphRVRDaGJjZ2ZZVXlacXRhU2xFYWVlOW1xb1dQOEVzYmZyd1dGaDRiRWJFcWdwb2hLTTJFQllQQmNOZ3dqUU4zWks4bkQzWHBrYks1cnhOQ25nY3ZueGJaVit1SlBBN1BhSmtEYitOSmh4N2oxZ3NxVnJOYU9sRTBvR2N5SmtFWC9MM2RVQW5XME44TWxlSDB3aE5yVmNVeE1OblUrWVRDT3Y3L1VmKy8wN1hta2VHcHBRa1Q2ZmNEWEhpRGZMangrbzg4T0tWMTNnRFlpUVBYVXBsSjExRitqMEZxMVd0UFMxRXBxcFpXZmRTWmxDdHBBeFpFM09IekpKMkx3bWNreVdHUDdOdVlxREhXNHhOOG5DVkJCRFhCSm5ibWpuWWZrelhlQWlaa2JPMUhPaGNONU5XazFvYWRSVDVkYm5vT0hRUjhUOFlPRDVueWNwTkRYaDJOWGxFY3VTckV3ZDkrTXVhY1A0N1JVNWtnTzZuN2lZKzVhWlhpR21SdG5nNDRHZ0NMZS8xQU5OblFLazVzMkdvak52QVMwVXA2V1RrWkp6WmtCdlJ3MTB0amRCZVcwUXpwOWhBRlk2U2NORXpJNEM0M0xYRy9Mdkt1Wnl0RC90T051Z2c0dmt4NS81MEVPakdkYUViQ2hlY0dzc2EwVVRUYjZXSUZ2SUdMS0d6Q0Y3Q3J1Yk1Ocnh0R09wQ3RCWVFraUlkbWJOZXZqRDRHTW9sWTBCZUd1N2w0Ym1paGJjQml4bkpDY1dOZEhrcEFreWhxd2hjOGdlTWlqbjBxU0grK1JLbVIyY3ArNHgrMWtHRHVZTVBpWUtBSS8veXdNQ2VjMHV1Z0NzaWVNMUxhTEpOeUxJV2s3UmhaUzlQNzNyb1N3T1poTlpyWDdFZHJiRVpCYkRucUorZVEvcitvdnRUcm5qdUsweUFBY2JnbUF3SjBGZTZXVWdpdG9NT1MxOWN5bTM5UHZRY213VEhLanZwT0hpdVlYUytIU3lsYzdNK3hUSFhpUTI5SWUvc3VTWTlZeGluc1lybTBKeHZ0eVNTN1doYkMxOTgrRTh3bHhlNmZmcCs1YzNlUldmSTdQSWJrUkQ5OGZ5aWpPWkh6RWdjb01Yc0ZTMThMQy9qbWhub3gzR1RWcWthV2N0L1VkUytzU0ZVTGR2TlJ5bzY0R2p6VUVveUJnSTR6R0VlV1NYdkwyZmFtaEVWSDlUcjk1aFppNFJaV2IzUi91SUljNHdrRHJoVEdLY0d6UzdUcFAvaUNCN3lDQ3lpRXpLT1VWMkVlUElTT0dqVnhqU3pUcHhwcnlrVHl0Q1ErWnA0OC9RUEc5Ti9xT1NPajQwaVc3ZC9vQ0NlR1FYR1E2WkhJVHhKVlBaQlF3alNzSWYxYTBDdEhXTG9EYzV3SkkwL2p0bGJwUVdEUXlRZWp4QnFLcDFLL0xZckRxWWtHZVZISE8yZWVHNDA2ZlpDQ2NoV1pQeWFXREMyZDBKOWUwODVLWU00RW9VTjRzTWs3Y3JkWWFmZWJpamZ6VFBraS8rcnFnTExadHlwRThqTUkrTkVjRUx6czZFc3hkbVM0NjkrUG9SS1AvS05XaFlWWVFicjVrODBMRHJ1dUhKNXlzVm82S25UaytDaTc4M1huTHM3NjlWUW5PcmQ5Z2pxTGN1TDVRKzg0T2RzRzVMNjRqdmE3VEsrWFluaHJCWURHMjFXMkJ2TlFFNldUb21tR0JtWnBPWDFiaXdTMi9TaTlQayt2ZHdNMCtyeFpaY0FHTkJONHVpQUlJUVZCd1BDZ0g0SlFHQ0daUnZjTXBNdDhBdmYwbytENjhUZXZmakJqaFMwd09UOHFYYXViT3JEM2J1T3c0R2d4bFlabWlnSitTWklEL1BMam0yZFdjekNPVDhES05jakY4MnFOZHdEK28xZUhKUDhuSU9WM1ZHeWxreVB4MHM1Z0VuYXNNMkovUzZnM0dxcFNkQ093SDZhQXVQdzREU3NYQzlXSVFzNDFHRFVjZmt5YW10YXd0VnJOR1dDYUlRbjBpWEZTZEFYclkxRENvUEUyVVFoclIyRG1SbDJLT1dZVElSMDJLOFl5Qk1aQlFoTFltRmFWTlRwZVpHZXpkY2ZFNFdlYUltOUdKQ3o3RFJEZVVIMVRZSkVpRTVRUWx0d1FRcnBDYWJDSWdEQVBiMUJlSFR6UzJ3ZVA0NHlYWGN1bUlIMVZwK3Z6S1VGUWg2SVJnTUFzZHlzR0R1T0VoTU1FWStlK2ZEZW1EWitOeHB3bWpMb0svMXlLWU1TY293SFJFblZCdFlNVTJlb2RVVkJ0cWFIcGYyTTE1emJwWUp6bG1VSFROZlZvWmpST1ZtWnhwZzhrUmx3NWd5YVJ5Vndlbmo5WFd3ZDM5blJMdjNKOVNxeVluS1ZjK256VlJlYTNXdEN6NGc1ZFEyZEVpQUxpbTBRc1VoTndRQ2ZzVjNjS0dxd0FmQmFtRWtNQit0YmdOL3dBZEdnd25pY1dLWjBScDZ2czJkZ21McXFJR0Y5SDROcmVNNDBTNUh0cnN2WkcxenhnU0lSMytRRjNpaXBmeWpYdTU1WnhjTU95K2VINitEWTNVeTRBUW9MRWdlVmhsb0pubDlmWERrV0Fzc21wOGZPVDUzZGhyVjVCV1Z2U3I2WDZUck94ZlBTNWMxRGljRUNld0cwUnlmZ3l5RVJXU1NXSGYwSGlXZmNZQmFScWVqZ3pFTW1PUWF1czhmYXNQOUU1SGlEbWlpb1hoK2VFQ3ZYcnNGbGl3b0pkMjlWRnYvL3RFM0pYOFhGZWJDRlJlZlBvSnI4TlByWUFlWkVFOC9OR2RFOXlHUUJzRVRDTC80c2dHV1h6ZnczWktpZENwUC82MUh6YUtCdno2bTNJU3p4ZGtkbXA4VHB4RXJaQkdaOVBwQllYSVFoczJVWllqTXVJdmVkY2RqRWdRQmV0eGVPSFNrTVRURGlxVFUxQVFGdEhVTlRsajE3aDQ0L2RRcEFES2x1V0Y3UGFRbDIyRFZjN0VYTWh3NlhLL2lsTFAwL0hnZC9jK1FGNkk3WTd2M0hvV3FtdVBTSWtnWlBoOUh6WU5ldHdqMWpXMlFteTIxM1lNcWpWYnUyUGFuTHl0YVNabTJNUktDVmIwSDJoY3lzVzR3ZnUrZGdiYy9PQUl2ck5wTTdFWXZ2ZjliYmpnRHJsd21YZVgreXVxdE1MdHNFdVRscENsS1dMZm1WekhQNE9uendiOC8yZ1ZQdmJSWllTY2I5Q1pJZEdSQUVwSCtaK2p6OVVVdDYvM1B5dUd6cmRXU2N0Q3BzMXRUSU5FK2pqcWI2ellmZ2d1V2xra2FaU0RnVXpHM2dsQjV0RGtFdGhnYVQvdGs0MEdvYi9aQ2tqMEJ4Z0xQVVpobGRORmhqMjhOalVBYjlHYXdXWktwM1lpMktNc3FWeEl2bWw4TVgreHFISGFwYUo3OCtZWDFJWFZBVEFrRUY4L0JrYzd1bE9KMGNOaENUaGhHRW54K1BkVFVpNUZuaU5kUmVRUkRjMUpON1d6cmdhMjduUVMyY2RJSUJJSGJhTENRc3ZXMGpEZmZPd3gvWDdXRm1qRm9RNXFOZGpBWmJYRG5MVW9OL1YvL3N6clVrT2wxTW1BeEp4QkhOSnRxL1RHaG9hUGNnaTdhcC8yYUltN3RMVkp4RnFPRFFvMFZqQTRheHhrVStlYlBtUXhmN0c0YWZqTWg1VjY0ZURwOVpZZys4UHBZT0ZyanA0N2ZpdHZQQXJOcHdBSGMvNVVUbm56K2tPUVozdnJidGVEdWMwa2Fub2xBaTlyY2FrbVUyTnRZQjNnZTFOVG5uWk1GWlNVemlmVVVESmNuaHVMVktqSHZSZk9uUW1sUjdrQzkwbkk0VXJZT0h2M0xnYmdHZXFBSEU2TURIZXNHaFRqVzBMaHZuaUc4ZHg3TGVNRm1OVWVOSkF3bm9ZbkJFY2ZrTjdkTFY2amQrL0JPQWlNcmdSblR3VW9ualhMMHg2V3hoN2p1c3ROSVBtYlFWWWF1VThlWnFDYVdoOU04ZlVINFlGMGptTTA2bUR3eGRWalhtVUxzZmhUVnlBdlB4MjBjZWppV2crNUV2eGlQRDJEVzlCelZ6ekRHKytZNzJ3bllzYU1paDQrMXdSZDdPdUc4czBzSmxBUG15NXlaeWFUaEszZFkzYmI3R0RFUFRBUWdYZGdtMXNPY1dST2dZRUx5c0srN3Fyb0wvdlZ4TlNsbmRPYUlvQm1DWnN4WVRicWhQTCt4TWljcE84TUV5VW5LQVJFRU9UY3JFYTY0WkhqaHRJZWYvQVIyNzYyR00wNmZFam0yK013OGFHanNra1ZQMnFDNnZoc1M3T2JJTXd4RlBJU1JSV3VJdlkyREo3d3dPc1BWQVdKNkdjYkNQaXBpVEpORHJjTWVTeHBhaE5MaWxDaGExd2w2M2ZBckdNMkdQUlYxRXFCUlcwK2VKSTJTSERqVVNDTVRhQk1QT0lWK3VvZmJpSzRjQjRoNHYyb2x2ZkhQemZERTM5WkgvZTVMVDl3SVJWTnlGVDFWWE52UVF5aGFIUXdSNWhnTFFPUGdSTkhrSk5YUE9OYWdDTGtOMVRqZVcxY05QN25XQnhhek1XcXV2ZnViaUYwY0tydi9HYUtHcnE1RHV6cTBnamt0SlFGU1U2Ung4YmIyYm5DMnV5TFZWOWZRRmRMc3FvNnZEc3pFOFZXN2ZqbzVDUmpWK2h6RGNlZ1lKa2NreWhIL3Q0NWhyaW1UMHFKb1hOMkk3aEh6Nm5WbTJMWG5HQ3lZVnhRMTMrYzdXeURSa1NtYmVzdkFFODl2aHg1M080WDZ0cDhzaEtzdmxlN1AvZW1tY3ZqejN6ZUduRVZ5YlJpSFJsRnRqTVJCVFVuTVVZM2UrQU45RVdkVWZ2MXhYYWY5alZjY2NaU0RpV2lWZUUrRmt5eGdOdXVIM2RvM2ZGNEI2ejgvUU4vZjk5OVhLOEpHT3AyUmFPREdxRUR2M251TWFHY2pEWlZKbng4TFJtSy9pcFpRR0pGbGRLcGExMnBLcERDemJDZy9yUXVWT2xvMHZ4Q21UOHRYblc2S1RtcE9wbDNGaEJIR1JKMUdZMVkzdEswUzd5cGFoTExpNUJINUZpVkY0eUVqUFNsS3AwWWVHakZUM2x0WEF6KzlUdDNzT0ZiYlJxRm5RRHFJZ2JGcWl6a0pURVk3Y2M1OHFwb1ZqeVhZTXlMbVNxZ0hVVGM1VXBLdFZFWUt3bGl3b1U4Z3lqRTJUQTdVUmxPbnBJN0lGRU83Vm03YkRtNEE2QmlpSTdselR4VXNuRmVzeVBQWjVtb0NyNVUrUStuelkySGxYNzhYODNvdnUyZ21sZjUwdExvTDduNXcyNmdHQjhhR0NSMURRNHN4bkVKQmlPKzd0MXJFcVBaemJIYzR1b1pqZ0FNOVo0SzlGUTBLb05HcHEybm9nd1NiUS9Ic2hCTUl2WVdpSEx4cUJWSUhzaTM2cnd5UHowdFg5Q0E0VUJidmRScUwyYWh6T2VKOTZMcy9uVG85K1FSYWVteHpXNlNtZ1I2Mjdqb090LzVNK3ZHTzNWVTBYTWNNQ3RmMUoxK2diK1E5akJnazlyWlB0Zm8rMmJBUEhuOSt2WG8wZy94NzVYOXZnS0xDUEJVTlBRYUd2c1VSbXh4am9WY1NZRUtlWThUZk8xaFpCL3YyMTlEMzExeTJRRDNDUU15TzdsNGxTQ1hGZWNSK3JxRU9uYkszNDAvb0hxSjlEKzFySzdISldWYnBDdUdxRmJVb3h4aXEzQmhSampGcWNzeVprUVJubkQ1K3hONXlxOU1GaDQ2MHFLb0J1aHFFUEJPYy9EU3JORlB4ZVY1T0N1VG5PS0M1UlZSOEg3ODMvNkxId2VNTm1RbDMzWHdXYVRBTEpYbFd2clVSSG5uMnM0Z1RhYk9rRWtsUnJVQ1dPS2NPS3pxUXlnZ09odTBZWUZYcjh6dHBja0NjUnpud3VpZU10NEhaYkJqeGR4ZWRVVW9sbW1hZ2tRTHlkbFpacG1xV2hYT3pZT1UvNnhVK09UWUNnOTRhN3ZZRnlXTFlnUzZWQTVQQlRrTnhPSWtJWTk1TUZFMTd4U1d6cUh5WG9oeERPVDlSVFk2aGhoaS8vZEVObmtoQWNxeTJ2aFhHNTZaL1BhY3cvRXh3SkM0L1QvMlhvV2Vka2dtdnJxbFZ6R3JER1hVTzZ6Z1F6RHpkUG9GampTcW1qQkVTSFRtZ3c3bmJUR2drTTNZZk92SWJpR2VlbWVHWkhMSERYdkdZZ254UUVsVm9hM2ZCMXUxZktZRStBYWN3Tk1tSWg4TEo2ci84bFp1ZENIWXJRSTliL3V6WXlMd1Jqamg2MFRTMFVXZWxjZXpJdlpDOG8wV2hNRllHVm1Da1RtR2NSemx3Uk96ampVZWcvT0FScXFsM2xUZkI5VmZPSGY2VGlXRzc0VE1wbmVvQVN3eHpac21aR2JEMmcrT3h1LzZvUFlEVUxJaVc5K0FoM0NhaE91bzVsaTQrQlZKVEVsU3ZQejRybGFkYzZsZ2xzOFF0Q0VhQURncWlsMlNTYlA1czFvdlFGMkNJdDB3MENXZU14L2dPSEt2elFIbGxPNTE2aVYyNHcyNGIxbGRmWDdNUkhucm1FL3ErZk4zOXFsRFBLSlVPMW5nOFByQllCcDVUU1ZFcXZQMStVMVQ3Vnh6S3JCbEdYb3pFUFBiY3BxaVRrRTRwbmFBQ05NVHRUbGhpZUU2NDJhQzhpNkFBM2dqUS9nQjRkQVlwMEE3eWw1ZVlvRUtnbTlpQ3FYRjQrK2lBMldCUldRYmNlTTBNYW4zbDVpUU95MXZHYm4veDZVVnc4L1VMRlo5Tm1aUUNsMTgwSGFZVVNKL0oydmUvZ0I5Y1BwQi9SbGtPUEh5UEdWNWJjeGpLditvYXRyTjl3ZElTWW10YjZMVFREVnVib2FiQkhUVXZReHFwMVp3UzJmZGpkdGs0U0hDWXdxWkZFTkpURThlVVV5Z0UzYlRwV2czS1Zoa01BZ2I1Ulh3U290c1BIVVFqUzBZZzBtd0N0UFp3d0h2YmdUSEVIOUNvR1hVNkV5UWxKQkJiZDl6SW1nSnh4TkpUeGtGUllZNEtFSUlDWmt6dmZib2Y1czhwa3Rqb1V3cFN3R2J0bjgvQktEUmxUNjl5RlFxYU1aZGVPSlcrUDN5c0U2cnJlME4xSjZwZEp3S2RTdWQ5NERtV1h6ZGY5ZG9HL0lqdXVCNzY1cjF0OURYVktpZ2FwZHZQWUN5VWJxRXJkSHZGRnZrdkRHVW5oUndIdnE4bFR2Y1VEdGxaOGtpSFBOWFdkeWtlVHJURnAvMmFUdzJVd3pWdUtEOVFwM1JPaVVPSEVSZTFhenhZR1h1SFVOeW9adkMrSGtxUG42VURQQmdKWVZWR0p1V3BwczRaMldnbUhvWHZDejJ2RUp0U1hudDhJam9zQW1wb3ZxV2JxWjZZTEVvMnJKaVlFZ2JhVXhmWG04M0VXaWU0OHEzUENZZ3V5TXRKa0t2aDBFaWJMT0VpMllhbWRza3huSXovMUhPZmdKR1lOMnZlcllDNXN5ZEw3Rlk4UDE2SFl1U1FQTktkNWEzdzJGUHZ3dm5ubEVrRFUvUS9CNTJ1N2toajZPbjFrZ1pRSDlrMGgyNWtRNDcxVnpaZERTTkdueXVDTnY2cmIrNk1hMGVmOXpUUTEwbXB5czBhQ2NNMStMZ1pzQmVsL0htWjc2YnJad2YvT0RoRFhRY0x0NjJ4QWFPemdhVjRCY1RqNW42b1RkMTk3ZUJ5TjRQZkg5cCt0blJLT2t6TVM0VWQrK3JCMVlNamNXazBYN2VuaGViQmVSZ1dZcGVPUzdaQXlWU2JaSEhxN29vVzZIQUpkSGZQUUxBdnRQY2ZUZ2sxSlZIeEJ6elE2Mm1EQU8rbGpjSmdzRUtDTlpQYXVmTGhhWnl2N1BXNW9OdmRBajUvcjJLdElhNzd3MUZBTEJmellybTlmYzVRQ0ErZEg1MFJiT1kwT3BLSWM2LzlBVGNVVDhiOU40STBwQ2hQdXl1YW9jZGpvWEZ3SEt5SngwQ2Q1NnNIUVNRKzNkTlg5VUpXZ3ZSNS9XT243amUzclRVK2gwODU4T291L2E0ZnpRb0t6S0N4MGp5aTFsTXNJblI0ZWtuTGFBVFduQjJYc1Vyc2pnMDZhMmkvQzNMZ2NJMEhLcXZyNk9RaXN6R0JWaTVxdC80OG1COEJRWEEvMmxSSDRlM1huTGpIQndyQzJiL2xBT1kxR3hOSk9WYnFUT0krZEZ3dzVMWFFyUW53dDJsVXRDSVRqa2xiVE1tZ1k0MktWZU5ZYm1pK05OMWhrSlpsTmlRQ3J3djFIR2hxNERHSXpMbG1TU04xMGthaVhJRWV1bmFMeVU0WEVNU2poaGI2R2dtcDNkUit6bkpJTlRSMnFDdjM2SFloeXdpMGYxY0RlL3g0RDFSbE9zVEpnd3M1bzhBUC95bzNBdCs1QnhoVFZoeTJhb1pDWXlkYVNhVHI4a1NxdlZBYmh1WTBoN1lZWUJrOXNGWWR6Uk1hY3RhRjgrZ2lxNjJwazRtMktuNEdBczJMck5GR3dCa29LUGlldGVoRE95UFJIN3RoS2F5aGVkR2lxbE9IalFITkZibUdabWpqb2p1MVVmZ3hEMTV2Zno1Nm5lU2MvWXNJOE53bW80TTJCSG5raGw0N3VVWTlaMWFkQlJnWDVrYlhYdm82ZjFKQTRTRWY3MkdxdHRkeWFFUDdxWVltMHJ1bmtkMldZUTlLZ0Y3UUQzVFhIdURTenlFMW9JKy80QjJCd2pDb3V3K3QvaEFwQ1AxVEVSRThnOHdrd0VxbkdsSWN0UHZRb08rb1IxWTQ5ZTVjakQ1NFRSc0NGMzE3bEg3NGFNT0xzc0NJenRIR2JjbElMNkhuTE1xUXlLQnJqMHY3bVRqMmZPZVhFU2JsOTdDbmtjTVZFTDFVUTNmOHZvZFAvcTNkL2N3V3c0Zm5UZ2xleXc0eU8vS1RlQ2djRjRUS0ZnOEVTWUZzMGh5SS84UU9ERENJc2JVNzZkaGxVSDdiUTE1c1ZOdnIyMy90TVhnbTdJbThoN0tJVEE1dXJ6aDVFTm5GeUIwcWNsMzQwNzR0TmR5eDJrNW0vNFJrWWJETERaZE45OEtESDl0QWFGc1BqT01VOHN3TW9DVXRmWE0wKzBQc2hWbVU5ejYxbmV4K1pCY1pEalhwME9lWXMvMzFML1ZyNWI5cU9DTW5BQVZweENZTTl0Q0N0YVNsYjVUbjl2V1VQV1FRV1pUelNaa2w3SVlaeGwrU0ZhSDlQaGZhMGE3SE54azNON2lZS2hFRy91RzNmanJQUTJ3NFluOTFiUVBSMjZUOUVLUW0zNHdnYTUzYktIdklJSUFvK1llc0lyUElidGdYREd2b2tKWkdvN3JsbGQyR05mSldNREU1Q09kTzlkTFpUa0xUYWpwSlJQdkpYazFPcWhER2hPYlZsRGxrRHhtVWMvbmFsL28xeUd5WTNYNHZJa0kwUnV5ZGoyNDBicWgwc3Z2azM3NzJWRGRNd0VJRDdTQWV4M0o0VUp4QkUwMUdSZmdRWS81MnloeXlKOCtEakQ2OHdiUUJtUTJ6Q3hJTjNYNXZGd1k0dTRrMDNmbWUrVVVmemw0YVZJYWVHQ2UzTGV3Qm0wRUV4bDBKMFBxK3BrVTBPU21DYkNGanlCb3loK3dOWmhIWlJFYVIxVEN6a1NBK2Q5ZlNnVG5DajJ3MG85b1Y2cnRZSnNFa3d1emM0TXpCQnJyTktNQzB6QUJzcVRZQzM5ZEVqWFhSVWhDWHcrSmErbGE2Z01BNC93MU05eTR3NmtSWXNkUUZlVW5LK1NsLzNXNTYrZVhkeG5YazdiRXcwS0lxMEhjdDhvb0VhalN1bWZWVitwNEZFNFBaT1FtQ1pHT0haSXNBK2FRYjJGRm5CTUhiVExxRkZoRE5reU0vMTZJbExaMW9lSTV0ZlF1WTNuTFFjeUxjdnFnYnBtVW9KNGg5VWFmYnN2d3Q2eXZrN2VHdy9Td2hucnZySE9uZWFBUm9WTjg0UlkxOTc1Q2hlVm14cnlUUkpKMHJuZW5nb1RBOUNMdnJqUkRBK2RMdWd5Q2E4a0RrYkZyRmFHbkVpU0ZLa1QzK0tqRGVXckFTTStQT0pTNG95MUxPa3F6cllvOWQvQS9Iazc0Z2N3ai83QS9WeFJ4YWF2dHRoeGdlZGFsM2VabWpQM3pEL25TYm0yMlc1NXVXNFljSHp1K2cycG9KZEFEWDlEZGdPMGt2SUFhMUd0TFM4QkpoQlpuaG1wNG5ERGtwUzhnVXNxWGdrakQ0ZzVYMnA1QkpaQk1aRGJNcWJSek9SOVJYTHFmOUlRVW5idUJTaitLU2pPRDBWZGYwM0padUV4UXpsQUk4QXl2MzJPSERTa3ZJcU9mc0lEam1nbUFuNWplajF5cE5TeW9nQjREdDNRZXNhd3N3ZkRkZFM3RjBpZ2QrT0xPSG1odHFNRi94dXYySi9jZDE1ZVJQM09lNHhYbFBleURNNmZDQURtZkdxV0lJY1ZGdW9sRDQ5clhkdjhoUDRpZXA1YTN1ME1PTE94eHd0QzBFc2NoYVFMQ1dBazlFTkdScWxhZ2xZbG8wQStldUFKWUlJM2pvc1lMVUFOeDRXamRNU0ZaZldWVGZ4VlpmdGRMeHpKRTI3aXZ5NTBHTWJCQ1lmWU1ZbFFPZEZ2TWkwdjZRaXBOdWNUSjBJYkdsSjc1OFZmZlZjL01DODFVYkhwRzlqVVo0Wjc4TkRqc0g1bnlJbkJWRVl6NEl4bXdROVNrZzZwSW84TUFZeHZiK2E5OUo3WXR6bGYwVVdDYllTVXlKZG1COWpjRDRhb2cyZGtleVRVbnp3eVVsdlhCS3RpOXFqR3hiblg3cmoxWTVWblo1R1l4bVZCSnBkTjdUNXBYeEtRUDY0YlFocnpIdGZnbzFxbG1jWHBwMzl4TDNtVCtmNDczU3dJbW1hTitwNzlMQnhpb0w3S2cza1M2RDB5cGFTNUJpNFdGT25oY1dUT3FEdk1Ub2F6MzlQSGovYjd0NTlmM3JySnZEOWpKR05KcWRkN2Q1VmRnY09kRGhMNkw1Z1prbkVzbWZuaGtjLy9qNXZaZVMxeGxEZmJlNVd3ZGZ0UnFnaHBnbHgzczRjUGJxb05mUGdEZklBaTlvRlQyV0VrYzZYSk5Pb0lNaXFUWWVNdTFCNHV3Rm9DamRENW1Pb1FNRys1cDFlMy85dnUxdDhscEwvcXlCVUt6WlNXRDJSZUZTQnZSRHc5K2lJTzJCTkRTUWNiTUgvSzJ3Q1VUU2w4L3VLL241bkw3emN4UDRmSzA2dFhTaXFkN0YxVHk3dy96QmN6dk1GZVJQWE41ZEhkYk9YYzRWemtBTUpxVkF0ejQwc2owMzBoOUlRNlBYR282QTVJV2R4c1FmbjlwWC9PTlpmWXNtcC9KVEdXM29VRXZETWJmSmYrTHNIWHBodDNuREM3dk02UERoamp3NG5JMHhaaHcwY2JldWNBcEQ4UGoxZ0E0WGdzQ2l0c2IxK2hsaHB4Rkxkc3pPQ1dUY09LdHZ4dWw1Z1pKc2g1RExSRjFHb2FYdktNUkNZemRiLzBXZGZ2K0x1ODE3ZGpib2NTMGdEbC9qSktOR0l2ZzNuUTVLWUJhSHdhSWM2SlFUdnJqMEI5SVJWbU1ZN0xRdzNGZ2cvcDZZT1NlQnR5OHI5azJZbVJYSXlVL2lNMUlzUXJKRkwxcE5PakRyT2RIQU1xQjVpMk13Q1NMd0FaN3hlNFBRNXdrdzduWVAyMUhUeVIzL3NrbmZzUGFnc2JyQnhmVkFhSVVKdnJhSElYYUdRZmExcm1nVlJzQ2dET2dIVTc3MkRhVC9NUUsyTFd4alk2SDQwNjM0ZXhDNGF0UVExdWc0NFlNTkN3T2FhVEtHRlRFVklTem9EYUlkN0ErRGpCcTVNd3d6bWhtOUZPVGZ0QW9ud0o0VWFMQVhqZWFOTUdGb01aeG5DWXN0TEpid2NUbllXaHFEU2xvR01vYmJQR0Z3ZThQdlBlSGpRUmpGRFZGMUo2RmxCc0tDM1FrWEJsalQwSnFHN3RmUStNcWZyQlAvdndBREFDRURJeURMT01YckFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZ1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUJUQ0FZQUFBQTJqQzBJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBDTmtOQk5rSkNORE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcENOa05CTmtKQ05UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rSTJRMEUyUWtJeU0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tJMlEwRTJRa0l6TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrK0xwenFRQUFFdkZKUkVGVWVOcnNuUXQwVlBXZHgzLzN6cjJUbWNsa2twQk1TQWdKNFNsSVZKNmlJRWl0cGFmcVZtcDliWFZkcGJVOUh0MnVhN1ZuejRyYjQ2dGRGVzI3cTJ5cloyVVBYY1Yzc2NwS1d4Y0JEeUNVcDRBbElBVHlKcFBIUERMUCs5cmY3ODVOeU54NVpjS2swUEQvY243TVpPWi83OXprZnU3di9uNi8vMy8rZjA1YnZ3UkdVTVZvVjZMTlE1dUpOaEd0R3EwRXpRbE1vMWw5YUY2ME5yUVRhSWZSZHFQdFFQUGw2ME80di9Nay9DeUFsdmRmWkR6YWJXZzNvUzFBczdCemUwSEthUmp4Y1BtZzF4VzBuV2p2b2IyTjFwVFBEeFVnZjBTVHEzOEU3UnNNWXFZTUlqWVdHdllNMmtkb3E5QzI1R1BuZkI3MnNSUnRxM0ZBTnpDWW1YS0VtNWpaYkRDMDlLdzl0RFo4QjEybGFyQ0s1K0E3MlJvMmVXVFlkeUlHUjlza2FPcFNvTFZiQm05UWhWQlVZNmQwRk1wUndFRkpJUS9WWlFMVWxsdGcyamdSWmsreVFxMWJ5TFRaWXJSUGtLblhrYW1IOFhuN3NHSnE5YjJyY3Q1SVVlRldDdzh2RzBsZlNoM3ZrT0hEUDRYaGs0TVI2UEFxN0N3elFXV0pCYjV5aVEydW4yZUhLVlVaNGZZaFk5OUh4dDdLR21MOGZYZHVRUDlqK01XQjU3KzBQMkRGSytnRnZJTHVUOVdXdlAyT2hpaXMrYjgrT0hoS0duaGRMQ3dHMThSNmNJNmZDalozTmRoS3hvSlE2QUplTEFCZUVObVpIa1ZTWlFsVUtRcHkwQThSNzJtSWVGcWhyK1VZK0JzUGdSUThVOXk0WklJSWQxL2poSVhUQzREajB1eExnNWVRdFI4VjNMWXoydjlhOU0wRldZQitOd3ZRa1RqUXY3UTlVSVRBcnNjUHZ5WlZ1eU90RXF4YTc0ZERUWEdRQlVjUmxGOTJOWlJmdWhnS3F5WkIycU5tdWpDRThBVGJUMERYNTU5QzE0RXRJSWNDK3N2MXRTSTh2TndGMDZ2RmRKdDlpdWdzTDdoOVo0OE85QnNtb085T0FucFJ4dVA0WWZnbCtIZjcvVzdjOFViYzhSenorekZaZzlVZjljRmIyMEowUllGWVZBcFZDNzhKRlhPWEFXOHRZQ2VTS2Ruem9nZjM3TnNFN1ovK0ZtS0JIa0F2RERjdmRNQUQxem5CS25DcG9QNGMyYnUyNFBaZG51Z2JsNXVBN2trRVdza0NOTVhKQ09wbS9OQlo1amVhTWNGYitab1hqclhKd1BFV0dIdmxEVkI5OVMwSXNvMmROYWJzWU1jaTBMcmxiVGo5MlllZ0tRcE1IU2ZBVTNlVVFFMjVKVlg0Y1FBWnZCcE1uVEtXSktEZldaanBNNjBZblA4ZWcvT2tjZ3FGRmcvL3R3LzhJUlZzWlZVdytlYUh3RkUxa1owbHBwd1Y2amdKSjk3OUJZUTlMZUJ5OExEcTdtSTlGRWxSak5pTUxINmRBb01Cb08vcFRXaGorY210TlptcUdTL2lEbTQydjc2aklRYVBJTXpCcUFZbDArZkQxRHRYZ3JYRXpjNE0wN0FrT2t1Z2ZOWlNIV2hmZXd2OGNYOFVwbUZNYmZiVTZLSHJrRWszUG03b2YrMko5eU1tRC8zMmxTay9KQnpUYnJkYnVYWG0xdzgzUy9BUHIvZ2dJbW5nbnZzMXFMMytYZ3czY3V1ZlVmSCtFWlpVTkVXUHdTWDhXVlkwdmM5UzAxaHQrcTlKSEFhM0ZQVUtGZzVFSkkxaVlMdG9RZU9CNTNNckJHaXFDazBiWGdIUG5qK0NUZVRnUCs0dGhwazFZaW8ydjlQUHBtV0ZOenZRUFVHdHB0VEJIY1JqVGFnenQzUXJjTzlxTC9nd3pIRFBXNmJEbk5PdEphYUNQeUxyanlvRGQxU0xSM2djVmg1Y05rRi96RVU2MUx2L2dPRUhCNi9jVjVya3FSRWRuemVrWFZwYXlEV1pnUmJNSGxINHJvOEwvYnI0SmR5c2VQQmJFbnJTbGVzQzRBdkh3NHlhNjc0NzVBTU1Jc0E5UVFsaWlwWndaVE9OWG1uR2VRL0dZbUJGNzExV0tBNFpiR0pMNnVzRmI4TnVlT3lOQUx6OEF4ZUlpZFdQWW9jVncrRVYzaHZCTkJncDZSTzZYM1JkYXhYZ2I4eXZyOTRZMHFzWjl2SnFxRnYrUTMxVEFqNlRFY0J0dmhoMCtHTUpNRE5kV0tKejM0NE1FQXYwUEJzM3hCWXhScXdSYzhSZVVyVUNHZTE1MGJVczZjNFFCenh1NkoxNXV3aFBEbjZOcktGVmduZDNSdlRTM0lTYkhnVE9hak8xU0xhK3FBS3QzaWpHMnFvZVl6RmpSaXdRRThSR05uNklNWjAxWkk3WUl3Yk5yV3dpUEc1Mnl2emdOazJyaXI1cXRjQ0N3YTlwS3NEenZ3dGhJZ2ZnWG5BOTJNZE95SHBGOW9ZazhQUkp3TUprcHFSUUJKa2dOb2lSYkNMVzNGZmNvTFAzd2djaG5jWEJiQktyamM4NnIwMEFtbUpvTXVGN2ZyN1lyajNTLzNPL1VZbnVpeFpaN3dHc1hISnoxb09nV05rWFpvT1JtREtMR09rT1pvZTZjdkczZGZZT044czZpMlkreHhUcUkvUDRwQmg2NDBPTzhYYVJTeHFuOFp1dDhUcGZ4YUtiZ0JOdEdXTWZ1dW9DZUR1aGZJOFpzMnhHb1FjeGs0a3BZbzdZSTYzZEdrbjI0c2dzc1RzbzVJaHZlWEVWZHhjSG1tWHczbWdJNktFbTlNNk9JaGd6Nnl0WlNuSUsrQ1BNTXpQbEptSW1HTXZNRGJGSERCNUdGcjlzbHhPSUoyYUozVE1oQi80bmZyOVBkTm01RzgyQitlOFBTUHFsVkhMSkV1QXNZcEs3N3pmcUdPa055eXp4WVRZczh5STd4RkE2dm9nOVlwQllKQ2JObkJLN2hQR0FoMzd1Rm11RlhkRG1tUDM5eHdmalhlYkY5VmRsekVpOXhtMUQ3elZpeGl4SEkzWjBoakl3Vmp3elBzeDUweUVwS1M0aGRvbGh2UitGbWw4em5WL0NjVnBDK2FPeFU0VXV2NllQeExkWHBoOTBSS1VZcWkyeWZoS21zNjFWRTBzMk1YWG5pNzFxSWdqT1V2RDRlNkc1VzRHYU1uNVFKeDN3eERBK1hjZGJmeEN5Rk51NXVlWkw0bUJUUEs0cG5GQVBlcVNTb2Q3TWJwdk04bUdaNjlNY0ZOYk4xSm5jMzZna05VQ0c1K016QzJFdTJrUnRKZzBOR3Z6dmFIc2NWTWU0S1dtdnFpaGVVYkxLaXMxTStSR3hSRXlsazZOeWtzN2tsNmNWTVBPS0RNOGdsdW1iaXRZQ2dhczFUOC9SMUJYZnNWaFduYmFESkNLcjdDd3c1VlhFbEZWSUhYYUlZOGJwajgzRXBvbEpuV0c5Unh6YldYbk5iVzdRNlRPQUxoMmJjaW9heWo1aitPRXNkbWJLYXl3dHgwZGlwaHE4Sm82cDFCL2JlMVV3ZTFrckR4WDlIbHF3V0xRaU03VCtjRHphRmdwVHoxUWdHNE9OR005TWVRODlrQzB4eFhjTGRSYVJTVzhZUURPNVdZc0ZDcWtKQVczQmJXMW1OeHlPR2NHNjNqdVk3S09wYnNpR2dES05oSWl0VkRNZ0VZdjZJS2NZSklVYzlMMENuV1VZR0hHWFd1bmlaL3JXQ2NPWmFTU2txdG9RQnJhbGJNQVQwTnh3dnZiRWlodE1Jd2IwRU5oS3d5d25wSWNkTXI2bGQwa3lGODAwQXRLN3ZJZmxvUFdld3RUdkRpVStaand6L2FWMWhrc3RQZENaUW81MGI3R0VrR2xrdmZTd1FnNFFoaG1yc0hDRGFjVERqdUZJeUhZNWFDemNZRG9YUUEvVGhRdnAzdU9HdW1NbXByOGcwRnlXa0VRWUxyWXM1R0E2SDVGUEgzSVl4TEtra09tOFNncjd1ZE55cm5Kd21aTkM5amRuT29kSllUcG0wMVk1c2dHYjYwUjhURXk1U0ZXSDUwZ3pWRGs0bGhReW5YZEpZZWFZeFBEUVdzYkJTZW11Rk9haG1jNWh5SkU1S1V5ZjlLVk5DdG5mbk9rY0pJVUR4UWd0NTVBanMxaVZnK2w4SkQ1N3lKRVdhUFkzWlRwM01YVE9JVWMyMTgvQ0RxYVJoRm5UaGtkODJwQ0R3Y3AwUG9vYldzaVJlN1pKZFVKYUtJYUpLZDlTRkcwSVZZNWNrMEl1Y3gxYVpZa2gwd2hKVFJjaHEzSjhKZ0krbVZsYVNHMEFhRm5WSXRnb1lmbFh1MGhMcjNINmFwLzBiVnV6SkZrRm04Q3p2ejVUM2tWc3BmS3hXalErUDdUZHFpVzVXdHdrTWdCMFRJS1FZRTBFMm1XamlSaHhzNUFmdU9JVVFQZlB5OEdjTkZNK0UwTHRERnZKUUlmMEdMclFtaHc2eURMUVRETDZqS05hTUFZOTVqbDUzYzc0ekVtSzczVGFDZlJpYkNvd3BueDc1LzRGV0ZNWXNVZ3FMMVNUNXBCR2huMzlRS3YraUhiYXZIbDFxUUcwdHlQdGgwZGx0c0lWczN5dmxKVitOdjkrRnVOc0p2SWFpR3IwcGtwQUs2ZjlYS1A1Y3BoVVpnQjkrbmphbWRVSmFEYjdLRk8rcE04K0txdHBlVk04Si9WMms4dlZKUGVORE5PYktzWFFjb09IKytLS3VrUXdwMWRTUm1rRHVhM0J5RGxUQjh2QnFBSWxkb0dkRGFhelZ0Q1lIenBkb1U1dU82SW5iVFBIeVVsMWtDT2QzQmZFTXBFby9jOXVjZmRkYzJXVlprTHZiMUNMYnIzTW9VRVBKb1dLcHduNDh0VHJFOUlpOUE3TU9ndFl4WVBwTEVTZU9aeGhibWkxcXdtSjkrcng4emhYNG5TNjZMelZkZnVFM2NReVVSamIzY0ozZEFUZ3VObVBYelVsdnNhS2ZPeXpqQWZqQzhzRE15a3hZNWFyRVR2RVVNWnc1TXVkK3VPaXlja3J5aEs3TzA5WktJYU9FZERVb205Zks3L0RITE1zR1FCNkIvNFh5eGo3ZUxNY0VCTlRPaEU3R1hNeFpFOCt1bDEvU2t5YU9TVjJpV0hkUS9jOEVhQzBNcmg2bTNXanF1cWROQVB3MTVVcWNORlk5TDZSUHBDT2JzdTRTbEVJYnhlMDZDWkwxWm5sWXNRTXNaT0pMWjA5WkpCWUpDWUh2MG5NRXJ2RU1OVXcrcWZTRFc4N2FUbHhxcGM3Wk43ZHR5K0w2Sjh0NzkyQWU0NW1EVDJDRVFVNFd1S05HYk1zUnF4a0N6V0lPV0tQR0NRV3pYd1NzOFF1TVV6TmVTTzRwcGJkcis4VjE1c3ZqOW5qSlpqaVJpOGQ4b0swNTRPTXk5aVM5WVJrOExQbGtabGxNV0tFV01uR2s3VDNBNTA5WXBCWU5QT3BNNHZzR2d6VFNySWFkRC91b3pqYTkveldnazliZk56eHdhc0wwVmJmV3hqU3YrVXRILzRZczgxVGFldUUvZFlibEtDcmp5M0d5U3oxSXB2RUJqR1NqU05pVFQ3MHNjNGVNUWltbGErSVZXS1cyRFZ5UWNORHg3MDBCZFduZjdQSCtrNVNKOHNZR2I0K0hTOEFWUUZwMDh1NGFTUnJvRTlyenJYNW9obExNVXdYbG9nRllvTFl5TjRISGdIcGsxZDA1b2c5WXRETTVXdDd4WGVJV1lOZGlBTjlobWdLa0QzUGJTblkzT0RoRDVpM3ZuTmVFQ2JpVGpWL0owaWIvd3V2b015QnZEN1dROUdnSFgrQnprQXN2bUlXeTRFdVNLTnpUd3dRQzdFTVl6VUdETm5TR2ZPZDFwa2o5c3l0aU5Gbk50czJFN01HdTVEZ29idC80aVZYNmtkcmUyU0RmVTJVUmk4TjJvZUl3Y21EVndmQWFjVURham9BeXZaMVdlT2ZmZ3RnOE4vY0d4MjRPbGxuK2VpWE51Z3VUZWVlR0JncUx6cGJ5Qml4UnN3UmU0TlpKRGFKVVdMVllIWWdETEQ4ZUpsejRDQ2UzV0tuZTRIYTdPVzVZcHNHODJ2a09ZTVAwbG1nd3N3cUNiWTFGb0RjZVFvZzVBT3VwbjdJWTBocEpCWDlrcFRaMHUxSDFzNTArTVNUQlk0bFRIOWxwdmZpSVlVMDhESks1emVtUUc4b25rTlJTUzdkVU5EVVY0RUs2dmJYUUczWUNnV0NCbzh1ODBGdGFYSVY1TmM3Yld2WDdpblloRTlQR0VBUGZBalh0YW95b1hINTQ2VTAycFQ2dVMvOThKN0FQMTFSS3k4eTczQmZpeFZlMk96Q2cwVUFKOHdDeTVJVnRNQXljMHRNdzVjVUJXWHJxNkNkMmdlaVJZT0hsdnBoOXZqa3pyelBtb1J0TjZ3cCtqaysvUnp0RkVVMGc5L25rL3g5UEZ1a2JzVEdPOVk1WHozVnd4MDN0NWxkSFlWLy9xb1BDaW44T0xVZmxQZWZBcTI3aVowVXB1R0ZKejB0b0h6d1V4MW1Zb3JZSXNiTTNEWDFjaWVJU1dMVFlGUXk3NHZyZW01czBnZVVQekdHdXNUTDBHWk1keXR6MXQ4VitIRjVvVnBsYnRmaHQ4QXZ0aGJEeVI1Qlh5R091MlFaOExPdXgwQkdaR2VKS2JzVUNkVDlHMEE3K0FmOSs0SjFtQUErdU1RSGxhN2tLa2hYa0c5ZnZyYm8yU01leTE3ODhjOVVlKzc2MXg0VldVMEUydk5zUmNyUGNqOVpSbFFTN1JmWFY4cVh2Zm0zZ1Fjcm5PcTQ1TGlZZzNYN2ltQmpneVB1NEIwbHdOZC9EYmlMRmdNSUJleWtNYVVjbTZFZDJ3N3F3WTBBd1Y0OUZsODJMUVIzekFubzRVWXFtRzk1dmVqbmh6b0VDak1PVTZuTzgxaTNaSEE2TktDTnhrUWtRVHlqcGtTOTZMMDcvZmZYbFNxVFU3VnQ3QkZoelM0WGZObGxlR2NiSnB1VEZ3QTNhUUg2K2hwZ00zMnd1Z2QwTjROMllpZkFjYlJJdkhROHBWeUNleTczdzhReFVzcXRtcjE4NDIzclhLdVBkVm5JSzlPWTV6YUVPVHFJVVRQUTdveUg0WDZ5bkxLOWFyU0xTbXphcExXMytXKy9zbFphbEs1VXM3KzFBTjQvNUlTakh1dVpOK3d1Z01wcHdMa25BaFJqNUZLRUIyRXJpbnR3M3NMTzlXaVNpdUdDakx4RkFnQ0JiZ0JmTzJnZURIazdqZ0tFL1FQTnBybGpjR045SDh6Q1dEbWRxOXZSSkc2LzYwM1hPbStFbzJwR0ExcXI1N0d1aUlsUEU5RFB1TE1lby9zcEhXcUtvYWVpMWE2OEpyajR2Z1dSVzYwV0xXMXBvOWtyd0piakR0alZiTU5iQm9PV0NXL1VEZ1VXMUVaZ3llUXcxSlpJYWR2RkZJajg1MDc3VzA5dEtxUnU3V1kwdkJxZzNiT3lLNUtDemR5Qk5qYWs4SU1hVDBLcnU2eEtudkQ4ZFgzZndzZloyYlp0OXd2dzUwNHJKbzhpZEFRczRPa1RvQy9HUVVUbVFXRTk0Nk5LRmg1dnZvS3FkNHFVT3hXb0txSmtUNElaRlRHb2NtVWZNMytnWGRqL28vOTF2b2VQVkpJN0NmRmFzd2RoanFiaDBnVDB2NVVQK1dEZFQ3c3BRQzVCbzZBWTR3ZW91SGQrdVA2K0JlSHJhb3FWT25ZNm1ZYXJacC9sNUs5MjJUOTZlWmY5SVA3WUNmSFNISGxucitkUmo1U0J5VVNnTzNNQW1sVHh0SnRLZW9WR0JhVFdTQnBMVnN3TFg3eGlibmpwMUhKbE9zY3lRS2FocFlrYUpudEhYdDFqMy96cWJqc2xmRjZJZDJkVHB3WU5PZ3AyUHVwUnMvQjRka0FiT3lGZ3lWc1hvMVVhU1NQdDJUVi92RlI1ejl6dzdDdHFwZnBxbDFyREFiQnZ6eklOaGxodDlmUE5ueldKaDlic3NlLzdVNHRJSFNTVUxkSWdvMWFJZDVqb3cwRVJabTBJTEpxQkxodjJ3VlU4WFVHd0ZoaGd1dzI0YVlkRlZOc1lYNndVTGI4NE9uSE9PR2w4WGFsU1dlWlF4emhFcmRBbWdGMjBhRmFlQTVZdGpzWkNod2FLcEhDeGlBemhrTVFGdTBOOHo4bGVTOGZlTnJGbC9SY0ZqUzArU3dEaTN6Q2h4MjREWW84QmNyVHowVTQxQndaTlFQK3M3S3gvZ1lxZkRvRHROR0pzMm1rcGVXd0NHODFxZUhTYU5vRTNySDkwSWRPb2RNUzZxWVpSTmtoeGNNd0FtVHh5cndFemhSbDlPc2ovMHFrT2c3MUVvS0ZvUmo1L0VjNkFsc3A1RHNPY2hqbU0xODFnTTQxQ0oyMENtY3B0SVFQY1B1TjV5SGhkaGp5dUhpaU13SlVwR1VhM0U0c0JNUFBRekVQM2UyaDZWRWJxZy85ZmdBRUFGSTRjUFRGOEdqb0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmdcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g54q25oCB5Yy6IO+8jOWxleekuueUqOaIt+eahOS4gOS6m+eKtuaAgVxuICAgIGRpdi5zdGF0ZVxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5tb25leS50YWJsZVxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4ubW9uZXktbnVtKGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIixAa2V5dXA9XCJjaGVja0RhdGFcIixAYmx1cj1cImNoYW5nZURhdGFcIix2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD1cInVzZXJCZXQuYmV0bW9uZXlcIilcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0ucG9ydHJhaXRcbiAgICAgICAgICAgIGRpdi5wb2x5Z29uKEB0b3VjaGVuZD1cInNob3dNZXNzYWdlXCIsdi1iaW5kOnN0eWxlPVwiaGVhZHN0eWxlXCIpXG4gICAgICAgICAgICAgICAgc3ZnKHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uPVwiMS4xXCIsdi1iaW5kOndpZHRoPVwiaGVhZHNpemUud2lkdGgrJ3B4J1wiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHQrJ3B4J1wiKVxuICAgICAgICAgICAgICAgICAgICBkZWZzXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuKGlkPVwiaW1hZ2VcIix4PVwiMFwiLHk9XCIwXCIscGF0dGVyblVuaXRzPVwidXNlclNwYWNlT25Vc2VcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSh2LWVsOmltYWdlLHg9XCIwXCIseT1cIjBcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbih2LWJpbmQ6cG9pbnRzPVwiaGVhZGJvcmRlclwiLGZpbGw9XCJ1cmwoI2ltYWdlKVwiKVxuICAgICAgICAgICAgICAgICAgICBpbWFnZSh4PVwiMFwiLHk9XCIwXCIsdi1iaW5kOndpZHRoPVwiaGVhZHNpemUud2lkdGhcIix2LWJpbmQ6aGVpZ2h0PVwiaGVhZHNpemUuaGVpZ2h0XCIsdi1iaW5kOnhsaW5rOmhyZWY9XCJoZWFkYm9yZGVyaW1nXCIpXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnN0YXJzLnRhYmxlXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGRpdi5idXR0b24udW5kbyhAY2xpY2s9XCJjYW5jZWxiZXRcIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJCZXQnLCAndXNlcmluZm8nXSxcbiAgICByZWFkeSgpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy56b29tUmF0ZSlcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4kZWxzLmltYWdlKVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWR6b29tOiAxLjIsXG4gICAgICAgICAgICBoZWFkYm9yZGVyaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZycpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgICd1c2VyaW5mby5oZWFkaW1ndXJsJzogZnVuY3Rpb24obmV3dmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRlbHMuaW1hZ2Uuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAneGxpbms6aHJlZicsIG5ld3ZhbClcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaGVhZHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxNDIgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTY1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoZWFkYm9yZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIDcwICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDcxICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE0NiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRzdHlsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCAnICsgKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggLSB0aGlzLmhlYWRzaXplLndpZHRoKSAvIDIgKyAncHgnIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJyknXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJywnICsgdGhpcy5oZWFkc2l6ZS5oZWlnaHQgLyAoMTAwOCAqIDAuMTcpICsgJyknXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvd01lc3NhZ2UoKSB7XG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KSAvLyA15Luj6KGo6IOM5pmv5pWw57uE55qE5pyA5ZCO5LiA5Liq77yM5Y2z5pi+56S65YWF5YC855qE6IOM5pmvXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGJldCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjYW5jZWxiZXQnKVxuICAgICAgICB9LFxuICAgICAgICBjaGVja0RhdGEoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKC9cXGQrLy50ZXN0KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpKVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxEKy9nLCAnJylcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURhdGEoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcRCsvZywgJycpXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bW9uZXkgPSBwYXJzZUludChldmVudC50YXJnZXQuaW5uZXJIVE1MKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4uc3RhdGUge1xuICAgIGhlaWdodDogMTclO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJvdHRvbTogMWVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cblxudGFibGUge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LnN0YXRlLWl0ZW0ge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIHdpZHRoOiAzMy4zMzMzJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbmRpdi5tb25leS1zdGF0ZSB7XG4gICAgcGFkZGluZzogMCAxZW07XG59XG5cbmRpdi5wb3J0cmFpdCB7XG4gICAgcGFkZGluZzogMDtcbn1cblxuZGl2LnBvcnRyYWl0LWltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMvdGguanBnKSA1MCUgNTAlIG5vLXJlcGVhdDtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG59XG5cbmRpdi5wb2x5Z29uIHtcbiAgICAvKmNsaXAtcGF0aDogcG9seWdvbig1MCUgMCwgMTAwJSAyNyUsIDEwMCUgNzMlLCA1MCUgMTAwJSwgMCUgNzMlLCAwIDI3JSk7Ki9cbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLyogICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nKSA1MCUgNTAlIG5vLXJlcGVhdDtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cbiAgICBtYXJnaW46IGF1dG87XG59XG5cbmRpdi5idXR0b24udW5kbyB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbn1cblxuZGl2LmJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDQwJTtcbiAgICBwYWRkaW5nOiA1JTtcbn1cblxuZGl2LmJ1dHRvbiBzcGFuIHtcbiAgICAvKmZvbnQtc2l6ZTogMS41cmVtOyovXG59XG5cblxuLypkaXYuc3RhcnMtYnV0dG9ue1xuICAgIHBhZGRpbmc6IC44ZW07XG59Ki9cblxuLm1vbmV5LWljb24ge1xuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcpIDUwJSA1MCU7Ki9cbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xuICAgIC8qYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsqL1xufVxuXG5zcGFuLm1vbmV5LWljb24ge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIGZvbnQtc2l6ZTogMS41ZW07XG59XG5cbi5tb25leS1udW0ge1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5O1xuICAgIGZvbnQtc2l6ZTogMS41ZW07XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogU3RhdGUudnVlPzQ2YTkxZjY4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSTRBQUFDbENBWUFBQUNLbHNYOUFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBQjNSSlRVVUg0QWNNRHdVTVhmc3QyUUFBSUFCSlJFRlVlTnJ0blhsNEhOV1o3bjlWM1MycGQrMXFMUmJla0MxWmxySEJMTWFZUUNBQmt3bEp5RGczRE55RU80SEJJVU15bVJtSW53bHo3d1ZtSUROM2NpY2JEZ1RHU1NESlhCSW1KS3dockFhTVdlSkZscnpJTnBZbFc3dlVlN2Q2cVRyM0Q3WDI3cTZTRFZocTFmYzgva055ZFZmVnFWZmZlZC8zKzg0cDZiN2RBaU1tUlJQd044QjY0QTNnL3dMTnVYcXozenJuMUQ1blB0MFRQOXZTbXhNRHVMR3h3Z3c4QU53ODRkZExnUzhEUHdHKytXeExieWozZ0ZOeFpvQ1RJNkQ1SnZBVm9GNEk2UEJHT0RZUVlWR3BqZG9pRzVMRXpjQVZHeHNySG5tMnBmZWZjdW5lSlZlREFaeFRBTXduZ2I4RnJnUVlETWRwN1FvU2lpVUJhTzBLY253d1NuMmxrekpIM2lMZzNvMk5GVmNDRHo3YjB2dXIrVHgyNW5rS21CcmdPOEQxQU5HRXdvSHVJRDJCMkxSalE3RWs3N1o3S1hQa1VWL3B4SkZ2dmhTNGRHTmp4ZlhBdmMrMjlMNXRBT2NVUWpDM3lQVTFqWjU3Z051QUlrVVZIT2tQYzJ3d2pLSm12NCsrVUl6K0l6RnFpMnpVVlRqSU04bWZBajYxc2JIaXA4QWR6N1QwOUJ2QXljRzRwdEh6UmVCMjRFS0FMdjh3QjN1Q1JCT0svajhTQWNlSEluVDVoMWxhWm1kaGlRMVprcjRNWEhWTm8rZmhaMXA2N2pLQW96TTZkcjh4cTI5dzg0MmZid0x1QmY0TUlCQk5zTDg3eUdBNGZzcmZtVWlxSE9nTzBqRVlZWG1sRTQrcndBTjgrNXBHenhYQVExc2YvYzAyQXpoek5EYmYrUGxKOGpxZVZHbnJDOUV4RkVGb3pLNmhnVzRDL1NkeGxGVGlMS3RDa3FTMHg0WGpDbjg2N3FQRW5rZERwUk9YMVhJaGNPSG1HeisvQ2JoLzY2Ty9lYzBBenR3Q3pUZUFXOGJrOVZDRVE3MUJFb3FhOVhQRElUKytrOGVJUjhNQStMcU9FUnJzcHJCcUlUWjNTY2JQRFlaanZIRWtSazJSaldVZUovbG0rU3JncXMwM2Z2Nlh3TGUyUHZxYlRnTTRzeHN3bndEK2JxSzhidW55RXh4T1p2MmNFby9oNjI0bjRoMlk5bi9KMkRBRHh3NlM3M0JUV0wySVBLczlnMGdZOFgrNi9GR1dsRGxZWEdySEpFdlhBOWR2dnZIelA5NzY2RzgyRzhDWjVDQkpaeDR3TjF4WERmekxSSG05dnl0QXQzODRPOWxWVllMOUp3bjBuMFNvYXRaN2lZVUQ5TGJ0eFY1Y2pydWlGcE1sTCsxeFNVVndxR2VjLzFRWFdnRnUzWHpqNXk4QUh0NzYyQk1QR01DWkRWbm1odXZ1QWI0S0ZJL0k2eER2OTJ2TDY0aHZBRi8zY1pSRWJFYm5Ddy8xRWZFTjRpcXZ4bGxhaFNUTGFZK0xKaFIyZC9ob0h3alRVT1dteUdaWkRmeG84dzNYZlFiNDd0YkhubmplQU02WkFjd1hnYjhHTGdMbzhrVTUwQjNRbE5meGFCaGZkenV4VU9EVXZTdFZ3ZC9UUVdpd2w4TEtXbXlGcFJtUDlVYml2SG1rbitwQ0s4c3JYVmd0cGl1Qkt6ZmZjTjJ2Z1c5dmZleUp0cms0L3RMcFZzZTNiYXI3U0MvNHBzZmJtb0I3Z0UrUHl1dVc3Z0NEb2V5WlEwMG1DZlIyRWhycVJWTld6VER5YkU3Y2xXZVJiM2RtUGM0a1N5d3VkYkMwM0lGWkhwc1dId1MrdG0xVFhmSk1BS0N0eDV6YndMbnA4YlpwOHZwUWI1RGpnK0hzT0JDQzBGQXZnZDRUcUlxT1p5TUVwczQvWVQ2NlhWSnExOTZTWEhUUmc4ajZCdGZxS3NaZFdZczVyeURyY1FVV0U4czhUaFlVMjBqQjV3RHc4TFpOZGQ4MWdQUEJndWJyd0YrTnl1dmpnMkVPOW1qTDYxaklqNityblVRc3F1czhzcmNEYzh0VGtqVFVnWUNSaDJvckl0bHd0VkNxbTBaL282RVZKQndsSHB6bDFjaW03QS9GYmJXd29zcEZpU04vOUZjdkF6L1l0cW51U1FNNHB3ZVlLNEcvSDVYWEE2RVlMU2Y5QklZVFdUK1hqQThUNk9rZ0d2RHFHNFRoSU9iV1p5VDV4QjZFcXFLb0trS29TSktFTEp1UUpRbFJmQmJKbFo4U2FsR3RQaENhekxncWFyQVhsV3NxejBxM2xZWktGL2I4c1lmNEpQQS90MjJxYXphQU16UEFWQUgvT2lhdjR3cXRYWDY2ZkZGTjBob2M2Q1kwMElNUXF2YUpsQVRtbzY5TDVzT3ZvQ2FHVVpVUjBLaXFpaEJpQkRpU2hHd3lZWkpsSkZsR3JUbUhaTVBWUWxnTDlhbVBmQ3R1VHkwRkRuZDJvRWtTaThyczFGVTRzWmpHbE5vandKWnRtK3I2RGVCb2crWWVZRE5Rb3FpQ0kzMUJqdlNGTk9WMTFEOUlvS2NESlpuUWx4RzZXekMzUGlzUkdrQlZWUlJWUVZWVVZDRVFFMGlUSkVtcHpDTmprbVZrazR4c3prZFpjZ25Kc3k4VG1QTjBuUy9mNGNidHFjV2NiODFPdE0weXl6MHV6aXF4anlhcW5oVC91Y3NBVG5yQWZCSDRHckJ1VkY2M2R2bUl4clBMNjBRMGpMKzdnM2hVWDFlbkZPekYzUHlrSlBVZlJSVUNWVkVtWlpsczNHVWsrOGlZWkJPeUxJUFZoVkozaFZBV25nK1NyT1BrRXZhaU1sMzh4NUZ2cHI3S1RhVjdER2c3Z1llMmJhcmJaZ0JuWEY3ZkRWd0w0SThtYURuaFkwQlRYaWNJOXA4azRodlFkNlB4TUtZREwwaHkrMDdFR0ZnVVZGVkZWZldQd2JUc0k4bmc4cEJzL0pSUUs1YnA1RDhtN0NXVjJJdkxrVFFBVitySXA3R21FTGZWTXZxcjU0SDd0MjJxZTIxZUFpZWR2RDdZSGFCOU1KUlZYZ3NoaUhqN0NBMTBvU282ZW1tRWlxbjliVXdIWHBCRUxEUUNGbVdVQUl1c1dVYUxrOGdwOEpoa0U1SXNJU3FXazJ6OGxCQk9mUTNnSmtzZXp2SWFySzdpN0E4SldGQmlwNzdTUllIRk5QcnJYd0xmMnJhcHJuUGVBT2VteDl0dUIyNGRsZGZ0Z3lFT2R2dUpKN1hrZFlCQWJ3Zkp1TDR5Z1R4d0ZQUGVKeVVDUFNrZW82SXF5alFlYzhydTZWVCtJOHRJSmhQcXdndFI2ajhoUko1ZDEvZFlySGJjRlF1d1dMTWZiNVlsenE1d3NhVGNpV25jUVB6eHRrMTFtM01hT0RjOTNuWUZjTWVZdkE3R2FEN2hKUkROVG1pVmVJeEFieWV4c0w0eWdSUWV4Tnp5dENSMTcwT29Ba1ZWVUJSdEhuTzZBQnFadmtiNGo1eG5JN25zNC9jcml5NitFNU8raDFQZ0tzSlpWcDJ4Z0RwbU5PYVpXRkZkU0UyUmJmUlh1MU1FK29HY0FzNU5qN2RWQXY5bm9yeHVPZW5qcERlU25jY29DdUhCSGlMZVBuMFBQQm5EZlBnVnlYUmtPMm9pTnA1bFZCV2hxaDk2ZC9SVStTN0w4b2lCdUdLalVHdk8wV2tneXRpTHk3R1hlRElXVUVlajJKNUhZMDBSeGZZeG9QMFIrTzYyVFhYUHozbmdwT1QxclVDcG9nb085d1k0M0J2UUlhK0hDQTUwbytxUzF3SzVjdy9tbHFja292NnhLZWwwZWN4cEFXaU1RS2NNeEpLRktDcy9MZFRpcy9STnMyWUx6dEpLck81aXpXTnJpbXlzcUM3RW1qY0dnbDhEMzk2MnFhNXR6Z0VuSmE5dkF5NEdPT21OMEhMQ1J5U2V2VjZVR0E0VDdEdEpZamlpN3dhOEhaaWJmeWRKZysyb1FwMW00cDJwa0FCSmxwQWxlWktCS0dwV2sxeHhqUkEyL1FhaXM2eWFQSnNqTzlHV0paWldPS256dUdkVVFKMDF3RW5KNi84TmZHWkVYc2RwN3ZReUVCeldJYSs3R0E3NjlGMzRjQURUL3VjbHVlTWRoREtCK0tvakp0NXNpWXdHNHRKTFNkWmRKakRuNnpNUTdTNGNaWlc2Q3FnTlZZWFVsanAwRlZEUE9IRFN5ZXY5WFQ2T0RRUjF5T3QrSWtOOUkxMTRXcUVxbUk2Ky9tdnp3UmMycVlub3RBd2p4T3hjNTVYZVFIU2pMTDlTS0FzdjFHMGdXdDNGMkVzcU5BM0VRbHNlSzJ1S0tIT09BUzF0QWZXTUF1ZW14OXYrbXBFeVFiMFFjS3cveVA0dW43YThEdnNKRFhTakpQUXRWWkc3V3pIdis3MUVzUDlEa2RjZlBmOUpHWWh1RDhtVm54WnF4WEo5M3lHYnNCZVhZM1dYWmx5Qk1ScFZSVFlhYTRwd1pDaWduaW5nZkJ5NGMxUmU5d2VIYWU0Y3doL0pEb1JrUEVab29KdDRSR2VaSU5DTGVkL3ZKS24zQUtxcXYwd3dteU85Z1ZoUGN1VzFRcmowRzRpT1VnLzVkcGZtdVphVU8xbGVWVGl4Z1BvVDRKdGJOalNFUGtyZ2VJQi9HNVhYa1hpU2ZTZThuQmdLYTVpNEN1SEJQcUtCSVgxZGVJa281b012U1BLUjdZZ1VmMUZPb1V3d203TlBXZ054MFRxVWhxdG1aQ0E2U2lzeDUyZm5QL2xtRS9WVmhTd3VjNHhtcW1QQUkxczJOUHpUUndHY2V4aHBxaXBUVkVGYmo1OUQzWDROZVMySUJyeEV2TDA2eXdRQzA3R2RtUFkvSzRuaDBBaFF6cUM4L3FnQU5NMUFyTC95UFdYSituUDFkaUFXT0l1d0YydnpINWZWUXRPQ1lpckdDNml2QVE5dTJkRHdxdzhET0Y5a1pEWEIraEY1SGFhNVkwaGJYa2ZEaElaNlNjYUc5YVh3L2lPWW01K1U4SjVBRmVxWTR6dVhwNlhUTWhEdHhTTUYxQVdyOVJtSXNveXRzQlNydTBTVC8xUzRyVFF0S01FMVhrQjlHcmgzeTRhR3R6OEk0RXlXMTVFNGV6b0c2UTlveSt2d1VLLytNa0hFTzlLMjJibnJJeWtUekIwQ1BjRkFYUFZaL1FhaXlZeXRxSndDWjZIbXVSYVhPV21vS1NUZlBGWkEvU2x3eDVZTkRmMm5BcHdwOGxxaDlZU1g5L3VEV1Ira0VJS29iNUNvZjFEZkExY1NtQSs5S0puYVhrWk54aWJMNjQrZ1REQnJ3WlBKUUZ5d2htVGpud2xoSzlKbklPWVZZQzhweDFKZ3k4NlRUREwxMVVVc3JYQWhqMlNxSHVEaExSc2E3cG9KY0w2V21wYnFoUkM4M3g5ay93a3ZzYVNpSWE4RGhMMzlNeWdUN01hODd5bUo4TkFJOGMxaEh2T0JHNGgxSHlPNTdBcmRCbUtlelltOXFFeXpnT29vc0xCeVFUSFZSV1BFZkNmdzBKWU5EZHV5QWVkeTRGdGo4am9RWmMveFFYdzY1SFhFMjZlL1RPQTdnWG52YnlXcDcvQ3NLaFBNRGY0enhVQnN1RW9vaXk3U2J5QTZpMGI0ajBZQnRjeGw1WnphWWdydFk4QjhIcmgveTRhRzF5WUNwd0w0N2tSNTNkd3hTT2RnU0ZOZVIzeUQrc3NFc1RDbWxxY2t1ZjJ0V1YwbW1Ic0dZaVhKcHM4STFWT3YyMEMwRlpaUTRIUm5KZHdTc0xETVNlT0Nrb2tOWkQvZHNxSGhKdW0rM2FJUmVBa29WMVRCb1M0ZkI3cThtdko2T09nbkdoalVYeVk0OGhybS9YK1ExSGc0TlMzTi9qTEJuRE1RUFEwa1YzMVdDSmRIdDRGb0t5elQ1RDltazB4OVZTRjFsWVdqRFdUcnpjQldvUHpFVUlnOXh3ZUl4TFNxMXhFaXZnSDlaWUtlQTVqMy9sYkMzNDB5UjhzRXN6RlVJUkNwVEszS1lpUURkYlZpNlQwb3FZdlhvNnpZS0VTK1hVT1h4QW4ybjhSU1lNTldXSnBsQnc2RmZaMkRTQklzcnlvQ3VNUTg2c3ZzYU92SmZwSmtncWh2Y0d6VElTMVBRUXIxWTk3emhDUjF0K1JNbVdDMnhXaTJGa0tncXVvSWVJUkFQcktkdkk3M3BHVERWVUpaZWluSUpvMWtFTVhmMDBtKzNZblZYWUpzTW1tcnRZa1hrZjdpVklhRFBvWkQvcEV5Z1pZSGxZaGkzdis4SkI5K0ZaRk1qbWVaZVM2dlB5b0F5YW82SXQvVkVLWTkveVdaRHI5S3N1bGFvZGF1MGZ4amowV0N4S05oQ3B5RjVEdmMwd3pFaVJBeEF3cGdraVJwR25qaWtSRFJ3TkNFTW9HVTdlb3h0ZS9FdE85cGlhanZqSGZoelZjQUtVS2twcThVZ1E0TlluNXJteVFPdjRaeXp1ZUVXckpJOHp1aUFTOUNDS3l1b3F3Wkp3eTRUSkpFWWdvaERudjFyVHlWQjQ5aDN2VzR4RkRIdkNzVHpGWUFxWXFDRU9wNEJ1by9pdm1sZjVORTdYa2ttNjdWTmhCRjlqcTBlZEtSVXljU2pXbEppdm93NzNsU2tqcmVHMXVzYjhqcldRSWVRS2dDSWFtVE05RHhkOGc3dVZkU2xsMU9zdjRUbVExRWFUb2UxSEVGbmFkUmRwVXkwWEZNaDE3NnRmbkFTQmVlTWtlNjhPWTcveEdxaWl4a1RLcEFibjJldkdNN3BlVGFHNFJhMmFEcjJTZkhaeVNyZWVvSnBub0Y2VUJnZWU0ZWlkQkFpdmlPRkNNTndNd2wvcE9TNytFaDVMN0RrcWhzRU9rNDYvVG5LZEpOVlduWkN6RGQ0QlBCL3JHNmtzRmo1aUNBRkNXVmZVeVlFc01aWmhaSnB4d25EY0l5ZkRhcEpGRVVKU2U2OE9acnFFS0FxaUNyU3Rybm5BNFBVK1c0QnNlWi9xMHFNcXFhTkVaL3ptZWYwY2xuNWhsSG5pYXFSSHFCTlRsUDVSbWpQbStrV1hvOG1JRTRqR3hUSjlMS2Nja1l3RndPU1VxN1I2RVFhcHAza1lsSkdTY0NZSlpsWXhDTjBCM215Uk9lbU5FOFowVE9wSjNNSkdoQ0tPUGJBMC93Y2RMUkdnTTM4eHMzVTM1V3hvR1VuejNqU0RMbzJmYlZpQnhFampRZEQrbmtlTWFNWTJTZDNJN0VjSG9mUnlJTE5kWXFjbVpFam9HbTNOTGNFdm9tcTB3bEI3MUdzTWxpalBkOHdGT1dsSk4xcXBJeWFIeTlteUVhTVVjWVRycG5MR2w0d0VBTXdDUkpIL2g3bkl5WXl4a25leWVYR1JnZUF3NEdPNTZmaXVwMHErUHBrcE5rVU9QNXFNYlQ0U0V4dmtXTlRZTWNHeGxuM2lJbkRja1I0MjAwRnUyZVk0UDI1RGlYVVRXa2xkWlVsYlpVbFVGVkdWa29keUlSeS9nR3Z5ekdNVVpKM0loVGlxeFRsWlNKNDFnS2pKSExLVTBscGZsOU9wNlN6am5PMVBXWFRsVkp4bFNWTXhRbkV4dEJhRHJIVVFDVFNVNHZ4NDFhMWJ4VVZZTHBIYUZpU2dkZ0FoamQ5MDMzZVF6b0dCd25zNnd5cHFSNWtuRDA5ZU1reC9lQWRKaTFLSTRSODVqL1RQbDV3akk2a3dZNWxvd3BLZGREU1daUVZka3p5V250Vm1GRUxnQW5rVVgvblBMYWNXa0djNklSdWFTcVRtL3RlS1orREl2VkdPdjV3RyttclIzWG0zR2tHZitIRWJtU2NIVEk4UkNBSmMxT2sxbXBzZEV4bUVPNGtVNEpPTW80RnpLQVlFUVdxcUo3bTVOTUpOaVlxWEpybXBMMExRRk9qQnVBcnF5dG81S0JrbmxPa0RQV3FpUnRPVzQwY3VWMkpPTVpuckhRYVFCbVdNaHBRQ1RIUTFYSTJGV2haMEhlVEtwVmtyR1h6cnlackRMOXJFMk8wNlV4czlFQm1EdXFTWnhTSldCU3hwbTJ6ekhDS0hQT0UyR1ZMdGNJRGVjNEFHQXhtek5wTldOazV5VjB0RE9PeVBwUlExUVp1Sm5PZUNTTlBRQU41TXpyeVdxcUFaZ1kyOXZhcWJsZmlkRkJNUTlnYzRwRlRnMDViaUFucHlNZXpUS3JmTkE3Y2htUkcybzgyME9mMlk1YzAydFZhVGRyTXJia3p5bjBaRnpra0dWZGxZNDkyZEkwTWh0N0FNNERjcXpkT2lveXFpckpJTWZ6bGh6TGFHN2xGZ0RJc3hnR29KRnhacFp4UHVqdk5DSVhjSk1tMlV3b09aaXlHb0RadDhBd0luZHdvMjhKOEFRRDBKRzFQOEo0MStaOFVGV245b3pOV2ZOVHRuNVVJM0lqRXRFTW5zdHBHSUNTTU9oTXppZWNiSlJWbndFNHZWbGRaTW80eGxadXVhL0hKZW5VRGNDTWUyN0xKbU93YzF4VTZlRTRDcVMySDAzM2FrWEoyRnA5WG1ZY1djNjZJRThHZ2dCbXMrbER4cWdSdVJSWlZkVklyN29Ca3R4UE9QcGVkS2FLc1pXY2VjWTZGeU4wUjNMOExjQzJyQXZ5aENvTTV6alhJOE5XYm5yMk9jNk1uRXhHam9HYm5BbVJqSjJTa2FOakt6Y0RKZk5Ua00ra09qNnR5Q25TcS9GOHV6QVFsUnNodThvelY1V3liTzEzU205bE5kYzBJbG5kaUlqUEdQbTVtbU1zK1ZqWC9ZV3dYdkRuTThoQ0V3QUhKQUZrYVNMUEdlYzdraVJOKzJkWmNnSEZteDhWMWdzMjNTK1o4NDJuTU1lbXBmd1ZINmY0MXA4TCsvb2JrUzBGYVoreExNdHA4REQ1WFE1aFNPMEJtUDZZOUtjdmNPQzRZdk9keFp0L0x2SlhmTnlZdWVaQW1EMW5VL2lsN3d2WFo3NHRaRmU1RHVhY0VUY2FCaURhQnFESlhZSDdzM2VKeFBuWEVYcmhoMUxpNUg3akNjMDJIbU1yeEhINUxhSmcxZFc2Mm1SVVJTRWE4RTdEZzZLT0dZRDVXZC9sRUEzNkVFSlE0SFFqU2RtOVFrdDFBMFUzL1VnTXQ3NU0rT1dISk1YZmF6eXhNejBwbVN4WTEzN3VjZnY2Ry85Y0tuRG95RENDNFhDQWFNQ0hTUE91emdrR1lIN1cxbEVoQk5HQWwxZzRnTlZWUXI3ZHFUbC9GcXk0Z3Z4bGw0akl6c2VKN1BpRkpPSlI0d21lZ2NoYmNqN09UL3kxTUpYVTZqbytIZzBUOVEraUpCUDZwajA5QjZtS1F0amJSeXpzeDFaWWdpWGZxc25ZSFpmY2lHMzFSaEhhL2pNcHV2dHBHRTl6Um55SVlTcXV3WFhWMTBYZWt2TjFIYThrNG9SOWd5U0dJMW1QYzlnS3VIQmwzZWlQYjBqMzdSYnJnZGNUU1lYZGg0N1IzTlkrTVNXbFI3UFZqcTJ3RkpOWjM4SzhaSDg3d1QvK1NJb2ZmZHQ0c2gvV3RGVGd3SEhKbDRSMTdlZDBMWmdVcWtvME1FUTA1TSsrZnNva3M2cHVJYXVYTDhac2toR3FHcEJrK1dMcHZ0MkNaRHoySzNOZS9uOERDRVdHMmJtdmpTT2QzUnBYS21GMUZtSnpGZXZlRXpCMjVHMkNmL3lSbE94dk41NzBCNFlZR2V1cXEzRisvQlloMjR0MGZXUTRGQ0RpRzBEVm1BVVdWVmR3OGFybE9Hd2pIWi85SGUrLzJicjl4Yi85dzBQLy9yWjAzMjdCbGcwTnJrMy9jUDlmTGx4MTdsZUtQTlVOQUwyRFBuYnNQVVR2WUhhVFQ1Wk5XTjNGV0oyRitocmJWWVhJcnQ4VGV2VVJTWTM0alFkL0dtRlowSWpyNm04S2krZHNYY2NuWWxIQ1EzMGs0N0dzeHhXNUhGeXlwcDZxc21JQUJrOTJ0TDMzOUJNdnYvcUxuendIdkFQMGpBTEhEaXdGR3ErNzg5N1BMcnZ3a2d1ZEpXWFZBRWM2dW5tMzlURCtVUFk1MEdUSncxNVVScDdOb2VzbXhIQ0kwUGFmL1NueXpoUG5DU1Zob0dBbVBNWmRnZk9LVzBWQm96Ny9URTBtQ0hzSGlJVURXWS9MdDFnNGYrWFoxQzllZ0N4SmhIMURmWWZmMi9IVy83djdqbWVBUHVCOTRCZ1FHZ1dPR1NnQkZnRzFRTWxmL2ZDeEd4WTJyVmtIb0tvcSs0NTBzR3YvVVdLSjdBL1pVbUREVVZ5T09VK2ZvNno0ZXdtKytHTXAydklTeGo0ckdyT1NPUi83UlY4UWp2VTNJT1Zwdi9wcFJCVVBFZkVOcFpYWDQ2eERvbUh4QXRhdVdFcEIvc2hPSk1mMzdYcjdrVzkrNVpGRWJOZ1BuQVJPQUlPTXZEVmFrZTdiUGZLd3RteG9zQUFPb0F5b0FTclBXcm5tRjlmY2RzZTdDeHFhemdNWWpzVjV0L1V3QjQ1Mm9tb3M1Q3B3Rm1JdktrTTI2U3VISlU2MDR2L0Q5NlhFaVZZREllbkdzLzVTWEorOFhaamNGZnI0WkNSSWFMQVhWVU5lVjVVWHMyNVZQYVZGTGdENjJvOGVlT21uRDl6Yi9QSnpKcUFyQlpnK1JscU14NVp5amdFbkJSNEpzQUJ1d0FOVUE1N3pycmx1NVNWZitQTFY1UXVYMUFONEF5RjI3RGxJWjArL0JtK1RzUldXWUhPWDZHeEJGVVQzdlVUZ3hhMkdnVGlhd1QxbjQ3cnFkcEcvY0xVK0JSdVBFUnJzSVI3Vmt0ZFdMbXhheHRMYVNnRDhmVDBkemE4ODk5cXpQL3JYVjRIZUZHQzZBVDhRbnpvZFRBTE9CQURKUUQ1UWxBSlFEVkMyOGJhL3Y3Unh3NVVYRjFYV0xBYm83T2xueDU0RGVBT2g3SE95MllLOXVJSUNoMXNmLzBuR0NPMzRUMEp2UERwdkRVVFo1c1o1MlZlRS9keHJRY2R5cEZHdkxScjBhc2hyRTAxMWkxalRzQVJ6NmgxbDdjMjdkano0dFJ0K0RneWtBSE1TR0FLR2diUnpYRnJnVEFDUUNiQUN4VUJWQ2tBbGYzSFB2MSs3OU55TExpaHdPSXRWSVRod3RJTjNXdzh6SEl0cjhCOHJqcEpLTEFYNlhzMm9CQWNKdnZxSUZOazFqd3hFMllSOTdXY1dPeSsvNWFpc3Mwd1FEWGdKZS90UUZTMTU3V0hkNm5xY3RwSHhQM21vZGZmVFA3aHZUWHZ6cnVzbjhKaCtSZ3JmV2I4c0szQW1BTWdNMklIU0ZIaXFYR1VWcjEvL3YvN3ROMmV0WEhNQlFDeVJZRmZyRWZZZFBvNnFaamNROCswdW5LVVZtQ3o2dG9STDlyZmpmLzRIMHZDUm5UbU5tZndsNTFONDlkZUZ1V3locnVQajBUREIvbTVkOG5yOXVTdW9MaThabDlmUC9OY3JyejcyME03VWRIUUM2RW54bUxndW9xNEhPQk1BbEFjNGdmSlJBdDEwK2RYSnk3OTA2NWFLUldjM0F2aERZWGJ1UGNpeEV6MGEvcUdFMVYyQ283aGM5OHJRNFNNNzhULy9BeW5aZnl5bkFHTXVyc0gxaWR1RXRmNVNmWms0bVNEWTM2VkxYcTlkdVl5R3BiVWo4dHJ2N1R2ODdwc1Q1ZldKRkFIMkFyR1p5Tm9aQVdjQ2djNVBFZWpLRklES3Iveks3ZXRXZmZ5YVMwdXFGeXdGNk9vYlpNZWUvUXg0QXhxWjJZeWpwQnlicTFpM2dSaDY3M2NFWG41WVV1ZDRCNktVWjhXMTRiOEx4OFhYNnk0VGhMMzloTDBEMnZKNlNTMXJHK3NteWV2LytMdGJmaEdQUm5yVHllc1pYL3RNZ1RPRlFGdFRCTG82OWEvMEMvLzRMeHZQUG0vZFJmYkM0bkloQklmYVQvRE92b05Fb3RuVHFUbXZBR2RaRmZrMnA2N3pxOE1oZ3E5dEk3VHoxOUtjTXhBbENkdXFxM0ZmdVZtWW5LWDZzbTNRUjNDZ0d5V1pmU2FwS2l0aDNlb0dTb3ZjWS9MNjVaOXQzYnIzcFdkOVUrVjFuU2VaYk9zeG45b3RuQ3B3cGhCb2U4cEFyQUdxTGZrRnpyLzg3c00zbmJWeXpVVUFpV1NTM2Z1UDBuem9mWklhQkM3ZjdzUlpYb1U1VDkrT0dFbHZGNEVYZnl4RjlyMDRKMTVHbTdlZ2tjS3J2eTd5RmpUcTg3ZGlVWUs5SjRsSHc5cnlldFZ5bHA1VlBTYXY5NzM2aDllZStlRjNYa3Z4bDBueXVzNlRGQUJuRERqYk5vMlUydHQ2ekpZSi9LY2FxRnAyNFlaSFAzbnpOL1pXbnIyOENTQVVpYkp6NzBHT0hEK3AvUmZwTHNGWldxSGJRSXgzdHVCOTdudFN2TE5sVmdMRzVDekZmZVd0d243T1JwMWRlRW1DL2QxRS9FUFpNN1hKUk5PeXhheFpzVlNYdks3ekpDZk5jV2NjT0ttTGtJQzhDUVppRFZEeHNSdHV1ZUM4YXo1M1dVbDFiUjFBNzZDWEhidGE2UjMwWnVjL3NnbEhpUWRiVWFsbUIrS29OSTNzK3lPK0Z4NlFGSC9QN0ppVlRCYWNGMTh2WEpkK1dWZVpBQ0VJZS9zSkRmWm9WNjlyUEt4YnZRS24zYVlwcitzOHliUmZOaXVBTStGaVpLQWd4WCtxVWhtbzdMbzc3LzNrcEFMcThaUHMzSHVBVUNTN3lXZXk1T0VzcThMcTB0YzJJQkl4Z20vK2lzRDJuNTFSQTlIYThERUtQL2sxWVM2cDBYVjhMQndnMEhlU1pHeFlRMTQ3V1g5dUk5VVZwWnJ5dXM2VG5SVE5LdUJNdUNnVFlFdnhuMUVDUGFtQW1sUVVtZzhlWmZmK0l5U1N5ZXo4d0dySFZWRkRudFd1MDBBY3dQL2lRMUpvOXpNZnFZRm9LVjlFMGNadmlJS2xGK2pqYWZFWWdkNFRESWV5dDVuazUxbFl1M0k1RFdjdkhKWFgvWWZmZlhOSEpuazl5bVBtSEhBbVhGemFBdXFmM2I1bFYvV3lGYXNCSXRGaDNtayt5S0ZqblpxN25WcGR4YmpLcTNVYmlJbStZM2lmKzU0MGZQaXREOWYwTFhEaXZ1SVc0VHovT2wxbEFxR3FCQWU2Q0EvMVpiMW5TWktvWDNJVzV6Y3RueVN2dDkxeDZ5OWo0VkR2QkI0ekFFUXpUVXR6RGpnVCtNKzBBdXE2Ni83aTNBcy9lLzJWWmJXTGxnRU1lUDNzMk5WS1Y5K0FCbitXY1pSVTRDajE2TzVBSEc1N0MrOXozNU1TZlIrd2dTaWJjS3o5N0JXRlY5ejhSOWxXcU9zakVkOGd3YjZUbXMzaGxlVWxYTHltY1pLOGZ1WG5ELzUrejR0UHQwNlIxNkU2VDNMR3ZzU3NCODRVL2pOYVFCMDFFTXV1L1p1N0xxKy8rTEtMM2VXZVdvQmpKN3JadWFjVmZ6QzdERFdaTGJqS2E3QVY2dk5EVUJXQzcvNFczNHNQZlNBR1lzR2ljeW5hK0EyUlY3Vk1uL3FMaHZEM2RCS1BoclRsOVRrTkxEMnJacUs4M3Y3TUQ3L3phalo1bmJQQW1jSi9yRlA1ejVlK3MvVnppODlaZTJHZTFlWlVWWlY5aDk1blYyc2JzYmgyQTVuYlU2dGpDYytvZ1JqRS84cC9FSHpyOFZNeUVNMkZIb28yZmtQWVZseXVqMjhsRXdSNlR4RHhEV2pMNitWTFdMT2libXg3dlpuSTY1d0h6b1FMTjAvZ1A5VkFsV2R4M1M4L2QrYzk3eXlvWDdrV1VnMWt6UWM1Y0tSZFZ3T1oyMU9ET1Y5ZkJUNDUySW52eFlla2NQTUx1Z3hFS2MrSys5SXZDOWY2NjVFczJsMk9RZ2hDQXowRSs3c1FHc1hmUlFzcVdiZTZFYWZqMU9YMXZBSE9GUDdqQWlwUzA1Zm52R3V1YTVyVVFPWVBzbU5YQzUzZHZab0dvcU9vREZkRmpXNERNZGJad3REVDM1VmltUXhFU2NMZTlBbUtQbm1iTUJkNmRIMW5OT0RGMzlOSk1xNGhyOTFPMXAvYlJMV25MSjI4N2dFNjljcnJlUVdjS1FES0J3b24rRC9sMHhySXVudlpzYXNGcnorb3dWbE5PTXVxY1pSNDlIVWdDa0c0K1FXOGYvaWhsUFNORzRoNVZjc28rZlFkSXIrMlNaK0tpMFh4ZDNjd0hQSnB5dXZ6Vmk1blJkMWlaRWtpRXZEMXQ3M3p4bW5KNjNrSm5Da0VlclNCckpwTURXUkgybm0zK1lCbUE1azVyd0IzWmUyTURNVEFHNzhnK043dnBjTEwvb2R3blBzcDBPRmNxNHBDc084a3djR2VyTk9FanV2dkFBQUR4a2xFUVZUZW1MeGUxVEJKWHYvMHpzMi9IQTRGVDB0ZXoydmdUT0UvMlJ2STRnbDJ0UnhpMzZHajJnMWtEaGVGbFdkaDBXa2d6aVRDUTMzNGV6cFFOVXpNeXZJU0xqNnZpZEtpd2pGNS9lcGpEejI5KzRXbjluMFE4dG9BenVTYjAyNGdDNGJadWJ1Rlk1MWRtdDluTHk3SFhiRkF0NEdZbFJ1RkEvaTYydlZWcjFjM3NuVGh1THh1ZWUyRjE1Lyt3ZjJ2TU5JYzN2bEJ5T3M1QTV4bjluMDB4Y1EzYnJ0Y1h3Tlo3d0J2L21rZkE5N3MvRUtTVGJqTHEzR1dWdW8yRUNlcHNVUU1YM2VITG5tOXFuNHBxMWZVWVRHYk5lWDEraCs5clBJUnhodTNYWDZHZ05QeTBWYWgzL2pxNWZvYXlONC96dHQ3OXhPSlpsYzBKa3NlYms4dGp1SnlYZWNYcWtxd3Z3dC8zd2tkOHJxS2RXdFc0bktNVEkxZGJmdDNQL1g5ZjA0cnI5Yy84UElaNmNaLzQ2dnpCRGdUYmxoZkExbHJHM3NQSE5ac0lNdXoyaW1zV3BoMUNVL0VQNGl2cTEyN09kenRZdjE1VGRSNHlqWGw5Zm9IWG81ekJ1T01BZWZabGpPN2NPNzFyMTZtM1VBV2pyQnpkeXVIMnpzMXY4L21McUdvYWlIbS9QRU94SGcwalBma01WM1Y2L09hNm1sY3RpUWxyLzBEYmUrOC9tWW1lWDNKQTYrYzhaYkYxNzk2MmZ3RVR1cm05VFdRRFF6eDFxNFd1alVMcUJMT3NpcWNKUjRDL1YzNjVQWFNoVnh3em9wSjh2cm5XMjc3WGlUZ1Y2Zks2MHNlZUdYV0xCS2IxOENaTUFpNkdzaU9kWGJ4MXE1OStJT2gwejVuWlhrcDY4OWJSV254dUx4KzdaY1BQNzNyK2Q5Tms5ZVhQUERLck91cU40QXplVERTTnBCOStWOGV2RzdScW5QUEh5K2dIdVZQK3c1b0ZsQXp5dXMxS3psNzRZSXhlZDI2L2NYWG4vcitQNmVWMTdOaFdwcFZ3Tm42MkJQTTF1aDQ2SzVwRFdTZXhYVy9tRnhBamZIdTNnUHNQL3krWmdGMVhGNmZ6ZXJHWlpuazlhaGFHZ0tHYTIrNVIyVVdSOGREZHhuQXlUQXdFeHZJUmd1b0ZkTUxxQUYyL0ttWmpxNWVEWG5kaE11Wmt0ZUhEK3g1Nm52L3RIcUt2QjRBUXJXMzNETW5GcnVmT2VBOCtodm14QUQ5NUI5SEc4Z0tVd1ppMmdKcVIxY1BPOTVyeHVzUFRKYlhhMWRSVTFtaEthOXJiNzQ3emh5S2pwLzhvd0djR1FCSXM0QzZ2KzE5bWc4Y3BuSFpFaHFYTHgyVjE0TnQ3N3orUmlaNVhYdnozWE51U3pFRE9ETWZNTTBDNnNRNHZtL1gyNC8rdysxM2gzMUR6cW55dXZibXUrZnNIaXdHY0U1OTROSVdVTmR2K3RMZmxOU2N0V2p3eFBGak81Lzh6MWQzUGY5azgxUjVYWHZ6M1hOKzE4c3pCcHhjaUV3N2NLUThvZUVVVUNiSjYvdTI3eGM1Y3UrbjlEa3pScEFDd2ZDV0RRMXhJSlNhZ2lvWmFXVU5wakxORURCODMvYjlxakZpQm5DbUFrZ0Z3bHMyTkF3RHZsUVdpZ1BSKzdidlR4b2pOQjcvSDF0QXdncTdIUEE1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwic3RhdGVcXFwiPjxkaXYgY2xhc3M9XFxcInN0YXRlLWl0ZW0gbW9uZXkgdGFibGVcXFwiPjxkaXYgY2xhc3M9XFxcIm1vbmV5LXN0YXRlIHRhYmxlLWNlbGxcXFwiPjxkaXYgY2xhc3M9XFxcImJ1dHRvblxcXCI+PHRhYmxlPjx0cj48dGQ+PHNwYW4gY2xhc3M9XFxcIm1vbmV5LW51bVxcXCIgY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIiBAa2V5dXA9XFxcImNoZWNrRGF0YVxcXCIgQGJsdXI9XFxcImNoYW5nZURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjM0Knpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwidXNlckJldC5iZXRtb25leVxcXCI+PC9zcGFuPjwvdGQ+PC90cj48L3RhYmxlPjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcInN0YXRlLWl0ZW0gcG9ydHJhaXRcXFwiPjxkaXYgY2xhc3M9XFxcInBvbHlnb25cXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiaGVhZHN0eWxlXFxcIj48c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoKydweCdcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodCsncHgnXFxcIj48ZGVmcz48cGF0dGVybiBpZD1cXFwiaW1hZ2VcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCI+PGltYWdlIHYtZWw6aW1hZ2U9XFxcInYtZWw6aW1hZ2VcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCI+PC9pbWFnZT48L3BhdHRlcm4+PC9kZWZzPjxwb2x5Z29uIHYtYmluZDpwb2ludHM9XFxcImhlYWRib3JkZXJcXFwiIGZpbGw9XFxcInVybCgjaW1hZ2UpXFxcIj48L3BvbHlnb24+PGltYWdlIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIgdi1iaW5kOnhsaW5rOmhyZWY9XFxcImhlYWRib3JkZXJpbWdcXFwiPjwvaW1hZ2U+PC9zdmc+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBzdGFycyB0YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwibW9uZXktc3RhdGUgdGFibGUtY2VsbFxcXCI+PGRpdiBjbGFzcz1cXFwiYnV0dG9uIHVuZG9cXFwiIEBjbGljaz1cXFwiY2FuY2VsYmV0XFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxCZXRNdWx0aXBsZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LThmZjQwNjdlL0JldE11bHRpcGxlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLm11bHRpcGxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuNik7XFxuICAgIGhlaWdodDogMTIlO1xcbn1cXG5cXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi50ZW4ge1xcbiAgICB3aWR0aDogMzQlO1xcbn1cXG5cXG5hLmJ1dHRvbiB7XFxuICAgIC8qd2lkdGg6IDEwMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xcbiAgICBmb250LXNpemU6IDJlbTtcXG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XFxuICAgIHBhZGRpbmc6IC4xZW0gMWVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/MzgwMzk3OWJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0lBQ0EsaUNBQUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxnQkFBQTtJQUNBLGdCQUFBO0lBQ0EsZUFBQTtJQUNBLHFCQUFBO0lBQ0Esb0VBQUE7SUFDQSxrQkFBQTtJQUNBLG1CQUFBO0NBQ0FcIixcImZpbGVcIjpcIkJldE11bHRpcGxlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOmAieaLqeS4i+azqOmDqOWIhlxcbiAgICBkaXYubXVsdGlwbGVcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEub25lXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMVhcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEuZml2ZVxcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDVYXFxuICAgICAgICBkaXYuYmV0LWJ1dHRvbi1hcmVhLnRlblxcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDEwWFxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge31cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLm11bHRpcGxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuNik7XFxuICAgIGhlaWdodDogMTIlO1xcbn1cXG5cXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi50ZW4ge1xcbiAgICB3aWR0aDogMzQlO1xcbn1cXG5cXG5hLmJ1dHRvbiB7XFxuICAgIC8qd2lkdGg6IDEwMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xcbiAgICBmb250LXNpemU6IDJlbTtcXG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XFxuICAgIHBhZGRpbmc6IC4xZW0gMWVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g6YCJ5oup5LiL5rOo6YOo5YiGXG4gICAgZGl2Lm11bHRpcGxlXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEub25lXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDFYXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEuZml2ZVxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiA1WFxuICAgICAgICBkaXYuYmV0LWJ1dHRvbi1hcmVhLnRlblxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiAxMFhcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuLm11bHRpcGxlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcbiAgICBoZWlnaHQ6IDEyJTtcbn1cblxuZGl2LmJldC1idXR0b24tYXJlYSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbmRpdi50ZW4ge1xuICAgIHdpZHRoOiAzNCU7XG59XG5cbmEuYnV0dG9uIHtcbiAgICAvKndpZHRoOiAxMDAlOyovXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIC8qYmFja2dyb3VuZDogI0NDQzsqL1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XG4gICAgcGFkZGluZzogLjFlbSAxZW07XG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEJldE11bHRpcGxlLnZ1ZT8zODAzOTc5YlxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtdWx0aXBsZVxcXCI+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIG9uZVxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+MVg8L2E+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIGZpdmVcXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLWNlbGxcXFwiPjxhIGNsYXNzPVxcXCJidXR0b25cXFwiPjVYPC9hPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJldC1idXR0b24tYXJlYSB0ZW5cXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLWNlbGxcXFwiPjxhIGNsYXNzPVxcXCJidXR0b25cXFwiPjEwWDwvYT48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWVzc2FnZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcTWVzc2FnZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMzNmZGI4MDcvTWVzc2FnZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuZGl2Lm1vZGVsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmdcIikgKyBcIik7XFxuICAgIHRvcDogMDtcXG4gICAgLypwYWRkaW5nOiAxMCUgNy41JTsqL1xcbn1cXG5cXG4ubWVzc2FnZS10cmFuc2l0aW9uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG59XFxuXFxuLm1lc3NhZ2UtZW50ZXIsXFxuLm1lc3NhZ2UtbGVhdmUge1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYudGl0bGUge1xcbiAgICBoZWlnaHQ6IDIwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbn1cXG5cXG5kaXYuY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi5jb250ZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjYpOyovXFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZT81ZDIzZDA1NlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0ZBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLGFBQUE7SUFDQSxtQ0FBQTtJQUNBLDBDQUFBO0lBQ0EsT0FBQTtJQUNBLHNCQUFBO0NBQ0E7O0FBRUE7SUFDQSxpQ0FBQTtJQUFBLHlCQUFBO0NBQ0E7O0FBRUE7O0lBRUEsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLHNCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxrQ0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJNZXNzYWdlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgZGl2Lm1vZGVsKHYtc2hvdz0nZGlhbG9nU2hvdycsdHJhbnNpdGlvbj1cXFwibWVzc2FnZVxcXCIpXFxuICAgICAgICBkaXYuZGlhbG9nKHYtYmluZDpzdHlsZT1cXFwiZGlhbG9nXFxcIilcXG4gICAgICAgICAgICBkaXYuY2xvc2Uodi1iaW5kOnN0eWxlPVxcXCJjbG9zZVxcXCIsQHRvdWNoZW5kPVxcXCJkaWFsb2dTaG93ID0gZmFsc2VcXFwiKVxcbiAgICAgICAgICAgIGRpdi5jb250ZW50KHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxuICAgICAgICAgICAgZGl2KHYtYmluZDppcz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVxcXCIsdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiKVxcbiAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVxcXCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS5iYWNrZ3JvdW5kXFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBkaWFsb2dTaG93OiBmYWxzZSxcXG4gICAgICAgICAgICBjdXJyZW50SW5kZXg6IDAsXFxuICAgICAgICAgICAgZGlhbG9nSW1nOiBbe1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmV0SW5mbycsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+aKleazqOiusOW9lS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvbnVzUmVjb3JkJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAncnVsZUludHJvZHVjZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWNoYXJnZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH1dXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBkaWFsb2coKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDU1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNzYwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNDAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0NSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY29udGVudCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNsb3NlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0MiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDg0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3VybCgnICsgdGhpcy5kaWFsb2dJbWdbdGhpcy5jdXJyZW50SW5kZXhdLmNsb3NlICsgJykgNTAlIDUwJSAvIGNvbnRhaW4gbm8tcmVwZWF0J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgZXZlbnRzOiB7XFxuICAgICAgICBzaG93TWVzc2FnZShldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nU2hvdyA9IHRydWVcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGV2ZW50XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgIGJldEluZm86IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZScpLFxcbiAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUnKSxcXG4gICAgICAgIGV4Y2hhbmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlJyksXFxuICAgICAgICBSZWNoYXJnZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZScpLFxcbiAgICAgICAgcnVsZUludHJvZHVjZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlJylcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuZGl2Lm1vZGVsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmcpO1xcbiAgICB0b3A6IDA7XFxuICAgIC8qcGFkZGluZzogMTAlIDcuNSU7Ki9cXG59XFxuXFxuLm1lc3NhZ2UtdHJhbnNpdGlvbiB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG59XFxuXFxuLm1lc3NhZ2UtZW50ZXIsXFxuLm1lc3NhZ2UtbGVhdmUge1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYudGl0bGUge1xcbiAgICBoZWlnaHQ6IDIwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbn1cXG5cXG5kaXYuY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi5jb250ZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjYpOyovXFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRk1UWkVRek13UkROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGTVRaRVF6TXdSVE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1V4TmtSRE16QkNNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rVXhOa1JETXpCRE0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K1gyeW1hd0FBQUE5SlJFRlVlTnBpWUdCZ21Ba1FZQUFBbmdDYW9NWExDd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgZGl2Lm1vZGVsKHYtc2hvdz0nZGlhbG9nU2hvdycsdHJhbnNpdGlvbj1cIm1lc3NhZ2VcIilcbiAgICAgICAgZGl2LmRpYWxvZyh2LWJpbmQ6c3R5bGU9XCJkaWFsb2dcIilcbiAgICAgICAgICAgIGRpdi5jbG9zZSh2LWJpbmQ6c3R5bGU9XCJjbG9zZVwiLEB0b3VjaGVuZD1cImRpYWxvZ1Nob3cgPSBmYWxzZVwiKVxuICAgICAgICAgICAgZGl2LmNvbnRlbnQodi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxuICAgICAgICAgICAgZGl2KHYtYmluZDppcz1cImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLnR5cGVcIix2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIix2LWJpbmQ6dXNlcmluZm89XCJ1c2VyaW5mb1wiKVxuICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS5iYWNrZ3JvdW5kXCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWFsb2dTaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcbiAgICAgICAgICAgIGRpYWxvZ0ltZzogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmV0SW5mbycsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9udXNSZWNvcmQnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5byA5aWW6K6w5b2VL+W8gOWlluiusOW9lS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3J1bGVJbnRyb2R1Y2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdleGNoYW5nZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVjaGFyZ2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBkaWFsb2coKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA1NTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNzYwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE0MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDQ1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDg0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndXJsKCcgKyB0aGlzLmRpYWxvZ0ltZ1t0aGlzLmN1cnJlbnRJbmRleF0uY2xvc2UgKyAnKSA1MCUgNTAlIC8gY29udGFpbiBuby1yZXBlYXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBzaG93TWVzc2FnZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaWFsb2dTaG93ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBldmVudFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIGJldEluZm86IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZScpLFxuICAgICAgICBib251c1JlY29yZDogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZScpLFxuICAgICAgICBleGNoYW5nZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZScpLFxuICAgICAgICBSZWNoYXJnZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZScpLFxuICAgICAgICBydWxlSW50cm9kdWNlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWUnKVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuZGl2Lm1vZGVsIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHotaW5kZXg6IDk5OTtcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMTIsMjYsNTUsLjM1KTsqL1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmcpO1xuICAgIHRvcDogMDtcbiAgICAvKnBhZGRpbmc6IDEwJSA3LjUlOyovXG59XG5cbi5tZXNzYWdlLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcbn1cblxuLm1lc3NhZ2UtZW50ZXIsXG4ubWVzc2FnZS1sZWF2ZSB7XG4gICAgb3BhY2l0eTogMDtcbn1cblxuZGl2LnRpdGxlIHtcbiAgICBoZWlnaHQ6IDIwJTtcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXG59XG5cbmRpdi5jbG9zZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG5kaXYuY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBNZXNzYWdlLnZ1ZT81ZDIzZDA1NlxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWlZQUFBTDRDQVlBQUFCUCtqd1pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dNRFZETkRZME1qTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd01EVkRORFkwTXpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBd05VTTBOalF3TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakF3TlVNME5qUXhNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtJaTJOK1FBQUdMTkpSRUZVZU5yczNRdHNYZlY5d1BHL24zSHNCRmdTVmxoNGRVQlIyTUxRSUJWVWlCWmFKbEpWdEJzcUt4cTA2Nm9LV0I5YXAwMmFxZ2wxNjRRMlRZTkpCUW4yVkVjN3VqS21sVEhveWxaYVZBMVVZQ3BoRFFYS0tJOE1LQ1JRSER2MnRYMjk4N3ZZMmZHNTV6Nzh1T1lHZno3U1g1QnpyNitkWTBmbjYzUCs1Mzk3Wm5mZG1aYWdOeHM3c25GZU5zN014dHV5c1RVYkk5bFlsd0NBdFdJeUcyUFoySk9OeDdQeFlEYnV5Y1lEMmFnMi9LanRPMHMzOXkveWt4K1RqVTlrNDlleWNhenZCUUNzZWV2bXhxYklqV3hjUExmOTJXeDhPUnMzWk9PNWRsK3N0ODNuYlo1NzRTZXo4WHVpQkFCbzRkaTVabmh5cmlFMnIxU1lYSktOSDJUak43TXhhRDhEQUlzd09OY1EwUksvMnVySi9TMGUrMEkycml4N3NQcVQxMUpsOXhOcGVzL3phZWJsZmFrNnVqK2xxZWswT3ozdFd3QUFhMFJQZjVZTEEvMnBkK09HMUxkbFUrcmZlblFhUFBYazFIdjRZY1duYnNuR1Y3THhybXg4S2h1bHdkRFRZUExyY0RiK0lSdnZLejR3dmVlRlZObTFPMDA4OEQzZkRRQ2cxTkNPMDlQZ2FhZG1vWEpVMmNOM3BEaDdzbjNuZUR0aEVtZEtic3ZHUmNVSHh1KytOMDNjOTZDOURRQzBGeWhubjVtR0x6aTM3S0hiVTB5VTNiNXp1aGdoUmRjWG8yVDZtVDFwN092M3BKa1hmbXdQQXdCdGl4TWFVMDg5blVZdVBELzFIN2MxLzlCRmM4MnhZTXBJY2ZKclRFcTVJcjloNnNrZnBkRmIvbG1VQUFCTE12UENTN1dXaUtZb3VDSTljdGVsamNKazgxeTVIRFQ5OUhOcC8yMTNwdG5KU1hzVkFGaXlhSWxvaW1pTGd1dXpPRG15TEV6K0tMMCtZL2Fnc1grN0o4MU9UTmliQU1EeTR5UnJpcGdhVWhBTHMzMitHQ2JIWmVOaitXZkZSTmM0OVFJQXNGSm1YbndwalgvajI4WE52NUVldWV1NGZKaGNsWTJCK1VkamJSSjMzd0FBblRCeC8wTzExc2dabUd1UldwakV1Q3ovNk9URHUrMDFBS0JqU2xyanN2VElYYjN6N3hKOHpQelc2cXV2cGNrSEg3YkhBSURPaFVuV0d0RWNPZEVpT3lKTXpzOXZyVHo2aEwwRkFIUmNTWE9jRjJGeVJuNUw0Wm9QQUVCSGxEVEhtUkVtcCtTM3hCdnlBUUIwV2tsem5CSmhjblIrUzNYL21EMEZBSFJjU1hNY0hXR3lNYjlsZHJKaVR3RUFIVmZTSEJzalRBWVhiSnFac2FjQWdNNnJiNDdCWG5zRkFPZ1d3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQW5kWnZGMENILzVGdFB5T3R2L1NqQi84ODg4eFRhZnpHUDZ2OWY4OFJtMVAvcWFjdCtiVm45anlicWsvL3NPN3o5V3c4N09DZlowZGZTOU9QUE5UK2J5dkhuNVQ2dGg2N1lOdjA3bDFwOXRXOWkvNjdsamx3eTkvV3ZwNTF2M0paR2p6enJHWHYzL25YbTdkU3I5dlcvczk5THdGaEFvZUVpSVNCazA4cC93ZVlSY25HejN4MnlhODlmdnR0YWVMbWhXRVNZWkQvZkxNSERxUlhQbnhSeS9pWU4zald1V25kMmVmVWZaNlpKeDhyZlg0K1dwcjlYZWROekVWVHo4aUdsczl0eDBRdXdsYnlkUUZoQW04SzhSdDdIQnpuOVIzNWxnV1A5MjNla29ZdXZ6SUxpaHM3OHZtbkh2M3ZCUWZtbnZYcmF5R1NQN015ZU81NzB2QkZGN2Y5bXMyZU8zcmROV25xUCsveGpRZUVDWFNqdUl6UTdEZjIzazJiYXdmNlRvVko5Y1huNi8raG4vSnpxVks0NVBObUZXZDI0Z3hQSnd5ZDg2N2E5dzhRSnJCbVRPOTVOczJPajVmL2d6M211Tm9aa0tZZi85ajM2ei91WjA5S2xkV0lndXhyYnhVRjhaeWxCa1E3WVJCbmJ6cDFCbWRnMjg4TEV4QW1zTFljK09yTkRRK3NHNis1dnVYOGliaGtFL05LOGdFejlPNExVOC93aHRTNzVjamFueWZ1dUsxaEZNVEJ0L2c1SnUvN1RwcDU2Y1dtb1RIL3VZdHpYbFl5SU5vSmc0RjNuSmY2VHV6TUhKTzREQWNJRXppa3hKMGFlVDNEdzZtL01ORzBVNWNhNWswLzkweGRYT1FudEk0Mmk0TExyNno3Mk1yOTl4NHk4MGdpU2hZemZ3WVFKdkNtVnJ4OU5INkRMOTU1MDZuNUpmT0tFMkFCaEFuUVVOeVZVN24zM3p2MitwUC9jbXZwSlpsT2E3WXVTOW1hSzUwUSs3WFJyYzNMdGY2U3krdk9mZ0hDQkE1NWNhbGhKUTZlL2NlL3RlNVc0QkRyaW94KzlwUExYc0J0MFY5UGszVlp5dFpjV2F6WjhiR1d6NGw5MGFrQUducWZTMFFnVE9BUTEzdlUxb1lIdWJJekdyRlNhN3NHZitFWDAvVFQ3emw0d0k5SUdibml0eFk4Snk3cmRQclMwVklzSlpwNmhrZGE3KzhtaThjdCsyc2VIcTc3YzZ4MnU1aVZkUUZoQW0rb2dWTzNMK3I1elE1eXJjNFl4Sm1DNGkzRmNmRHN4akJaN3FxM0RXTnRrWXZITGV2dmtBVlFyTFE3S2t4ZzVYNlpzd3VnZy8vQXN0L2U0NnhHVVZ6V3FMNzhVdDMycVNlYVg5NlorTnBYVTNWZjgvZXNtWHI4MGJxRFozd2RxeUhPOXNUZllUcDNDM0duemF6aTV3SldJZmp0QXVpYytPMjlOREJ1dnJGMnQwNStiWkRac2YycDhzMjdtcjVlbkUxNTlZb1BMWGlqdnVLQmVmcnBwK3BpS0w2Ty9QeU9abSsyVjdaV1IwejZiRFMvSXY4bWV2SGZPSHRRZGlkU0owU2tWZGZJaXJZZ1RJRGxoOGtaYjIvNFdObDZHeU9YZm1UUm55UGVxeVovY0o3KzNnTXBGVjUzL1FYdnJkMmxjekNNN3JodFVYZnNOTHNUcGZnbWVzc1JDOFBGR2l4dFBYZDhySFlHcVN6NkZuUHBhdE90ZHkvNGM1enhpWW5EZ0RDQk41VzRmUEpHM0ZvYVp5MktLNy9HLytkRFpLSkw5MWxFeVhLaklDYlZidnpjbjlidCsvMS9lWDJxZk9OcnkzcnRlSVBHZUMra3ZNcUQ5NmZKZi9xU0gzZ1FKdERkR2wzR1dRMHh6NlJzYnN0YUVMZEs3Ny91bW5UNDU2OWRFR2NiUHA0Rno4Zi9QM3BhdlN0eVdZUVV6ekxGWEpwV2w5OEFZUUpkSWQ1d2JsVU94Q1czRjhjbGpvRzNiV3Y0aG4vVHUzZlZEc3lsUVhYV3VRdVdydzh4V2JmUnVpdnhXdDBtTG0zdHYvRzZaYzF6NlJuWjBQSnkxL2hmMzFBTElVQ1lRRmVMeVordDNtd3U1a0hFS3FWbGEyN0V3VDUvd0l2ZjNzdm1uNHpkOHNYUzI0dGoyeXNmdnFqMmRUUTZxOURvYkVIWkcrQkZsQndxNzVVekw3N2VzYU8ycHVFUFhOTHlIWm1YSW1MTitpVWdUS0RydGZNT3dBY0Q0U2V2cFBYWmIvWEYrUkJ4aVdEMGM3OWJDNGhtVWRKcWJrTWNuT1ByS2R1K0ZzVCtpVkcyNkZxck16M05scmFQczFTaUJJUUpISkxpTG85R29WSmJPajRMa09Ka3pmai8yRlo1Nkx1bGk0WEZiK3Z0VExpTTI0TEw1a1dzTlJFbHhUTkJjWnYxWWkvREZNOWtBY0lFRHIzZjJyOTFkOU16S00zaXBPeXVuc243dnRQMjdiRDlwKytvUDdqKzRQdHJhdi9IWFRvYnJ2ek1nc3M1RVl1dDltSEVUSEdPeXV2djkzT2pIMnJvSUN1L3dncUxCY2RpWW1tTVYzL25xclp1VVoyUGsxWm5NeUpLeHE3OWc3YS9sdnphSlFmRDVIL1cxb0prNnovMDYzVnpUTVp1K3ZPV0h4ZVh1NG9yOGNaNk1CRTZnRENCUTBiTVBhZ2QxTEt4bUZWSlc4Vko1ZUgvV2xTVXhBRzA3RXpOMUhlL3MyYStGM0VwYStqZEZ5N1lWbnM3Z0RhL0w3RVEzWUo5bWdWT2hBNGdUR0JONkR2MmhOUzNhVXZwWTNIN2J4eG8yelh3OW5QcW8ya0o4eXBXVTluN0J5MGxSdUp1cE1GZmVuOGEvdGduRnI3K3ZyMTFsMkppTWJwR0lpN2pMRlZlaEU2anU1MkFGZmlGd2k2QWxUZDArWlV0bnhOMzI4UmFHWG0xU3dVTmJtMk43WWRkL2NlMUEyWCtQWGFLdC9MR1hUaXhYSHVFVEYyWXpNMHZLUzdEM2twdHJrV0ROVUhhWGNJOXZ5eCtvK2ZIK2ltRGYzZjdvbTd2TFM2VUZ1OEIxR2hPejlnWGIzbzkyckt3bUo4TTIrcHpIYmp0eTNYcnVzVCtxSDdraXRvdDRmcytlSUVmZUJBbTBOM0s3cVFwaWxWRlc5MVdYSFpIVDluaVova0RjN1BYblBueGkyL1lQaWt1aTkvc2VaMFFRVGUvbjhyZXAyaGVSRjFlWFBhSmp5M3U5MWJyMUFCTDQxSU9yTExpaE1wR0lqaml6RUs4eDB1enl3M3RpdGRZcmVYVHkxYWpyWXVrVmJ4dE9TN2h4Sm1QdHI0L3V4K3AyeFlmdXhMZkE2QTFaMHhnRmNVRTFySjN4TTJMZVNDVDkzN3o0RG9sY1ZkUDlmbm4wdEQ3TDBrOXd5UDFFVEMyditYbmpkZk1MNS9lYmh5MVkrYVpwK28vM3lNUGxaNWxLSjZKbVBpUHI2ZDE3M2puaXA0bGFlZXlVbHoraXZBcjIxNjIrRng4cmE5KytxT3AvOVRUL0JCRGgvWE03cnB6TnI5aDN4OWVhNjhBQUt0aTA5Vy92ZURQTHVVQUFGMURtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQXJKRCtidjhDWjdPeHJ6SlZHNk5UTTZsU3JkYTJBUUN0OWZYMHBNSGVualRTMzVjMkRRN1VSbzh3V1pxSWthZkhKOUxFVE5WUEZnQXN3Y3pzYkRvd0U2T2FYcDZjU2tOOXZlbjQ0YUZhb0hTanJyeVVFMmRFSWtnZUd4MFhKUUN3Z3VLNEdzZlhPTTUyNHhXSXJneVRaN0tkOWI4SEp2MzBBRUNIeEhFMmpyZkNwSVc5bFNsUkFnQ3JGQ2R4M0JVbURjUXBwUitOVGZoSkFZQlZFc2ZkYnJxazAxVmhzbmR5cW5iWERRQ3dPdUs0RzVOaWhVbUpmVjEyT2drQTFvSlhLc0trMVA3cEdUOGRBTENHajc5ZEZTWlRzeTdqQU1CcTY2WnBGRjBWSmxWTHVnTEFxalA1RlFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRmlGd0FBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbWRnRUFJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoWWhjQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDcEF2MDlmVDRqZ0RBS3V1bW8yOVhoY2xBcnpBQmdOVTIyTnM5T2RCVllUTFMxK2VuQXdCVzJZYis3am4rZGxXWWJCb2M4Tk1CQUt2c3A3cm8rTnRWWWJKNTNVQlhuVTRDZ0RlN09PNXVGaWJsWW9iSkNTTkRma29BWUpYRWNiZWJwbmgyM2VtSnFMYWZXYi9PVHdvQWRGZ2NiemQzMlRTS3JyeHVjdHp3VURwcWFOQlBEQUIwU0J4bjQzamJiZnE3Y1dmRkdhVzNqcXhQaHczMHAyZkdKOUxFVE5WUEVBQ3NnS0crM2xxUWJPN1NHMDc2dTNubnhVNkxPM1gyVGs2bGZaV3B0SDk2SmxXcTFUVHI1d29BMnY1bFB5YTR4aTNCY1V5TkcwMjZlZFd3L2tOaGgyN0pkbUlNQU9ETnpiMjVBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFvRDVNS2d1MjlQWFpLd0JBNTlVM1J5WENaRFMvcFdmZG9CMEZBSFJjU1hPTVJwZzhuOS9TdTJIRW5nSUFPcTZrT1o2UE1Ia3N2NlZ2eXlaN0NnRG91SkxtZUN6QzVLSDhsdjZ0UjlsVEFFREg5Vzg5dXJqcHdRaVRlL0piQnJlOXpaNENBRHB1Y052SnhVMzNSSmg4Tnh2UHpXL3BQZUt3TkxUamRIc0xBT2lZYUkxb2pweG9rUWNpVEtyWitOS0Nnam50VkhzTUFPaVlrdGI0VXRxK3N6cS93Tm9OS2JlZVNjd3pHVHI3VEhzTkFGaHgwUmlGT2EyVnVSWTV1UEpybkQ3NXEvd3poaTg0Ti9XOTVVaDdEd0JZTVgwL3ZhWFdHQVYvazdidmZDNGZKdUhxYk96TlAydmt3dk5TejlDUXZRZ0FMRnMweGNqTzg0dWJvejErZi80UHZZVUhQcGwvWnYveHg2UU5GNzgzOVF3TzJKc0F3TktqWk4xZ3JTbWlMUW8rbmJidjNGc1dKdUVyMmJncHYySGd4QlBTeGt0LzJXVWRBR0JKb2lFMmZ1Z0R0YVlvK0lzc1N2NStRY0RNN3JxeitLUll1UDdXYkZ4VWZHRDg3bStuaWZzZXNvY0JnTFlNblgxR0dyN2duV1VQM1o2TkQyWmhVbWtWSm1FNEcvK1lqWjNGQjZiM3ZKQXF1M2FuaVFlK1oyOERBT1ZCc3VQMDJpM0JEVmFVLzlkc1hKSkZ5WGp4Z1VaaEVtSml5UmV5Y1VYWmc5VlhmNUlxai80d0M1WG4wOHpMKzFKMWRIK2FuY3lpcDFyMTNRQ0F0YUszdHpaL3BIZmpodHA3MzhReTg0UGJUa3E5Unh6ZTZDTml5c2luc2lpWktudXd2OG1uaWcrNE1odmZtZ3VVTFF1K2p1d1R4dWtaQUlBMnZKeGlvbXRLdHpUdG5EWmVLQ2JFYnN2R2pTbTNDQnNBUUJzcWN3MnhyVldVdEJzbTg1VnpWVFpPek1hZlpHT1AvUXdBTkxGbnJobE9uR3VJbDl2NW9HWnpURm9Gelk1c3hDb3BjVDBuM3BJNGJremVrRjZmbXdJQXJBMHg5V04vZW4wVitjZXpFYmZ2ZmpNYkQ2VFgzNCt2M1BhZHBadi9UNEFCQU1GblkrM0Z0MXFJQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/mipXms6jorrDlvZUucG5nXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG93TkVKR09UTXhSRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dORUpHT1RNeFJUTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQXdOVU0wTmpRME0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pBMFFrWTVNekZETTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTWZ0aG5BQUFCbEpKUkVGVWVOckVtVmxzVkdVVXg4OTM3OHlkbVU1bm9LVXQzVWpwZ3RvQXJZWkFVR01VeEFlTW9ManlJZzg4NFBMZzh1cUxUMFo5MGNSRTNHSkl3QVNDUkEySU1aSGx4YmdBQm1sa0d6cWxoZEtPTGRCMnByUGMzWE5tdnFsVE9uUG4zcGxwK1pML0xIZnVkNy9mUFhPK2M3N3pYZmJKcW5Zb28wbW9CMUViVUQyb2UxQk5xR3IrK3pScUZCVkM5YUZPb241SEtka0xuSWdQT3hyUVZTTG9BNmhYVWMramFpM09xK1ZhaWRxR2VoYzFnZm9XOVRucXJOT0JCWWZuOTZLT292NUM3U29DVzZqVjhMNTBqWjgyK2x0NzV3UFlpL29JZFFiMUpJcEIrWTJ1c1ptdWlkQWZvN3lWQXU1Qy9ZRjZ1d3dYS3VhV2I5RVlDTjFWRnJBSjVqbytTWHBoL2h1TjhlY0dmOHY2a29BUmRqMERkZ0kvMXNIQ3RWb2M4NWdWZEY1Z0E4d1YyUEVJZnZURHdqYy9qZjJZdjJXRkxXRFoxSDNZNGRBQ1cvYk9Wa2NNRDFjMStZckdZVGNUUG1TWkpERDMvMnBZQ284L3N4M3FtMXFnLy93NU9IbjRFS2lLN0N6VGVMMndZZXNMMEg3dlNyZ1pHWUhqUHh5QWlmR3hmQ0drQjFrK3dJOXY1aDRYTnpmVXpIeFJUV09OaXdsZjVMUDhrcVZOOE96TzE2R21yZ0VFUVlDNnhtWm9YdDRKL2YrY0EwUFhiY00rdmVNVmFGdHhINGlpQ0lGRmk2RnJaUzhNaGk1QUtoSFBBODNXdExxcmoxNVRZNk56WEFKVEpCTVplNzlRNk5xMGJUdjQvTld6ampXM3RjUFdIYnZBTFhsc3d6WXVhNXQxdktvNmdQL2FTd1ZESG1kaWM0RFJYOVlKd0RZVlRFLzFEWG1QWjZFbGo4Y3g3SXlyMVRkYWhESDJCTEhOQWs1YkY5Z2JWaGxzS0hTcDRFVUplc3ZMK2FHTHdWSzdldm04WlViTVpVc0R0MHZCZ01pRUxWYTlhSEtNREYxMUJHMEg5c1pnT0QxNXJScXhFZU1NY0lQb2V3VHhBMWFkRkZtR0kvdSt0QTF0Ri9idzNxOUFVNVZpaTQ0QU1hYmhQZjY0c0Z3S3ZvYlJZWDJ4aWFOak5BaGpPR3R1NjRUQTRwcTg1OUJ4K3IzNy9yVVZnZjAvODhMWWRYWDZGN0t3R3gyN3gyNGN0V3ZwU3NMeXlkZVRZUVh3Q0l3NUtqdnNRRmNTTmcyY1lmUVFzSVF2UzV3T1hBcDBxYkI4c2kzaHJKUW9XRlVwQ2Q4SmREbXdmT29SbzR1QXhmTHFCcFpPMWNWUEUvQzhzZ3NWa1VaaXVQWk5sbFF5MndoZGRwS0x2U2lSWm1ScDB4aW1PVFdmc0pXQXpqSVNzS21DTVRMZnNPVkNjMGFUZ0hYRk1NS1ZoS1VKNWpTTkY1M2dHVWFkZ0xVcFF6NVRTVmlLQms3U3VKMkdqTFNQb1JHd01xeE9uekdLVER5bmF3T25hdzlML3dVemhXbVpqS29Rc0p3eTlkdHhRenR0MVduajFoY2RwMXU3MEk4Kzlad2xNTEtkd2xyekZyRUthWDhHaUk1cThSK3RPblYwcnlvcEtkaUI3dWhlYlFrY3liQkZpVlhZNkc4MWFKY1IzZUowMHRBdUZ1bzBIcmxSY2dZckJrM0ZhS0ZHVE9nT3AvbE9xSkZOVVZRQmpnMnBzVzlNY3BsOEMvanZEMEJpT2xaeXVpMEVIWTlGNGRoMyt3c3RLUTFrMmtkc25ERlROVjlWb3dUSllvYXExNHFlVnEvZ21yTjZTOGJqV0NaZFRKZjRrdVNGOElVKytQbmdQa2RyZyt4NmVsRk5IVlFIRjhINDZEQWMzYjhIcG03ZHpCOFpkUGxrU0prOFNGVVVLbTB0bHQzUXhycU9kZzg3SkNhdVhlZHJlQS9mVys3aVJnb29wajV5S2puMkRyNlRPd3lnVW5mdS9OQ09TQVJQR0xnb1Qreld3WXpmTFZnYUd4aytKUlppNG15enkzeWNmQ1kzKytBdFBmWDNGWG55TTF4d0tBc05TMlBTMk1SQUxKekp6THZ6ZzVXcGdmNU1ZYzVBZjVZVjA0alV1cnk5REpoN0lXQXhRU1JDOHVUdUVTMytHMzY5REpubkk3TGwzaHIzRllwaGJ1d29ZTUJPZEh0cWRxSlBOOCszejZJYjdPR1dEWEdHMUp3RmNhNkZ1WldCVzVsU3RaWTBOWFZVUzV3UENwSWZvOGN5VnBuSEJiTkMxNlF1LzNvMk5mNzF0S0ZlNHBZZDRtSE1MQXA4QjNTQzdoTC9Lak9pSlFZU3B0cGZMVWkxYmlaVVpDczJZV2lYUXNyRTNyQXlkUnpIR09TdzF3dkJGbktKbVVtSW9ZNDZYdVBnc1RFdEdVY05MSFZWZGJXNC9BOEZSV20xNExBZXBFVldWRmY2YnFDZi9xc2wraUh6R0d5WVQ3Q2IzQTNNZ3J1RGxndWVUT1JJSW5pRTN6VXRRRnB3b0NuVUZaRXhmNlBMMzRuSnB0UEhYRTBlSnRianNTQk9VaWs3NDNYVGpPSThHRWZYR3IydHkyRmNGNFR4V0p5dkRjYTRyMFo0TkZDTDFvWjJuNFRTaGlIdEM2Q0NmSGUrSGpLbE4rM0JVdEp4YzRrNW00cG1PcXhtUUZSdXZXbCs0K1Bjb2xFZUNVdzdIQzRIajA1TlBpQmRmSXFIbkFDL2dRQUg5K1ZBUXc1c2tvUEdPR0NNdTVsaUY5U1dTMWlBeXpuZ2JtNTVpVjh2bjRVMURpZnpHekJLbmFqL0NUQUF3ZFEvSVBoQ2FoOEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWlZQUFBTDRDQVlBQUFCUCtqd1pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeU5UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE15TmpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBMFFrWTVNekl6TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16STBNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNOFpLM2dBQUYreEpSRUZVZU5yczNXMXNYZmRkd1BHLzdkaHhZaWVPNHp3M2JacDJUUisyMGFwTml4Z3dtbW9JbFk1cUV0QkZyQUtKYVhRZGRDLzZBbmdCVEJXOFlMem9tMnF3ZHNDRVZOUlFpaERWcWdpQlNEZWdFMzFZMjYzclU3WTJhWk00YVp3SHgzbHc3Q1RtL0c1eTArdmpjKzFyKzE3bnB2bDhwUDhMbjN2dE9DZFhPdCtjOHovLzAvTEVPMk5wQmxxemNXczJObVZqWXpZMlpPT3liSFJsWTM0Q0FDNFZKN054TEJ1N3MvRjJObDdNeHJac3ZKQ05NOVcrYWZQNjR1MHQwd3lUdGRuNC9XeDhJUnVYKzdjQUFLcDRQeHYvbUkxdlpHTlhyV0hTV3VNUDd6djNnMythalQ4V0pRREFGQzQvMXd3L1BkY1FmYlY4VXkxaGNrODIzc3pHVjdMUllUOERBTlBRY2E0aG9pVStQOVdiNTAzeDJpUForSExSaTBlR1I5UDJmVWRTLytEeGRQRFlTRHA2Y2pTZE9uMG1uVG96NXA4QUFDNFI4MXBiMHJ5MjF0UTl2ejB0N2VwSXEzc1dwbXRXTGs2TE85dnpiMTJXalMzWnVEMGJEMlRqVk5IUHF6YkhaR0UyL2lrYm44Mi9zSGZ3UkhxOS8zQjY1ZjJEL2pVQWdFSTNYYjQwM2JCNlNWclZzNkRvNWU5azQvT2IxNmZqdFlSSm5DbjVsMnpjblgvaGUyL3ZTeS91SExDM0FZQ2FiRnkzTEgxNnc4cWlsNTdPeHE5bmNYSnFxakQ1WmpidXE5eXcrOUR4dE8ydC92VEIwTEE5REFCTXkvSkZuZW1PYTFlbnkzb1g1bDk2TkF1VEwwOFdKakVwWlV2bGhoMEhqcVpuZnJncm5UeDEycDRGQUdaay9yeTJkTmZQckUxWDluWG5YL3F0TEU2ZUtBcVR1STBuWnN3dUsyL1lkZWg0ZXZyVjk5THdxQ2dCQUdhbnM3MHQzWDNqRldudCtETW5NV24xdWl4TzlzY1hsYmNMLzBWbGxJUzRmQ05LQUlCNmlLYlk5bVovZnZQU2JQeDUrWXR5bUZ5UmpTOVd2aXNtdXU0M3B3UUFxS1A5UjRmVGQ5L2VtOS84dTF2ZUxiWEkrVEM1UHh2bmJ6anVIenpoN2hzQW9DRmUybm1nMUJvVjJzKzFTQ2xNWXR4YitlcnJldzdiYXdCQXd4UzB4cjFiM2sydDVhY0VyeTF2UFhKaU5MMjZ5K0pwQUVEalJHdEVjMVNJRnJrMXd1U095cTNiUHpoaWJ3RUFEVmZRSEpzaVRHNnAzQkxQdmdFQWFMU0M1dGdZWVhKdDVaWjRJQjhBUUtNVk5NZTFFU2FySzdjY096bHFUd0VBRFZmUUhLc2pUQlpWYmhrNWZjYWVBZ0FhcnFBNUZrV1lkRlJ1T1gxbXpKNENBQnF1b0RrNld1MFdBS0JaQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFOTm84dXdEcTY4R055K2YwejN0ai80bTBkZWZSY2R2dVhOYzk3dXZLMS9PLzM5YWZES1kzRG8rTSs5N3JseTg0Ly9XZUl5TnB5OXVETmYwdW4xcTVJTjMzc3lzbmZjK2ovN2N2UGJmdlJQclNKNWVtWDFpL2VOWi8vL0xQSzZ2WHo2M0ZPd1BENmFIbjl2clFnekNCNXJYNTVoVnordWR0K2NFSEU4Sms4NDNMMHZXcnVzNS92ZVBKN2VmakkvLzdSZGhVaGtuK2UrUG41ME1uci96bjkzUzJqZnZlSXZHZXNHaisxTyt0UmZubmxkWHI1d0xDQktpVGZVTWo0dzdPTjY1WU1DNCtxcmwrU2NlRWczb3RvYlgxc1IvYjZZQXdBWXJ0SFJvZDkvV2QxL1dtTllzNzBzTXY3aTk4LzljK3RTcGR0YXd6TGUvdXVPai83bkVHS003eU5NSm5OdlNtWmQzdFBtQWdUSURwSHB3cnhWbVFHTlhDSktLa0hwYy9kZ3lPVEJrRjhaNlpCa1F0WVJDWGxmS1h0dXJseGpWZHdnU0VDVnhjYmp0M1dlTWY3cjV5d3NIK2EvKytjMFlIelpqajhkQ3ZyQnNmSDN1UHBkOTVlc2VrQi85WkIwNzJaMVNLTXlyNUEvTjdCNGMvZlAvaGtmUkdsZmlwUjBEVUVnYjV5YnYxOUZFNG93VENCSmh6RVFqUHZIWWdiZHF3SkMzc2FKdnkvWEYzU2Q2cmU0Nk5POE95b3JNdFBibjVtZ252KzdzWDlqWFYzejJpWks0bklBUENCSmhDM01aYTY2MnNUNzUrTUYzWk0vNXN3T0R3NlhGZjMzL3o4Z21SOCt6MlF3MjdiQUlJRStBU2RlZkhlZ3JQTXBRdlBjWGxrYnMrMFRmdXRlTWpwOU8zWHg0WXR5M09xdHl5c3ZneVNseGVxdVhPb05rcXJjdVNtMk5UTDErOGRXVzZZbW1uRHd3SUUyQW04Z3VleGVXWjZmaTE2M3BMWWZMQXo2K1o4TnJUcngyWUVCb1JKZm01TUdVeDBiWFcrU2ZWSER0NWVzcjNsT2E1TkNpQVlvMFhRSmdBTS9TNUczckhUY0RkK3VhaHd2Y05aUWY4OGtUWHl2ZHZYTGM0L2RXbU5STW1uQTRjSFUyUHYzWndWci9iWkdkWHF1bWFQL1Y4bVZpTEpYOVpxbDY2Y3BleTR1dUl2OHFWWndGaEFsUTU4TisyN3NPbDJlUFNTeXd0LytEdGF5ZTg5MXMvT2xnYTRhbmZ1SHJjNVlyYnIrbWQ4UDUvL2RGQSttRDQ5S3grdjhuT3JzeEd0Y3RTalJEN0tjNUlQVmZsN2loQW1NQUZGODlxaVdYUmkyNHQzWFRWNGhuZHlycHEwY1JiWk9QbngzTnY4cy9LaWYvQjMzdlRzdExaaGNySnFzL3ZQRkwxNXhmZDJseE5uRmtwUjB4ZVRKaU4xK05Nd2x6TnhhalhyZEdBTUlHUHBIaUFYTFdEZk5IWmg1bUt5eXR4WmlEL3JKeDRkc3pHZFJNZll2ZUQzY2ZxOHVkdWVYV2c2bXR4U1NQT0hoU3R1OUlJY1VscExpYlVBc0lFcUtQeVpaelppclZSR25sN2NQeWVPdzhPMS9UZW1BajcrQ3NUSXluV1hubDRHcE5zbi8rOWo0LzdlcktGNndCaEFreFQrWEpLcGNxekhQblg0djFGQzZ6bC9jKzdSNnBld3FtWGlKTFpSa0hNcmZucnoxNDU0VkxTdzgvdW1uV2N4V1c2T0NNMjEvc0ZoQWx3MFNwZlRxbW04c0FmZDdERVpOR2hrZFBuYnlYT3oxbTUyTVNrM0QvOXovZlQzM3p1cW5GemJHTFNiK1hFMzZrZUQxQVVJZmxMZExFYy83OXRIL1NoQTJFQ3phdDg0TCtRejhxcFZkeFdtNytESlQ5bjVXSVU4MDYrdm0zWHJPYTV4QVRtcVNZRVAvemZlMlo5ZHhJZ1RPQWpiYllUVHlOVXBuTzdiWVRNdzdOY09LMFJJcTdXZnI4L2ZlR1dGVFU5TDJpNjR1OXQvUklRSmdBMUs2L1BVclRvMmt0VFJNVmtTOXZIdkJ4UkFzSUVZRVlpU3ZMcng4VDZKOU85REJNeDQ5SU5DQk9BR1l1N2RQNW8wOXB4bDNOaWZzNVVsNThpWnZLWHhKcjFzaFVJRTZCcHhkeUtyWS85ZU5MM3hCMG5YL3E1MVpPK0orNDQrY3AzZGx6MFp3anV2M241aERrbWYvbTlQVFh0eDgxWndGUk9nTDM3RTMybFp3UTVhd0tOMDJvWHdLVWxIc28zVlpTRVdBY2sxZ09KTXc0WHExaWUvNjRzSmlxVm5uSmM0MnF4K1ZWdUkzQWlkQUJoQWhlZFdKbTBtVVJneEMzTVJjdmlQN3Y5VU9tQWZhSGpaTi9RN0plWGp4aUpPNU0yYitoSkQvN2ltbkd2eFJMMitVc3hzZHBzTlhIV0pQWk5wUWlkK1BsQVk3aVVBM1ZXZm9qZmxYMExMc2lmWDE0MExlOHpHM3BMejljcGlwSS8zSGIyMHNaUUZsUDVzeW5sT0hucWh3TnBzQ0MyWWhKcExXY2c0akxJald2T1hoYXB0djVLUk5PejZ4WlA2L2JlL05vdzhiVGZhdXVQUFBLL1ovK2VFUmJseWJCVC9WbmZmbmxnUXN6RjNKTUhzc2lKL1huYkZKZk5BR0VDRjlSa0QvR2JDMFdMcGxVVHo3NTU2TG05NTc4dUw2MWVGQ2VWcTZaV0tsMGFxV0ZDYUFSQUxmdWxFV3VPbEFPc0hEQVJKZFgyVWY1TVYwUlhmRzgrVG9vaUQ1ZzlsM0pnRHNYWmhXYnhyZS8zajR1U3lqaUoxMlpqc0liSm9YTzVMK0lTVHB6NXFNWExleVkraFRtK2Q3SkxQa0Q5T0dNQ2N5VCsxMTNycE11aUEzMys0WHUxUEhndnIvejAzcTF2SHByMGdYWVJKM0ZaNTdjM3JwelJtWUZZZkt6b0xFUCtURVNjc2RtMFlVbGR6NUxVc2t4L0xKeFdOS2VtMm5PQzRuZTlaOHYyZE12S0JUN0kwR0F0VDd3ek5sYTU0ZUgvY0wwVVppTW1YL2JrSm92V09nK2pHY1hFMThrT3lCZnozdzI0OEI3ODVZK1ArOW9aRTZpemo5cFM1YkZteDhYK1VEL2c0bUdPQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQkFuY3hyOWw5d2JHd3NIVHQ4SUJzSDAvQ3hvWFJxZEtTMERRQ1lXbXRyVzVyWDBaSG1MK2hLWFV2NnNyRTB0YlMwQ0pPWmlCZ1oyTDBqalo0Yzlza0NnQms0YytaMEdoaytVUnBEaHdaUysvek8xSGZadXRTZFJVcFRobFJUL2xaalkrbkE3cDJwLzUwM1JRa0ExRkVjVi9lKzgxYnBPSnVhOEFwRVU0YkpnVDN2cFVQN2R2djBBRUNEeEhFMmpyZkNaQXBIRHg4UUpRQXdSM0VTeDExaFVrVk1haDE0LzEyZkZBQ1lJM0hjYmFhYlNwb3FUSTRlR2lqZGRRTUF6STA0N3NieFY1Z1VpTHR3QUlCTDkvamJWR0V5ZlB5b1R3Y0FYTUxIMzZZS2s5T2pvejRkQUREbng5L21tVWJSWkpOZnovaDBBTUNjSDM5TmZnVUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWjJBUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdGaUZ3QUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtZGdFQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1Mbnd2MHhibTM4UkFKaGpMUzB0d3FSSTI3d09udzRBbU92amIzdnpISCtiS2t6bUwxam8wd0VBYzZ4elliY3dLZEsxWktsUEJ3QmN3c2ZmcGdxVDd0NWxhVjY3eXprQU1GZml1TnZkMnlkTWlzVGttMlZyMS91VUFNQWNpZU51UzB2ejVFRFQzUzRjMWRhNzhqS2ZGQUJvc0RqZU50UFprcVlNazlDMzVvclVzM3kxVHd3QU5FalA4bFdsNDIyem1kZVVlNnVsSlMyL2ZIMWFzR2h4T3JCN1p4bzlPZXdUQkFCMTBENi9NL1ZkdGk1MUwrbHJ5dDl2WGpQdnZOaHBYVDFMMDlGREErblk0WVBwNVBHajZkVG9TQm9iRy9QSkFvQ2EvcS9mVXByZ09uOWhkK251bTdqUnBKa1dWTHVvd3FTOFF4Y3RYVjRhQU1CSG0yZmxBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFnSWxoTWxLNW9hMjF4VjRCQUJxdW9EbEdJa3lHS3JkMHREbUpBZ0EwWGtGekRNV1cvc290WGZQYjdTa0FvT0VLbXFNL3d1U3R5aTFMdXpyc0tRQ2c0UXFhNDYwSWs1Y3F0NnpxV1dCUEFRQU50N3BuWVg3VGl4RW0yeXEzYkZqUlkwOEJBQTEzellyRitVM2JJa3llejhhdThwYkZDOXJUVFpjdnRiY0FnSWFKMW9qbXFCQXQ4a0tFeVpsc1BGNzV5ZzJybDloakFFRERGTFRHNDV2WHB6UGwrM1Mra1NyV000bDVKaHZYTGJQWEFJQzZpOGJJeldrZE9kY2k1MWQramRNbmYxdjVqazl2V0ptV0wrcTA5d0NBdWxuVzNWbHFqSnkvMzd6KzdMU1N5cFZOL2l3YkJ5cmZ0ZW5hMWFtenZjMWVCQUJtTFpyaWp1dFc1VGRIZS94SitZdlczQXQvVVBuT3RiMEwwNjkrY20xcXR4b3NBREFMSGZOYVMwMnh0cmNyLzlKWE42Ly84TVJJeXhQdmpPWGY4TTFzM0ZlNVlkZWg0Mm5iVy8xcC85Q3dQUXNBVE12eTdzNjA2YnJWcFJNZU9ZOWxVVEt1T1lyQ0pKWmgrK2RzM0oxLzRidHY3MDB2N1R4Z0R3TUFOYmxsWFYvNnBRMnJpbDU2T2h1L21ZWEp5RlJoRWlKcG5zckduZmtYOWc2ZVNLLzNIMDZ2dkgvUTNnWUFDc1U2SlhGTGNKVVY1Wi9KeGoxWmxCelB2MUF0VEVLc2V2Skl5bDNXS1JzOE1aSis4c0ZRNmg4OG5nNGVHMGxIVDQ2bWtWTm4wcG14TWY4YUFIQ0phRzFwS2MwZjZaN2ZYbnIyVFN3ei83RVZpMUxQZ3FyUDNuczBHdzlrVVRKYTlPSmtZVksyK1Z5Z1dOZ0VBSmlwZ1d4OE5SdFBsT0ppZlpYUXFlRUhiY25HOWVuc3BOZ1IreFVBbUlhUmN3MXhmVGxLSmxQcmZjQlJPZmRuNCtwc2ZEMGJ1KzFuQUdBU3U4ODF3OVhuR21LZ2xtK3E1VkpPdGFDNU5SdDNaT09XYkd6SXh0cHNkS2V6YzFNQWdFdER6QlU1bXM2dUl2OTJObDdLeG45bDQ0VjA5bmw4aGFwZHl2bC9BUVlBVk9BS3lyV2ZjMkVBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lvIDlpZborrDlvZUucG5nXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG95UTBJMk9EWXpORE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3lRMEkyT0RZek5UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qSkRRalk0TmpNeU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pKRFFqWTROak16TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrSU1rTlBRQUFCb1pKUkVGVWVOckVtV3RzRkZVVXgrL003dXgySDkyeUxkdDNlVzFCRE5EU0dLQkE4SkdJMFlCR1UxR2o4UXNmZk1Rb212Z0lxTUZnRkUzOG91R2xpY0dvQWJVS2hrZU5BVnRpU2x0cEtaVUlsS1ZMQzRYdGExdTZiYmY3bkJuUG1iMGxXN3F6TzdPN0xTZjVaelozNTk3N216UDNubnZ2R2NiMjd1OGtCZE9CVm9NZUFwV0JGb0VLUUdiNi94aW9CK1FBblFmVmdScEJ3WWtHMWxadlV0V2hOa25RQ3RBcm9LZEIyWEh1eTZaYUFub0t0QjEwQzFRTjJnYzZwN1pqVnVYOTVhRGpvTE9nbHhMQXlwbVYxc1UyYWs1dnFpNVhVNWxST0NReVFKK0NYay9ocmNoWkdMUUx0QldHaHo4ZEhpNGxSR3lDNjF2VEFEc3hMTi9FUHNEYnBTa0JNd0svRWhxQ1NjS1VrMmszN0VQOHA2SHFwOHFrZ0FHMlVtVFpXdmcxbTh5WU1kblE1OGw0MERHQldTRzBFQ29laFFaTVpNYU5NV0hmalZVSEZpb0MxdmtHRFFLai9YVm1QVHNGZWpZeU5HL2NaMGdZaDhONnkrZUVZY3BpTlRQZmxraytmTHlDM0pPZlJXb3Z1c2pPbW4vSmVEQ3NDc1dzNThqV0RlVmszYUo4Y3FYUFF6NCtlbzUwdWNkaU1ETmx3UElaL05vaUc5YTR3T2g5SVgxbVU2d0hzZWRheU40WDF4Q3JVWCs3cksxN2tHdzUwS1FZR21HL2VtRTFXVlprdlYwMjVBMlFsNyt2ancwTi9nT21WU3VQYkc2ZE1pUWdCakk4bDdGVExuUnRmNkppRWl6YThwSWM4dVh6bGNTbzB5WUZLeTJGSmozNVlHT0ZiTWlqVE13VVlCZ3ZLd1dXZTFpdTV0d2NjOHh5SmRCeXNORkRUYzZBYVQyeVRRS1d2S3MxdmhIOUpIZGFRMGUvYktQeG9CUEJvdFU3ZXVQT3dHZzJqV250Y3pqQUxjTjVaVi9EVlM5WHE5SFpUeXJtNXBEOExHUE0vN0VjLy84TEptT0lGeFREdGw1emsvY1BueVZoUVpTOVIyUzE4NEJ0ZDliQWhZRGs0Y0dpVmV1Z0lEUGVZK0xFd2dtR0UwMkpwNVhDYmpuWVJQd2hQa0dVWXpJbFJ2VHdJNjdmMkJ2M1ZyM0tjNGJLUkJNSFBZY2VWT0xwRGVWejBnTTd3U3p5L1VXT1l5ZlF3NXlnNGNxVXhsR2xuazRuckRUNUlvd2NBdXNGalc2K211Q3ZCRHFkc0JGZ2lWR1B3RHFSMGVhbzdUZ1o2R1JocFlrWFlkUWhzRlprV0dNeUs3NGE2RlJnSThBU294YUJOYWxzVTFpR0lSbzI4VG1BWlJucDNoUk53MHBCUStSOXlkUldFcnFTV2NabG9nUXlNcEpyTkh6QU01Mnc2WUNlWUVSZ1VSdjB1cVliTmxWb3lpZ2lNTS81YnpuVENZc1RUT21LcU5Rb0k0L0FZWXY3Y2tzNllURWFxRm5HbFpobDBJRjVqREFDQndzNmFsb1lJZXhMRnl5R0xyVjdqL2luOTdDLzBIRWNuUnBFNElCK2ZIRElPTkxkSEsvU05qaldxRjF1bFVLLzkxajhuUUd3bllHekpqWWk3ZFpDb0pHOHpycGo4U285c0xnZ3FVVkJDZlNEY2RwR3krMDZoV3dqeU1xZTNsU05tOWV4Z280L21qUEcraTdKVlhMMGVwSmV3UkpCTy9ya295b3lGVjZwYWFhWlVHRmlpZktDK292YkQvOUlSRkdJVlhFSG5HN3h3SmpzY2lzSFBURHFKenVPeUNReGdhVzQvZEFQeUVZWkl5ZU9PUmNsTHpQbTRVNStKSGRwY2NCa203SjdHeDRQa3ROWCtzZ2lPT0liOVZwU2Q2bUhiRHZVb21wdk1MR2ZMcmFhaU0xaUlPMDlIdkpPOVJuU1BlU05lWCtXKzFMZGdyYjl2OERQVHREb3BHTStuT3N3UTdrZ21ERnJSZHY2THo0SlpXUVZrYnRvbk4valduN2k3VzA2L3pBT2g2c2cvNTJaSDN6ZnZYREQxWVV0ZS9hd2ZNQjd0MkN4YjJEWWpTeklSTmttSC9OaDhvblU3VjNXbnRhMkJXM2Y3V1VFUGpqalNTcm9FL3RHQm1TaFRHTE0zQnBBWTRoemc1eDVWMDgyMmx1LzJjWHl3ZkdaODJ4d0hQdkV2cEdCc29UaTV0Ym9XTG1Kd3lpdnM1YlYrWWJHTzFhOHRobkdkdUYwd3NMcmQ1VTI3OWx2N1QySG5uVlFoaWtaK1VoZUlzcTZsenlEVVFPZkNwZnFzR0dzTjVUWFZYZkJtMjAzK1kyNUpiQjdadEpLQ3FGcjFzQi85VXRQZmZTdHlYTzlIVW91ZzY3Uk1EWWxXU0g3alFPelFYREIvREJHQ3p1bzBGMnladkgxSmM5dThHVVdMazRIcTJIVTFUN253cy9IWjNjM0lLaUxEb09iY3JCeGdhT2dNZHhocm5nZXFCaGtkWmVzTGUwcGZYVE5tTlcrREk3ZlJuWGpOT1F6MzNLZXozZisyV0M3WHQ5QklwL0JidEFKNXFiRFFEWU5wT2dyRW9CemNNSE1VRDcxZUM3dStIaXR3ZFEvOTM2N0o2L003alBuRjRReVp0bWd6Q0t3V2wwa2t4OE9hc0srRWM0L1BBQkRxeWVyNzd3ejk5cmZUaWp6MHIxQlAvVm9MNDBHb1lSUlJPbVhVT3B0ekwxWnFNZHRJRHg2bStsYjRLZzBVVWxGOUJSUFFVTFVlN2dud1BWNWdIcDBoTVpaVVZIWWUzSStwenBVa3Nnbld5UDF1b1ZlRWR3UUJVMmlZSDBVZEpRQzRoWERaVkFwYUx5d2xuQmVVNCtnUEJSUVR4OUNLK1BoTUlVTDBBY1FrcDJvL3dzd0FONkVJSG5qQ1N5b0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvek5rRTRNakV3TmpOR05VWXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG96UXpORk5rTkNRVE5HTlVZeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPak0yUVRneU1UQTBNMFkxUmpFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qTTJRVGd5TVRBMU0wWTFSakV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K2pHVmpwQUFBR2RKSlJFRlVlTnJzM1cxc1hYZDl3UEcvSDJJSE4ybGFwMDlwMHF4clM5TlN2RlUwcGQzSzFCWVFMR05qMnJvVkZaQTJVVFlldGxaanI2WXhlREhneGZabWFJQTJLa0NieGhoMG9HbHN0REFWS05MWStwQ3l0aW5RQWkybGlkdW1UZEttZGt6c3hQYk96L1oxempuMzNPdHJ4OWZjeEorUGRKVDQzT3RyKy9oSzUrdHovdWQvdXFZZnZpTXRRWGUyWEprdDEyZkw5bXk1T0ZzMlo4c3AyZEtmQUlEVllqeGJEbVhMY0xiOElGdDJac3MzcytYK2JKbHErRmxET3lwWDl5N3lpMi9KbGovS2xyZGx5M2wrRndDdzZ2WFBMWU9SRzlseXc5ejYzZG55ejlueWlXelowK3FMZGJmNHZJMXpML3g0dHZ5WktBRUFGbkRlWERNOFB0Y1FHNWNyVEc3TWxrZXo1YjNaMG1jN0F3Q0wwRGZYRU5FU2Ixbm95YjBMUFBheGJIbDM1YVBqQjFNNmtIMk4wZUdVRHU5UGFXSWtwYWtqMlhMVXJ3QUFWb3Z1TEJlNjEyVDVzVDZsdFJ0VFdyYzVwY0ZMVXVyZlVIN21HZG55K1d5NUxsdHV5WmJLWU9ocU1QaDFJRnUra0MyL1h2Zkk2Tk1wN2R1VjB0NmRmaGtBUUxXenQyY3BNcFNGeXJsVmovNW5pcU1uUXp2R1dnbVRPRkx5cFd4NWM5M0xQUFgxbEo2NXg4WUdBRnF6NmVxVXRyNnU2cEV2cHhnb083U2pjT1NrYW96SngrdWlaR1IzU285OFdwUUFBSXNUN2JEclU3TXRVZlRtdWVaSXpjSWtCcVc4cTdEbTRCTXBQZmFGbEE0OWErTUNBSXMzdG5lMkphSXBpdDZWZHQxNVU2TXcyVmhYTGlOUHBmU2pmMHRwY3R4R0JRQ1dMbG9pbWlMYW91ampXWnljV1JVbUgwNnpJMmFQZWZLL1VqcDYyTVlFQUk1Zk5NV1RYeXV2alluWlBsUU9rNjNaY25QaGFUSFFOUTY5QUFBc2w3SG5zc2E0cTd6MkhXblhuVnZ6WWZLZWJGa3ovM0RNVFdLZ0t3RFFEcy9jTzlzYXg2eVphNUdaTUlubDdZVlBpSGxLQUFEYXBiNDEzcDUyM2RsZHUwdndsdm5WTWFQcjNnZHNNQUNnZmFJMW9qbU9pUmE1TXNMa3RZVW54alR6QUFEdFZ0OGMxMGVZWEZGWVZUem5Bd0RRSHZYTnNUM0NaRnRoVmR5UUR3Q2czZXFiWTF1RXlhYkNxb2xSR3dvQWFMLzY1dGdVWWJLK3NHcktMSzhBd0Fxb2I0NzFFU1o5eFNkTjJsQUF3QXFFU1YxejlIWGJLZ0JBcHhBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQXdFbXIxeWFBbjQybjloOU9ZK1BGRzFoZGN1NHBkYzk3OU9sRDgvOGY2TzlKV3pldWJldjNkY2VEejZlZGp4K2MvL2phVnd5bWF5OGRYUEwzRTYrWGQ4RlpBM1UvNTc2UmlYUmY3bXN1eHFzdjNKRE9XTiszb3IrN2IzMy9RRHFVKzkzOTJ1Vm5la09ETUlIT0V6dXNQLy9jRCtjL2ZzZHJONmVicjk5UytkeC91SHRQK3RxRCt3dnJ2djJocStwMjZoLzUwaFB6SDcvL2hnc1dESUcvL05LUDZsNjNtWGpOOG80MS8vbW5EdlFXd3VUbXYzdGsvdjl2dkh4ait1QU5GelY5L2Z6M1gvdDY5V0Z5cE81NXJmcjBlMTVaRnliWGZPRGVKYjFXL3VkcEZoL2YrdDZCd2pZU0ppQk1vQ05kbWYzMWZ1YUdOZW41ZzBkbVB2NlBCNTVMTjEyektRMzA5U3o2dGVLSXltMTM3WjcvT0Y2MzZnaEV1M2VLTDQwZFhaMlJLVDVBbU1DSkxnTGtONjQ0SzMzbUc4TXpIMGVnM0ozdDRHS25Wajc2VWFYWlgvcnhXbFdmdnh3N3pEZzZFRHZpOE9UelB5MDg5cDBmdnpSekZLWlZDeDJ4aVo4aC8zUEVVWW9iZjJtVE53OGdUS0FkZm5QN3NUQUpYN3puMmZUSzg5YW4wY09USy9MMUw5bThydW5qNVdnNHBiOW41cFJGbzVpSUlGck1xYUhsRUVlSFh2WHpwMVkrRnVIMDJQRFlzcnhXMWZZQWhBbWNWR0s4UXh3RnFPM3dZaWQ2MDBjZm1sbTNGRmRkdkNHOWZxajF6NzN4Nm5NYVBoWURWOHM3NHN1MnJGdnl3Tk4yaVpCb05IYWxsU05QVmE4VkEyeGpMRXZOMWpQV3poemhFaVlnVE9Dazk2WlhuVlczdzl0KzRZYVpKWTZnMVA3aTM3WjVJUDFPazVBSTE3MWljRkZqVk1wWDFjUVJsRnFzUFBIY1dGMzBITThWTGZIenROUHQyYlo2ZEhoMC91T0ZCdG8yRS9HVkQ1b1lORnQxRlJRZ1RPQ2tjMFgyVjNwY2ZaSVBoRGlkRTFmVXhMcGFtSngvNXNzcXg0aU1UVXltcC9ZZG52bC83ZDhxVlpmcm5yMmh2eEJGTVVha0ZpWTdTMGRHcm43NWFUUC94aVc4OGYzVzVPTXB4TlZGbTA3dkwzeHU3ZWNwaTNqSUIwUjUzRXpWVlVENVM1QUw2N01veWY4c3h4TW1nRENCVlMxMnZrc2RtQm94a3I4c3Q1R3F5M1d2S0kybmlERWljWVZQUkVUNUtNNkZady9NL0J0SER2SkhEL0x4RkM0NloyRCtrdUhhL0N1eFJGQTQ2Z0FJRStoUTVkTW83MzNEMXFhblNpSVVxc1k0NUk5ZUxNWHYvdkxaNlYvL1orLzh4NC9zSGtuUHZ6UlI5N3hMTjFkSFJjeGRrcGVmejZNOC8wcDU3aFdBNDJGS2VsaEdNUXRwbkRxcEJjZS83M3p1Wi9KOVhMeXBHQngzN2RxZkh0OWJIRjhTUjFzYWpWMHBmMzQ1cHZLdkFiQ2NIREdCWlJSSFIvN3c5ZWZORDdLTXk0Ymo4dUhGRGpDTmNTSXhPTFBzcjcvOFJPRVVTMHdYM3lpUTh1NzlRZjFWTjRzWnVCcEhnVXd3QmdnVE9BSEZWVFF4WTJ0dDl0ZDNmdktSbVV0V2YvKzZMUzNmNXlibUZpbVAzWWp4SFBrb2lmazVybXdRRnhGQ2NjVk5Qa2pLY1JLRFZ4dUp3YkJWeW9OVU53L1cvenpsbVdtcklxZjhzMGFJQVFnVGFJTTRQZksrTjUwL2Y4K2MyZ1JsVmJPYjFnYXZ4ZzYvYXJCcnMxbFUzL3FhYzV0ZVJoeFgzRlFkS2FsRnpXSnVCbGllRGJhbWZLVk9XR2lPa2ZLNEdqTy9Bbm5HbUVBYnhCVXNjY1Npblg1aDYvb2xQMzdkWllOTlB6Y21IOHVySGFrcHo0TUNzTndjTVlFMitmQmJYcDYrUDN3bzdUMDRQdlB4R2V2WHJPalhqMU5CK1JzSzVqVWIzQnFxanNURTNDcGxqVTc1QUFnVDZEQ3hjNytpeVQxYVdwR2ZyR3lobStOVnlkOVFNTy9WTFF4OGpWbHA4Mk5hWW02VloxNFlYL0R6OHBjNngvUHpYNzlxcHRzWVl3SWdUS0RONHQ0cytYdlF4TkdGbFo2TUxDWkdxd3FPVnE0U2lsbHB5emZMR3o1UW5JVzJmTW9uNUsvZWlic1c1MTJ6N2ZUS3Ezc2F6ZndLQ0JOZ21WVGRtNlZWaCtabVZjMTdjZXhvNGVQYWVJOW1zVk4xMVU3RVFTdktrNnpGMXlzUGdsM29IajU3RDA3VWhVMWN0Zk96aURSQW1NQ3FWcjRzZGpFNzRoaVhzdERWTGJYSG04MjhtcitiYnMzSTRhTjE2L0wzNXFsWnY3YTM3dWZKSDBHSkl5OEx1ZWVITHhZK3JsMlJFL2ZlYVdWN1ZGME5GS2QrOGhPN0RiUjRLbWowOEdSZC9BSENCRmFOVHBnaHRSd0dJYWFxLzVNZDV4Zld0WEp2bnZMNGxqalZzNUJHbHl0Lys3RVgwczNYYnlsRVd6bXc0alJRUG9SaW12MFFWenpWN3R1ekdKLzc3NmNMSDMvbE84OGQ5eGdnUUpqQUNhRjhHbVl4czZ3dXA2ODJtT3pzZ1IrL2ROdzc1YXJKMVpwdGc3d0lqaGlEMDJ5c3l6OSthN2d1cUdyMy82bTZRM0ZlUGdRdjJieHVKbkxLVnlmVjVwWXBQeGNRSm5EU0tjLzMwV3lXMVNwVlU5TGY5dlhkaFNNUXNYTnVkcmx1N1BqTGcxZHJIbnp5K01Qazh2TlBYZFEyaUFESUgzWDU3cDdSaGtjK3lrZExGcXQ4eCtVLy9hZEhLNTkzKy84K1UvZGNRSmpBU1NkdW1sZXoyRmxXUTlXVTlLZVZCcU11TklEMHZzY1BObnlzZkNwbG9EUnVJMzlVSVM4bWpZdnZJNDRBTFJRMjVURTJjWFFpLzNyL2w4VlJ3ekQ1WHZGcW52S2x5NHNSUjI0YW5WS3FIVFdwMm82T25vQXdnUk5lSEtYNHliN0RoUjFoekNXeUhNcFh5U3dtanNwaUovL1Uvc1B6d1JUL1ZoMDVpRHNsNTArQnZPMDE1N1o4cENVK054OFdzZlBQQjhiZDN6MVFOOWFsRmhMNWdJbXdpN2xQRmhvTTNNaFhIM3ErTHE3eXY1OUdSMDF1TE0yM0FnZ1RPT0dVTHhFT3RibEU0dlJFSEFrb0g0VzQvWjVuS3dlcGh2d044UjcreVVoTDMwTjhuYmppcEh5VW9MeEQvdWdkVDZiWEQyMXNPbFlqYmo2WS8zNWp3R2h0SnRzUUU3V1Z4NGxFOER5eWU2UVFOTFZMbE9QZldwakU0ekhXNWN4VCsyYkNLSUlrWnNlTlVNaUx1eldYeGNSdDhYWEdzcDh6NWxKcGRObHlQS2MyTHFVV1NERWo3MXYvOXFINTc2L1pVWk5HNDJRYTNUc0lFQ2JROFM3Yk1udEtJR0toSENWeEZPVFI0ZEdHcHhxV2NwU2dLbjdpaXBhWWhyNTh0K0ZZbW9WSmVZQnIrUVo4TVE2bUhDWTNmZlNodXRlcDNleXZQT0hiclovNS92eU5EQnRkRlJSM2E3NjdkR29uWnBPdHpTZ2IzME0rS2hyZEVESEVrWmVJbUlpZC9MYk5QejkvZGRCQ1Z5b0J5ODlOL0tDTllyNk9abGVlL01vbDlXTXM0dFJGSzNOOExPYmVPNy82aTJmTzdPRGp0UmVqYXViWXBhZ04vcjF5a1ZjbnhmWmJhQkszVnNYUEh0dWdGanVMM1JiTlhoZFlQbzZZd0RLS1V4dTFxMmxpUUdsKzBHdCtZckE0VWhKUkV1TTFIdDk3YkZCbnJQL3RWeDhiMjVDLzcweGVESHh0RkR6bFFadlhaanZoV3VoODRJYUxaazdIdENvR3A4YjNzTFBCUU5xRkpqZUxuZlpiWDNQdS9IYUl5SWpYYStWSVVHeXJtNjdaTkw5ZGoyY0FiSWlqSkxYSWlYL2Y5NmJ6MDk5ODVjbktteHkyS3I2bjM3dDJzemMrTEtPdTZZZnZtQzZzdWZjanRnclFWdm1aWm1zQlZ4dlBVUTY2NDNudCtWZ3ovVDEwcnF2ZVgvalFFUk5neGNVUmkzSXNMRmM4VkwwMmNPSXd4Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQ2ViM283L0RydTYwbVRmNmVsby8ybHBhczBwYWJxN2IyWWRBTkNDNmFuVVBUV1J1bzZNcGQ3eEYxTFB4SXZadW1saHNoU1QvYWVuaVhWYjBuUlB2emNXQUN6cEQvenVOTld6TnFWc21WdzdtTG9teDFQZjZKN1VrMFZLSityUVV6bGQ2VWdXSk9NYkxoUWxBTENNWXI4YSs5Zll6OGIrVnBpMDRNaTZ6ZW5Jd0RuZVBRRFFybjF0dHArTi9hMHdXVUNjdmhFbEFMQXljUkw3WFdIU1NGZFhtbGgvbm5jS0FLeVFtZjF1QjExVTBsRmhjclIvY1BhcUd3QmdSY1IrTi9hL3dxVENaUDlwM2lFQXNJcjN2eDBWSmxPOXAzaDNBTUFxM3Y5MlZKaE1kNi94N2dDQVZiei83YmpCcndEQTZ0My91bGNPQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RHd0NBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd3NRbUFBQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQmcxWVpKMS9TazN3Z0FyTFRwYVdGU2FlcUlOd2NBckxDdUR0ci9kbFNZZEIvOXFYY0hBS3o0L3ZlUU1LblNNLzZpZHdjQXJPTDliMGVGU2UvNGdkUTFOZUVkQWdBckpQYTdzZjhWSmxXbXAxUGZ5Rzd2RWdCWUlUUDdYWU5mRytzWmZ5R3RHWHZXT3dVQTJpejJ0N0hmN1NRZE9ZL0ptdEhoMVB2VDU3eGpBS0JOWWo4Yis5dU8rNzQ2YzNQRktaMm5Vcy9FU0pwWXR5Vk45L1I3QndIQU11aWFIRTk5bzNzNjdraEpoNGZKck5ob0w1dDRNUjN0SDB5VC9hZWxxZDZCTEZMNllyTjZad0ZBaTMvc2QwMU9wTzZqWXpOWDM4d01kTzJnTVNVblZKak1icy9wMUh0NC84d0NBSnpjM0NzSEFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQTFJZkpSSEZOajYwQ0FLeEFoZFExeDBTRXlVanhTZjAyRkFDd0FtRlMxeHdqRVNiUEZGYjFyYk9oQUlEMnEyK09aeUpNSGl1c1dydlJoZ0lBMnErK09SNkxNSG1nc0dyZHVUWVVBTkIrNnphWDEreU1NUGxtWWRYZ3BUWVVBTkIrZzVlVTEzd3p3dVMrYk5renY2cC9RMHBuYjdleEFJRDJpZGFJNWpnbVd1VCtDSk9wYlBsczRjbG5ETmxnQUVENzFMZkdaOVBRanFuYUJHdWZTUG41VEdLY3lhYXJiVFFBWVBsRll4VEh0RTdNdGNqOHpLOXgrT1JUaFUvYStycVVCczYyOFFDQTVUTncxbXhqRkgwbURlM1lrdytUOE1GczJWOTQydmx2U0tsM3JZMElBQnkvYUlxZmUyTjViYlRIWDlRKzZDNDk4TWVGcDY3Zm10SkZ2NVZTVDUrTkNRQXNYVS8vYkZPY3VyWDh5SzFwYU1mK3FqQUpuOCtXVHhiV2JMZ2dwVzF2Y1ZvSEFGaWFPSDJ6N2NiWnBpaTZMWXVTeitWWFZOMWQrTlpzK1hKaFRSdzVHWHBuU3B1dXNuRUJnTlpGT3d6OXdXeExGRVZyM0ZKZTJUWDk4QjJWYlpNdFg4eVdIWFdQakQ2ZDByNWRLZTNkYVdNREFOVmlucEs0SkxoNlJ2bXZaTXVOYVdqSFdLdGhFdFpreThleTVWMlZqNDYvbU5LQng3SlFHVTdwOFA2VUprWlNtaHhQYVhyS0x3TUFWb3V1N3RueEkzM3JaKzk5RTlQTUQyNUxxZiswUnA4UlEwWnV5YUxrU05XRHZVMitWSHpDdTdQbDdybEFPYVB3YUh4QnAzWUFnTmJzUzdQRFJmNmwyWk82VzNpaEdCQWJOOUQ1KzVTZmhBMEFZR0VUY3cxeDZVSlIwbXFZMUNyblBkbHlZYmI4VmJZTTI4NEFRQlBEYzgxdzRWeEQ3R3ZsazVxTk1Wa29hSzdNbHRkbXl4WFpjbkcyYk1tV2RXbDJiQW9Bc0RyRTBJL1JORHVML0EreTVZRnMrVWEyM0o5bTc4ZFhiV2hINWVyL0YyQUFzdFdxV29UNW5kNEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeU1UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE15TWpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBMFFrWTVNekZHTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16SXdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCsrWUttYndBQUJraEpSRUZVZU5yRW1YMUlXMWNVd0crK2pacmc1MnAxYUtkVytvY2ZHMUkvVm9jVk1zSEovbWdwZzIyTXdmN1lCN295SFZNM2hnamlwaFZSViswSFcrdEt1NjNybk1KYWgxQ3BVbXkxczdxMUR1ZWt4aW4xVzJ1cUpqR0pNVHZuNVVaUysvTHlYb3oyd0NINjh1NDl2M2R5N2pudm5pdXkyV3hrR3lJSFRRZk5BazBFalFQZEMrcFB2MThGblFZZEFiMFAyZ25hQTJwMlRIQWtXaTdJb01oRDRKZEFQd1E5Qmhva2NPd1M2QytnWjBELzNHbmdKTkN2UUhOd0xObWVvT0YyME04QitwNjNnWDBvNk1lZ1V1SmRXUWR0b09CcjdtNFc4NWd3Rmg2cUZ6NExkZ0NXMERrL1FSdXRXblBzdG9DdDY1WVVtS2hISkJJbGtSMFd0QUcyN2pTUDZOTThBZ2JZTkxGRWVnTW1DaUc3SkdBckNHeDJjRUd6QWx2TXB2MHc4Q3BNNEVkMldkQW0ycjR5dkxLZkYvRGl6S1JTS3BVMTc2Wm5XYUJEa09HNzIyTkt0OERxb0pBcWtWaWN5RGJSK1BnNHljdkxJOW5aMmFTaW9vSVlqVWJCTUhxOW5wU1hsNU9jbkJ5U241OVBKaVltMktHQkFWZ3FPZFBhOHRKQ3Nqb3dwSmN0RzR5TmpaSEN3a0tpMCtrMnJ5VWtKSkNxcWlxaVZDcDV3eFlWRlpHaG9hSE5hNEdCZ2FTdXJvNUVSa2F5cGp4Z1NuMDNPWHpnS1E5RERoUXAvVlJmdTBwZENPWU1pekk0T0VpS2k0dDVlWm9ObGlsN1MwdWt1cnJhWmNxalRLS25nQ0ZlVW1SeWhjYlZTRmMvblFQYVlEQUloblVPTlZjQ1RLOGkyeFBBakhmOVZjZTV5bTFxYXFyTFNSRzZwS1NFRmRvZExFcDZlanJuR25SbWs1U1ZsZUZmNmhjek5HZGhkU3BjalVwSlNXSEE1dWJtV0wvSDYvaDlabVlta2Nsa3ZHR1RrcEpJYVdrcGtVcGRGMUhJR1B1QXJmSHZPemROaklmVGM0NitBcXRTeGZXWXZyNitwTEt5a2xsb2ZEek5GeGJYaGtLaDRFNXp3SWFNVEVoQU9JajkxSUVhUHF0Y0NMUzNZQjFDR2NWaWUxd3JFdm5tVWI3UTNvUmxkZ3AyUmhrQ0srUSt5aGVFSkg4KzBONkVaWUR0akFvRWxrdGxzbUNoaGoyQjloU1dXWGgyUmprQ1M4VmlpYThuTlY4STlIWmdtY1ZtWjVRaXNHUmIreHdvN1ZhcjFlMTlHeHNidk81ekl4SUVGbG10NjBaUFJ2TkpYWHlLQ3graGpDSW1ENXVNaHNjN0Nlc05hQWNqQXR0V0grdW1kaHAydTlDVTBZYkExcVg1NlZGdnd1SUM0MXNSZVRjejdJeFdCRjRmN3UrNTYwMVl6QVpDeWpnZitYZWd0eDlaRWRqYzluM0QzWFdMMmVndFdFeGRRdDg5T0JzWEZ2UGExZlBmb0ZQTkNHeGFtSDc0YUdKa3FJOXJVRTFOamVCeXl4ZTZ2cjZlRXhqWS9vQzk1aUt5SXJBRmQwYzNtaTljNHhyVTNkM3RVVkhnQTgwMU4wcG55MFZrVzBaV2Nhdld2SUdMc08xQ1k5L01oUFlmbCsyZjJGaVBLNWc3NkppWUdKZGprZWxhMDhrKzJnbmRjR3lSOVBnTzNuTDZ4Q1VibGlRV3dXMFFiaGc5TGJldW9JT0RnNW01V2Fzb3NQeDZxdW9pc2xIR3pUMGQ5bXNYcnY5OHZtK29yN3VMYlhCVVZCU3ByYTBsOGZIeFJLVlNFWTFHSS9qZHdBR2RsWlhGeklGejRZNDVJaUtDOVg1azZialNoSXR0d2RGVDN0em13NHM4ZGlpakEwTEREdGEyOVZVRWhPeUpJTTlRZEF1elV3VzVCNy9RemM5Z09HaEIxN1kyVWt3WU1uQ0R0cUg0ZzFOUUN2WFBDaFp0QTBNanNpQVRaWHR5bXcrTEQxMjlBdnBmZitmdmY1MHIvL1MwRlJMZ2JzT2lUYlNORE1oQ21XeXNyU3FBdHRCNEdiMSsrVnpQbVMvekc4eHJSc051d2FJdHRJbTJrWUd5V0xZMms3Y0t4c29rN3A4ZzRNV0xzMU9HNHllK2ZROWlPM3hIWTNaK1p1cGs4ZnROQTEzdDZOa1J5ckRHMlZ0emJsc1IrMGxRRkdpY2YwQlE1R2NOUHg1TlNEdDhDTGJjWW0rQ1l1b2E3TzI2VlozL1ZzdXE3dEVFaFIybmVkZkdDOWdKR3Z2RG1DMHdzNGNmeWoxMjRNMkNzdHlJNkxnRDNvQ2QxSTRNLzFSYjFuYXJyWGtZL3AyaVlUQkpjeTRyR09laERJWEdkSWU5NG4yZ3oyUERNZVAxTjJKZmUrZWpsMk1Ua2hOa0NoOUIrMEdMYWMzNFlMRC9mdnVsczdkdi9uYjVBYkVmZ3oya0MyeUJob0ZMS0Y2blNBQ092U2ZzRElWUmp6K0hyV1NsbjhydjhKRzNZNUl5TkRGaFVkRjdBMFAzaE1JMXRWUW1sOU8zTExOUnY3SzhORDg3UHpPdW5iN1gzVEhhMWZyREtGelQwM2VET2VyUkdab05MRzZiM1h6UDZhaTNzYXlwcWNkRHNiTFNXTWRmUVVaVjR0UlV4TW10Rk1SQ3ZZZXhpVzllODlTanl6VFA4Z0tSQ2ppSnRGR0RPRG51cjZhcDE5WDBFOEdWVHRERUNkWklRVmNvSUg0YWFMa1ZkTExweWJtYmpVSTd3R1hVODNJNkg1dUgxeW1jaVQ3QWhxY0w5WDhCQmdCNWlEbjBNcysyN3dBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMVJUVTJNa1k1T0ROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8xUlRVMk1rWTVPVE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalZGTlRZeVJqazJNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qVkZOVFl5UmprM00wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K01UR1dCQUFBRmpkSlJFRlVlTnJzM1gxc1hXZDl3UEVuanQvaU9DK05uVFpwM29pU3BtdFJ4Zm9HYTRYVVV2TEhFQjBNcGpZSXFHQ1VEU2lEUDlBMElXMmFKalpOMmxTaGFVQUhIZkRQQ20zR3kwUUZtclNtZEIyb3dCS29SdGV1N1JvRm1xUkp1eVFsdGV2WWp1UHMvRzU4eS9HNTU5clg5cjJKblh3KzBxUGE1OXhjMy9zNDZ2M20zT2VjdStqMG9ZZlNMTFJsNC9wc3ZDVWIxMlZqV3piV1pXTnBOcm9TQUhDK0c4bkdxOWs0bUkxbnM3RW5HNDlrWTNjMnhxZjkwMnUyVC9xMmZZWS9mSDAyUHA2TjkyVmpnOThGQUZ5d3VpYkdxbXhjbFkzZm05aStQeHRmeThZWHNuR2cwVHRyYS9CMmZSTjN2RGNibnhZakFFQWRHeVphWWU5RU8vUTFLMGh1ejhiVDJiZ3JHNTNtR1FCb1FPZEVPMFJEN0pqdXh1M1Q3UHRjTmo1YXR2UFUwTEUwOHNMUDBzbVg5NlZUZ3krbThlSGo2ZlRZYURvOWZ0S3ZBQURPYzR2YU90S2k5czdVMXIwaUxlNjlKSFZjdERsMVhYcE5XdHl6cW5qVC9tdzhrSTJicy9HSmJJeVYzbCtkUmEwOTJkaVpqVnVMTzA2Ky9JczB2UDhuNmNTK1IvMDJBSUJKbG15K0tYVnZlRk1XS0s4cjIvM2RkT1pveVZCeFVXdFprTVNSa1c5bDR4M0ZIWU5QZmpzTlBiZkxiQU1BVStyWnVqMzF2djdkWmJzZVRMRUFkczMyc2VtQzVJdlorRWgrdzhtano2V0JKNzZSeG83dk44TUFRRVBhVjZ4UHk2NjZQWFgwYlMzdStsSVdKQitkS2tqaU1Nb0QrUTJqTHoyVmp1LzVTanA5OG9TWkJRQm1aRkhIa3JUaXVqdFQ1OFZYRm5lOU40dVMrNnZmNU0reWlkTnlQcCsvWlJ3Wk9iN25xMklFQUppVmFJaG9pV2lLZ3Mrbnc3dFdsd1hKWDZVeksyRmZNL0RFUDJkM05HUTJBWUE1Uk1sUUd2ajV6dUxtT0Izbkw0dEJzakViZCtadkZRdFl4NDRmTUlzQXdKeU52WEl3RGY3M3Q0cWJQNVFPNzlxWUQ1S1BaYU9qdWpkTzdYVTJEUURRVEVON0g2NDBSazdIUklOVWdpVEcrL043aC9mLzJLd0JBRTFYMGhqdlQ0ZDN0VlUvdFhkOWRldXBvYVBweEw3L01HTUFRTk5GWTBScjVFU0RYQjlCY2t0KzY4Z0xqNXN0QUtCbFNscmpMUkVrMSthM3hHZlRBQUMwU2tsclhCZEJjbmwrUzN4UUhnQkFxNVMweHVVUkpHdnpXOGFIWHpGVEFFRExsTFRHMmdpU1pma3RwOGVHelJRQTBESWxyYkVzZ3FSejBvM0d4OHdVQU5DNklLbHRqYzQyMHdJQW5HdUNCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBRGpuMmswQk5OZXh3YkgwKy9mOHNtYjdaM2FzVFcvWTFEUGxuMzF3ejh2cEs5OC9ObW5ibGt2YTAyYy9zR2xHaitIZ3NkRzA4N0dqazdaOTZ0YTFOYmU3ZDlkTDZYcy9HNWkwN1pOdjYwOXZ2V3BGeStibmZ3OE5wei8rcDRNMTI3L3pKMXZtZk4rZi9lNmhTZC92dUxFdnJWdlZPZVA3ZWVmZjdxMTViQ2RHeDlPQm82T1Y3M3U2Mm1aMXY0QWdnYk5tVlc5NzlrSzRJZ3VDNDVPMlA3bC9hTm9nK2Zjblg2blo5dlpyVnM3NE1ReU5qS2RIbnhvcUJNbmsyL3pYTDRkcVlpVDg0T21CeXI2cDVGL282d1hHWENOZ0t2V2lxZmljZitmYWk1cjJlNDBZcVQ3UG02N3NLUTA4UUpEQXZITDlsdDZhSUludjMvWEdWV2xKblEvWmpxTWFlMStzK1VqdWRPUGx5NXIydU9Mb3plUDdYcTE4ZmQ4UGpwWGU1dkY5STlQZVR6TmY2SnY1bklwMjd4MU16eDhaU1ZkdlhsbzV3bEU4YXRTb09QSlNQVG9DQ0JLWXQrSUZxL2l2OHpMditidDlNNzd2NHA4cE96clF5TkdGdUUzOHk3NlJ4N21RSEIwWVMzLy9yMGRLOTFXajhPNDd1aXIvbmUxelA5L21ET1lqaTFvQmdIUE9FUks0d01XaTJRL2N2RHIxbEx5VjlEOEhUOVFzc28yakxKZXQ3WDd0Ky9nNnZ5RDE2ejg4VXZOMjFhcmV0blRQaHpmVmZic3FMOTVhK2RQNzk5ZThmZFhxeGJhTml1Y3lIeDRIQ0JLZ29SZjUyU3hHTFZQdjdZaloyTHFtdTJiOVJ6NHVpbUh3MS85eXFPYkYrSU5adkV6bHQzOXpaVTJRSEJzY1Q0ODlNOURRQy9sRFB6OWVFeU14bi9YVzBxenY2MHgzMzdHdThuVnhjVzFFek1iK3JzcHRpbXRBcGxxWVduYVdEU0JJWU1HSkY4Qm0vU3U2a1NDSkY5ZThWMDZjcWxtY0dyZFoydFZXV2VTWlYveStLczYwaVpESTI3UzZvN0tBTkJhSnh0bEVWVDk2ZGpBTmpaeWFGQkRGcUtpM2lEYnYxWkh4bWlNeTFmbU1vS25LejIwY2Rha1hWUkVqOWZiTlJQNlUzNmtpRGhBa2NFRXIva3MvVHNWOWZOL0JtdHZNOVJUZGlKd1lzVWgwY3BBTVRMdndNK0ptdGtkNzRyN3o5OStNMkh2aStlR2E2NWFVeldYSW4vSWJIREVCUVFMTVVyejRybG5aWVNKeWdWUVdVY1hydFFCbmg3TnM0QUlSTDc2SGYzWFNSQUR6a2lNa2NCNnF0eTZrNk9yTlhlbDliKzZ2ZlAyMUh4Nlp0TzRrdjI4MmIvUEVRdFBxV291SG56aGU4M1pOOVcyUHFmYUZScS94QWl4c2pwREFlU2F1WE5yb1dvM2xTeFpYb2lGR2ZGMXYzOWtXYTExaXhHTFNWb2xGdnRhQ3dQemhDQW5NWTNFNStabjY1bytQelp2SFA5dWpHOVVqTXRYVGVRRkJBc3pDbWJOQzlwNzFueHRIRmNvK01DL0UwWURZNyswUFlEN3lsZzBzTUQxZGkrdnUrNGQvZTNGQlBJZTNYN09zb2VjRFhEZ2NJWUVGSks2VWV2bWw1V3M2WW5GbzJhY0ZuMHMzYkZ1VzNyQ3BwMlo3L3Fxck4yenJUWi9aMFphT3ZGSjdCbERmTXYrTEFrRUN6UG1GTnhRWG1OYTdySHhjR2JYNGRrcGMrcnlxZjNsSDJyYTJ1L1R6WUdMeFp5TlhRajNiK3JPZ2VENTNCZGVxL0ZWWHB3NHcvNHNDUVFMTUlFaDZTN2ZIbW8yaWlKRjZWeG90QmtralZ5U05oYTg3SHp0YWM1bjNNa2NHSmg5QmlVdk1WeDlqZkYxdlg5bjlYTFoyK25tSjA0L244bGs4UHNRT0JBblFCR1hYQTRrakhjMDBORko3eGRFN2IxbFYrcGt3Y1luM3ZET1hnaSsveHNoVSsrSis2a1hZK1dndWw5c0hHbU5SSzdSUWZGaGMwWWErenBiK3pMaSt4aFhybHBoOFlFRnhoQVJhNkxuRHRXOTV0SEpkUkN4Ni9lRE5xOVBSZ2JGNU95ZjFyaTJ5ZSs5ZzJ2blk4WG4vTzQwcjJBS0NCQmFVNGxzcGNmU2kyZUpNbEZqOEdtOEZ4ZEdYQ0o1NlFWSnY4VzBzaUMxYmcxSnZBZTVjVHRXdGQrWFhSaTkzZnk3a2YyODdidXp6RnhzRUNTd2NaVmRaM2JxbStaZGhqd0JwZFBGbjJicVBPRjI0M29MWU9JMzROOVl0U2V0V2RWN1F2OHRQM2JyV1gyZ1FKTEF3UFgzd1JNMjIxVE5jMEZydkxKZjFmWjJscC85V0RUWDRHVEFSVGRPZEJmT1BENytVL3VLMjlVMmJsN2ljZkprbm5oOXU2ZStqYkU0YS9heWNCL2U4bkpaMi9YcStyOTY4MUNuSklFaGdmb2xvYVBRc2pJMzlNenZTVU85Kzg1K2ttMytobis2eThEOTZkakFONWE0TFVuYnRrbmg3SW44L2NiYk52YnRlU2xzdStmWGFpWGpMWnJabjJjemswdlh4YzZjTGxlcHB6MVBOWDZ5dEtYc2NqejYxcjZISFVUeGo2ZTQ3dWdRSkNCSlltT0tGZnFxM1B1SmYzU2tkYWNuUHJyNGd4K202VXdYQmpodFhwUGUrT1M3R05qbHV6bncrenNDazU5THEwMzVqOFdpOXorWEpLenZ0dWFpUmE3VGs1eWwrZG9RWUlFamd2Qkl2Y0hIMnk5UXZodTNwMDc5N1NicDMxLzgxL0FMYXFCdTJMVzNvTWI3cmphc213cVN2S1IvQ0YwZFNack9RZDgzS2p1elBMVTkzZlhsL3piNzg1K0RNUmR4UFBuaGlBZTl0TjV4WnNQb0hiNzA0Mi9lcmhvSUlFQ1F3TDFUUGNxbG5ZMzlYM1ROTGFzT2h0ekxpYllpaGtmcFJzbjRHMXpLSklDZzdVeVl2am94RWpGVFhwY1NSbkhzK3ZLSHlvanc0ZkdyV2NWSjlQck5WakpuZTdzVTF6eVhtb3Q2cHhGT0ozOGtmYnIrNGRGODgvOWhYYnovUWZJdE9IM3JvZEg3RFM5KzV5NndBQUMxMThUdnZtZlM5SzdVQ0FPZWNJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFFQUV5V2grdzZLMmRyTUNBTFJNU1d1TVJwQU1UTHBSZTdlWkFnQmFGeVMxclRFUVFYSW92Nld0ZTdtWkFnQmFwcVExRGtXUVBKUGZzcmozRWpNRkFMUk1TV3M4RTBIeTAveVdqb3MybXlrQW9HVktXbU5QQk1raitTMWRsMTV0cGdDQWxpbHBqVWNpU1A0ekd3ZXFXeGIzOUtVbG0yOHlXd0JBMDBWalJHdmtSSVBzamlBWno4WjkrVDNkRzk1a3hnQ0FwaXRwalB2U211M2oxUXVqZlNIbHJrZlNjZEhyVXMvVzdXWU5BR2lhYUl0b2pKelJpUVo1N1VxdGNiamt5L2xiOUw3KzNhbDl4WHF6QndETVdmdnlTeXR0VWZEVnRHYjdnWHlRaEQvUHh0SDhyWlpkZFh0YTFORmpGZ0dBV1l1V1dIYlZqdUxtYUk0L3EzN1RWdGp4Ui9sYmR2UnRUU3V1KzFCYTFONWxOZ0dBbWNkSWUzZWxKVHI2THl2dSttUmFzLzFvV1pDRUI3THhwZnlHem91dlRDdC82K1BldmdFQVpxUjkrYnFzSWU2cXRFVEJ2Vm1NZkgxU3VKdys5RkR4UnAzWitFWTIzbEhjTWZqa3Q5UFFjN3ZNTUFBd3BWakFXckptSkR5WWpkdXlJQm1kTGtncTk1T05iMmJqYmNVZEoxLytSUnJlLzVOMFl0K2paaHNBbUNTdU14S245aGJPcHFuNlhqWnV6OFpRRmlTcGtTQUpIZG40WERZK1VyYnoxTkRSTlBMQzQxbWc3RXVuQmw5TTQ4UEgwL2pZY0VyanAvdzJBT0I4MTdZNHRiVjNwN2J1RlpYUHBvbkx3Y2NWV0FzWFBjdUxKU0dmeU1iSnluY3pDSktxOTB5RVNiL1pCd0JtNkVpS0Jhd3AzVDlwYXlGSTJocTRvMWpvZWtVMnZwaHlGMDhEQUpqQzZFUTdYRkVUSXlYYUdyelRxSnVQWldOTE52NG1Hd2ZOTXdCUTR1QkVLMnlaYUljampmeWhSdDZ5cVJjeTEyZmpsbXhjbTQxdDJZanpnbnZUbWJVbkFNRDVMZGFDREtZelYzdC9OaHMvemNiM3M3RTduZm1jdktrVjNyTDVmd0VHQUVESU1tVXlFUUM1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xUlRVMk1rWTVRek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFSVFUyTWtZNVJETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVkZOVFl5UmpsQk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pWRk5UWXlSamxDTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrdUIrRFl3QUFCbUpKUkVGVWVOckVtVjFzRkZVVWdNL003Ry9iM1JiYUFnWEtUMHVSaUJTSUNtME5EeWJ3WUh3aHlwTVlOVDRZVExRWUhreEVub3lnSlA1RUVGQjVzQ0srS09GQlZDQVNNYUlGYlBscCtTOHRQeGE2WmFIZDdyYmIzWm1kSDgrWnVZV1c3c3pPYkxmbEpxZXpuWmw3N3pkbnpqM24zRE5jZk8xQ0dFUHpvTlNpUEl0U2pUSWZwUXlsZ0YwZlFBbWh0S0cwb2h4Rk9ZNGlEUTJ3dHJITjBZUmNsc0JMVWRhaHJFR1o3TEJ2Qk9VbmxLOVF6b3czOEdLVUxTalBVVjhZVzlOUURxRzhoOUF0dVFiMk1kQzNVVnlRMnlhamZNbkFrN2tBbm9lcTJNY1oyaDIzaG5PMDRCeHJFTHJkNmo3ZTZxS2lhY3R3b09QakRRdUdmUzNHdVU3dXFhMnF5UW9ZWVd0NGp2c0RCeXFCQ1dvNDEyU2M4NGdWZEZyZ2xLcFZZY2NET0VBK1RIQ2pPV251aHBxcUtsdkF2WkxzZC9IY3ZvblViQnJvRW1MWS9sU0YvK0ZybzFaOHdDVnM1WXdnTVBycHltYUI1OVVOd00rcUJQblVNWkQyYmdjUUU4NWcvUG5nZWJrZWhPcmxvTjY2QnRKM240UGEzWmtPdWhwWlBzYWY2MDI5Ukg5S2VUTGdGazZrZXhCK3hoendidGdLWEtEdy9qbTEvUUlrdjloa0c1cGd2ZXMzQTEreDRJRjNpRVZBL09UZHRORGs4cEJwK2JxbWp0T2pUQUxkQ2VjVCtJL00vS3pudFEwallQWE84eGFDYi8ySEFGNS9WckQ2K2VBazhMenlqbGszRjJQaVJnR2p2U3h6ODl4SzA5VTVyVHo5ZVFiTitmeU9ZZTlmbno3YnRDOHlyU0syRWNDa1hiL0ExMXVGVytWOHM3bHZSR2h2Zlhyb1RMRDYySzBuclYvT01EYmgvZW9wOUN1NHFDai9heng2elhxcEY1cEJxRm9FM09RcDZVZkY4M1Jkd2NVSXNtd2JWbTA3QitKdWZPdUtZbm9QZW93NXlMYmpVaXdoNmhwZVZseXdBazhFTEVObk1nSGl0azM2UXJPamFidXdTUndUSkRHVG13c1FvNjdoaXdOOS9PcVp4VytpMm1zeXB5bXlya0U3bW5iVnJzd0o3SVBJQytIZnVpSy9rNGJkYU5qVnRwTVVtNXJPSlN4YmZOWDZBZjk0UFR3LzExRm1aUU02bDdDNld6VVl2UVRzRVRnb2Rwd09aZ0dkTGF4dXV3YWpoemNXSVplWFZRN3JBSG9zc0xxWkdZd3VBaGJHbHFuZ0VMeU5JWGdlYitYSG1oY0pOQUtIdVc4aUsxWWJyc3RPY0xIbkpYUkdUbjlrU2RHaTR3bWJDK2doUmdMVzRyTFNOZDZ3WTRWbWpCb0JLNUdVM0pGTFdGcGdkaU9pN1dLR3dhZ1FzSHkxUDltY1MxanlCazdDdUozVzNwODhSYXdFTEIwT1JacmxEQXZQYVc3Z05QZXd6QWcwTFhtd0swSktsUWhZN0JIbDNsdURVcE5scE1GdGpkTndheGZhL2RKYmxzREk5aS91Tlh1SWxZQlRLTEcvd3RGZkxCM2cwcnFzZ29JZGFHRkpuU1h3c1hDTTJHTEV5djlRTjErbEt1UGhVRi9UbldUcWtpbFVaMGZXRVN3VHRJYWJVYk5HVElkQ2tTWldDVldIUWs4Y0pYemdkdTllRFUrbTlZTU5uK2tieG16RHJSbTAxdGNEWXNPblp1VXI5ZWZidmQ4VEcyTTBkaHo3TzNzSWtyc1JGNVhIQy9ObWxucmRvN0kzYlNBSzZya200TXNyQUh4NW9KeisyOWdwT01rTldEN05sNVFCTjZrRXRKdFhRZHoxQVdqaDlHSGdjaXh4ZE0vMThJLzQ4enB0NmtkczgzRmZSeFhLaWlLMzYra3RTMlp2TG5RTE0rQVJ0bWhLNmRwNDl1Ykd2cFJNNWtBMmszeTQ4a09xNnNZYnJ1MXU3OTRwcVZyOFVjSFMzTWl3ZzFpSWliR04zT2JqNHRPWTJtK2NpY1RQNHF2WWhRbUhOTkd3TkNmTlRRekV3cGkwK3g2RmJIaW92VmhlcktJOWs1dFQwWjdGU0VycHh0MzBZb0hqM0JPazJjR0c2K0dkZjk2Sk51Sy9WOEQ0UGlKYTF0YVlyZHltL1JOMjVDT2lQUGhHMWRUWDBiYW5qeWNzdnY2dWI5cnZmTnRpYUxhTk1ZeXF5S2V0d0ZOaEJZd3ZRVlNTbVYvZ0VtYlZQMWIyQW5xUVo3Z01SWERIdXhaOG14ZWpnLzlzdXhMYVB5QXIvekhZbTh6dmFyYUFoMEZUZlppOFJTWEs5SnFTd0lJMTVjWFBsL2s5QzNJQkcwcElsL2QxOXZ4NjRsNy9aZnlYZkZzSDAydzhIYXdsOERCb2NuZFVLNTZETWhObFVtMUpZTjZxYVVWMUZRVytSYmo5ZHJRZlRLbGE0dHBBc3ZWSWQxOWo0NzErK3A1QjBlZ1dXMkQzbUJsb3BrbVluYTlJQ0U2TGppcEQwNWpHYWFVR2ZRS2Z2NkkwV1BsRVVWN2xWSis3ck5EdEt2VUxmQkIzdFI0OVRxaWFsRkRVV0RRbDM4VVFHenJmTjloeDdHNnNJNm1vY1pZYmhKbEd1NWszU0dWTWNlMStwMlBhcHRwYmtHbThGS1dZMlRxOUJUY1RZVmhSa1RTbE1KQVUweDdaSm1WZWQ1bEdZOHdUYUxaeTh0VnpIWHNzZ2lFTjVqR3RCOW1Sd1AzRG9HRVliSUtCOWpOQU9nNkM4UWxYY3pLNUs3dUZyV3VFSk1vQXZld2hYQ1lhbGhtY3lCNUF6WGFoL2kvQUFJTitLWFJxSzRFK0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvME5EazRRVFV3TnpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wTkRrNFFUVXdPRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalEwT1RoQk5UQTFNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qUTBPVGhCTlRBMk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0U3WjFvd0FBSVBOSlJFRlVlTnJzM1Z1TVhQZDkyUEgvek41NFc1SFVVaFJKVWFKa1NoUjF0V3pKZHB6VThVMUZhaU1RQ2doMUd6ZEFidzl0V3JzUGVXa2YyajQwZlFtS3RnOU9nTFlvMnBjMGR0S3FLSXpFYVdFbGpnTTB0dVhZa1NWWjF0VVdKZDRra1Z5SzVKTGNKWGVtNTNkbVp2Zk0yVE83czh1OTYvTkpUcFk3ZTUxRE1mL3YvTS8vbkZOcm52cG1Xb0o2dG4wazJ6NmRiWTlsMjVGc3V5M2J0bWZiU0FJQU5ydkpiSnZJdGhQWjlrcTIvVVcyZlN2YnZwOXRqUVcvZXQvalhlOE9MdktISDh5MmY1SnRmenZiYnZkM0FRRHZXeVB0N2Vac2V5amJubXcvL2xhMi9mZHMrKzFzTzk3dk42djMrWGxqN1cvOGVyYjljekVDQVBSd2U3c1ZYbSszdzloeUJja1hzdTJsYlB2SDJUWnNQd01BZlJodXQwTTB4TjljNkpNSEYvallWN0x0SDFWOThQVFZnZlN0dDdla0Y5NGJTbTllSGt4bkp1dnB5blF0VFRWcS9nb0FZTFBYUnIyWnRnNDAwNTZSUnJwajIvWDA0TTVyNmRPM1hrMzd0a3lYUDNWUHRuMHQyejZWYlYvT3R1dFYzNi9XWTFIcnRtejd2V3o3NWZJSFhyd3dsUDdvMU5iMDFGdmIvRzBBQUYyZXZQMXkrdHorSytuK202NVZmZmdQVW11MjVISjVVV3RWa01UTXlGUFo5a1Q1QTcvMTZtajYzV1BiN1cwQVlGNWZQRFNSdm5UUHhhb1BmVDI2SlF1U3JwbVNxalVrdjFXT2tSK2RIMDUvOTN0allnUUE2RXMwdzkvSjJpRWFvdVNKZG10MEtjK1F4RFRLMTRvUGZPL3NTUHFYeis5S2w2NWJHd0lBTE02T3dXYjZqWWZPcDQrTlRaWS85TVcwNy9HdlZnVkpuSllUSzJIM2RCNTRkbnc0L2JQbmRxV0wxK3IyS0FDd0pLTkRqZlNiRDU5UGoreWVLajU4THR1T1psSHlicnhUTEkxL1U0eVI4QjllR1JVakFNQU5pWmI0OXkvZlZINDRMcWoyRzUxM09yVnhSN2I5ZytKbnhRTFdWeThPMllzQXdBMTc3ZEpnK3Nvcm8rV0gvMzQ2L2ZRZHhTRDV0V3licVk4ZnZ6ZGtBU3NBc0t5Kyt1YjJ2REVLaHRvTmtnZEpiTDlhL0doY1p3UUFZTGxWTk1hdnB0TlAxenQzN1QzWWVmVFVsWUgwdjQ2NzZCa0FzUHlpTWFJMUNxSkJQaEpCOHBuaW8zLzZ6aFo3Q3dCWU1SV3Q4ZWtJa2tlTGo3endub1dzQU1ES3FXaU54eUpJN2kwK0VqZktBd0JZS1JXdGNXOEV5ZjdpSTJjblhYY0VBRmc1RmEyeFB4N3BPaWw0WXRvbDRnR0FsVlBSR3FNUkpGMTN2Ym5XRUNRQXdNcXBhSTFoeDJjQWdEVW5TQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBTUdnWHNObGN1ektScmwyKzFQZm5qOXkwT3pXdVgwc1hUcjdaOWZoTkIrNUlRMXUzZHoxMjl2V2ZkTDIvZGRmTmFkdllyVFB2WHo3N2RucnBUNy9SOVRtN3MrOXoxOGMvbS8vNVo5LzU0elJlK0RuRmo4MG5mdTZ4WjcvYjlkalJUMzIrNjJjWHhjL3AraDBPM3BsMjNYNjQ4bVA3SC9odzJwTHRnL0p6NjFmVmZ1cDQ1NlVmcFlueE0xMlA5Zk44bC9PL2hlZS84ZnMzL0gyR1JyYWtvNTk5b3VmelhBMXJ2UzlCa01BaVJWaVVCKy81eE1BZXlsOXpxQjBjUmVYUE9aZ041aEUwQTBQRFMvcGRwNmNtMDlVTDQ2bHhiYW8xOEczYmtROTZ4Y2ZDNU1URlJYM2Y4WEpjN1QzUTgyTzNIbm13OHJuMXZmK3lmZFJyb0Q3KzR4L09pYlBWZEh5SnoybE8yRXhlVGNlZStYYTYrNU9mbi9memZ2alVmMXZWNTNlWGYrNElFdGhjeXJNYS9RN1FNZUR1dUdWZno1bUtCZVBwek52cHhXLys3OWtJZXVUbjB0amgrOUtwN1B1V3cyRWpLTThBVllYUytESVAyaDkrOHU5VlBoNHpQc3U1RCtQdkttWXA5aDc5b0g4d0lFaGdZeHZaUHJxaTMzLzYybFNhdkRBKzUvR1lZWW5EU1ZXdW5EK1h6OHhzQnZFYzQ3bE1uRG1kVHY3azJXWC8vaEdna3hNWDBxN2I3c3hueFc1a2R1eEdiUjNkNlI4VWdnUTJpamoydjJOc2IrVXI5WDQrdjd6ZVk2R3ZYOGpvM3YzcDlLcy9YcGJuRllQaG5QRElZcVJxdGlkK1pxK2ZHek5CY1hpcWMraHFQcGZlUGQxMUdDWitqNlhPRHEyRXF1ZGUvUHRiN0pxTDE3NzlqWHhtcE9qZE4xN0x0NVRtWDhlejB2WWV2czgvY0FRSmJCUVJGMVdEVUsvREJ2SDVuVFVWTWRBVVArL2dJeitYTDVhTlYrQzlnaVMrcHRjaGhEeEk5dDJlN3YrcmZ6MU5aQU43NWF2ZTlwcVZXSVJhWFBkUk5EQThuTGJ2MmJmc3I4ejdHVmpQdnZGSzEvdTc5aC9zSHZRTHYzZk15cFFqYU44OUQ2ejRMRkd2MllRN0h2dkVvci91MEVjL21WNzY0Ni9uYTBqNnNaZzFNcGZPdmpQbis4YnZ1V1dCbVkvQjdPOS9OTnZIblVYS0lFaGdBeWt1TnB3dkdNTHIzL21UZktBb2YxNW5zV3lzODZoU2RZWk44WlY1UDJleHhPR1QyT1l6UFRVMWMwWlErU3lmbGRhWkdaZ0pyRkkwRlFmSmk2ZmZtaE1rdTI0N3RDWXpDb2NlL1lVbEJWd3MxcjNuRi85YWV2WFAvazlmVWJLWUdaaXE5VFl4NnpGbTVnTkJBblJtU1dLZ2lGTkdsOU94WlRyam8ydWd6ZUtvT01EWHMwSDNwajIzempuTUVJOE5ESS9rZnk0UGdoRk1NZXV5a0FpTXNwang2V1ZxNHRLcS85MlZaeWkyNzk1elE0dU9RNXdTZmY4dlBaa2ZEaXZING1aWmV3T0NCTmJqUDRyMjRQeHU2ZFg5K1BHZnpjeEtyRmN4ZUI1NDhORjBvVFJURTQ5MUJ1WHk0YXJpcS9yNVpuRXV2SE95Ni8xYjdyeDcwYk1PODYzeFdHcVFGV2NVNG5CYk9ScjZtWFZhaXEwVnB6dWZmK3YxZkFhckgxY3Z2cmZnUGw2STJSUUVDV3hpMjNidHlmN3ZhM01PTjVSbkhjcGlkaUplb1cvRTAzVTdGak9MMDlwUHFlK0FXUTBSSGlzeEU5VXJoc296TCtQSDM3aWh2Ly84dE9oRmZMMGdRWkRBSnJiOWxuMzUyU05WYXdiaThWN1Q5REU3RWJNTnZSYk1MclIycFdwTndVSmZBeUJJWUpPS3NIam9sMzhsLy9OaUZzUFNyWHhJSXM0Z1dlcXBxcGZQbjVtem9EWU1iN2VHQXdRSmJOSkJ0TmM2aXVManZXWlFOcnI1b211eGwwVy9VZ3FTT0oxMUtZY1k0bUp2VlJjNWk4djJseGZWeG4xMWp2YTV4dWY4aVdPVnB5WEhtVUQ5c0tBVkJBbXNtQmhFZTYxQnVORzFDVXU1ejhsQ1g3T1dGK1phS0NMbS9EK2I0ZUY4MFdlc3M2Z1MxeThwQjB0OG41LzkrZE56NGk4VzFGWmR3ajBXbWZaN0E3eXFoYTV4alpUbDNwL2xoYmNkVllmb2VuMXVyMVBLUVpBQVhpblBvK3J5OWJFSU5zNUE2YlZvTXg2UDA0K0wxekk1K2R6M0trOWhQdkR3eHlxL1I5VmRrUmNqdnJiZnIrOFZENEFnZ1J0NkZic1VXK2U1MCsxR1VuVnIrd1cvSmh2ODQweWEvUTk4T0Y5M3N4eCsrc3lmcGFOWjRNVXNSZnhPNVhVamNhanM0SWMrdm1iM2p3RUVDYXlvT0xPbWNXMXFSWC9HZkpjVmo3VXJWeXF1UzdIUTE5V1hhV0NPR0ZuczZhcFgycjl6NTFMN1hSK3JPQndTQzFEakVFengrVlJkUGoydWxIdmd2a2U2N3BuVGNlZGpmMlhaNGdjUUpMRHVuTW9HdjZWZVA2TGZzMjk2WFZZOHJnZ2I5MHZwSmRZMUhIajRveHQrSDhlc1JpeENMVjllL3RYLzkzVDMvc2dDcGVxd1NjeGl6WGRsMlB4bkRBLzNmVCtaNmFuSk9ZZURGbk92bmZWOGdUd1FKTUNpeEl6QnNXZStQZThaTzUwelFXNGtTcVpYZVBhbkxHNnNWMWExMWlZQzR3TWYvY1g4VU0xOEloVDZXYThSTngwY0x2MmNYb3RVWTZGbytZcTJ2ZTYxRTlFWU4xYnM1L3NDZ2dTV3pYeDNYVjJ1SzdGR0pMejlrMmNyRjIzR29aQmlwRVNVVEYrYnpCZHpMclIrWXFUaWtNYmJMeitmRDZEbjMzeTk4bXRpOXVhdUJYN2Y4aGsvOHkzcXJBeVNIbXR0WXNaazMvalpPYWZnRnZmSHJmYzkwdmMrTForTkVuZFh2dEhEUEhFYmdmTHY1N28wSUVoZ1VjbzN5ZXZucG5uejNYVjFmQW1uNzFZTjZGVmkwV2JjOGo0RzF2SWRabU9CWjNtUloxVVVSTENVcjVNUzBSTm5yRlF0RWwwUElqak9ackZVTlZNVU53WHNkeEZyaEVmRVpIRTl6dkcvL0U3YWZiQTd0eGFhYlNuZmsrWnNLZVFpa2dCQkFvc3lmcXg3RUw3UXh3ekhXdHlISlJ6KytHZG1ycVd4bU52ZWw5Myt3WS9PT1F4U2RhWFRzVHNPcjh3K3I3aWo4SHhpcHFqWDg0enZOZkxjTTMwZnN0cTU3MkJYa0VTTWxXZWhGZ3FTaGU1Sk03SmoxRDhzRUNRd3Y3SEM3RWJNTkx6NGY1OHFEVFkvcTVodWYySE9JTGhzaDJhbUp2djZ2UExOMnVMVi9sS2pKQTZESE1wZTRjOTNUWTNGSEFwWlNTZXoyT2gxdUtZalBoNkxUZnRaUnhMclFCYjZmamRxZE84Qi85QkFrRUQvNGl5TzhtQWVyNWF2WGhoZnRkTkg0K2ZGWWFLcVdZSzRlbWxjTUN6TzJLaGFKQm0vNDlIUFBwSFA4bFJkSnlUT0twa3Z6R0l0UjlYZ0hJYzE3dnI1eDFma2VoNVhLeTZLdG4xMzlaMkI0MEptVmI5ZjFhWDVJNjdLRjA2ckV2dnhubDk0UEIxLzd2czlUNlcrRWZIM3VORHZBQWdTNkhMcUp6K3Fqb1NUYjg0YkpESG8zTlRqVmZCU3JnUWFaOUxFMnBDbFhFUXR2cWJxTXVrTGlkbWh5ejB1ZGhZRGRjVGFTZ3lzVmRkenFRcWZXS2RSdFM5ajM5L3gyQ2Z5bWExeWxMejFvMmZTbHAwM0x4aVRjZmJPZlF1Y0lqeWZ1TmhiMWZWVjRyb3ZxM2tkbEtyTHk0TWdnUTBtVHVzc3ZrS09tN0YxTHJZVml4VG5HK1NyN3F1eVVKRE1kNytSbUNWNS9odS92K3pQc1h3dm0rSzlZdWE3MkZxSU5TWUhKeTdsc1JBM3BZdnc2WFZqd2NVTW9IR3hzemxCTWp3ODUycXdWUU50SEVhS0dJbmZxZXB3VmZ3NUh0c3h0bmZtc2VMMVhlTG45eDFzRllmU1RyN3dnM3dSN1dMQ3hZWGFRSkJBcGFyN21jUWhpdDJIN3A0SmtoaW9PMmU5VkoyK3VaaDdtc3c3dTdIS2R3V2U3MTR4VlRyNzQyajdFdmlMZWM1eDVkV3lYajg3cmc4eWZ2eTc4LzV1RVNQRncwaTkxdERFbjR2ZjU2NCtmbjYveW90ZkYxSTFpN0phNHRvc3NKblU3UUxlRCtKc2toaHdWL04wellpUkdGQmpzZXBhbjE0YnovdWh6MzhoRDdQbEVvZE8raEV6VXdzZHF1cDFqNXFJa2poamlHNXhXR3M5TEVpRzVXU0doRTJ2TXp1U3Y2Szk5NkU1RngyNzBZRytJeTVJRm9kUWl1OFB0TmNjeE9HZk9LU3ozTW9YUWF1NmRIb2NmdHFWQlZuOExuZC80cGZTOFdlL2UwTXpDYkUvRHo3OGtjcklLTitrTU80UjFEbWtzZnZnblQzWDVYUU9HVldKZFM1eHc3MnErK05VRGRTcitvcXVGRkJWejdIWEplYjcrZHlxdFN4eHhkdk5jRU5IS0tzMVQzMnpXWHpnNTUvZVo2L3d2aE5uaGl6MjVucXJ2Y0FSWURQNTg4ZFBkNzF2aGdSU0VoWUFhOHdhRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBREs3TDM2clpUSk1YenFlcjQyZlQ1TVgzMHZVcmw5UDAxR1JxVGpleUR6WDhyUUhBQW1xMWVxb04xTlBBOEVnYTNMb3RqWXp1VEZ0Mmo2V1JtM2JGQndYSmZLNWZ2Wkl1SGorV0p0NDVtUVhJVkw3RFlvZW1XbXJ0dkd6SDFtb0QvaXNEZ0Q1ZTNEZGpiSjI4bW8ydlY5T1ZjMmRTZXVPMUxGQ0cwL2E5QjlMb3dVTnBjTXRXUVZMVXVEYVZ4bi82U3BvNGZTTGZlYlY2Rmg2RFErMGdxYlZpSkkrNXp0dVovdk1mSEFETVZranBqODNXMjJaelptdE1UNmNMSjQ2bGk5bTJmZDl0YWZjSGpxVDYwTEFnbVhqN1pEcjN5b3VwMFpodWhVaDlJTnNpUE9yZFFaTDNod0FCZ1A3N3BEbjdkbVpycE5USTNqWWE2ZExwRStueU82ZlR6ZmZjbjhYSmdmZG5rRFN6blhMdTVSZnluVkVieUNKa2NEQ1BrUlJSRXVGUmI0VklMVlhOamdnVEFKaG5sQzI4YVJiZVJvaGtML2pyclNCSmpWcldKNDEwNXFYbjB0WHpaOVBOOXo3WUdvUGZMMEhTbko1Tzc3N3d3M1JsL0d3V0k0TjVrT1FoVXEvUEJrbHhtK2tRSVFJQWkzajFQenVFZG1aSWFwMjNuWEcya2IvUWp3bUM2Y21yNlpZSFA5d2FsemQ3a01UTXlMc3YvR1VXSStkYXN5THhwR09HSkErUmVudG1wRDRUSURXeklnQ3dOUGtnMm15UHY3V1pRS25GWVp2MjBZaG1vejNXWmx1TXpURkczL0x3bzZzK1U3THFRWEx1cFJleUozeW1IU09sMlpGMnJkWE1qQURBY2xWSkhpSzF6aG1yK2RrM3JjTTJ0V2E3UkdhMmxJL1JzYVJpN09oRHEvcGJydXFGMFNaT24weVgzajR4RXlLdDJaSFdlZEtwYzdpbUV5YWRFQkVqQUhDRFRkSjlna2huaVVRKzdzWVluSS9GQSsxdE1EOThFMmUrYnNvZ2lWTjd6NzM2WWlGRWlqTWpyWFVqTlNFQ0FLc1NKalBqYm0xMkRXZWFpWktCZERZYnMvTnJnbTIySUJsLy9aWDgxTjdpVEVneFJwemFDd0NyR0NidHQ4VW9LYzZjeE5rMzUzLzY4dVlLa3JnQzY4VHA0KzFyakJRV3NKYlBwQkVqQUxEcVVUSzdock5ldUNiWVFIN1lKc2J3VFJNa2NUbjRacjZhdDE3WUNndFl4UWdBckZtVXpCeXBxSGVQMVRGMnh4aStPWUtrMmN5dnh0b3FybHIzTVNzeEFnRHJLRXBtMTNUbVkzWTJkc2NZWHJ5ZXlZWU5rcmhyNy9TMXFmYWw0R2RuUm9RSUFLeS9NSm1aS1dtUDJ6R0d4MWkrNFlQazZ2aloyZU5UOVpwMUl3Q3dubU9rWXN6T3gvSVZ0dUlYUnB1OCtGNXJrVXo3dmpTdGU5UFVkQWdBck1NdWFYYnVJNWM2UVZMUHgvS1Z0dUl6Sk5jdlgyNWZBSzd6eENxS0RBQlkreHFaK1hQM3VKMlA1UnM5U0thdlRaWkNwRlo2Q3dDc2t5cnBmdHNPazN3czMraEIwcHh1ekQ2NVRwaVlHUUdBZGRva3hiRzZWaHJMTjNLUWRPNG9xRUVBWUlQRlNTdE04ckY4b3dkSjliTURBTlozaWF5dXVwME9BS3kxVlF3U015TUFzTEdzM3RodGhnUUFXSE9DQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUI0UHdWSjA5NEdnQTFsOWNadU15UUF3SnBiZ3lBeFV3SUE2OXZxajlVckhpUzFXdllqbWswZEFnQWJzVXV5TVR3Znl6ZDhrQXpVWjU5VkoweWE2Z1FBMW1lRUZNZnFabWtzMzhCQk1qQTBVcG9oYVpiZUFnRHJwRWE2MzdiREpCL0xOM3FRREc3Yk5sdGE1VU0zWmtvQVlKMjBTTE83U3dyamRqNldiL1FnR1JuZG1UMmZSclkxVStkLzRnbHFFUUJZaDAxU0dLL3pzVHNidzJNczMvQkJzbVgzMkd4bE5acUY0bXJPTFRJQVlJMUtKSFdQMFlVeE94L0xOM3FRak55MEt3ME1EV2RQcU5IYUdtSUVBTloxbE9SamRXdmNqakU4eHZJTkh5U3BWa3ZiYnoyUVBhZEd0bldtZjFwUHRDbE1BR0JkaEVoeGJNNjNHTE96c1R2RzhCakxOMzZRWkVZUEhrcjVVMmswQ2x0bkxZa29BWUMxajVIMnpFaGhySzYxeC9EVnNDcEJNcmhsYTlxKzc3YXN0S2JiV3lOZkpHTTlDUUNzYll3VXgrTDhKSlQ4aUVacnZONSs2MjM1R0w1cGdpVHMvc0NSVktzUHpGUlhzNzNOSExvUkpRQ3c2akV5YzZpbU15NTNaa2V5TVh2MzRTT3I5aXV0V3BEVWg0YlQyRDMzcCtiMGRMNmwyRXBSMGl6WEdnQ3d2Q0ZTT0V4VGpKRThSTnBqZEd4ajk5eVhqOTJiTGtqQzluMEgwbzQ0ZEROOXZSQW0yWTZZYm5UTm5DUmhBZ0FyRWlMNXJFaGhKaVFmZy9PeHVCTWoxL094T3BaYXJLYkIxZDRuTng5NUlFMVBUcVlyNDJjN2V5bmJCdkszK2MxNzZyWHNUKzBiOHRWcXJZVzkrVTZzK1E4S0FCWmZJek5OTWhzbHJaTkxPbXRHWm1aR3JrK25yYnYzNUdQMWFsdjFJS25WNittV0J6K1Uzbm4rQitucStYUDVmcXBGdU5Xei8xUFAvNUJGU0N0R1ltdk9uR3JVWEpYVGpnQmc4N1JJcy92UHpjSVpyb1UxSTUyWmtiZ0FXb3pSTVZaditpREpvMlJnSU8zOTRHUHAzTXMvVHBkT24yakZSak5tUlFabVprWmlwaVNmSVltWmtieERhb1ZKRW1FQ0FQT1VTT0ZOcy8yL3M2ZjJ6Z2JKOUV5UXhHR2FtKzk5b0hXMFlnME1ydFd1aWljOGR2U2h0R1hYV0RyMzZvdXBjZjE2YTRhazNqcHNreHJ0dDZrMk96TmloZ1FBRnRFbGhYVWphZllLck0zR2JKRFU2d1A1ZUx6YWEwYldUWkIweEVMWExXTjcwdm5YWDBrVGI1OW8xVnBFU1JSYSs3Qk5hMHVwZTVhay9UNEEwQ21RMGgrYk0zZnVuYm5FUm52ZFNJeWdPMjY5TGUwNmZLUjFpNWMxTnJnZWRsL3NpTEdqRDZhZGR4NU9GNCsva1M2OWZTbzFyazIxUTZUZTZnNnpKQUN3aURZcG5yR2FaaTVJR3FmeWp1NC9tRVlQM3JscUZ6M2JNRUV5ODh0a08yYjMzZmVsM1llUHBza0w1OVBWOGJOcDh1Sjc2ZnFWeS9tWk9mbWltK1EwWUFCWVNMNEtjMkFnRFl4c1NZTmJ0NldSMFozNW90WDhSbm5yOE1YOTRQcmNpN1Uwc25OM3ZnRUFtMS9kTGdBQUJBa0FJRWpzQWdCQWtBQUFnc1F1QUFBRUNRQWdTT3dDQUVDUUFBQ0N4QzRBQUFRSkFDQkk3QUlBUUpBQUFJTEVMZ0FBQkFrQUlFanNBZ0JBa0FBQWdzUXVBQUFFQ1FBZ1NPd0NBRUNRQUFDQ3hDNEFBQVFKQUNCSTdBSUFRSkFBQUlMRUxnQUFCQWtBSUVqc0FnQmdQUVRKVlBHQm9YclRYZ0VBVmt4RmEweEZrRndzUHJKOVFKQUFBQ3Vub2pVdVJwQ2NLajR5TnRLd3B3Q0FGVlBSR3FjaVNGNHVQbkxIdHV2MkZBQ3dZaXBhNCtVSWtoOFVIM2xnNXpWN0NnQllNUS9PYlkyL2lDRDVWdkdSVCsrOWFrOEJBQ3ZtVTNOYjQxc1JKTTlrMi9IT0kvdTNUcWNuYjc5c2J3RUF5eTRhSTFxaklCcmsreEVrc2JMa2Q0b2YrZHorSy9ZWUFMRHNLaHJqZDlLK3h4dWRDNlA5ZGlwY2orVCttNjZsTHg2YXNOY0FnR1VUYlJHTlVURFZicENaSzdYR2RNbC9LWDdHbCs2NW1PNGVkY1lOQUhEakR1KzRucmRGeVg5Tit4NC9YZ3lTOEsreTdXenhzMzc5eUlVME91UzZKQURBMGtWTC9QcTlGOG9QUjNQOGk4NDc5ZElIdmxUOHpFZDJUNlYvL2VCN2FhdXJ0d0lBUzdCOXNKbTN4SWQyVDVVLzlFL1R2c2ZQVmdWSitGcTIvYWZpQXg4Ym0wei83cEZ4aDI4QWdFVzVlOGYxOUc4L09KNjNSTWwvem1Ma2Q0c1AxSnFudmxuK3BPRnMreC9aOWtUNUExOTVkVFI5OWRoMmV4Z0FtTmV2SEpwSVg1NjdaaVI4UGR2K1JoWWtVd3NGU2RpV2JmOHoyejVYL3NDTEY0YlNINTNhbXA1NmE1dTlEUUIwaWV1TXhLbTlwYk5wT3Y0dzI3NlFiWmV6SUVuOUJFa1l5cmF2Wk5zL3JQcmd5U3NENmR2dmJFa3Z2RGVVM3J3OG1ONmRyS2ZMMSt2cHV1VW1BTERwRGRaUzJqYllTTGVNTlBKNzA4VGw0RCs1OTJvNjBIM1JzNkpZRXZMbGJHdVZ5aUtDcE9OdnRjTmtqOTBQQUN6U21SUUxXRlA2YXRlanBTQ3A5L0dOWXFIcmZkbjJIMVBoNG1rQUFQT1lhcmZEZlhOaXBFSzl6MjhhZGZOcjJYWTQyMzR6MjA3WXp3QkFoUlB0VmpqY2JvY3ovWHhSUDRkc2VvWE1SN0x0TTluMmFMWWR5YmFEMmJZanRkYWVBQUNiVzZ3RnVaUmFWM3QvSmR0K2tHMS9rbTNmVDYzNzVNMnZkTWptL3dzd0FPRkhjS1lHQksrQkFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvME5EazRRVFV3TXpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wTkRrNFFUVXdORE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalEwT1RoQk5UQXhNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qUTBPVGhCTlRBeU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4Ky9JS1RwZ0FBQm9KSlJFRlVlTnJFbVh0c1UzVVV4My8zMGZmYXZicXh3U0NiR3hNWmJJRkZCQklsRWpVYVlsQmpOQmcwRVJJakppckdZS0lHd2NRSEV2OFVFSk81aEljbWpQZ0hBaVp1U0ZSZ3dBYm9kTkF0YXhtdlBUcTJkVzNYOTczWGM5cmZjRnQ3MjN2YmJwemttOTdjM3QvOWZlNjU1NXpmNHpKTHRoOGdHWmdXdEFyME9LZ1dWQTBxQmVYUS83MmdmbEEzcUFOMEd0UUtDazNjb09yUVpsVWQ4bW1DTGdPOUNYb1JWSkRrdWdLcUd0RHpvQjJnVVZBVDZGdlFGYlVkc3lxdnJ3T2RBRjBDdlpFQ1ZzN3lhVnU4eDhtZWpRMTFhaG96Q2tOQ0Qvb0M5SFlHYjBYT0lxQnZRQjlDZUFTeTRlRXFRcVR6OFB2ZURNQk9oT1ZXN0FPOFhaVVJNQ01LSytCR2tDUk1IWmx4d3o2a0MvWlh2bHVaRmpEQXJwUlk5amM0c3BKWk02WUErbXhKQnAwUW1CRWlDNkhoejNCa0lyTnVqQW43dG0vWXYxQVJNTzhiTlVnc2QzUjJQUnNIYlVXRzNoZStOcVFFRm5UbXJ3akQxQ2E2VGFYVlJBNi9Wazh1YlZ0RGRqMjdtQmkxbkdxVUhCMVBkcSt2SVJmZmY0d2NmSFU1cVNnMHlqQXp0Y0N5SzJsWjQ0TGVla0dYY3o1Uk5hZ3FNcEh2Tnl3aitVYk52WE9YYjQrUkxVZitKcjZRb0JoMi84dDFwSGF1NWQ2NTRmRVFlZjJISytUNnNDOWh5UU9tUnlxYTNyMGM1MkdvZ1l6STY3K1VLMTJmclh0b0NpemE4ckpjc3UrbE9rV2VUZ1NMVm1qU2trK2ZXU1JiOGlnVEV3Y004YkpDNHZnbjVGcFdGQ1IrZFJQUXBpVFFjckNUUTAzT2dPbEpaSnNDSFBXdVJ2L081Q2VaYm1jY3c3STNSZWk5TXRDcFlORis3N21iZkRpWXhNWVZyOEU1Q1dQeGxkYnNoMERYeWJVNjZ4Z2h5K2Zua1ZLTFB1SC9lQjcvYjdZNVNWaVFGTU8yMzNTUkQ0NWRKUkZSa3ZjeXk1Y0QyeDdEWUZjdzZtSHZndnBINFlRNTJXT09RMks5QlFtR2lhYkUwMHBodHpSMWtFQTRSZElDVzVRUlBiejYxbkYyZE1tNkxhTEdzREpWNHFEbjBJTktQTDErYVVsMllQOGZlWjE1MTM1dFJnOXJKRTVUcTdTT0t2VjBObUZqeVJkbDFDQ3dUdVMwRldxS3Z4TG9iTUtpVVVZZEcxM21zRnloMm83VGdVNFhObGJQb294YUJPWWxoaldtTStLcmdjNElGa01peHNnak1FY3lNSVpoNEM1TWFnZkJOUnhETWpXT2pmWXBDZjUwV2lzcFhVb0dGMFdPaVRFeTBUck1SRUpqTXdtYkRlZ0pSalphTVVLK3ZwbUd6UlNhTWtvSUxIQitsejJic0poZ1NrZEV4Y0F4UmdHQkkvb2hlM3MyWWJFYXFCbkdGZTB6M0xYalBrWUVnVU41dHBaMlJvejRzd1dMcFV2dDNDUDVzQndKNUYxclJxZUdFRGpJKzBaR3RLNit0bVNOZGp6OW9PcmhWaW4weDA5Vko5L0FjL1ZkaExVbXptK2pzN1V3eUcyeG56bWVyTkhhYW10YWc0SVM2TFhWUlVtQnpZNnp5T1pHVnJablk0T0lNOHpjcmxOdEdvL3ptbHdqMjZBMzdSRXNGWFNYMHl2YkZwa2daTnZvVHFnNHNVUWFCem56TzM4NVJDUkpUTlR3azVPMjZJSXgzZUZXRHRycERaTHRKMlQ4QkN6NW5TY1A0bVdVTWJiaUtPZzRocENNYnVTRzRDOVpWQmJKc2NiTjNrWjlZZktIZlpnc21tT0dKT0ZKUzljUTJRWXJCVFZ6ZzRuNWRGbWVnUlNiZGVUcWdJZHMvZWxmY25NMGNiNGJuTjJuaTlwL1BBS0gxMEdlS2N0OFdOZmhqUHdCd1pENzhNMTFPejhYOUpaNTVENGFGM0QzTFRpeDh5UE9QNGJoNEFBRnBtK2tCRUVEY0lHanVMVnhMd3lGNC9kdDN3ZjZCb1k5eUlKTWxHM3FNaCtTVDZKdTd6WGQ2ZmdMWHNVK1dKYUVaaDBXK3NTK2tRRlpLTk85RlNwZE5jZHNwSGE5Q1BHTVpVNkVlQTd5ZnRlQXIzUnhIVXllTmJNQ0s0UjhSVzJIOTFwNi9qeUh4WVBFdm84RXAyOG1UemVNbFR0WVVhQWhDd1hiTjdocTB5YUk3Ymt6R3JQK3NiNDVyWTJOeHI1LzBMUGRsQ0Z1UjM2S2g2bVhDZlV5cG00RTZtQVlCcFhPWUdHNUtXS3l6by9PMkxOcFVMb01nN1l6ODVwM04raGN0MjNVc3pkb0daTlNBaytEeGgyNkFDdUVKWXZqbkVQcjd1OEo1WmNWQ0xxY3JHekZhdDBETmdpQkE5WXJSMDlCSDcwVTlwWWNiTnp1WmR5TzVhSE42RTBzZHdoWURpb0Q1WHZMVjFTNXF0ZXVCcTh2aGVXM1VWMmNodjI2NGQ2TzNPN1Q1OHk5RjNwSTdEUFliWnBnZDJrWXlHNERLZnFLQk9DWWRMZ3pWQUxDK2x3TXNvZ2F2Y2xUc2FyU1YxcFRHVFlYbFFyNjNDSTRaNUZZWGt0bldTRTJISEJ6Z2JFaGpXZW8zOWpmYVRkZmI3WER1WEU2TjNEU1dCMmcxU0NjOG9HVmZnbWwzc2E5Tnd2MU9NNVljT21kUTkrQ2hvcWJ0S21JbmhJb1NKaDZEK2NFT1BNYW9oNTEwMG9nS1hwRHoxV29ybGdNaVgyeU5WS3ZXK2d2Z2hzbVFaTkpzSDRLNnFHQUhwb2ZJYVdneWNwYXlyeW1Ia0dOVVVBZGZRaGV4c01SQ2hla0R5Q21tNmovQ1RBQUExa2hBUE5CUmZrQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMU5VUkZOakZHTnpOR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8xTlVSRk5qRkdPRE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalUxUkVVMk1VWTFNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qVTFSRVUyTVVZMk0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K3hCVkc2d0FBRHo1SlJFRlVlTnJzM1U5c1ZWVWV3UEhENjJ0THJYVmFDcHBhYW1ScUpDWE93aUJ1UjkxTlluUmhvakhqeWlIQi8ydGpqQnZkdUZZVEhZa3JaM1NTV1UweTI4R1pwVWpHaFlLWUlDYlFhWVovVmFDVXZyWVB6Nis4NHUzbFNsK2xMeWI0K1NTL0JlZSs5aVhuYmI2NXZaeTM0ZjJEbDlMUFVNdXpLOCtEZWU3TGMzZWUwVHo5ZVhvVEFIQ2ptOHN6azJjeXo5ZDVQc3V6TDgvK1BNM1ZmbmozeE1wLzE5ZjQ1bHZ6UEovbmozbkdmQllBOEt2VjI1cE5lWDZYNTdIVytyRThmOG56VHA3ajdmNnlXcHV2RzI3OTRpTjVYaFlqQU1CUEdHdTF3cEZXT3d5dlY1QThudWVyUE0vbDZiSFBBRUFiZWxydEVBM3h4R292cnE5eTdhMDh6MVJkbkoxcnBQK2RtazdUNTJiU3pPeGN1amczbnhhYXpkUnNObjBFQUhDRHE5VnFxWjVuWTI5MzZ1L3JUVU1EL2VuMnpVT3ByL2VxZXhlYjgzeWM1NEU4TCtaWldFdVEzSlRuYjNrZUxsLzRMZ2ZJc1JObjByZFRKMzBhQVBBckZUY2dHakVMQytuc3pHeWFPdlZkT25oME10MDVzaVdOM2JvcERRNzBsMzhrYm5ERXM2aHh0K1JDTzBFU2F4OVZ4VWk4MFpISi8vc1VBSUJLY2NNaVpuejB0clJqMjJqNThzT3R4b2dIWUZmY0thbDZodVR0UEk4VUY4NmNQWi8rOC9sWFlnUUFhRXMwdzcvL2UyaXBJVW9lYWJWR3VsYVF4RzJVUGNXRms5Tm4wNmNIajZUdnoxK3d1d0JBMitKUE9kRVEwUklsZS9ZZVNrLytWSkFNbDR2bDlQZm4wNEhEUjlQOHdxSmRCUURXTEJvaVdpS2FvdVR0SENWYnFvTGtqWFQ1U2RncnZ2am1tQmdCQUs0N1NxSXBTdUpBdGRmTFFYSkhuajhWWHhVUHNNYXRGZ0NBNnhWTjhlWFJxdzV1Zlhydm9hVUd1UklreiticFhyNGFaNHQ0Z0JVQVdFL2ZUSjVZYW95QzdsYURMQVZKekZQRnE4ZFBuTEZyQU1DNnEyaU1wL1llU3JYbGIrM2R1cng2NFdMRG9XY0FRRWRFWTBSckZFU0Q3SW9nZWFpNE9uVjYybTRCQUIxVDBSb1BScERzTEs2VS9yWURBTEN1S2xyanZnaVM3Y1dWK0tJOEFJQk9xV2lON1JFa0k4V1ZpNDE1T3dVQWRFeEZhNHhFa0F3VVZ4WVdIWVFHQUhST1JXc01SSkQwRkZlYXpVdDJDZ0RvbUlyVzZLblpGZ0RnbHlaSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUVFSFNXTEZRMjJCWEFJRE94Y2ZWcmRHSUlEbFhYS2wzZGRrcEFLQmpLbHJqWEFUSlZIRmxZMCszblFJQU9xYWlOYVlpU0E0WFYvcjdldTBVQU5BeEZhMXhPSUxrUUhGbGFLRGZUZ0VBSFZQUkdwOUZrT3dycm93TUQ5a3BBS0JqS2xwalh3VEpwM21PTDYvY3RMRW4zVG15eFc0QkFPc3VHaU5hb3lBYVpIOEVTVFBQaDhVclk3ZHVzbU1Bd0xxcmFJd1BkMCtrNXZMQmFPK2t3bmtrZ3dQOWFYejBOcnNHQUt5YmFJdkJsYytQTkZvTmN1V2sxcmhkc3JmNGloM2JSdE10L1gxMkR3QzRidEVVMFJZbEgreWV1UHpZU1BIbytOZnluQzYrNnA3ZmpxWHV1b1BTQUlDZkwxb2ltcUlrbXVQVjVYL1VTaGRlS0w1eStEYzNwNTNidDZWNmw2KzhBUURXTGs1bGpaYUlwaWg1YWZmRWp6ZEN5cVh4Y1o3M2lndGJobTVKOSsrNHk1OXZBSUExaVhhNGY4ZjRVa3VVL0RuSHlGK0xDMVczUGw3Szg0L2lRbFRONysrZDhLQXJBTkNXYUlab2g0bzdJOUVZTDVZWDZ4Vy9JNTU0ZlRMUDMvUDhvWGdoSGthNWZmTmdPbmJpVFBwMjZxVGRCZ0JXaUhORzRyLzJEbGFmL1A3UFZtTTAyZ21TY0NIUG8zbmV5ck9uZUNIZVlQbS9CVStkbms3VDUyYlN6T3hjbXAyYlQ0dUxpNmw1NlpKUEF3QnVjTFVORzFKWFYxZnE2KzFlK202YU9BNCtUbUF0SFhwV0ZJK0V4SjJSK2FxTDlXdThWL3pBTTNrK2FZWEo1dUxGZUVOL3dnRUFWbkVxWFg0YzVLTnJCazRidnlnZWRKM0k4MjZxdU1VQ0FGQ2gwV3FIaWRWaXBOMGdXYTZiWi9PTTUza3p6NlI5QmdBcVRMWmFZYnpWRHFmYSthSDZHdDhrVGxON09jOHJlWGJsZVNqUHpqeDM1OW1hSng2bDdmWlpBTUFOTHg3dE9OOXFnNi96SE1qenJ6ejcwK1h2eVZ1VEh3UVlBTnNGWU1XYTk5TXJBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJOMEl5TUVZNE1ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk4wSXlNRVk0TVROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZM1FqSXdSamRGTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkzUWpJd1JqZEdNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtvNUNybVFBQUJwMUpSRUZVZU5yRW1XdHNGRlVVeCsvTTdPNTBkOXVsM1Q2M3ROQW5GYkN0dGlsQkRURVNVZUVEUWEwZi9HQjR4T2NYUmZsaTFHQ2lNZW9YL0NLdlJGUlFFNk9RRUpHS0QwQVRSR2hMZ0FLaExmVEZsbTY3cFZ1Nzc1M2RtZkdjM1Z0dDZjN3V6TzYyM3VTZlRuZm4zdnVicytlZWMrOFpuYVgxZlpKR000QWVBRDBDYWdBdEE5bEEyZlI3TDhnQjZnVjFnVTZEL2dJSjB3T3N2ZkNlcGdsMUtZTGVEM29aMUFxeUpyalBTclVTOUNUb1hkQWs2SHZRUHRCRnJST3pHdTl2QkIwSFhRQzltQVJXcWVYUnZqaEcyNm5tblkzekFad0YyZ1hxQkcwQU1TVDlobU9zeHpFQitoTlFWcWFBYTBEblFLK240VUxKM0hJN3pnSFFOV2tCTTdLMGlpNlNSakwvRGVjNGY3cnBuZFVwQVFQc2FwbGhUOEZsQVZtNFpvVTVmMHNFSFJlWWxjVmE2SGdNTHMxazRac1o1LzY5NmUxYVZjQzg0RFpDaDhNTGJObTdXd0V5L0ZtLzNaZzBEb2YxNW85bHdqVEVHNlcwS0o5c2UzbzlXV29ySmgxWGU4akJvNytRa0NCb0lqRm04V1R6cHNmSWZmZlVFUHVvazN4KzVBUnhqRS9NdVE4WmdPVWp1SHh0NXVjY3YyTHR2Ly9vSS81bWtlUDN4N1A4NHVJQzh1WUx6NUtTQWl0aFdaYVVseFNTdW9veTBuNmxoNGlpcUJwMng5Wm5TUDJ5S3FMak9HSmRaQ0V0OVhYa2NuYy84Zm9EYzZFWnRubTRxT1g0MHJHempqa3VBU21TQWRnUGxVTFg4NjBiU0k3Wk5PdXpXZ0Rlc2FXVjhBYURhdGpxOHRKWm4xdXl6V1RyVTA4b2hqekt4TXdCQm45WkpUSGNvMG85YllYeGs5bzBkQlp2MEF3NzA5V1VHakN0UTdaWndOUzZyeWJLWUYwOUE0cURJdlFibStOREo0UEZkcm03TDJFNm1Na1c4MkdHV0NZdFZlQzdESy9VNjhxTmdhalA1dWRhNG42UG4rUDN1QmdqMUtmVndQWU0yTW0rYjQ4UlVaSVU3NUZacm9Jd3pPNDh6MUFvYW1Gbjd2STFzQ3B6RWoxbU1DU1FYUWNQa3h1RHc2b3NyUloyMTVlSGlSQU9KL1IvWkVQR3FJWFhCODZ3UTdZMXI0RFpWeWRiT0dnNXRLQWFTei9VZEc5R1lQL3pYY201Wk96Y3IyaGh2Y1RvR3RUR1ViV1d6aVJzYlBGRkdmVUl6RXVzcmxKTDhGY0RuVW5ZS0hDTWtVZGdBNFNPZkswVHB3S2RLaXdOYjhob1lLT0pnbUZNcVNSOExkRHB3TWFDVzVSUmg4QmNXc2NHaGlFc2wvd2N3T0o5Yk5vSGxlaE1ET3g5QTZuMFZoTzYxQ1FYVllhSk1USlIwN0JTZUdvK1lUTUJQYzJJd0xJK0VoeVpiOWgwb1NtampNQ2lJZXpweXlRc0xqQzFHVkYxeFNiR0tDSndaSkZ2dURPVHNCZ050S1J4TlEwWXNZNFJRV0NoekhtK0U4NXhnVXpCWXVqU3V2ZEk2TCt5R0N3SFJtUkY0RkNXNEhhWkErTWRpVHB0MmZTNDVuU3JGdnE1amVzU24wb0Q0KzF3MXNSelZIUzNoak80YlJPWGZrelVxV2xGYlVwSlFRMTBvckd4bFV4Y1JqWTNzcktubW5maVJ0UmI1bXp2TUlZbXJ5dDF1dVZ3cHB6QmtrSGJGY2FPdWlJd2dUdDAwRXFvTkoyaWZMZ3RYanA2NW11R3lIRjMwZ2VPdEJHMzE1ZHl1bFdDL3R2dEpaOGQrVW1oK0NaTHdQUVZzbEhHMkltajB2RUhRakk1L2xGeE1xZXlMTWpuenRtOWVYd0JPQ2Ixa3lWd3hNZEZjdUZhTDlrTEp3VXRlNFBwL1hTUk5aZmtXckxKME1nWStmU2JvMlJzWWpMdS9ibWVXNmVYMlU5OEI1ZDRQdk5FSDJLNm9BM25PcXdlVmduNjdKYjI1Uzk5SU9qTmkvL0hRZ3JFWGQvSXF1djczektFdmVnTy9mZ2ozVjM1Q1lGRzRZYis1VU0vN09Ha3NPLy9nc1c1Z1dFM3NpQVRaWnQ5eklmRkoxT3pEK1pQM2JoVWEvOTVMMnc0aElXR3hUbHhibVJBRnNva3g2MzhESlErTElFL28xTktPWDVIaUE5N1JsMlc2a2FaWWZVTEFjdEtFWCtkdlcxUDZaMkxaM0ZOazlqN2tWREMyaHIxbGR1NDM0Q09MQzk0L05jck5tNEQzeTZkWDUvMWpvQWJmSkUvZFJNdDIwc1pnblBjWmFhRnFaVUp0VEttNm9ncDVBcERVcm5tTVplYVEzeHVPVzZmTStvQ0VMcnlQSU5ubW5vUEhjZ09PTHVwWllkb0dKT1RBdDhGN2NlbjVLU0liSnZvNmpjSDc5ejBHb3V0WVowcEk2VllVM0NpdSs1VzI2R2EyeWRQd2h5REZOYXVCRHNyck1WcldNSWlzUmN5Q0ZnQktnUGxqVmxYMXR3dWJIblFiU3F0aDlPc1NhT2ZCaXora2E3RjQ1MW5pMTFYYjVMWWE3Qmh1c0R1VURlUUZYOFJOUzhXQVJ3WEhWYUdTckR5Q2lyQ3dxUElHY3lqMW9acWw2V3FPc0JiYlNGOWRxSElHaXd5eTBXM1g0d2tDcHdrdVBtd2Q5d1ljam1zN3Y2K0VsZFhIeWNLUHJvM2NGSmZIYVhSSUdrV1l0UytDYVhXeHRxYmhWcThFQXM5SlBiV0UzOEZQUlUzbzZpSWxoSXBTSmhhRC9jRXVQTWFweFoxMDBnZ3EvTDVUWlY2N2VzazlzcldSSzF1b1g4UjNEZ0Rtc3lBRFZCUUR3WDAwUFVocUFWTkZOYVNOWmxhQkRWRkFYbjZFRG9GQzBjb1hJZytnSlRxUXYxSGdBRUFSREFtd2FOWUlRNEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFs+mXrS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1lc3NhZ2VDb21wb25lbnRcXFxcYmV0SW5mby52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtZTJhNGFjNmUvYmV0SW5mby52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuYmV0LWluZm8ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZT83NjYxZTJhMVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0NBQ0FcIixcImZpbGVcIjpcImJldEluZm8udnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi5iZXQtaW5mbyh2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiKVxcclxcblxcdFxcdGRpdi5yZWNvcmQodi1mb3I9XFxcIml0ZW0gaW4gYmV0UmVjb3JkXFxcIilcXHJcXG5cXHRcXHRcXHRwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0XFxcIilcXHJcXG5cXHRcXHRcXHRwLmRldGFpbFxcclxcblxcdFxcdFxcdFxcdHNwYW4g546p5rOV77yaXFxyXFxuXFx0XFx0XFx0XFx0c3Bhbih2LWh0bWw9XFxcIml0ZW0ucGxheWxhd1xcXCIpXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDkuIvms6jph5Hpop3vvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5iZXRtb25leVxcXCIpXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDlgI3mlbDvvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5tdWx0aXBsZVxcXCIpXFxyXFxuXFx0XFx0XFx0cC5ib251cy1udW1cXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOaVsOWtl++8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLm51bVxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcmVhZHkoKSB7fSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIGJldFJlY29yZDogcmVxdWlyZSgnLi4vLi4vZGF0YS9iZXRSZWNvcmQnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi5iZXQtaW5mbyh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcblx0XHRkaXYucmVjb3JkKHYtZm9yPVwiaXRlbSBpbiBiZXRSZWNvcmRcIilcclxuXHRcdFx0cC5jcmVhdGVkLXRpbWUodi1odG1sPVwiaXRlbS5jcmVhdGVkQXRcIilcclxuXHRcdFx0cC5kZXRhaWxcclxuXHRcdFx0XHRzcGFuIOeOqeazle+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5wbGF5bGF3XCIpXHJcblx0XHRcdFx0c3BhbiDkuIvms6jph5Hpop3vvJpcclxuXHRcdFx0XHRzcGFuKHYtaHRtbD1cIml0ZW0uYmV0bW9uZXlcIilcclxuXHRcdFx0XHRzcGFuIOWAjeaVsO+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5tdWx0aXBsZVwiKVxyXG5cdFx0XHRwLmJvbnVzLW51bVxyXG5cdFx0XHRcdHNwYW4g5pWw5a2X77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLm51bVwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICByZWFkeSgpIHt9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJldFJlY29yZDogcmVxdWlyZSgnLi4vLi4vZGF0YS9iZXRSZWNvcmQnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5iZXQtaW5mbyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuXHJcbmRpdi5yZWNvcmQge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGJldEluZm8udnVlPzc2NjFlMmExXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2JldFJlY29yZC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJiZXQtaW5mb1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJyZWNvcmRcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldFJlY29yZFxcXCI+PHAgY2xhc3M9XFxcImNyZWF0ZWQtdGltZVxcXCIgdi1odG1sPVxcXCJpdGVtLmNyZWF0ZWRBdFxcXCI+PC9wPjxwIGNsYXNzPVxcXCJkZXRhaWxcXFwiPjxzcGFuPueOqeazle+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ucGxheWxhd1xcXCI+PC9zcGFuPjxzcGFuPuS4i+azqOmHkemine+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0uYmV0bW9uZXlcXFwiPjwvc3Bhbj48c3Bhbj7lgI3mlbDvvJo8L3NwYW4+PHNwYW4gdi1odG1sPVxcXCJpdGVtLm11bHRpcGxlXFxcIj48L3NwYW4+PC9wPjxwIGNsYXNzPVxcXCJib251cy1udW1cXFwiPjxzcGFuPuaVsOWtl++8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ubnVtXFxcIj48L3NwYW4+PC9wPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxib251c1JlY29yZC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTY5MmNkMGJhL2JvbnVzUmVjb3JkLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHAge1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xcclxcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/Yzc2NWYwMThcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBO0lBQ0EsbUJBQUE7SUFDQSxlQUFBO0lBQ0EsY0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLGlCQUFBO0NBQ0FcIixcImZpbGVcIjpcImJvbnVzUmVjb3JkLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXHJcXG4gICAgZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICBkaXYucmVjb3JkKHYtZm9yPVxcXCJpdGVtIGluIGJvbnVzUmVjb3JkXFxcIilcXHJcXG4gICAgICAgICAgICBwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0IHwgZGF0ZXRpbWVcXFwiKVxcclxcbiAgICAgICAgICAgIHAuYm9udXMtbnVtXFxyXFxuICAgICAgICAgICAgICAgIHNwYW4g5byA5aWW5Y+356CB77yaXFxyXFxuICAgICAgICAgICAgICAgIHNwYW4odi1odG1sPVxcXCJsb3R0ZXJ5bnVtKGl0ZW0ubG90dGVyeW51bXMpXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uLy4uL2pzL3JlcXVlc3QtbGlzdCdcXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgIHJlYWR5KCkge1xcclxcbiAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNSZWNvcmQoKS50aGVuKHJlcyA9PiB0aGlzLmJvbnVzUmVjb3JkID0gcmVzLmRhdGEpXFxyXFxuICAgIH0sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JvdW5zUmVjb3JkJylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgICAgbG90dGVyeW51bShudW1zKSB7XFxyXFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW1zKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfojrflj5bkuK3lpZbnu5Pmnpzlh7rplJknKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAvLyDkuK3lpZbmlbDlrZfmgLvlhbHljYHkvY3mlbDvvIzlj5bnrKzkuIDkvY3lkozmnIDlkI7kuIDkvY3nm7jliqDnu5PmnpznmoTkuKrkvY3mlbDkvZzkuLrlvIDlpZbnu5PmnpxcXHJcXG4gICAgICAgICAgICBudW1zID0gbnVtcy5zcGxpdCgnLCcpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIChudW1zWzBdICsgbnVtc1tudW1zLmxlbmd0aCAtIDFdKSAlIDEwXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDJlbTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCBwIHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogLjVlbTtcXHJcXG4gICAgbWFyZ2luLXRvcDogLjVlbTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG4gICAgZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuICAgICAgICBkaXYucmVjb3JkKHYtZm9yPVwiaXRlbSBpbiBib251c1JlY29yZFwiKVxyXG4gICAgICAgICAgICBwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XCJpdGVtLmNyZWF0ZWRBdCB8IGRhdGV0aW1lXCIpXHJcbiAgICAgICAgICAgIHAuYm9udXMtbnVtXHJcbiAgICAgICAgICAgICAgICBzcGFuIOW8gOWlluWPt+egge+8mlxyXG4gICAgICAgICAgICAgICAgc3Bhbih2LWh0bWw9XCJsb3R0ZXJ5bnVtKGl0ZW0ubG90dGVyeW51bXMpXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuLi8uLi9qcy9yZXF1ZXN0LWxpc3QnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c1JlY29yZCgpLnRoZW4ocmVzID0+IHRoaXMuYm9udXNSZWNvcmQgPSByZXMuZGF0YSlcclxuICAgIH0sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JvdW5zUmVjb3JkJylcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGxvdHRlcnludW0obnVtcykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bXMpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfojrflj5bkuK3lpZbnu5Pmnpzlh7rplJknKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOS4reWlluaVsOWtl+aAu+WFseWNgeS9jeaVsO+8jOWPluesrOS4gOS9jeWSjOacgOWQjuS4gOS9jeebuOWKoOe7k+aenOeahOS4quS9jeaVsOS9nOS4uuW8gOWllue7k+aenFxyXG4gICAgICAgICAgICBudW1zID0gbnVtcy5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAgIHJldHVybiAobnVtc1swXSArIG51bXNbbnVtcy5sZW5ndGggLSAxXSkgJSAxMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYuYmV0LWluZm8ge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG59XHJcblxyXG5kaXYucmVjb3JkIHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIG1hcmdpbi1ib3R0b206IDJlbTtcclxufVxyXG5cclxuZGl2LnJlY29yZCBwIHtcclxuICAgIG1hcmdpbi1ib3R0b206IC41ZW07XHJcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGJvbnVzUmVjb3JkLnZ1ZT9jNzY1ZjAxOFxuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2JvdW5zUmVjb3JkLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJldC1pbmZvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcInJlY29yZFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYm9udXNSZWNvcmRcXFwiPjxwIGNsYXNzPVxcXCJjcmVhdGVkLXRpbWVcXFwiIHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXQgfCBkYXRldGltZVxcXCI+PC9wPjxwIGNsYXNzPVxcXCJib251cy1udW1cXFwiPjxzcGFuPuW8gOWlluWPt+egge+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcXFwiPjwvc3Bhbj48L3A+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxFeGNoYW5nZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWYzNjdhODZlL0V4Y2hhbmdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LmV4Y2hhbmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcuZXhjaGFuZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwYWRkaW5nOiAxJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmNoYW5nZS1idXR0b24gZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDUwJTtcXHJcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzRkNzA1MDE4XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUZBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiRXhjaGFuZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cXHJcXG4gICAgZGl2LmV4Y2hhbmdlKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICAvLy0gaW1nLmJhY2tncm91bmQtaW1nKHYtYmluZDpzcmM9XFxcImJhY2tncm91bmRJbWdcXFwiKVxcclxcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXFxyXFxuICAgICAgICAgICAgZGl2KHYtZm9yPVxcXCJpdGVtIGluIG1vbmV5RGF0YVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJtb25leWJsb2NrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcIm1vbmV5QmFja1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cXFwiYmFyY29udGVudFxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cXFwibW9uZXlJbWdcXFwiLHYtYmluZDpzcmM9XFxcIml0ZW0uZ29vZHNpbWdcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cXFwiYm9udXNNb25leVxcXCIsdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5leGNoYW5nZSh2LWJpbmQ6c3JjPVxcXCJkb2V4Y2hhbmdlXFxcIix2LWJpbmQ6c3R5bGU9XFxcImV4Y2hhbmdlQnRuXFxcIilcXHJcXG4gICAgICAgICAgICBkaXYuY2hhbmdlLWJ1dHRvbih2LWJpbmQ6c3R5bGU9XFxcImJ1dHRvbkJhclxcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5ib251cy1idXR0b25cXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5ib251cy1idXR0b24odi1iaW5kOnNyYz1cXFwiYm9udXNCdXR0b25cXFwiKVxcclxcbiAgICAgICAgICAgICAgICBkaXYucHJpemUtYnV0dG9uXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcucHJpemUtYnV0dG9uKHYtYmluZDpzcmM9XFxcInByaXplQnV0dG9uXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICByZWFkeSgpIHtcXHJcXG5cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxcclxcbiAgICAgICAgZGF0YSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvbW9uZXktZGF0YS5qcycpLFxcclxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5QmFjazogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5Z2XLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBib251c0J1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBwcml6ZUJ1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBkb2V4Y2hhbmdlOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIG1vbmV5YmxvY2soKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYnV0dG9uQmFyKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJhcmNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJvbnVzTW9uZXkoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbW9uZXlJbWcoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBleGNoYW5nZUJ0bigpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMzY0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtZXRob2RzOiB7XFxyXFxuXFxyXFxuICAgICAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5kaXYuZXhjaGFuZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5leGNoYW5nZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLm1vbmV5LWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1tb25leSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cclxuICAgIGRpdi5leGNoYW5nZSh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcbiAgICAgICAgLy8tIGltZy5iYWNrZ3JvdW5kLWltZyh2LWJpbmQ6c3JjPVwiYmFja2dyb3VuZEltZ1wiKVxyXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xyXG4gICAgICAgICAgICBkaXYodi1mb3I9XCJpdGVtIGluIG1vbmV5RGF0YVwiLHYtYmluZDpzdHlsZT1cIm1vbmV5YmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVwibW9uZXlCYWNrXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XCJiYXJjb250ZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XCJtb25leUltZ1wiLHYtYmluZDpzcmM9XCJpdGVtLmdvb2RzaW1nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cImJvbnVzTW9uZXlcIix2LWh0bWw9XCJpdGVtLmdvb2RuYW1lXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLmV4Y2hhbmdlKHYtYmluZDpzcmM9XCJkb2V4Y2hhbmdlXCIsdi1iaW5kOnN0eWxlPVwiZXhjaGFuZ2VCdG5cIilcclxuICAgICAgICAgICAgZGl2LmNoYW5nZS1idXR0b24odi1iaW5kOnN0eWxlPVwiYnV0dG9uQmFyXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYm9udXMtYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLmJvbnVzLWJ1dHRvbih2LWJpbmQ6c3JjPVwiYm9udXNCdXR0b25cIilcclxuICAgICAgICAgICAgICAgIGRpdi5wcml6ZS1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICBpbWcucHJpemUtYnV0dG9uKHYtYmluZDpzcmM9XCJwcml6ZUJ1dHRvblwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICByZWFkeSgpIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxyXG4gICAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvbW9uZXktZGF0YS5qcycpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YaF5bqVLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nJyksXHJcbiAgICAgICAgICAgICAgICBib251c0J1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgcHJpemVCdXR0b246IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WlluWTgS5wbmcnKSxcclxuICAgICAgICAgICAgICAgIGRvZXhjaGFuZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmcnKSxcclxuICAgICAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW9uZXlibG9jaygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYnV0dG9uQmFyKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDUyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTA1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYXJjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvbnVzTW9uZXkoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vbmV5SW1nKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2hhbmdlQnRuKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMzY0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG5cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmV4Y2hhbmdlIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuaW1nLmV4Y2hhbmdlIHtcclxuICAgIHotaW5kZXg6IDM7XHJcbn1cclxuXHJcbmRpdi5iYXJjb250ZW50IHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5pbWcubW9uZXktaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG59XHJcblxyXG5kaXYuYm9udXMtbW9uZXkge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG4uYmFja2dyb3VuZC1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwYWRkaW5nOiAxJTtcclxufVxyXG5cclxuZGl2LmNoYW5nZS1idXR0b24gZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgd2lkdGg6IDUwJTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBFeGNoYW5nZS52dWU/NGQ3MDUwMThcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gW3tcclxuICAgICAgICBnb29kbmFtZTogJzEwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MDAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6ICcxMDAnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTBX6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MFfph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvbW9uZXktZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEVNelJFT1VVeE1qUXdNMEl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRU16UkVPVVV4TXpRd00wSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tRek5FUTVSVEV3TkRBelFqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1F6TkVRNVJURXhOREF6UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNclBGMXdBQUlOOUpSRUZVZU5yc2ZRbVVYTlY1NXZlMmVyVlg3L3VpWFVKQ0VrSXNFaVFHRzJJVEhDODRCRTdzZUp4aHpzU1FjN3hNNWdTZkdXS1MyQk9mY2M0c2VKTFlKak1tTU1Qa2pHTUhpRE9Zd1RiZ0pVYnNRaEpJUWxKTHFGZjFVdDFkZTczMXp2L2Y5NnE3RVpJc3dFaWtlVmZucXJxcjZyMzcvL2U3LzNyLysxb1JRaUJxeTZlcDBSUkVnRVl0QWpScUVhQlJpd0NOV2dSb0JHalVJa0NqRmdFYXRRalFxRVdBUm9CR0xRSTBhaEdnVVlzQWpWb0VhQVJvMUNKQW94WUJHclczMXZTM2U0Q2RLN3JPK3J1VkduRDVoUUxiTnZoNHp5VXFNbWtWTlZ0RFg2OEpwMWFGRWt0UWp3R3VEVFdlaExBclVGUUhXaW96cU1SYkwxYU4xcTFhcW5VOWpHU3ZvdWhkOUoyY291a0p2cmZ3M0pwZnJ4V0VjRTdBcVk1N2xmeEI0ZVQzK1BYOEMxNmxkRno0QnQwN0JiOWVwVm1KMGIxdDZqVVlpU1JHeHl3a1loNUtaUjgvZmM3SDdvTXFubjVKUVNweGRuenRldlhFOGdIMGw5cUVnRy9YQVdlZVFEUXZNam8zZmt6UDlsK3ZwWnUzS3pFVGlCRTd3Z1VVajE0ZEFwNVdpTy9LU3hWRHoyZ0pzd05LZWkxRUczUmxGV0M3RWppdlBQdThXeGo1dmxzNitvQnZ6YjRJdndtS1VDSUpmVnVhUWhNckNCZVdSbEV6WXExclAyVzAvdW90Um52dlRqVkpJcUxaZ0ZlZ1BneFk5Q3BzeUF2WW1raFFRbUI4ZXMvajkvM2dQWVVrWGNsQlNUUkRUN2R1MTl1N3QvdlZ6VjkwcHNkMk9mbUQ5OWo1dy9jSngzZEFta0RTRUFINlZvRmtEQlE0OVRxQldZV1JHZmkzNXNBbG40OTFkZmNwU1FMTG02Sk9xc3doaVVVczdHYllGKzl4ZW1ublR1clZuNmQ3MENKUTQxQ1RYVEJYRGV5TWRmWHZORTVzK21OcitMbTdmSHZpUHp0MUZhWnVuUGwrRWFCblJ0TnpCUlNuaUZRc2U0UFpzK00vR29OcjE2bHBVcVhlRUVraWdTRGlTNEE4ellwUVRnRWl4RWsrWVR6b0xMaitKS25wNDFETUpnSzJ2OC9vK09CL2NvNGYvblJxK3FrdkVDMFB1bTRTNzNSVTMxR0FxalJYcnFlZ1VDYUpxVnZwanBWcjdvNXZ1T3pqYW1lS1BqeEtRSllJRDU3VTdFbkE4TVVhY1VOU3BPdmhwRE5DM3BMdjhYdGFDQ0s5NTVKdGRjbk8rdDZTbTlEMWdoYUl3NSs5RERXZGdYbEIvOW9WTFMwUDFBOCs4N2VGQTBkdUxaVE5rdXVaa3RZSTBETVJRbk5kcUNxWUs5YXh0Yys1YXNQMmkvN1czTEtsQnlseWJDeVdTbFo1NllhdWxBNFNWQ0kvbmdodFhBV29UcUp5ZkI3VjZUTHNVcDE4SWhlK0U0Q3FHanIwaEk1WUpvNWtleHFwN2lZZ1NSMlo0RjcxMElGU1F2QUZqVVhYUXgrQzJ0dEtYNzNpNHh0UzZhdkhUdXo5eE5QNzhPTkNOWTVNU3RBQ2pBQTlKWmpUQlFYVnFvMVBYZVYrK3ZwL2VmRTNzV1lkVFdxZVFISUN1NmhnRVVpZGZqYzVaaWpEbVRxTXFYM2pLSThVNEJUb3U0NUNYeldnVWVpaEd0UlZRNDdoa0NUV3lONTZicEh1TWtaZXI0Q2VNNUR1ejZGamN3K01qajc2RmdGc0ViQ3VGWXluc0sybXNhcmtiQ1dyTUhkczdMbStUWC9DcXV5KzliYTk5dDNUaFJqYWMrOHNVUFYzQkpoRkZiT3pOcjV4YSsxTE45eSsvWXZvWGswVFNYYXlUbXBUMFJaQ0ZqQTRTWmJTT2N6djI0dUpaNGRoVGRuUTFReFNyVjFvVzl1S2RHY2Fab2JVWm95dTA5UlFla1VnMkI3ZHovWmdGVzJVU1lxTDQzbk1QVCtONldlZmg5bStEMTJYRGFCNTgzcGFMTTBrbldXU1dDZThudTVWSmRUaVJOT2ExYmpoZHZGTllUM2ZlK3MzbFR2WlcyN1ArdThZVUpXMys3RFNtUklMR3MxVHZxUWluM2Z4OVZ0bXYzcmpWeTYrSGUyYlNKektjdUlYd2FEWEZLbEcyQ2krc2hmSGYzZ0VibDVCcG1NQW5SZjJJek9RQzJKUVh5UExxUWFTcGFwMCtSTEhTQW8zeHo4RXF2RHBiZXFxSjJQUjBuQUJreStOb0RRMUFyM054K0MxYTVCZHZ5Vnd1Q29sbnFWUURZdGdvUmkwcUdiMjQ3di83dmsvLy8xN1dyN1EycXFqTmVQRDg4NS9ZdUc4QWNwT1JibXVZR3JPeDEwM1QvM1J6Vi9kK21WMGJROGNIM1pZbEhBQ2xWQXFyVmR4OE50UG9YalFSdHVxOVJqY3VScGFld3JDSlJBVm5jeXBUc0ljZ3RtSUd4c0xvdUVVTlhqbFZ3SlZrTVQ2TkpZcVhDaTZCMis2Z3VPN2hqQno5QlZrTjhTdzRlWWRKSzByU0RyTFFhS2lRUk9yRlpNY3N4UFA0Kysrc09mT3ozMjc0OHNkelNyU2NTSEQzWGNsb0R6c3dSRVZYN3IreENjK2UvZTYrOUY3NVVsZ2tpVHA1TkdhTVJRUFA0V0Q5eDlFSXRHUDllKy9DREd5ZTU3REFCcUVOM1ZWZmZQQlB4RWlTR29GZWJiQ3RhSEZYTmhrajEvNXdZdW8xVWF3NFJNYmtGMUh3RnJrZWJ2VllNRklVRWtqbUtRMXhuNk8vM2Jyb1UvZStYRFgvUnY2L1ZPU3Nld0IxV2xPRG96cHVHSEQ1QVgvL2Q3dS9kaDJMYW0rYWhEZ044Q01rVlFhUGlaKzhpTWNmV2dLS3kvZmdaNnIxcEM4eFNCVVUzcXRNbFJSbHNhWWJ5NkJzYkRDQ0ZpZmdGVjhpOTYyTWY2VElSeDdlaGRXZmJRRDNWY1JqUTRSYnBjWFFUWFlWdE9pMi8wWS92WHZqbTk4NEVEbmdZMTlMbHovWFFRb2E4WHhPUTF0YWdHUGZzTVliYjdwdWw2NDlHYTlzZm9aVElvN1l4Nkd2L2VQR0gzTXdlYmZ2QmFaamQzd2JBTnF6Q1QxcUMxS3BEaFRLa2c1ZThDWEFDdkl3L0Z0aTZUVlFXbi9CUFk5OENQMHZjL0F3SWMvUklEUzJIWmxrVlpPRGVvQ2M5LzVmMlBYM1dyM1RmczU5RFI3MHY4Nkg0Q2U4KzB6eTFWUW1yZng1VSs2ZjlWODA0NWU2WGpVS21HdWo3d0tQVTV2K1FUbTkwaENCTFovNmtQSVhOQkg0VVlDV2p4RllNWUNyMU9vUWNmcHVoWityNUZnVU0vY0YrNm55VEY0TEI2VHg5Nyt5UTlKV3BnbXBrM1NLQk1TU2tpN2dlYmZ1cnozeS8vQy9Ucnp4anlldCtUTXVRNVJoaVpVL05iV3VjMGZ1SDNEN3dQZEVLVUNDWTlDZ2tGMmpCUG1jUk1UanorSzBjY2RiUHY0cjhPa29ONzM0OURNZUtCaXp6YjF4dUdPWXNHZWRWRWZkY2o1S1FSU2RWYlhLM0lzSHBQSE52dGFKUzFNRTlPR2VFelNLbWxtMm9rSDV1WDlmN2podGhzdm10dk1QT3JhTWdlVU5TU0hLUDN4QXU2OHMvdDc2TmxJSVVFaHpLR3kvVktncEUzTVBQMDRoaCt0WU90di93Yk13WFo2T3lIVmJBQ0dPRHRqR1hxM3p2eVlsREtoYjBKOWZJS0V0Ull1aWwvb0tRV2R4bFJOVTlMQXRGeEVOREZ0TTA4OUlXbGxtZ1BhRWZCQ1BQM3hGN3YvZ1hsa1hzL0hKczI1QTVUNnhMU0hUMzlZZkticll4dFhnTlNTejU1ajZHVXEyUXpxSS90dzVMc2pXUDlyMXlDMXBvdWtnNXdmM3RCV2xUZm05WkIwQ2xHRE5VWDMxZXFJcnlhYlZxY2hpK09MdHZYc1hHQzVPSmdHcGlWSk5HMGcybzc4L1FocVJDdlRMR1JjS3dKZWlDZmliZVduUHlJK3c3d3F5MWxDNTZzcTFqV1Y4UEZiK3Y0VWFJTmZMTXJKWXJXbHFDeUJzemp5d0I2MHI5bUNwaTNrQUZra0hheTNGcElCNGl3N3BOMTBpeWZveHdIb3pUbXlpVS9TYXovczZUcE5lbVV4bmp5YkhvN050REJOT2FLdGZjMVdEUDM5SHJwUFh0TE9QUEE5SlUvRTJ5ZHU2ZnNUNXBWNVhwYUFzb0JOVFB2NGphdjBtNXJlMTkrTXVyMDRXUjVab1Z3TTB6L2RUZll1aTFWWFgwamVyRVpoaVJFbUEveXo3bEphK0JLS0Y2MnBDdlJjRC9Sc0hxSjRETEZXbDdUamFqaVZ5VUFyaE1tRnMrNTBZNmFKYVZ0MTlTYlljMW1pK1VWSnU5dzRieXc2NGkxM2RWOEw4WG96ODN5dWQyWE9DYURzOVRXckZYejRJKzJmaDlJTXIxeVZFOHBkWVkreE9vNkpaMDZnYStNV0tCbjZYVE1XcEZmNDRxeDdJK3h3cTVQa2hLNkEwVXpYMXc1QjJCbG82VEZvbVY0Q3VrU0FCMTcxRzdsM1F3cVpOcWFSYVoxNFpsTFNydWptQWo5ZWljSXZ0UVVmSVY2WjUzUHQ4YXJud25iT2tMOXd5UVl4c1BXYTlwMXd3aVM1ZENZSTBKU0d5YWNQUWJHYjBITlJQMXdLM2xWTzhtSXg3M3EyWFZwYWtrNTdxa3pna2JyTmpFRFVPU2RNY1czOUlJd21paS9kbFdSUDh4eUFMNlFBejZvekxid05SN1F4alV5clltVUQybFA2QWoveWU4VGpsbXZhZDF5NlFRd3k3OHNLVU02cmwwb09kdTVNMzRpQkp2aUYycUs2NVRqUm0wWCtRQjY1bmxWQU1rYXJYVjhFODQzMEVDQUd5M1g2SlhqQ09raDNTa3RWN05VY0dKbFJrdFFCa3RKNUNienlac2JoUUlWcEpGcHp2YXVSMzUrWFBFaGVHZzRTODBpODd0eVp1WkY1WDFhQXN2T1hWVzFjZW5udUExenE0ZHRPb0o1OElXMVNaV2ljMUpTTzluVTlzb0JBa2FxV1AvY0NsWHZhSGtwWXcvdWxFRU40ZFZna0VtcDZKWXpzQlB4cVBWdzhuQVFnajlRaEtlWDlTNnVQNkpnTDJWY1dNMFJDbkhsTVNaT1FOREt0N2V0N3lIem94TU9ZNUNWUXpVTHlDQ1J3Nlk3c0I1ajNaUVZva2N6VllEZmlGMjdKWE1tcVNJU3FTVTZNNlNGL1pBYXhXRE1TSFluRnZjOVRTRjZndnBmK2EreUorWEluUktFWTA2K1B3QzYzSUphbEdOQTVJRUdVWUlwUWNpb1ZBbm9TU21JRmFpZEdhUUhNeWkwNVdmckoyMmt5VGFCSXdCYkdFSXQ1M2tVcERVS2pSSHRDMHA0L2twZThCTnR6b1QxM0JDN2NuTGx5UlE4UzV4TFF0MzJEdTF6eXNIS3p1UzAzbUV5aGFBZmVxQWd6T1c0WmRRb2xrczI5Y20wcGFsZ0w1QzlKbUNzSUo1Z21DaXdsTGdIaHlGeXJaMWx3YTdhc0hCR2VBYXRRUmF6alZ4SExqY0lya3ZIUzI3QzRuOFd2V1NqdVBwaXQxMkgrNWZWd3FzTXl5YS9xTGpUVGdCNDM2WlZ6eGJ5RFE1MXBERXRCRjV5dWNJOVYwdXFwU0RXM296bzlGT3poQ3AxSURqZEZpZGZzWURLNWNvVzVqWDU3Y3RrQXlnQ3NXcFhlaXBZWXZFbG5ZWUlWWFlVelc0UmZVNUJlbVlQTDRZdlJrQVN4dUl2SmVmdjhKT3F6QlJJMlhlWk5oU3hKNGUyekZJSFJCTlZNUUtYMWttektJTjQ2QzFIZEN5M1pGdVFhdmZCT21pSlR1bDVwQ2taaU41bzJib1U5MzB6MDFjbnVWdUFRQUdMT2tyOVRuQ04zV3hURklaQTFKTHU2YUl5MDNEK1ZjcXNHQzhSMUJWTHRPWlNIRkRoekJhSy9uU3YwNVhCc3M3WE9HUEVlMzdLc0FOVVZnWjVlY3kwTUNzd2RaOEhtOGE1TFlhWk0yazVIb2prZUNHTm9PL21YWU9JVXpPdzlEQ1dXUWJKN1BVbGpGVnBNcFI1VW8yZ3hRUkpGMzlYWWxaeVVkYlorbFd4b1V5dktSK1l4KzlLRUxBemp4Z1ZqTFJkMkliMjJHMTcrR016NGNaaTl6WkQxU3NJazJsU1MrQVJKUG9IaEtQU3pMOU9FcXFwaThzVkR5QTIySTlYZEhoU2QrYUhOWlV2WlJMVFRRaXZQVk1oSmFvY2JxbVNQRnFWR2RyVzd6MXkzckZSdU5xV2d1eWZXRDJuSy9JVjBtRXBBVy9OMThnME5raGc5MExJeVBHaFVLbkF1bENiTkt0S0VIc1RhMzd3VXFlMFVma3lUQkhKeE5Uc29YSEZRYWV5c0JOVUtXcUlKcGNPek9QR1RJUUtYSkM2VVVJVWtkSUlXVUJmZE85T1hreEtFT3BlRkZzTGRHRi91MDNJUk42dGJaTW4ra2xRZWYrQUFxcU5UYUZ2YnRtaERGU3pZZFNPdVN4NnNRaDFxbjFqUVFCSnV1bTFQdDlHM3JBQ054UlNrTWthYm5EUFBrMjVIMEZ5NGRWZFdIUVNsc21HbUI0MEo4Y2pSVWRGKzhRVms2K2J3MGw4L2pOVWYzWXJtcmIwUUZiS2p2dmE2S2dXMnRiN3RZdmFGRVNnMFZ0TUY3VWgwWmFRTnJFNFVVU1RuSmYvY01GSWRGd1NZK01yaU5odi9Mby9Fa0dSeGtWbXBqbGZ1K1NmVVo0cFk4K0gzSXRiVUpHMzJZaW80ekdJeEdjU0RXM1VsVDJMcFJxanJJNVUyV3BjVm9KcW1tS1pmeVhKcGlRVFREek11SkJHK1RhR0xvaThKOEwxZ2hTL1VodkVNYStpNzZrcVNZaE9IdjdzSEs2cysybmYwUWVRcjVBejVKK1haS1hTaDk0eWtUdmFSMUdGWEZ0bnRmYkt3Uzk4OVJxQVdFRzh4U2VySksyYmo3SjlVV2tCMGFLeENhYUc5L0w5ZmtIVzZHMjkrUDNuR0hiVDRuQVVuVGFvVGRURXRxWkx6NU51Mi9FQTBRcW53R0kybXE5bGxCU2dGNGFadUZVek1ueUNBdW1TWW9IaGg3dFVMYlNVYTJSaHZNY0dPeHRzK0xYUU5uWmRlUWlaTndiRkg5c0dwV2VqNWxVRm9GVXZhUnA1Y2lldHJQTkZnYTh1ZktzSEsxNlZFdFc3ckExRVRhb1BGR0xhQms5YVNJRWV0amdQZmZsNTZ2ZXMvZWhXcDhCYnBTUWZnTGRtbzhaV0ZjRWo2NEg1b01wZzNOaFdhS2Fzd1l0Wk1iRmtCS3NpL3B6VXNVSnlHV3ZMaHBkdUQ3UzB2T0NHMkVMQnpEU1I3U2cwSnhTS29ETFJUMWRDK2Jac3M0em42eEN1b3oxdFlkYzBLNkNTTlRqbXNSUXB5UDR2cVBrVkIvMWdCeC83eE1KS2RhYWdrcVRGU3AxMlg5UVJoa0l5SHVlSlRrWkpaR3ByRGtZZjNJZE9SeHNvUFhFRmtaZ2pNK21LMW9MSmtTNWF1WVpvYkNSQ1oySENEK3drT2VTd0t3UE1UdEg0dHNhd0E5WDFoTzU1cVNZK3hOQTJGUWdRdjNRWS8zVUtoQUtIalc4RlpFdFdWY1YydzFFL1JLUFowZkFOTkd5N0N4cVNHVng3Ymo3MlRKVno0MFEwdzBnUnF3ZWI5a05kc2NudVdpMFRPUk45N2VpazBjVkVlTHRGM2RDd1UvTkNyU3A2UWxvMWg4cGx4SEh2OElBWXU3a0xQbFR2Z3VSUm0xV3FuMzRmbGNoVU9VYmhLa1ZRelYrbjdDbWVMS0Z3cFQwR3Q1cm1JQWJadjFKZFZwb2dpbFZxMTZoY0RhVFZrZFo4Mk93b2xQMHIyVlFRQzZMaUxaU2dpWFBXbjZ1VGRPcVJpWTIwcmNNRTFhNkNMTXZiKzNUNVV4OHVrSWdQN0xLWEdEVUN3aWhiMDlnUmEzak1Bc3prSjF3cHN0TlFHZmxCeXlkNzJ5QlBIY2Z4bmg3RDY4amIwWExJVmpxWFRBcWdHU1l4VDBTRzh4ZklUaDdmbE9FU2hxWnlmSnQ2R2FlRk8wZWRCR1V1dDZwZVdsWVNXU1BOTVRHRktPdkorT0NUcnBkbEptR29TWlpWQ2xqb3RZcFc4V2k2b2ppWEM4TUE3cGJRS3B3YVhWSnBxdEdEZFRoLzdmM1ljMHhTbURGNDlRSUpDQUZLY3FzWjVQMVZEYWFTRUd0bEV0bkZPeFNhVnE1TlcwT1YzMkhsaTZhd1hYZVNIVG1Cd2F4cXRxMWZBOXVLY0ZUaTFwcEFWK1pxc3lvZGRvN0NYdEUzZEpudXBJNmJTT0ZPY3FDY0hpY09lOE9qaStEVHp2b3dBSlllU21ScUJ1elNYVGhQc2FqQjUyNGt6Um9VQ0RGSmZmcFVQSWFXZ21Fa0s4TXdncEFtckMyUmxnMHcyNkFSR25lYWNZbGlhdUphQkhHSkpVcThUYzNBZG55UlZSL05nRXA3dG9UNXJ5UzY5YlFJNTNob1BQaXRWcFFxV1Vrb09WOHRBUnRMaWxNZ1c2MVpRV2VnRmlRT2w0V0F4RGF4aTYyWHlrcXZFR0sxVXp5TDdIZkRBWjZjY2l4WUtlKzNoSVhIbWVYd0tvOHNLVUc2dmpvdkRLQXNaN1RtTmhVLzJ5MHlvOG1SOGJhNUtvVUdjVkMraGI5RXFWK2VDU1RYaVVOZ0wwb084cWd3Yk9meXB6TW16bmI3bXdiVVZ4Qk1DVHI1TVlhN2duTGhNVkRSM0dxZ1MwR3BZTXNCQ244eG9VTW8xMUVsdEJ4Z0pVZ2dNSHNXcEZSK0paQjMrREptRFZKT3NqRmRrbnNDVFl3bUhiYjBscSt2bHpkZ25JQ0JyOC93d0Qxb3NTVnFZRmJwQUN4ZzBtTmt5Y0h4Y09iS3NBRTJSc0IwZFZWNHVUZm5JWkJUWVRpTlVJTStTYkJSN3FaVkpGMDE4YWx2R0Q0RktGaFRFQ3k2K1pybFV3ek1yY2lFRVJ5VllldTJxUlpxWlFERlZ1dFpmclBZandEakV5V1pWTkFySldkSTgyNFhqaFY2MG9pd2svVFc2djhPcWs2KzJhdkM1MWxiVEYzWitoQWozUVpWUTNZWTAwbkpFcFVROGRHcVNGNHQ0VXZ4R0JrbEJhVXJnNkppNmYxazVSYmtVY0d3Y2V3NGN3d21rZ3RnemlBRko3YzVYa015cEZKbVNIYlU4ZVhESUo0ZUZRZUxuS3doNm4rVmFtbFN1WnVkT0pQdENrNU5jcTloU2hmT0JNRUdpejNaUkp1TjVxNHgrZDhva3hYVnlZR3o2dWVMSTk2VGVaeHJjNFB2c2tHa0V2c3MvOHk0T2VhOXlqTVo0TWl4V0pTMU1rNlROQzJrbG1zbW5sVHd3THd0bExVeEQwZ2Z4UEhsMERIdVdGYUJ4TW91elJhWHl3Z0U4RGQyWEU5SUExU2FibFcwaE5aaU1vVGhSQ1dKRHp6K0ZaK2t2MU96SW42WEQ1TUd1TzFKS0dBSUprQmZFczhMeDVIRUcxdGFjZm5QTExrenlnaFgyVEIxdjhYdlVQUUxGSUVCOThvd2R5dzVqeTVQSE80a21MemlPeURRamFVb2VtSmNHbU13alY5Z1R6MC9ObHBUeXNnS1V0U0Evb09tcGw5VEhVQWlsU1RUeThCcDByMG9oaFk3Q3JFZXFUNUdyWDRMYUFQNDBYU1liMkFraUZlZzc0VFZTNGtpK1ZJRkVRa0Y1MHNIQjUyYXg5K2twRE84clU1akQ2bGtKd0E4bDJpVTFiT2pCbzNQcU5XY0JsTk4zWDlMSTR4YnlIbUpFdTBFOE1DOWg0a2p5aUhuaStXWDE4VlQ4bkJZc25JT2FJbUt3dlVuZ21mM3F3L3NQd0lublNDcmtwTkNFa21OUm5jZ2oxMFUyTUpsQm5WTjBmdmpaR1RvN1ZCNDdSWnkzVlJYcDBUSTRiTCtTNUdpaDV1UFFNMFc4L1B3TTRpMUEzNllFSnFkSzJQMnpQUExINmtoUzJNSlZvbEpGazJUR3lQdmhCMDFaQktnaS9BWGdUdFY5TDloeFlWcTlWQVpOUkh1RmVHQmUrRFBtalhsa1hwOTVXWDJZZVY5V2dFcTFTNnJ2eEN5T1B2S1U5Z09ZUWxaOEJMbDRRUTZrZ29SU2dkbVp4TXdveFpHNkp1M2FvcVNlM01sKzBZUmFGQSt4QThyeHZFY1N5aXFWY01MSS9ncDI3OHFqV0s5aDlTVVpESzV1UVZ0TE16YnRhRUdtVzhXUlEvUFl1MnVPQUhFbCtFR09uU1JPY0paT2xqNmNBVXhQMHNZME1xMW1aNEpvTDhzcXdNQ01oTlVzeE9NalQycy9KSjZINGpFc1AwQjlLYVhBdzArcTl4V0hnWFF5bEVLT0F5azhxUTVQb0xWZmc1TnBRdlZFS2NpcnMwTWl3VHU1Qi9hc3pyc2ZOSWxwVXExSlE4SGNpSTBYbjV6SDZJa3lPdGFaMkhRWkFaaEtvVTZoUkwxQ0M4UTJzR0pOTTlidnlNS0x1OWozNGh5TzdDNUR0UVhaZVVWS3Vrdk9reStjVTR3WjBrSTBNVzFNSTlQS05GZUhUOGlTRldsbmlTZm1qWG44dno5WDcyV2VmYkVNQWVYV21oUFlNNlE5OU5CUHRWZGl6VjVZQnhSS3FVdTJ0RENPM0xwV1RKT3JyL0l1aVJ1cVp2ZmtIdGhQaTd6WE5NV2JvdXJocFdkTGVPVklBV1lIc09ueUhMbzZzN0RLR3F5cXQ3QXcyRlpXaTZTaUVjZjZ6UzBZMkpKQXZsYkRDOC9PWStSQUZkbTRKbTA0UytucngvUkRXanlvWkVPWXh0eTZGcUo1UXRJZXFPZ2dyUnRyOGNBOE1xL004N2x1NS9Ud1JYTkdPUGM5YXZ6WDhqakZpRWxmSmdLa1IwaFNXaHFaUm5PMmhOamFRVXdmTGNBd05ibFo3WWQyYTJsWEZGOCtvR1Q4aUlVWFhpeWdianBZdXoyTmxhdXlVaEpyWlZvTUN5SFEwbXZKa1NMQWFrV0JiRHFGVGR0emFGbWw0ZWg0R2Evc0xhTTJMMlNjS3Z6WGo4bTBNRTNUUXdYRTFnd1NyV1ZKTTlQT1BEQXZ6QlB6ZHQ4UGpMdGFNc0xCZVdqbkRGQjJqanFiQlY0NG90MTc3eVBHZnJNbGpEZERWY1VwdjhxaFEraGFZOEp1NmtOaFpJN0NEZ2JWZTcwTlpRZklWVkFsME5wV0cxaS9LUXNUTWRSS1FpWVBoT2VkMGFuaXorMnFDN3Vzb3JzampRc3VTY05QazZOVEphOVphbzNYWHM4ME1DM0Y0VGxKVzlkYVU5TEtOTXZQL1NBY2l4TlBmL045WS84TGg3Vy9ZVjdQeDEvRFBxZEg4dG4rRkNvSzI1VWJ2djlucFFkVzluc1lIZGVDdzdGc055a09qR2NNcUtzdXc4Z1RROGdwRTBpMForSFVmRmtUdEhSeGNMMlJiZ1RaSHNkR1dBRDk1aGFhUm1HTHB0TmljRVN3SjZBb2l5ZjBDU2dqcWFJMlZVUkJkS0gvdld2Z0gzMEc5WklUYlAveFUrYm9tcjRlRDhlR05Yendqc3pIRkJVUDVsS0xnQzdiSS9uTVlITmFvRlJWSHZ6Y1h5WC9rcC90MU1ZUGJYS0RHSS96dHBWOERkNngzZWkvYWhVcXlSWGs3TXpLNmo3UFdiUm5qVGpWc2NTQ25UeWxtanlMTGlzaUxKWllYejR3MGcrelNOSnUwcGc2alQwM1BDdHA2YnRxdGFTTmFXUmFBL3N2MEpieE9XZVB6Mzg5K1pmRm12SWdxVnVjcjc5VmY4NFBNTEoySGV6MDhlTzl4aC9jOGEza3JuaktSVndMSjVNbVVZc25VSmtzd0RuMERIcDNEc0xyM295Wll3V29XaEQwUzFCbEhPckxjR1VCSFBjdDlJWDdMZDVMSHRXZ01hZHBiSjlvNk4yNUFpN1J4TFF4alJKd29wbHBqNmRkM0hGUDhpbm1pWGs3bjA4Vk95L1BuT2ZWdTc3UGMvN240L0hiL3NlRGlabTJEbGQ2ajlLbWhxQlc1K3FvUFBkajlHM09JWG54bFpnZWRlQlVpekpuTHR6RjlPRXZ0VXZwRkhJTUhtdDZ6RUZ5MjVYb0lScVlGcWFwQVNiVHluWEVUUHUzSGtyTTNQdFkvTFoxeE5QNWtzenpZa05mczVMVXdKN09sZFVidi9XWjR2KzVibWRkR3g3VkYyeXRQQkZOTmxVaG81YmJlaEdxYU1mc2l3ZUI2UkZrT25TNlBpNXRYdkRZdGwvR0tpTTdhaWl5Y3I0NFJmRkhXejlhdG0xQUV0TW83bjFScHZZQ203bW9UZ2Y2WER5NksrNzlxNy9JL25aVDJ2OE8yMDMvRlB2aTc0b25pY2xOWndKMXFxQ3lHdjdjZlorZHYrdFhMckp3ZkZSZlV2b2FsSlc0NUlCazEvUkE2OTJJd2tRVjVVTUhvQmJua0dwVkNRVGVSdzFPckwzaGh4cUlZRnROTmRoR2swYklrK1JsbTVCZXV4RzVuaVM4c2Ywb0RvMURUeHZCQ2d5cjVYbVl3VjRYLzdUWHhPOStyZW56Rkw1K3JhUEpmODJ6aWQ2VmdNb05XZkp3eDJkVlBucnk3KysrYmY3UDNudXhoWkVKUGFnYlV4ZmRZN2RrOFg0M01wdTJ3bGJiVU10VDNEajZLdHlwU1poYzZKQlI2ZnZrcVBqcVFwTDhkSnNGOG5HQUtvY2JOcXdTcHhHSmpvNU9KUHBXSU5HYVJzeWZRV24vSHZLdTZmMk11WEF6enZyd3huVi90NE1mNzQ3ajk3N1JkQWVCK0pXZWxqUGJ6WGNWb0ExUUorWklVajNsRDcvNnljS1hibnBQTlQ2VnA3aXZTa0NyaTdXMm5QSnppeDdpYlNaU3F5K0FxemJCcXBDSFN0SnF6MHpDbTUrR1lnZlBSZVl6dWZ6YTJCZVh1enVOSWowT1RmaHNURk03WW0yZGlPV2FZU1lwZlBMblVSazZnUHFNQlQycjBiWGFBcGllcnlDVDhOSFo1dUU3UDB0YXQvK3YzSjJxSXY3OEY0SDVyZ1MwQVNvL043ZFFWVzc1N0srWC84TWZmTERVelNwc2JGYkQwcWVrU21BOUYyNVp5TWNCcGxhdXBQL2FLUmFOU1U5VmVEYXBZQXZDdGdoQUo5dzc1VkpnTGhuaHY4M0N6d25rZXFVWVY3WERpTkVLcUV5amN1eVlmSXlmbnVacUNIMEJ5TWJ4ME40V1Q1NTkrUzhQWnlhKzlram1qM0pKLzU2emZVN3V1eExRaGsydFdBcEdaclJyZjIxTC9VL3Z1S0Y0eFlYOURrYnpLc3FXVk10TEtBOW0ycXQ1OHNtbkJwOHRhbXVIbHMwUllJbWdaQlRxYTBXVUQvVnk4cDEwS1o4ZnRXYW00WlNDSjdocUNXM2hUNG9zaEZqMGM5cjAwZGZxNDZVUkExOTVLUHZrRC9iRS82U3Z6ZnRoMmhTbnRaa1JvQ2ZaT0NicDFXbDlWWHZHK3plM1hsdjZuWnQzVnBveUNXQ1ViQzAvVmVUa1I4VUVsVVJoUXNBT2t2NE5XL21hQnlDSHRsV1dCc1dDTTZyS1NkWDJqYkFxcGd2MGtUb3QxWUZ2NzByTmYvTkhtZnVuaTlwZEs5cmRJVVhCRzBvY3ZLc0JYU3F0czJYVm1DbXBIN2xpbmZWN3YzTmw1ZXIzYmF3WmFYS01UcEJuekpMY09BVDJ5d2xiQXVGTWtlUjFraXF0a0tQMCtQNkVjLy9QVXo5NThwQjVkMXZHLzRlV3RPK2NyVlJHZ0o1R1dubVd4K2UxSG5LWWJyaHlmZjJtNjdmVUxyMWliVDNSMTB6ZUtUazRzeFRMV280U0hsTjhvN3dFOG1sUzJOSkNNU1NmWXhvbDUrem5oK08xUi9Za25xWFg3MmlLZUxDbjJSdkRHNVRLQ05BenBiTVVXZXRGa3FtdGNEM2xtazI5OW5VNzE5UXYzYjdDR3RqUTdTZ2RXU0dkS243NENKL2o1VVBXYnVPWkcwdlVNdCtIdjhlaFI0THNac3dJRXV0VFJRVUhKd3p4L0t2bThLNGo4ZWRlSG90OVg5ZkU0MTA1NzFWZGZldWIxQkdndjhDK3psWFYxdm1LdWlXWDhIZXU3blF2V2R0cHIxdmQ0ZlFNdExoTlpIZVZMSVVYckRxTjhBOUROSExJRERTcjZtSk54WFJKRThPeit2elFsREYrZURKMmVHaFNmN1pRVTNjMXBmeTl6VWsvcjd3RmlZd0FmWlBnc25TVjZtb0g5UUg2ZFZVbTdxK21jS0tYZ082ZzNrU3FORVdTRnBPbkdIekZKb2VxV3FpcTh3VGNGTDJPMFhWRHhQMVJ1dTQ0OVdsZHc5dXlTeEw5dWNtelRQQ3o5RFVsL1NudTlOWnpMZ1gvTlZ0SkZHcDZ5dkdVSkJmZ0NTRjU1QzFPbDhJZXk5QkZOYWFKU2lvdWFybWsrN3A3L25OdmI3dUVSdTNjdHVoUE5rZUFSaTBDTkdvUm9GR0xBSTFhQkdnRWFOUWlRS01XQVJxMUNOQ29SWUJHZ0VZdEFqUnFFYUJSaXdDTldnUm9CR2pVSWtDakZnRWF0UWpRcUVXQVJvQkc3WjlMKy84Q0RBRGFLS1hoUXZscVdBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBZlFBQUFJSUNBWUFBQUNZYmh4MUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk16ZzBSamc0TVRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTXpnMFJqZzRNalF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPall6T0RSR09EZEdOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWXpPRFJHT0Rnd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzZlN2c4d0FBRDJSSlJFRlVlTnJzM2IydkpXZDl3UEhuZWViYzNTamdoamlLTEJZcUExVXFUSStwRWdrWktZNEFFMWVBWkFPR0lta1FJaTVDSXY0QXI0dEVLRlVTTHhLS29raXBnb0FhU0VjRHVHT0JCbGU4S0h2dm1YbnllMmFlT1dmTzd0WGFFb2g3Ti9wODdObVo4M0xQV2xCODcyL2VUdjdxMDMrU1VtNy81bFJpWFhLc1kyT0k3U0hXdTFMU01MUjFUbWZIeDJYSStRUHgrdFB4MUZQeE0rK045VHRUem04cktkMU1UVTRBd1AzcXNwcFN1cGRxL2ZWVTAwK25XbjhVNisrUFUvMzJXT3YzeHJGTysybEtGL0hrUHBaNG5OcmpzVzNIejAreC9wdi8vdG5KeCs3dWozbUwrQkx5V0lZVzhaTE9XdENIMG9KK0s5YWZpOWYrS3BaM0xlR1BuKzQvMnhxZXM1WUR3SnMxdmRaME05WTNJK2J2aU8wL2paQS9PeTBCLzhsK3FQKzZIL09ydTZuZTNZOFI5bHhUaWQ4QTlsSHozS0oreVdmdURqSHZjVDZFdkFVOGxodkw5aC9kR01yZlJkZy9IVUcvc2V2UmIrOWZmeEdZUTk2amZxRHNBUERBZEg2TWVtMWhUeEgxV0ZKTTM3Vk40ZStLcUg4eGd2N1hGMlA5Mm5uSkx3OWxlcU9NcmJsVHloSDR5L0s2TzB6bVBlWkx5SE9LYWkvTFVENGF5NnV4L2ZpOHl6MWVYNE4rMkVYZngvSWk1QUR3bHNNKzllMGw2RDNxZlRmN2ZzZzNkbVA5N0xEUEg0M212bFRLOVBYUzk0TG43VzhHeDZBZmQ3SFBNWStaL1dhc2IrNkdYVVQ4bFp1Nzh1SWM5djc2ZkR5OUgyY3ZmVUpmZHJVZjk3WHJPUUM4aFVHOTlpazl5am10WVc4eGI1UDYySG83dFVZL0hsRy9FODM5WUVuNTg5SFlmY3JUSlVGZmo1blB1OVo3ek0rR1A0eVFmejJXRDk5Y3B2UWw5dTI5dzdxcnZjZDgzYzErK0sxQnpnSGd6YU5lbDdEWGZOajlQc1gyVkdvYVd0RGJjZk0yUEk5VDcyMTZNWlpia2RtUHhkdC84MERRMjluczYzVGVKdkUybVVmRVgvdURPZWJEOGx6YnpkN1BkRDg1RVM0dDY3bm5tNDZMT2dBOFBPYnIvdXpheC9YYVl0NWVpWFdKSjRmNVJMamFtNXZUOGsvNmNMejF0WGpiczZsTjZpZEIzNXdFMTQrYjM0NmdQOU5pSGxGUFo3dmxtSG83MjcyVSswNkNXK045RW5NQTRHSHk1aWo0UEJDM1hlKzVMcy9IZG02NzMrYzk0ZkZjMjcyZXkrRTh0WGpwbWZqamRteSt1UDNNMHE0cmI3RnVaN1BmR01ySEl1WXYzT3dueEoxdGRyZlBaNy9uemNsd0tSK09tK2QwWEFDQXR4TDFUVHY3SWV6U3J6d2Jlbk1QZTlDSDN1UjVUL3E4ZnVFL1B2R2U1MDZDUHZSajUvM1N0TnY5elBaNU4vdHkvZm5tSkxoeWVjZ0JnTjgrN2lkaEw4c2w1WFBZTitlNTNSZ09WNkhkL3ZlUFAvbkhtd2w5dVJRdFh2ajdkbW5hZWpiN2VsT1o0eG50cDd2WGhSd0FmdmRoWHplMjk0bHBMWjZidkI0aUwvUGw1ZStJN2E4Y2duNjIzTkwxM1ZIK1Q1MnRONVFweHhQZ2pwZW1pVGtBWEVuVSszQzkzb1o5dldkTUxKK01LZjNkZlVKdnhTK2ZpZVZzdlc5N1d3NVRlUkZ6QUxqS3FMY1dIKzdxMmp2ZCszM1dHajRIdlgzUlNoVC8rZDE2Ly9aKzE3ajFXdk84K1dReEI0Q3JpUHJ4cnE3em5WM1hXN1V2eS9QZitQaVRaZjdXdEhod2EvMVNsblUzKzNKdjl1TTE1V0lPQUZjVDlaeU9YVDU4SytyeHk5UnV0WmFYZVBDaDlXWXgyenZBbFhSNkJ6Z0E0SXFpdms3cDIyOUhYYnU5aFAzcHRuNy9jTGlOYXpyZXpqVzc0eHNBWEord0g3L1pkTnZzM3ZDbkl1ajVmZHR2VFR1NXR0eDBEZ0RYWmtwZlYrc3g5WEw4R3ZQM3RRbjlpWFVpWHk5b1QvbjAzdXdBd0RVSSt5V3Q3aFA3RXlXMkhsdS8vclNZeWdIZ2taaldTOXArNDJsK3JOMVo3a2ErTCtMT2JBZUFheGp5ZEhwK1crNVRlMnQ1T1FsM3Z2d0hBSURyRVBWOE1xVnZHMTUwR3dBZS9mRzlQRERMQXdDUFRNalRZVUlIQUI1NWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3RC9mNEplL1k4QkFJK1V1ZzI2a0FQQUl4LzJjaEw0ZXR5dVNnOEExNnpiOVRpWTE5TWh2VXdwbmRkNnVzZjk1QWNBZ09zd2hEOHdjTGV0MXZEVzhoSmJ2MXllcU8ySmt5a2RBTGlHWVY4aVByZDdlVngvV2FhYWZqNC9VWHZNKzdoZVZSMEFybGZNTDJuMTFBYnlhSGtFdmY1d09qeXhsUDZ5WStvQXdOVk81ZXVxTFlkdUx3My9ZWnZRLzJkYzZ0NmY3Q044ZFdJY0FGeWZxUGMyMzlmczN2RHZsM0dxMzU1aXF6MHg5dHJQRS91YWMxTTZBRno1ZEQ1UDVhazN1bTY2M1JvZUxTL3g0THY3cWQ0ZGx5Zm1GOVlSZmp1bGl6b0FYRUhNVDZienZxdTlON3N0YzhOci9WNFp4enJGZzMvWkwwK21mVDJkMWkrNzFnMEErUDNFL0RDZGIvcmNXbjNvZGpUOEwrKzhQcFg5TktYOU9MMGF5M25ianNEUHl6S3B4NGRNZlVvWGRRQzRncGpYdWNYenJ2YXBIanJkKzMzZUd0N2VXaTdpeFZqdVhvejFhN0draTNGcWorZnFyN3ZmcHlycUFIQVZNWjgydTluM1M3T1hWcy9OcnYvOEYzZGV2enNIZlI3WDQ0WHpjWG81UnZRM3p2c2I5KzJOcmY1MU02MkxPZ0Q4Zm1QZUQ0ZlBUZTZEZDJ2MTNPeHgrdkw2SSswWWVxLzgvTUpMOFlZVzkzU3YxNy85OENIcVV6LzdmYjJnWGRnQjRIY1M4c1BaN1BPZFczdHplOHozdmRYM2xnRTg5VlovNGRrN3I3K3hmc2J3WjA4K2xuSk9zZVMyL2tGSitZbVUwMVB4YVBubWxyeThzVDJ1ZWYyeGZQSjh5c2YvcU96L0Z3QjQ2OVA0WmlJLzNKdDlQdmt0eldleHQ4bDhIcnozUzhqL2Qxbi8wMGYrN2NkZjNYN0ViajdsUGQ1WThoUkwrL3ExL0lXbzhoT3grVXlMODNKLzk1THFNS1ZkRkwzRW00YjVGNEQ1dmJGZVJ2V2NqLytCV2RZQjRDRXgzM3pCU2oydXAzNTUycmc1WnI3dmsvbkZIUE14M2R0UC94bkw1Ky8vekYzN0RTREhEK1I0YzE0bTdQUDQ0N25ZL0VhODlPZnJMdmF6aVByVVloNDFuNkxlWlY3cU10bHZodmJsa1IzeEFQQm1VZC9lTkdhOUE5emg4clR4ZUFMY2ZDaDhQeS8vRmN0ejkvYmorUU5CbjArQlQydU01N3EzNTM4VG14K0o1Wlg0ekJmV2cvTFRVTklRVS9vdUw1UDZJZXBwMldXL2xMMmF6d0hnb1RFL2JxemZtSFp5TnZzYTlPTUpjRzM1eHphWlI4d3Yyc1QrWU5EcjRYNXkvWTh5WDN3ZVQxM0VueS9HYnduZkdhZjZ5cmdyajdlL1lEZVZ0R3VUK3J6clBTKzczdWVZMStXWWU1L1dBWUNIRjMzOTJ2TDFEcTN6Wkg2NFljeHk3RHhDL290MkFsd3NyL1d3ejg5ZkV2VCthMEU1UnIwdXMvcDZ1dnlkK1BCdnh2S1YvWkEvdVJ2cWpXM1FTdy82NGNTNjdhY0xPd0JjTXBvZmQ3TnZ2Z0wxTk9qamRONnVNNCtRLzIxTTZoSDE5ZnJ6NWZLMUI0SytYT2VXVDZLKy9DVlRILzFMKy9CZnhQS1ppekgvUXdUOXBRajY4N0c4czJ5aXZzWThaeDBIZ0RmcmVyM3YyUG5tUkxpZnpyZGtINmZiKy9uR2IvMHM5MzRkK3I3ZncvMkJvTS83Ny9NbTZubjdGK1FVUFUvN1dMY0Q4MmNsMzkyTjlZdkRrTDhVSWY5QVRPa2ZpcGkvUHliMDk4YjZWdFQ4N2ZIMk05TTVBRHg4U28vNStTSmkrNnZJNjkwWW9IODBmNTM1VkwvVnZtaGwrWjZWNDUxYjExdTl6bC9JMHM5cnU5Ly9DVEFBd2NJOGFHVURwWW9BQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUJzQ0FZQUFBQ2NsRUFRQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yT1RSQ05UVkVRek5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJPVFJDTlRWRVJETkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWTVORUkxTlVSQk0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZNU5FSTFOVVJDTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrRklXTXdnQUFKL0ZKUkVGVWVOcnNuVDJzTk10WjU2dXFlMmJPZWQvN1loYmZEU3d1QkJ2QUprVFlFZEo2c1VTd2t1VU5rSXlzdFl6RWwrM0ZFR3lFVnJzRUdFU0taRHRZWkNGa3NUSklKQ0NSV1lBM0JKTnRBdWxlUkdJditONzM0NXlaNlNycWVhcXF1N3E3cXJ1NlorWjgzZi9mR3A4NTg5SFRNK2U5ODZ2L1U4K0gvT0luZjBZSUtZVVVSbFJTdUlzU29wWjBNV0tqNkNMNHNtMnZHMlh2LzFpdHhFOHJLVDVhU2ZOajl1Y1AyNmM4dHo5M3doZ2hUQ1A0NXhvcEphU3E4L2ZiODcyRVRITVFRdXQxVDZiUGtNNDVuTnZTOTU1OHZMRTM2L1dmSXdSQkVQVGdaTnF2ZlhscnI3OXFqUGhIYmNRL05FWis1MmpFWHgyTi9OdURGdnFncGRqYkMvMDgyQWZTejZPOTJNY0wremp4ZTMvMnJkNXhhem8wSVNqQXZGWUI1QTdnMjBxSUhmMTB2NzlqTDc5cTcvc3ZtMHI4U09XaEwvMXpKWFBOSFkvUGVEVWM2WVMwdjVJQytBVUFSOUNVQk0rVjUwd3dWNlovYm91aFB2akZuSEErRUFSQjBBT0d1aFRhbUozOXB0OVptUCtRdmZ5RUJmclBIaDI0LzUrOS9PKzlGbC9iYS9QdTNvTjliMUZJRnd0N2k2dXhzYTJabmQ2ZDE5WmVienk4Q2VJN2dubGw2UHFIcnlyeld4Ym12MlR2MjFxWU0vQ3RNK2ZuS2JyWVl5ZzVvTElXSzkxbEl5U0ZDVlIxQXNCeml3Q1pQcDV1N0szTkNlNmNmcG9GN252NlQ4M09YTjhEek9QRkV5SURFQVJCRjNIbnpyUTVUR3BEY0xma3M5KzVGdXJXZlpzZnNVRC9EUXZ4LzNhcjVkZHZHdkdiR3kyK1Z6V0J0MlBDTWRBZGtBMVpkYkdSQkcvQklMY0FGOWNWUS8zVFY4cDh6ZjcrZG5Ec1B1ek9CdzdQcDRNSG9Fc1BCb3E2ODFtdTRRcWRPVUY5RWJSTFhIem05a1lUUmxlZXF4TDkxWXc1Q2VyR0xpNFk1dFY5Z055Y3VCaUJJQWlDU3NHdW1ldkdBNTFkdXpnWUNyTmIzbXE1dFpmL1drdjU2ZHRHZnFtUzhrK3FocmJJWlJKL05jRjRJNFYzNWc3bzE1YlNGdWExdlh6bHVqWmZJTEJ6NkwxeTBBOWhlWlVLdGROMTVWMndzcjY5V2JrSHJMUUZwWm1COS9sZ1kzajFzZUo0NU03cEF4azkxMHk5MkRUTTVSM0NQQWR5QUIyQ0lPanlUdDEwd2V6Z2diZjIvdzVLY21oOW80bTU4dTFhcVQ5V1IvRWZMVzErelQ3c21IVG9uUHpXd3R3STY4WUo2TStlMWVKUG5sWG1reGJvMXEyNzBIdllWdyt1UElUYlc1QVQzSVpoZDBsUVA2NEFqZUZGZ290bEwzMXU5SW5KRXNiYTlSRzlsbG9PTDFuVkxwSXdBdDhVS0dVYWxFYmI4OUNyenVNMG1BUG9FQVJCOXdIMThCWExhV2ZHY1BpOUlaTk5lK2xrb08zM05MUFdZbDhKK1FVbDFUc1dJVDluSC81NkJQUksrZ3oyU25DSTNVSzhmcWIwTjUvWDhwUFhGSHF2M2UwaHc3M3lEajJFMkpVSFFldktld3gxS2ZQR3lCWEpYWTE5ZGpPZDBUNlg3QzRMSHgvMno1Y216OXZGaHF3cjk3N2xIQUROK0Z4TVA0SE9tR1AvV0JjRitYREJZZktmSWFBT1FSQjBHWWN1UTJxNmMrY0VkZG9DcCtTNFVIVkdPZUpzbnRsQTYwL2EzNzVwbi9TejlMQytRNC9kZWNXWHIxNVgrbE5YOWlEUHJIMi9za2QwN3R4d0JsMjhieDYrNzZXU0NXYktDT3FWQzcyZndwMFNnSi93MFpvVng1WjFuVmcwNU1yV0VzbDQwanQxRDNONUp6QlhFNnNmay85REFPb1FCRUdYZ1RvblFvdTJZb3hjT3BlU0U4eE5sd1RYMlREOUtTUFVWKzNWTDhUSFUySHZuR0d1ek05ZDErYno1TWl2bFJZN2ViU2cxNjU4VGJtU05wY00xeVhCRWN6bDRNVkdWS0pzOVJXaGM5NVBGcU9ERnk0RzVKSVhXZ2RHenNLWEU2dVJzcENDMGNmTEExTzY3WTgxbnlVRVFSQjBnYS9sK0JKdFlTdmZBeVl3ZDhzSjZxWk5WcjkyMXovL2h6Ly9IejdUQjdyMDllYktmSGpuM0hsdzZoYm9sRERYK0ZDN0M3ZTNJSmQrenp4NWVrT1FTTGZYdkp6b1dkZm85dXZ6bDVMSDhPTk10SEJZOG9mZzl5UEY1SXJEdjNlUis0ekltVGQzQVhNVllqVXphd3M1RXk2QklBaUNMZ3IzQ095aE5KeVMwUWVSZEVHc0ptWi8vWE1mLzdjcGgvN2JsdnB2Ny95VFBPVEZSalJDbVdQcnlxWC9QeWtMTnFqang1Q2JWUXRkK2dCMFEyQ2ZMZWl4RktqMFBwS2Q3T1Q4NXhBOTFqbnpDOWFhODc4TXRSREdnRG9FUWRCOWdyMzFnNkpMUUE5UUQyRGZjUUs3K1NFTDlTKzNhUExoOUIrMWQvN2l0dXNJeDArdWZHbWFvcEl1Q3g4cGMxLzVzc0NaaXVsMnJqbFo5M3graVBlUHY5eWRiMFJpbjJGK2NSTzloNVBhekJhN2NqV0lJcFN5RytDR0lBaDZTRkJYUGtyZWdWMEV1UCtDZGVrL0dqdjBMOXJMeHZWdDk5bnNTclFIWUc1UlNaV0g2eXpNYzg2VjI2TXVjK25zWXVlREZLc3YwOGRQdWZNcTZtQTN4YjhKdDA2dnFac0wvVXVRdmhlK0FxZ2hDSUtlQ05TRHdhNVUxOXpOODN0RERQZEFaNmgvdGgzQzRwMTU3VzErekdqSkhjeWFGVEFmdU50RlJEY1RFRCtERm9iYlpiMU5Sd3RLM1hwelhGZVh2OENWUzUrQVdCVFZXT3JTRVhhSElBaTZjNmdMNGVldGVFWnZwSW5CL3RuZi85ekhsYkozZnN6KzhrN3RZL1NWNnJxL3FiajdXK0Fmd1VqckFwaW5FdVF5RG5mV3BXdHhpZlRzcGNsd2xBZ1huRzhXbGxOUXAzcDNDclZmUXQ2VnowTjhTZWhkQU9vUUJFRVBBZW9SazBOOU9uZHVkWjFlM3lHV1U2ZTRUOVErdEI3QzdDRmVIOXY5SGdndGxHUW9nOHJDUEg4VHVWeHp1Q2x6eDl3UDd6aTlDRmdMbUNVWjVsd2d1QjNjSlAwcG12UjdqVzhtbUIvM0YzSGxicEdSN3ZwRzUyaEszbU95REgyaU5oMkNJQWk2TzZqN2RpQWRvNlUzNEs2Ym5PWDRUeXY3eTArMlU5T29rTjFQVFZOeVp2UUpPVTNLMEY0STh3REhKUWx5WnBnSkxtWC9zdGFoTDhnd3AvTjFEWFFTeVg2NXBMMFc3UG95enB4ZGViWEdZdU8vRUFpQ29FY0k5c0JuWnJXZmxPb1liajZxN0IwL0hoN1F0WmJMdS9QWU9ZOXJxTXZDdVF3L3F1TXViVFpqL0p6eEV3SGVQK2FDb1RGMG5yejNMeWVCbUE1MzI4L3BlSHZlV25OZjE4K0xvbXl0Kzl4NXlRWC9oTTRZRllFZ0NJSld3VHl1TkpNUnQvM2x4NjFERng5UjhRalU5c2tsNFhCeW5uc1BxM21ZOTVxK3RPNVNGTDdPY2VwdExyNllwaW11QWFmekhHZU41OTE2eFBJTHdGejVzamsxQTlnU3FNTzRReEFFUFM2d081NG9NU3hwY3l4L0VVQWVJc3FMekpjTzRXUXpDL09SR0V5Rkx6YUtCSnlZSkZjYWJxZnpxNmZPVTJiaHlUQS9WNjE1Y09WVEhmY2tRdThRQkVGUEh1cWhFbHoyK3J5L1VGS2E3WEJyV0M3OXVxZHM4WGlQdUFUbU5LS2RYWHJoWG5vTDlMc3RWeU0zM0VZU0prUCtVZE1ZT2pZbHdKMnIxbHo2ejBrdEhaSitMcGVPc0RzRVFkRDl1L1BFTjNLN1hXNVp6ckNJeHA0dWhubUFHSVhFQ2VxRk1HK3ZiYlpGWUtBR01KTmxaa3NpN3FZcGF5aERycmplcGtFMjliN09XV3RPNFg2S0VDaDFJUmQrd2w0NkpyQkJFQVRkRzlTNzZ6NE1yN2d1ZkhNV3Q4V2g5d2hrc3FnMlhhV2htWUpIQUVnSzBrdk9VNWYxYjVmMUxtcWZXalo4aFVCK2x2STB2NWlRdldTODBsak0xTjFuY05YR0FPWVFCRUVQRFBTcXRld2MwajBEMUgyb2VjbndGbG1hOFc3T05TKzhwQzViT1djOHR5QVp3dnh3ZXlaWHZzdC9Kbk5RTHZuc0Y1dDJBNUJERUFROVVNY3VSSmZVN3NHNnNaZnFaTGRPVU9jczhnS1lMM0hwTHFOKzdxM05YRUxtK2R5SHRObVZKOEpSOHhadUhITWl6RG54YmVNK2k1SDdMMm16Vy9veVM0QnZscFg0UVJBRVFmY2lOUUlFdWNOcXMzelU2Y0JKRTl4TXFrVnN4a0d5UzU5TCtxTGo5YkxUMThUZHpYem1lZmdNWmsyNXoyYTNpNWZpem5mWjExVE9sVS9PalQ4bDlMNWdMOTBBNUJBRVFZOFQ2REt4cjExdHAwdWtTcUIrQ0ZDUElKTURUYWl2TGdMVkNTVnJSWHZuMjBSM3UvUkxzak0vRWViT2xWOE54cDBXT1BHenVuVGpRQjRXVFFBNUJFSFFJM1hveVh0ckQ3ZVZicDBhd2h4dkpscXN5akZJWnlJRGkvYW9FeTFpWnhQV2VQOTZtMTh3eU1IN1k1aXZyRFduUlF5RjlwTjc5WmR3NlptSUJaMy9LUG9CUVJBRVBTNmdUNFZtdWJlY0I5emlHbWd2YWp6REVEYnpZQ0x1a2xPZHdrK3FKL29RM0xteU10cnJudW1wem9DZHMrWFNnWkJodnJKeEREZUoyVngxbjZ0Y0NlWkZMcjBiSm1NQ3dEWGNPQVJCMEJOMDZQa0dJclMvMnlackxZWTZoYVgzK2RlSnVDbnJncjMwazRhenlHbDNuZ3o3eTJTa1lGV3RPWDJXZHRIQUY3WFdpYTl6NlJRcFlaRHJCbUYxQ0lLZ3B3MzBuUE1MQ1hQQlZTNFB3Wk16ZGs1ZHpySkpiU2RjdXQrYlh5TmVWRXlFbGRYMnVpaXpuV0crcHRhY0ZnejJOYks1Q1ZKTVIwdld1SFQ2dkVJakhkMGdyQTVCRVBUMGdWNElEOHBJdDFCZjQ5YTVuQzBHWWE3TmFMdVBuVkUyYkQ1VHN0YmtJZHpiVnBody91WjRXTDZnOEUxaWFNRWdCL2tJNnh1OXpEelBEN1RoTFFhRTFTRUlncDY4bHFleEI0N1FIckNGRTllR0w5aEg1bjFuNFZ1K1pnL3VBT2htcnB2Q0V6b0JnaUU1VFdZeXpQMDU4SUprLzJiaGtrbHhYa0IvV2h2M244MmZvcGx3NGpPZkI3ZkhOUVpPSElJZzZJUHAwS2ZjdWN6eWtKclFNS3hLeXMwR1VPL3ZxU2NPemlOTDZ3eTAvRDd3RXBoUDlJTG40U3RxZW9yWkdwaTNyanpackVmbVhicWMrRnhTV3lHVWVLaURHMGRZSFlJZ0NBNTlnZnZ0NXBwVGlOeUZxNWZNL21hblR1NlY5NVBUR2VtMDMyeHVFb0RpY3JpRHZiK2VQTGMrenc5cDBKRTczMTBuM20vMFBtai9md25NT2ZFdDNpczNzdzZienRsa1A3dVViVGN1MlRBNGNnaUNJQWhBTDRQVTlKMnUwNXZpc2FHbDJkOW1mMk5oK215YzFkNTJyWFBBVHlhZ2hRVkY2UjUwNW5HdWozeVZoNmdGcHI0dGh6azNpZG5zQ212M3ArTHJxUS9NaGRJWjR1Y2F6UXBCRUFROUNha1M2SlU0WUhlN2NsbmNwUWx6Rms2YW5XL2tZQWZQWStDbnhJdUd3bWdBT2ZQTUlrUHVudWNYQlJhZyt2WjFXUWc3bEtPUjJ4OVZBY2pGbi9Hd2dZMGJ5YnB2aDk5QUVBUkJVQS9vWE02VUJKWXNkdWVqV3doc1ZBSlcwb3lHd3NaWkIreXkwK1YyRFBYaHFOWkpoV3p2RWN5ZmRWc0hCT1RoS0ZTQ2VRazg3ZnRVdEREb05hVlpIdm9ZTFN5TUcvamlodDBjVmpleGdTQUlncDYrYW9aRW80V2h2ZkJLK1JHcTgzdm5PWmZhWHFXYTlWM2xHN0JNWjZ2ei9kYXA1OXc0TlpzeEIzVkNpOVhVSG4yNmQzeDRmL3IyMVd4WHVYWTZHdGZORDhMbm8yaTZGQ1Y3NmE2Zit0RnRXeUM1RFlJZ0NDb0dlZ3NTU2pScmZHSlc1ZUF1NXh6Mi9BUXYxNGltNXA3dVV3NHo3Sk4zVUk4akJCVWZ4K3hmOTU5RGM5Y0wzbVJxVDU5cjZUTVJCSWI1WEsyNVVxNFJUUzg3ZnVHZWVPOGNHNS9rZGtTU0d3UkJFSFFDMEFjQU5Ob0lRMlZwWE5KVk1DTjlZblkzT1d4WlBlY2t1Q25YMjBIOStkZzFrMHMvcXQ2aWdETFBEWVgzSnhMUXVOM3BNRU9kRzlmVXEyRk9PUUxzeXVsMVRhcEh2U2wwNlM1YkgwbHVFQVJCMEVXQTN0SE5sMFVSdUh5M3M4VzkwMlVIZkU0WWF6WU9zQmtYT29SNlZ4NVg4MGhYbzIvRXVoTVlBRGxSZHo0TGMzc3VpaUlJY2FpK29Obkw2RDNTWjByNzRwaHdCa0VRQk4wSjBEc0N1U21iMUJDRzk0M2RtTk4yUDMzQ25RL2h5bnZPVnhYRE14ZUNaNmhUb3RuMnV2OXNxa3NmZHFhamM4czVkRG92UFFpM2gxRDVFT1lVUFppQ09UM3Y2cTFvRzhLVVFUMlljajhZaGJjZXVQenNpWVhWNDM4RDJES0FJQWg2b0VDUHY2aDU5T2FOK3dJbnA4b1R5aFoya0pVRXh4Y3VZZTZRZHR4OEg4RS9Palpub3ROZSttMjNsNjdmdkJUVjh4OU1MQ3k2KzN0Y0RnTllJdWh3bDdWRDN2bHpLZDdtYW1GVXdMZUxiZHhRRkY2a1BHYlF5WVVUM2dCMUNJS2dCd3owQWR6YmhpOE1kalVlcURMVHdwVDNvZTN6MkJrUDk1Q3BSdDI2ZUhYOUE3M01lbVhCMmd3Zlgxby9IMmFRRDZDamIxNmxROThjSmJqaTBiSHVMWnNrdE1jUU0rMWt0MVZUMlI0RXREUHRhSk9jTm9BNkJFSFFvd1Y2L0hYT05lSHVwNlNNOUxhTXE0QWh0SjlOM2VBc0FFY3VtWnp0emZ0Q1dxajNPTHQ3WnAzMys4dDVOYXhudDlEUnI3K2ZURWpqTEhpQ2VSVE9uMjdQNmtGT29mdkhrT1FtZlhtaXpBQjhDdGFsMFJ3SWdpRG9jUUc5QTdCMXBNSmVibzR1Z1l6RDI2b2dROTdOQ2VjaEtPUytJN2RNSVd2OTVqMTI2dDNEWFh2VjhGaUN1N3ArTVQ0ZGdyNC9GamU3cVRjOTRORDlvNUkyampUc2t2dnNpUlBuNWkvMHZybmpuWGxnWTBwbE43M084VG8wejhuYmJYT3U4NGREaHlBSWVzUkFqOTBaQVpOQzJYN2ZtOGVIaHN6eVhPdFllaHp0a2QrODdKVzNPYWozb2QyT1Y4M08rcFlqU1BkZ1BuaU5zRkJJTFF6Nm5QSXVuUWEyY0VuY3pmMW5xdmZjZGdUdGlaYTIvYzhJNElVZ0NBTFFDK0RPOWVLK3F4cDNhTnRlcGNIcmdTa29tNXhIck41MHM4Z3RRRnVvK3hJNlNZbHplaitiWmM4bGIrMyt2b2Q1dkxmdHA2T3A3WHppRzJYRGl6Q3E5RDRjYUNnaEhFSzdkZDRtQVc0SWdpRG82UU9kbThiUTFRdnYrY1pKZEZSS3htTkxuMlZkTUplb1dRanJtL2ZiTWpVSDlmZUVldlloOXpqN2ZHNkNReGNMOXpnVG5VdnNDTHI4T2wyakd2MzZ2YjR6cDNJMFNyeUx1OFlsUU9qSzdKcmlTWEpuRVpjRytxWStjV25lcU9mN0hZSjdmVE04Q0lJZzZKSkE1N0t3U3JsdWJteWdxWjBxQVRRRzEzbnJwZ01VQTNCcHNJbWJVRFp3NjVSbGZ2MGhUb3dMVFZnNC9IN3pTcWlyNTN4L0dLODZiQU5yZkNpZTlzMERySHY5MlFuMGZQd1h5ZEMwOGFOS3ljMWZiRzg4M3MrbVJjeGNWejZUL1FXQ0lBajZ3RHYwQUpZMmY4cEJoY1BVTW5LQWxMVWRKNnZSOVZPbmZ6RTBHM2Jkb1VUTURJYW1zRnUzRHRxQi9HVmJDbWFhSGNPY21yMDBMLy8vZU95cWtvdzhiZ2JqRnc5dDR4aGFSRnkvNVJya0RNQklyVmpic2E3bnpGUVBicnY5blJZalZlZThld3NHMHkwcUx1S3lrYkFHUVJEME5JRSs5LzNQQ1cwaDVPdGJzVktKMXJCMTZTa2hhZnRjVHFJVFBpT2RNdG1qdW5hR3Q0V3dPUjU1U0F2QjNZWEtsUXUxRStUckhidGNjdXNjZ2c5WjlwSFQ1cEdwM0xCbUU3MGY0M3FxSC9lVERXYUtlVWxSRDBvQWxBUDN6U0F0ZDluelpYSjNJY1RZSVFpQ25nelFjMS8wL1E1eDdvdGZrb09tVUhlQWtRK0g5MXo1bkhFL3VCbmdrdURxWjQwN1VEb1FHd3R4QWpUVmtGT1hPQUszZnZYUFF0THJFRGlOVzFoVVhPcG1SUFBxWHhqbUZGN3ZaYnY3QkRrdXQxc3k1V3c0Sm5hejdRYTFTTmtQcFQ5NkdBTG1FQVJCVHh6b0dUZEhOZVVxOHZMVW5TMiszN3RuWTVvK000YWxYNVJFUjI3ZlhocUNPMDg0dTNZTENldmdsWDBSMmhOdkxNaXI1Ly9HMzJmYTQwbGZSKzdDOFQ3eGpVTHNmc0hCbWZmSDIybUl0elgwSm9MM2xWczBDSk4zc0ZNZDVSNjQxa1VGNE9JaENJS2VHTkJ6WC9hUkNQQXQ1UDE5K3RnZmpFSlE4WHZaTGR5NTcvdXRINjdpSnA2Uk82Y3dQVGx3UlpQY2pOOENzSXNGQ3NYVDdRUmcza2ZuZnVxMythRXd0SGNmTjU0UlB2U3YwaCtSTWFWQWUxeWdNMVBqWU9IaUlRaUNQc2hBTjJLNnJhamsvV2E1cTNzOTIwMTlkRjNZSXRCd0V4ZnQ5OE01ZWE1MldlelZNOWZrNVhCamVWOXpRaHQxZXFOTWVOY1I3cjMrQW9FejY2Lzc1elVjTW1NZXcvNzJuU0FlLzVWQUVBUUI2RUxNalZQTjNzTndyZnMra2ZlL0k4QlE1dnYrdGQ5Yjk0bG90SS9QUDZYUGhqL3dIanoxY1E4UWxzTzY3aFhRZXFvdy8rQXNWQ0FJZ2dEMDh6djBMRFFIOWQvRCtteE9tSHZMWlpGemYvZHJUcFRqeGpQMDJNWTZlTE56Ymo0Q2xhc3hQMGFIVmN2R2cwS2xxd09VeDBFUUJEMEtvSWVzN3BMSGNUS2E3cHRoT2NaNzZ4S2JZOWVyUFFPTDBFcTJnNGQySld2Tm5wUHoybjE1S2x1Ym1rZk80Zlo0OXJxWmRPYXR3MjhYQXVkY0ROd3ZBTS9xemdGekNJS2dod1YwNTJnOWJQaExPdW9jTi96U2pnSHZIOXM2N2NJditLbEhjUjA1Z2RUdmVldmJOKzQxR042U2srR29WdDExdW5NTmM5VHVoU3VkQ3dOVmJsLzNEMHFMQU02K1g0QmNocm5vV3JPV3VGV3AyblBxUlFYdUdueG5mejFrdVVNUUJOMC8wS2swVEZuSVNlZWdqYlp3cEpKcWFYL0tER3J2Q2tEZS9YSnltMi9mR3RxNDB2NTRxQytuc2pWOSs1bzdyeGxUT2FoYlFGTmlISlcxTlJiMk5FT2RwN21Kc0JjdmZET2JsMkpWYTFzZmJUQkNyM2hQdk5NL3pjZmMxTFI0Sk9wYWQzLzJVRGhnRGtFUWRPOUFaK2RLWVcxTjRYTVRPZW43bUNRbXV5RXA5VmFvelhqNkdZZml1U2U3Ry9CQ01IZkpiM3N1TTZOR05nUi82aVpuN0UrNm44QlBrOXBrOVViSXE3ZTZValNsdVBUTkxSQnUyeEE5ZnlhWFdyUzB4eld6ZkRRTFA3c1c5SEswT3ZBUGtmT1JHTEFiZ2lEb2tUcjArNVlmaGNwWHFYbE10Y25BeHZkd3B4N3JCQjRlclBJRC9IeHkyZFJJaHJ2SW1WZStiZXlPYjY5ZXZNM1FibDUvM3kwR0tHbU9wcnhWVzlmUzFrTXV6R0lQRFczQ1pMalo1ak1QUmZGQ3dTeGtjWEZDb0N3bk8vYlBJUWlDUGdCQTUvbmpWOUdFc2VuVDRQbmwxSnJWSjhneCtDbUU3bHZBOG43NkppNXBNL3c3UVpuR3I2cXJGd3gvZHZaODJ5djduSnR1MnRvQVF0STN2K0diYUxGQnJXUjlkN2tuQ2FyaTl3UklReEFFZlhDQkhvV0MyUVhUaERIT1ZGTVp0blI5NExrOUsyV3NoMHgzS2JuclczRHhCR1lld2xLNUVha08vRzVmbkI4bkZkK3YvVDQ4aGR2ZDFMYjMyMFE0N2laSDRYM2ZLblowK3I0ZW52ZmUrWFhkNURtWGpCY2NNVUFIUVJBRVBVV2dSNDFiS1BSTnM5YW5TN3Y2OWVqc292ZXYreVZyRFBNWG5YUG1rYTYrbGp6c3Uvc1o2TzN6NkhZdWZXdmFFanZxTEVldW5QYlV3MWhZV2pnMHgxdlhnQ1lUOHVkVG9MMTVlbzVkbEtobmZ2UnFOSmIxb252dkVBUkJFSFFuUVBldFdCMUlmY2g2YVhtMjcra2U5cS83TUgrckIzTkRicHdUNDN3V2ZCd044RC9wZGdJMTFiTVR3RG04N3V2WDZYaHVwS3BwRndPY09FZjkyK3ZkWUpKY0Z6MFlLUnJGS2tQdGZCZ3NZelQraFVFUUJFR1BBT2p0UUJNWFFuY1o2akpqdkFkZDRlS21OQnhlZjUyRllCeG1aeld1cFd1SUFFeTVZcnFmZXJ6VDQza2s2OGFWckRtb3YrQSs3ejFvODRMaTRQYlJRODE3RXVhSkNXdTBseC9LNnppazc0YkY4QUlGY0ljZ0NJSWVCTkFqOStzNnRCRzhFblhTTSsxYyt4Q2tKaTl2ZktoYUoxOXpDSFBLZHUvMnIwVUw2T3hwYjY4WjZHekNiMTliNW03YThpMkNOaVhMOFo1NkRPeVFVYStQYm1RcVpjVXZDamNZdjhBSjJ3NGIzOFZ1QUhlRTV5RUlncUE3QWJxVWJYTVgxeHExR2o1ZzdMYm5RQ2VrRDBrZkhHaHpVS09KYUZmUEJ6QjNrOU5hSUNvMUdMSXljTXpDMTE2VGEvYUxCdjNtKzZKNjlvUGR5eERVeWFuZnZoeTNtU1VBYXhjTm9EN3hER1ordmFuNTV5a2o3K2ZFVjkxRU56ZnIvZEMxdzRXRGh5QUlnczRLZEhiZ2xXTTVBVHpLUm0vN21KZUNPMkhZMmZtU1M5Vk5maDFCaXdjYWJ5cXIzbXR5OGxrRVhVNWlDL2Y1UHU3T1lEZjhld2lYMCtQYTBEcnRsZTl2aE5wZTlhSE9aVzJ2eC92M0h0aTBKVUREWHFqaFRhaWJQOFZsdStsd2xjdWU1OFkrUi9jNnVXZ0ZCRUVRQk0wQ25SUGFLQU9jd3NNV01aVnlYZU9rS0krZ3o3bDA3cFYrNjV6cEZPaW90STFoSzNzTENaY3dkOU56OEwzSEhLSkZBci9XM2gvSFA0d2U3MEhKZStwUnJibGJ4OWo3ZDg5OWw3azM2YmZJcnZySTNlZ29sTjltMTQ4dCtlanErRDRUdlJYcVRlOGpFZFN4enpRZTdzZjhjQm9JZ2lBSWlvSE9iclBTRG5yTXlDVnRYMHRvYjZKOTh1bmpjcmUzZGs4OGR2bTBiLzZxNTF6bEFNampjNDZCV1hPNHZEZDk3ZmFsZGVVZjZrVWM2RHFkQTlXdHN5UFB2U1BLWnI5NXhTRHU3Nit2M1JPUFI4VHltMnZQTzlTOXQ4NGQrKzRRQkVGUTFxRXZtSlkxR1hidlphNDNuQzJlREdIbm5Qa293YzFCblk0enJFa1gxYklFZllLL2lVZW9jb0xhcmV0WU4zeC92dXRjenFtSFJZRnA3T1gxZTc3VWJUdVlORmZtenFkUG1oNHJYUm5nQ082RHFYY1FCRUVRZ0g2YUVSK1hvN2tTc1VQeFhqQTdjMjZ4T2c3Yjg5Q1VnVnVtMGpCWjc1WUJuV3JMQnlGLzNqUG5aak83VVZtYUEvMjBVMitQRTByZHd2NzZvdnA3VTNpWC95V1V4dmtaOC94NXQrTnBFWjZISUFnQzBFZk9NVS94bkV0bmtCTXdKeExlK3RUMDdXRGpKTE1STEc4eTFyV3JEWmVsdzBVU0dmSGF1bkJWYlROUmc2MC9oNEllN3VUWWZiMjdHdzZ6WGV6T2U0c0tNeGttNmQ2UHBFR3NLcHBQcjl2NmR3aUNJQWdPZlpGTGQvWFZOOHNTdUNnUmIzczE3c2dXUVkxRDNzTmowaUtBOTYwSElEVHpwV1Qwdk5ESnJTTzY1cUV0NDFwejAwS2RoOEJZTjE4RVNSOFNweDcwM0I4K1YxWTNTKzJGQ2pQT09jRlJkWEJ2M1R0Qzh4QUVRUjhzb0p1WTNOTXVuUjhiWFBrUzBaUXp6aEpYMmRmSjdyL0xSTzA1NzJmdkI5RUNhZ3l6R3p6Vzk1ZzN6ZUMxOXJ3bjc4TDRxZmF1TmRmRU05UkxvdzlVSG5malJybUtldE9GeVRNd241NUZ2aExHQkhlcDJ2MzJ0dVlkZSs4UUJFRlBUbW9STUV3RS9lUEJoNWlYd1p4YnJwSWJIazFiNjhPTzU1Q25UcGlkdElrdXpoV25tc0trNEtzRzdyNTlSYzZBencwU04xMmptNG50Z2VSVGFjRkRVK05vbjcwMERHNG1ZRDZ4S0pqNTVDM2MzZjY3RzFuckYwWlM0cjhDQ0lLZ3ArWFFCL3U4dVI3c0JQS1Z6VTk0YnpuVW1DZk52N3VSNTVYbm5QQUlRQXVkWmc1Z0ZDYS9lY2tqVnRQdzlGRDB0ZTJsMmZ2aE9QeDRXdnhVdGU5L24zSG5KWHZuczZBditSaVViOXBuWEtraW5Ec0VRZEJUQWZxTVplUjk0Y01KbmRFMm80WXhLYWk3RXJVMHpPWHNudlNzM2ZWNzk4K1MyZXNtTkkyWkdLSHF6bU1GMVBrSnZrZThmUjJHZXJJeHpYMUkrcitEN01OOXhVSUJnaUFJZW1oQUR5VmtuT1IxV3NjeUx1ZEtOWXlKZVVzM2FaM0phbmZPbWp1cXRSbmVjclZMcCtPWWtFUTJmTnY3Ryt2U3E4ekN3WndPOVFCMkN2RlQrSnNXRDBxVkxVYUtuUHZDQlU2Rzc5M2ZTQUx1RUFSQmp3L293NGxqVFhrU1dBN0NveEt1bkRVM1hFS1dDK1Z6WTVYWTBSYkJKZk1ZM2tldTJ4R3NROWp5VkRacUF5dW5POEJ4cmJxVS9ZWTFTeFNheENnL3RFVlcrWE5mQzlQU01ybDV3ZytLQUFCM0NJS2doeVExTHZmU3ZwNzhjRHJNNjEwSDg1bDU0clAxNjBxSmJNWjkwOHpmSHJMeXcza29OUTFhVHZiTHRNR05idWIzNk1HK1d2UjZ2TWRlT2pkOVJkZTVJbmMrZDcrTTRDNlJVQWRCRVBTZ2dCNjd0UUN5Z3I3cjA5Lzd5aldNbVczUEdrSzVUVDdVN3VHYkxTa1RKdTIwaGVqMi9GTTE2YlFGTUFGMWJpYVQybVpJbkFMM2xkK3MyZC92TzE3dUVVL1ovY05jaGJXWjdhZTY2SktuQSt3UUJFSDNwdmhyV3ZFdlBQZjc2Qnp0cVJCUUh1WXFNemM4NGRScG5PblU2NGFNN0w0OU50MnZPV2ZQdDV1czI1UlRBQTViQUxPQTh3MW9hT1FzN2FzcmRlSmZKN1RPM2M4dnJFNzRXeGx6aGtFeUVBUkIwSU1CdXpMUnNJODR3THpxYTV1ZE5NRjhKbUV0N2diSE04NmJTUWM0SHRxeUFDNG1md2NmdDJEa2F6cnlQcjVSK3NqRVdiTFgyNHo0ZUhiOEtlN2N6TURjZ05zUUJFR1B4SkgzZVMyOVE5ZG1yd2RzV2dWMUhwaHkxZFUyejlHaERURVhaSWxUc3BnNTlTTXdZM2RmQU43MERQZjhJb1dncnJaWDV5dEoweUduWVQ4UmhqL1ZWWnZUam9NRU9RaUNvRHVGZVh5ajV1QzMzRlBJL1gyT1dndDM0NXJlSWpLMFRlME5YWnVIZWduTWUxUFZUTW9ZbndhVG9xbHQzRmJXRkVVYy9GRVo2bkxoaU5kWnNQc2E5dmxCTVFBc0JFSFFrd1c3NlVDdU95eStyeG9qL29sdk5GSUVzTWNXdmdUbUlrd3JHMjJabTR4VEZ0MGU4ZXp4cTBuVGJlYU9ZWnI1ODUvNzhDaVNrR29ObThrSjZBYTc3QmEzaXAwSHUydndrMzNmTXpBdjJqdkhlZ0NDSU9pQnVuVEg1Z0J5WWpjeG5GaXU3SlcvMTRIMG9iSXI1dFVrRERjZHpETXdTQUhFaERLdFdaaHZmT2E0bVFUY0hJeVRFZmR3NGZLNmVlZzZkOXpNZ0RNOTJPWHNVRGRtSHV6RmRFYTRIWUlnNk9HRFBKcVNIVERRdi95OWRlank3K3lGNkc2SmIzOEsyY0Y5Q3JZRUtYYTNadmE3ZndoMTUzWUxwS3FrODEwQzlQa29nQ3plNytiU3VobFhubnpmbDRCNkQrekhETmlYVEhTYjRqYWdEVUVROUJDZ0h2ak1yQmFPM1k3aDhqdnFhTVJmSGNNTk9qellRVDNwMG9PalZkWDBGMzRHNmk1cnZLQjVDbVhNSjhQdGZZdHRabHJTbW9LV3RlMzBzZGxQTTlXYU5nM3lFVHhWUFo5VnYvcXZyQWZOY0piODg0QWdDSUllaXp1UEdVM01KbllUdzRubEZ1anlidzVhdmtzM0hEelVHOVBGNW51cFlMNlZxNUJxdHZOYkV1cFpKNW1BTExkQmxkbkdNTXMvanZGaW9MMXduL2l5QkRZejAwVXU2WUxiZnZXVld3eEpkYUcvdW00LzQrR28xb3ZzblNQY0RrRVFkSEdZZCs3Y01ibnhNRDk0bUR1R3k3OVZCeTIwL2VXUDdNWGU2S0hPRDNKV3Z2M2VKZ2kxZTlxNUwvUUptSVVSb2lVUUlCYzdURlk3R2V3enp5V2dsN2huL3o2TVhnanpMaHpnSXh6cWd2OEN0SU03WmNhbm9nV0w2STI5Y3dpQ29IdUZ1Yi9Tc0JOM2pDWldNN09aM2ZLUGZ1VWIzOWFLZnRscitUVjcyZnM3K0VFaC9FNVBOQVFmRHp3ek96UWs0VnlOV0RiQUpFeFd5NEZrMkpkOXJaT01qc092VnhvT0oyQTIreDdJaTJBZXY3L3EwbEEzTGRqWFJGTWdDSUtnaHdGejU4cTdNSHNFY3VMM25oak92blRQTjRoM2I3WDh1cjlPRDJpZHVwWTBhblRENDBhN0RMdUZrOEQwY2RHZ2x5NzhiU1pKNC9iSDU3TzRUWURhekdKZ2JnNTY3NmdVMnFaTGRyRWdwaGM2TGRRdlBCTjlCSGJzc1VNUUJEMG1tSGVsYVk3Tk1hc3R1Ly9nbDc3eDdYY1o2Sjd3NHFhUnYvbW1rZCs3ZFE5d1R4Q1ZPSXJhWmNEcllkcDhvVlAzTFV6TGFVNUpkNXQ1MSsrb1d0WmtwWFRmbnJjVXlwUFdrbEdIYkp2WWROVEF6VU92N3VCZmlPbWdYbURZVjBVOElBaUNvTFBEdlBFNWJudlA1c0JwWXJabDkvOEl6MVVISThLRHZuZmJ5Qys5YVJUQlhkem9TdXhON2R5NlQ1UnJRdk9adGw1OWdQVlV6WGxtRWxyZW5WY3pielc2bkJweVR4eGJMb0ZybXhjd0ZVeVk3eXpIbmZiTzJWVnVDZGdOM0RrRVFkQkRBSGxjWHg3QzdESE1iNTM1NWd1eDJqTDcxMy81RzkvK1hqaEc5VlAvL3Q4Sm1xVkN2dFQrL0wvMjhoRUx0WThxNnMzdWIyOU5xM0ZkYXZoL012cktqMXl0akcvalVhekhaVUFmREdLUkU0N1pIQS9GVUM4R0ppWDlOUXZPbWZiZitZTlNaVURNN1dkVHNoeC9xUHB1L3duSjNsOXRIdVp3NXhBRVFXZDE0N0VqRjk2Vmg4VDBZd0xtcngzUWYvL24vL0QvL0c1OHZQcEk3bHd5ekVWbGlhK1UvSFdweFVmVTBYeUt2dVoxRlJXelU2STd1ZExLQXQyK0NEMUhlYWNzaDFBUDVWMUx2ditwOXR6SUxFQ0djTmVsVzhJTHRvNXB3V0lJem5vQldPM0NRdFlxZ25wSnYvZkU0NmhVejM2b05NcjJ6c0JwdXRJOU1kZnVGekNISUFnNlA4eERPOWZJblI5OUdYbHc1eTNNand6elAzOXpsTDgyUEdiTmRsNFRSeXlnQ2FpTjJkdXJuN0gzL2FtOTZ6OXAvejNlVkZ5NExyYktoZCtWTktKU2twOG5JN01Yb0d1T1RTaGVMM2ZuY21PZkk4cytBVDR2T2YzNDlvSFNEMzR2WVJXNTdZMzlmYi9zTDhOUTN3M2pGTkhCVXlObFplSUVsSC85NDkwQzFJaDVzSVBuRUFSQlovM2FqZHU1aHFZeFlZdjcwQ1crK1RBN3cvd3ZyRVAvakwyTUlGVVRwTWtWODZVSlgrWG10VjB4L0dmN0NsK3h4L3U4OWpEZjBVOTdBNW5SbXR5NXZVNVFkeUFQYXd6NzA1QTdONHRnenNsd1JuWFRZVW8rREg3M3N1aGprMHNpLy9ZOGpGSExnS3JwZlIvNzlmTkw2ci83N2Zqb1QyT2YzdHlmSzVaeml4SUlnaURvWkljZUpxYUZkcTVSMDVpRHoyWjNDWENjMy9hL3lKbGJtQjhJOENPZ2gvN3RNVWg5VTlXRGRjQmZzQ0QvYXd2eHIxeFY4dTJqZmNXTmZlaEd1VXZsb2M0bDNEUXlORHlicUwvMHk1K2lBM29tSVUzMkFXT09zc3cxYXVtTlorazVWWGF4c0REc1RtcWFRZWc5dFRlZDIxS1E0emRMU1lpNnVmOVF0NVJ3NXhBRVFSY0F1amFST3hjeWdya0lkZWJrekw5TENYQTNXbjR6T1BWYm5RUzZjdnhWZnBrZ1pDL1R6Z0w5ajQ5R2Z1dW96WmZ0U3VFWHRrcHVOL2F4Ryt2TUt3cTcrLzMzc0ovT3RlRStETDRFNmRJNlVuRmM4Q3h1YzFvSUd0NFdNTk9OWEliSDBmWGlESDMzUEozb1FaK0I5cXpyZGVGdjk1bnFlLzduQjNjT1FSQjBObWNldWZOb0JHcmJtejAwamFFNmN3dngvMm12Zi9mR2czemZ1RkQ4Q09qR1I2MHBPUzVBM1VRSDkwM2Z2M3RVNG9zYkxYOW5xOHlYckR2L3JMMzhjR1ZCV1Z1b0I2QVRkSlJ4Ym4yeEE3U3VlQncrbnpnT2ZRck5BdER3b21YSmVkWHN1SmU3WXg4dmFjdmZscmp5MU9HNC9zQzlXYTN4WHdNRVFkQ1RBTHZzdS9NK3pQK1IycmxhYUgvMVlNUzcxcDIzTmVpaGxQeVlCSHBZSlhpb0d3dG8zajdXRWRUdGxiMkY0YllTNzI2aytBM3J6djk3cmN6SGFpaytvYVQ4U2V2VWY4eTY4M2VrRm05SnpteGJpSFFxa1ROcW1UdHNwQXVMbDY0WjZMRnFXY3hBTkhYeE1Kbmg2b0ZkZWlyQmJNbGVkRzh4WWMrRlZpV0FPZ1JCMEpOdzZkWThVeXVZbDVhejcxck0vZ09OTTdkQS8wc2F0T0xuckhpQVU0YzQ1OXFKMDhGc0QvV3ZBZ3dBVm1Za1lzeVZvK2dBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJUUFBQUJHQ0FZQUFBQU5aRHdZQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBCT0RjeE5qSTJSVE5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEJPRGN4TmpJMlJqTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qY3pNelZCT0RnNU0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pjek16VkJPRGhCTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTnpkYzhBQUFCL1pKUkVGVWVOcnNYV3RzazFVWVBpMWQxMjdkMk5qbUdQY1pGQ2VJUktnRDFPQVdqWW9nTEFxQkVOQmdKSTQvSnNPTmlCS3lvQkNDL05HRUVnMyttQ0dTRFlJb1RvMEdKQ2lJb0NJQkJvRTR0MFhHM0tXN3QzU3o4M3ZPZGo2K2xuWTkzYzJ2M2Zza0o5MjZmcGVlODV6bnZPOXozcTZHNnFKNUxCQ1NzcGVabFlmbGZXMkIwaVlvemN3STBReUhLUWdaQ2xpUGQwOVhVeTNyY3Q1aTNlMU56T3R4TStVNTZySW9oakx1K1NhL0o2WXBEMFZkenRwOFYvVmw1blYzVUMrTk1waDh5TkRUVSttcXFXQzNhNjlUejR4U0dEVS9GeEVaQ01ZK2RkalMxWFF6bjhoQU1QSnNvc2Y3bnF2cUV2VUdnU3ZFQ2svalRTV0xjRkZ2RURnaGxpdFpCZlVFUVNXRS9kK09adW9KZ2txSThkNHVOL1VFUVNWRUxQT1NBMG5RcEowRUFoR0NRSVFnRUNFSVJBZ0NFWUl3T2dsaHROM0RteDd2SzFwZ2lxU2JuYmoxSy83WTl2TXgxbnlrT09qZ1pCU1dNVTlkRldzN2VaQzVMNWNQKzMybGJYQXdveVdPdGYxMGhMV2YvSWdVWWxpWW1wNDFvT1BHclN6bWcyT1ptc1c4bmNOdnlTZmxiV1BtOUNuTU5EYVZHYTBKcEJERFFZU1VOZS95RHE3Yit6cnJycXVRUGpieDJVM01PcU8zYU5oZFZjRk1xVk40Q3daUDlSOWhuZDhmdGtVYldNTDhKWGZ1UFhrOEVXS29nUUhDREVkTGZ2RXRWcjkzbmZUZ2pNMVpwZjRPaFVEckQxNTNKMnNzM1RXZ1pRWFhTMTc4V3U4OXR6UndBc2ZQZVZKUkNRZHIrQ1NmbG95aGhQUG9oK3Fnb3VObGxFRU1Ucmp3VkowZk5CbnE5eGN3Wi9uSC9IY29WSHJCNFFFdmVhUVFBWUFaMjNFaGg4KzRoTWZ5Z2dacUNDQVJNNGhsd2xOWHpSb1B2TlB2TWlDQ1RpaFF4NFhqek52K1QzZ3h5dXJkL0w2MFpNRDEycFhtN1d4bEtTOXQ0akZGK3NaOXJPWDRnWWdMTW5VYlZEWi91WnRMT3FRNHpyNHE2TUFLTXJpdW5lZGtNRTk1V0Nyb3hMbGJ2M05JMzQ4NWN5R2YrWUlNSUo4Z2cwRG51WU9zYnQ4Ym5DaDh5Vk5VSkcxalNVU3BoVzdUVHN6Y3RqTmZNRTlOUmNBMVh2dzlZY0VML0xIejkzSStLM21HTVgwdWEvcXNNS0RVQ3dKaDlzcW9BNGlYK0hTK1QvQ0lnTFd4NU0yQXgzc3FUN082RDE1bUtldmVWK09ZaklJU25pcURnT0VxMGtqRDBIcDRlMC96MmFPNk42UzBnNkwxSWZBMzBjbFFFa2kyR0RSdFFHcVp1WmlsclN0VzFTUlU0SWZ6Mmg1Znl3a0hrZ24wNTRFRURIUnoxNmpIUTVWQTN2WWZQOVVsTVpLeWwrbmJtQkpFaUorVDZ6TW8va3FobFd5czR4aDR6RXpJTlVpQm9GTmtJSkQ2cHRKdC9hYTlpYm5ybWZXQlIrKzZKb2prZGJYejg4a0NjWXE0ZnpUY0Iwam11dm9MNjd4NFlrU01zNGhmTWpBb3RvVXJmWWlBZ1VTd0poT1FOaDVLNUVyQjVYckwxendPQ1NYMS9ncWpUVTNGMG9UbFJpdzU0YUsrWkJzYis4eXIvRDNnUFNFV1FYT1dUOUpWNEduU215SWtMUzFVQXpjUnlRdExlUEt1YzNKZVJrTzFTaUJCQmhtcGg4SWcvc0QxY2QyTzM3NVg1VDMra2FlQ3FsVEkrMUhPQmFLaWdYVHg5c1djckZBY3ZXVWh1bE1JU0xWMlpyWitzMGZxT01RSWx2dnR6Sm8xWHlXQlVKYVdiL2RMU3pPeUcvZU5Yems1dEtqZDhWekExNmV1ZDZpcVViUFpIdkw4T0M4YXNwYnUraHVVWmNoa0ZrQ293QXNFaUp1ZHc4WWtwd2QwSkVHRXRsTmxkdzJzekQyRWU4eUFEREVsRzZHMFV3S3lpdERkVUtsSWUvRmRKSEJkT2MzYzE4N290c1BKaHhoQ0lDZzBXdUo1cEE5RHFPWEVRV2EwMnBUbmJNeHo4enB6WHowMXFNMHFRb1Q0RUtFeUVoZy8zR3hTQ0NLck1LR0NXMUY3TVZ6NGUvdnp1dk1pNEVORWZBbWRLVFh6enBKUlErb1FkVXVHMWplUUNnS1ZiRVFnWmVWbVpma29EdXQ2Mkh2d2p6Y3djeHNQeVNsTndoTXJlSHFMKzNBZWs5OGIwYXVGcmI4Q21UREl3T1ZkNHcwTXhDZndkanFEcG9kYWJ3VHBjS0NDbmJpSEZqSFdaellGeWs2UVhxYTlzcE03bHUyblMzVWY0K2lPRUhEMGpIR0pVcTgxVDVyaHMra0VkRno0Z2ZzSTBvVG9hQXc1azJNeTd1VUREa3M3MEtaWmYwak1XZHZuVE9hR3RidEtoQkNaUkJqZWZyeTlSRjAyVUZRTFB5STJjMWJ2MXZrUVNqS01MZXlQd01Gc1BaNGxQY3ZobFlTN3UvcC9JMktEU213d0NVTUtjdXc4dkZPdG44RFc4MUNURkNrdnY2NmlFckpJV0xSS1RaY2pwVkRHR0tsazBPNWVZbzhDczFZRWRXS25jeWcvTDRHU2ZxNUtxSnVVT0MrMnZnVmhRZFpJUVVRUkFwNEQ5ZzRFR2JCcGhDb3BiU0FvYWh2NVRtZGhtVlJOcHF4S2dIdzhrSnk3UEtTUGdUb0k0WTFFa2xrV0VVNGxJblhiL0R5ZkdvVmc5Wk9RWnRSRUpDL0pWOHZZVUplSm5VdFVWUTFtY0xBM2duT0hpbk40MmxxNmkyKzJEWVZSTnBMUXBWT0pHV2FlT285M2FHem1iSjg2Q01RSmlCbENiV1ZEVFZERzc3L3hCU0oxMWY3SnJXNVA5U1crNDZnTjlyUVYxY09OY0txdlJnSzZxNWlDRXFTczNoclFpeEJFa0sxTGhCS2dXZ3FSdmkxN3FScnRnMXhvb3ViQ2YxQ2k0ZE5YVWJOa3dESHN1dldYU2dqRUNMY3JMdzJxMUV3VXBrQjFMRm01dkFBR3ZnSklJUUpTbjlkZk96Tnk3MWVIVnJ2dWxneElQZlluOEFHYTRjN2J0UVc2QkowVzJVTHFSeW9xSnpKRWlROUJJRUlRaUJBRUlnU0JDRUVnUWhDSUVBUWlCSUVJUVlnT1FyUVp4cGlvSndncUlXb05NUmJxQ1lKS2lJdGpKS3VjQ2FPREVKL0hKR2RRVHhCVVFwU1pVeVl3bzlsS3ZVRmd4dWF6UnozTVlIemJPblVXOVFhaE4rMVVTTEVqWnR3RVIyekdkT29SSW9TSzNkYkpEN0xZOUV6cUZTSUVWNGxLWmpETXRFNmI3WWkvejg3L01RZGg5TUhIa1ZKSWNVVjUySmlVdmV4R1RQTDRQZmlTZUh3dk9MNEsydXR4TTlaRFgvZ2E3VEJVRndYK3Y0c0tLY3pLd3dxbDVTbHRydEltS2kyR3VpeXE0ZmhQZ0FFQVZZeTV6b0xNRUgwQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSVFBQUFCR0NBWUFBQUFOWkR3WUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwQk9EY3hOakkzTWpOR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBCT0RjeE5qSTNNek5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa0U0TnpFMk1qY3dNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rRTROekUyTWpjeE0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K1FRakpVd0FBQ0JwSlJFRlVlTnJzblh0czAxVVV4MDkvdjdYMHNZMk5QV0F2MlJNSGlPQkFIaEpRMUJCaW9pRWpRRXhjb2hMSWdEOUlISWhHZEtDUU9HUWtBMkVMeEdDY2tTRHlra1NSSUZNV1RjWXpJQXRUOXlLTXpZMk53cmF1bzExYjc3bmRyN1JiMi9XeGtEN09ON25kOW50MFhlL25kODczbm51N242ejcyR2Y3QVdBdGtFSlp2YXkxc0hhTnRST3NuZnF5ck13d1lMYkF4OVdkRGdmS0dCQ1dZMS90QTdWY2dERVJNaEJsOU82Rmtpell5YUljNUNvMXFHTVNJQ0V0QTVLZVNnZEJFSXNxOXU3WnZhbXFZemdRUDM5VERsRmpCRkF4SU9SRVJFakJnR0tCQU16c1lZQjlOWmdzSUNpaklHUEdYRWllbUZuT2R1K015dC9TN0FERStlOHFZQ3dEUXEwUVFDRVFFS0VHQlcvc3djU2dNTEwyaUVIUlp6QkQ0cVRwa0pzM0YyUXlXWVlFUlFRK1lGREF5SUF3VUlRSXpTaUIzNWdGMXM4VzdHTUxSTWhrMFBudkRhaGp1eWJQblBjKys3SU9EeFBvTFF0dHlhVEdIZ1M4NEZrYnd5NTZ0VndHa1N3cmRQeHpIVnFiRzliMkhOLytFUUVSam5ESU1DTllNNEdTZVVhMENmVlgvMkFldzdTZFFhRWdJTUlSakVFb0ZJUFJRbWJVdzkybUJ0eTFnb0FJNDNBaERIcEhoS0t6cFFtM0xvMmdkeVo4MDRjZ3M5YWRSRWFHVHNzTFZMTW9Rb1E1RmRiMEFURFFyOE10U1FRRU1jR2hBSXNaZnlSVFNVUFN4NDJHbmFSaElpQklCQVNKZ0NBUkVLU1FCa0tNVHVHTlJFQnc1ZTZxNW0zQ1c3dmRRcE83NXlha2YzQWFJdk9XVSsvNm9JQXNYU3RTbmdQRDNXdGVuNWY4emk0UWxXclFaRTZGZHAxMlZGNExncVZLZjhhdjV6RDFkY1A5TTZVRWhDOGdwSzBwQlhsc0lqU1dGSGdGUlVMK05vaWVPb2QvcjJ1c0JVVmlCbXVyWFI2dmI3enMwZk5IVHBrSGNRdVgrdjIzRVJBK0NEdElWR3I0Vlo1YzhDazBmLzY2UitlTlcxSUVpVXNLYkQ5amhNRG05cXJ0NzRPV3I3ZEI3OVdqbENjQ09XVzBIdGtGRXd0TGVJZGlSNDkwWldGa3NJZkJHK25yLy9UcStObzFtVjRkajM1bk5LSkxXQU9CVjZ6MjBtS0lmZjRWaUYrMHdpVVFhQ0RSTTBocG9yK3RHZTRjS0hLYkJ2Q2NuTzIvOEFqMDRPSlpNSFhmcFpBUURLT005aU5iZVVpWHh5YkEyQVdyWFhhc0JFTjNiUTJIUVpVNXl5UFRpYzk5NzhkUzZ2MWdHV1hnbGR2MTJ6SFFOOTkwbXVPbC9YRXZMZU5mSDlhY2hNek5sZFlSUnU1c2FEMjQycW5Qa0FEcStPa1FSWWRnQWdKMTczaXhMUm9rdkZIa2RQLzljd2RzSGR0MnRBeFNDejdrcVVZUmQ5ckJrT0xRTVNsL3ZTMmFCSXZqSnlDR3BBVUVJV2IyWW43bHU0b2traDVXSHdTVDdvSE5rR0p4Q3FHd041M29NMW9QYmZUck5YbVZqMVZSQk1SbzFDTEdMU3B3QUFFN1VwbVU3cEVoYmFtTTRaRUNvWmhVVXNOOWlGU2J1TE8vMEs5VWdaVlNpaEJQTUNLTVg3bVZoM3hKUnUwOTZLejZub2Y0cVFjYVBhdGxkRFRaQUpKZzZMcHdFdjc3OWozS0I4RVdJYUtuemJPbUFqWUtRTE1vK1lpUmhCNEJLNHJSMCtiYklKQWlTL3VwY3IrS1QvZXJLa0YvKzVaL0pwbWxNZ0xDeDVFRjd3UTdzK2dLZ09pWmk1bDVuT0MwSW9rZ2RKNDd6SDJGdjhLNmhpL3pLaFFoUm5Ga01XSW50ZGV6MUZJeURJTHU2OVhRVzFzTityL1BVZXdQdFZIR1VLRXBGRlVhTVBYMThDdTI0MHdsaU9vbzd1VDc3OVJCNzEvbi9iNlMwZENPbmJQVUo0QzluUlYxVldNaElEelUwSWt1N0F6c3dKeGlsbWFZRWUxUVI3TnQvZ0dCbFU1djVrWHNVNXUzczZKb2RBTVJpS0JlUXFjWW4rMXd4VDBScjhNTUw2V01KeVQ3dW9HM25aUDZkakdJaFNWZS9iN0cwalV1L1ViZHhnVk9qYTBuczZ2dVprVTlIVDVUaEdEeUJnWmV1N0NyWUxxcVpyb0ZxcmVMWEdRZ1I0amJGWnRCMU1SNGx1OG5UaDZXczdXWGZnVmQzVVhQZ2VqcElBSUNHUWh2VEZicy9OTzJ0TkhmMnNUckVaSFp6MXFuem1rbU03eE1KZVp4cVNDRkMxMWFLeit4clo5SVcxZEJ2UnBPUUF5ZHZjUTVDcXcvNFBRM1NwcnBwTTl3aERnUWZFWDJoc00yR0hEaUMxZEpTY0l5ZGR2eGZUWW9jRVVWTG9vaEJiR0hjR29lbjM0VlloZXU1Qk5mOXRQaHp0WlA0cXlvU2RjTlNjczM4R054VVF5dXk5VFduT0dycXJ5cFpPTE1xMW5mTTJ5N01qVm54SFBkZlppSWdQQlNHT3BWMlMvd3lwOG1aNGJET2dqMENlZ1ozRTFsWTZUQXoxemdNbjZNRk9nck1LcGdRNUQwTFEyODFLMXZ1ZzZHdGxzdURhajlOTHkzQ3JhVjFnRUpCRWFDdEhkM09LMUZTQ0Rnd2xoUFJoQVlDYkRVamZNTHNRdnliV3NwRVM0TzJHQm51MXNuZ2ZBNHIzMW9ScXlYdURwWGVnMEVoQWZDaXFHK2RaWHR6VWFQMEZ0L0E3cXZuUFc1NW8vblljT29Fem45TmI0QVY1V2F4VHRGTXFTdTFGeGE0SE9sc3FINFpaZjdBcjFTR1ZBcG8vMkhuYUN0enVZZm9Cbk5XZ0krRjZZUysvVVJ6a1lobUdvd2Fram5PQk5PYUtFZkdYb01McUxwdWpEeWE1R0tiL2k3QWxIOHYrSC9mcmdDWWxVaWFPUUMvZlB6TUpQUlpBR2QwUXhhdlFsZWZMT1EvbUVJS1VqckVDUUNna1JBa0FnSUVnRkJJaUJJQkFTSmdDQUZsU3hER2dGQnN0M1RFMlFjQlFNQkVlWTA4QnU4c2hhaDFPQ1dOZ0lpakNPRG1kRmd3bWEyZ0NZMkhqZGZKaURDbUFpOEp6aE9idUd0bitOVE0zRHJTUUlpSEZuZ2FjSUNoc0g3Z0Z2a0traEp6OEpkUndtSU1EU1FDQU5HaHY0QjYwM2hzL0xtZ3lDS1c2THl0enlpKzNhR0FRU1BVNFNGcHdtTURBaERMNE1oY2RKMGpBN2xESVlkZUJnSHdqU1lTd3lpaGQ3QlVLMDEyRVVHVEJNWUdlSXlwMEJ1M2x3ODdBdnBlQTdFSTBhTG5zTmdCaU90bUFyUk5BRjhOSUV3Q01vb3lKazVCNUpaWkdDNzk3SG8wT1FBUkorUjM4UVREQ2Jyclg5SklRYUVUQUNGVWdQcXVIaElZcU9KbEl3c0VBU3hxR0x2bnQyYnFody84SXhBbEM5YnRYNHR2WFVoTFNOcnVDTDRDbXNuY0RTeHI2ek1ZRFFQdHdqL0N6QUFQc040WEZ6d0I2RUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WlluWTgS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQS9DQVlBQUFBeEJleUlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJORGc1UmtReE9UTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk5EZzVSa1F4UVROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pWRk5UWXlSamxGTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkwT0RsR1JERTRNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtDZ3NGRkFBQUMyUkpSRUZVZU5yc1hYbU1GR1VXZjlWZDNUUGRjL2NjTzhDZ0VEWVlpU0tDdWloS2dxNG9zT3N0bUpVVmhlZ0NpOUYvRkR6WUJCRUJFeVVpeTVKc0FBL0lMZ2hCM0lCWHNwcEJ3RVNRd3lFZ2Noa0c1bUttZS9xYW5yNXEzL3ZxcTVydW51Nlo2cG1lcnA2bFh1YWx1bzZ2NnF2Mys5NVozMVFKVFE4K0NIMGtFL0t0eUZPUWIwRWVqVHdNdVFBNUR3elNRcDNJUHVSTHlLZVJEeUYvZy93RGNsVExDVWFlTDR4YkYvdlFpUnJrdnlJL2lUemN3S1JmbE1mWmdYd2o4cU44KzBYa3JjaC9SNjVQVjh1MFVqbS93Rm5rSlFhWUEwckR1WXpQY3BtWFp4clFtY2lua0JjaVd3MTVaNDJzWE9ZaysxbVpBRlJFUTc0Qmw5dVFLd3o1NmtZayszOXpMSHAwazZLVWVwOGQ5MjBYQUdaSWhrQnpnaENMdnlDb05ZSnNNZjNwYUtnWVFhMGtNQTB4NWh5b015S3l4UlExQTRvTjFwc0IvbUNJTHplSnNDR01OQUhhS2NHZnNNR3podGh5SHRSbkVhdlozVFM0OFlFSDFKV1dpRkJaYnBaT21lUzh5S0FjSjR4dG5KZkNwakdUNndzYWsycG9zVWxhYVlBNXFQeHBXYVU1dWlMTzVFb3kwbkFoWkJwbEVXQ09zbTd3NEdERTdLbi9Edk9OaXRQUVVSZUtCRFMxaTRTK2xRSU4wbGRMUmNKTy9za0IvVjErSk04bVNFOFk0aG1jUk5nUmhpcWdmM01FSnBrRnFEWkVNMGdqWHNTT01HUUZCRFMzcHYwMTNudjE3cFQ5OGNmWjB2L0pKMm0xSzFtOEdEcVBINGZnOTk5RDFPbE1xMjNCTTgrQVpjUUlpTFMwZ0dmZHVsNlBMMTIyRENTL24xMHY4UG5uT1FWcXFVbjZQUzYrSVo5cHlUUEJlRDNMZThXTEZrSEJ2ZktZQ3A0K0RhRmp4elFQQXRzZGR6RHV2UHR1YUh2cHBiU3VTMkRtanhzSG9mcDY2TzMrYmRPbXNXTlpIOCtkZzF3cmh5S0dFK2lXeU9SYXJSZ1g2ZGtaNzlhdEVHbHJZNy9MWG54UlV4dFRXUmtVUFNvL1BveDJkRUQ3K3ZVRDJzZWltVFBaa3ZxWnJoWEpCbkVNclNJRFZKQjBmWkpDcHJKOTQwWndvSWFaSFE1bVJ0dFhyKzVad004OUJ5YWJqZjMyN053SmtmUG5CNngvaFdpYXFWL01YK0Z5eU83ZHllOERCNWJ2eXkvQnUzbHo5Z0dWTWJTYW1Kb0tZTmQ3aEhWKzl4MEVqaDZWVFNtYVVNdE5ONlUyTDNmZXlZNGhvallEcVRIVWo2S0hIdEptTlhDQUZkeDNINWhIanN5Ni9EaUdGcEVGU1pJazVvSlBjSzFaQTFVYk5qREJGRDd5Q0xSeGdCTk5iY204ZWFyNW96YVMxUC9lSnpzSFhVdHhBY3lzZi9oaGN2ODZjYUxxWDhsYWhOSEg2cEdQRXBhaWtwRHE0c2p2dWd0TVJVVngyMElYTDRKWVVRR2RkWFZnbXo0OXFmQVU4K2VycllXODIyK1BOM3NlRDNUdTI1ZFMyL0ltVE9nSzl5dGtUMk95MjZGdzdseDVrRFEyUXNmZXZiSS9mKzAxOVZwT2pJS1RuWmZ1UVFIVGYrQUErTFp2MTdYT29DdWc1VDFFcFNXelovY2VIYWN3aFpkVEFFcGdKbXREb0NuYktlTHRQSGlRZ1prM2VqVGIxcjVsUzFJd2FZQ1VMVm9rdXd5TXpsMnJWdWxlT0xxcVNuMlMxNnR0b0sxWUFaYWFtcmpCMWRzQXN3d2ZEa00vKzB4ZGIxbTZWSFA2bFVsaWdPcnRQNzFmZnczdDc3L2ZyM000M25nRGJOejBwYm9mTDVwRGI0eEpWTnFRVmpZdlhOZ1ZNYUxtbGIvNnFocEZhdzJJNGt5LzI2MkxYSTFpZkJJS29tWTF6WjhQUTNnUTVQNzBVL0R0MnRWVllYcjRZZFZFTjczd0FrUmRMdG1rb3o5M1lEczl5UUMwaDl5NHAzVjFPNEtaYnNseFFOTVhBN3IvTDhvSkh5cGx1QTlTaHRzazlrL1MwSGRKSjdtS1BLdldHVkVwczMzb3c3bE1wYVZnbXpvVjhtKzRBVm94UXUyeGY0bS9sZlZVMjY4MkgxcUVnaVRXaXloRkdmclJSM0VWSXExK01aZjg1MVVaRkZreFRiRlJkV2ZNbUxoY1V5RXFFUFFxdEtvcXRneTN0aG8rTkpaYTNuNjdXK21QSmZZTEZyQmxCeFhlRHg2TTIxZjI5Tk1zNTB1MmoybU14NVB5Zmh4TGxrREJwRW5kMjFDZGR1ZE84SC8xRlZ2UDUrVkUyazdYSWdCank1Q1dhNjlWOThkdEg5WDFGTkkyWlFxRXI3OGVnaWRQUW5nQW53VGxsSVlHa3BUVHhKZ25GWUc2T3ZEenVtb2kyT0htNW03N2VzMHZVYkFLb0FIVVJMRzhuREZwbW5mYk5yYmRqZ0FwMTFEelRteVRiQ0JZVWNNVGoxV29CSE5Wb25iTVg5MVhDNkRKS1ArMjI5VGY0Y3VYTTNwdVJRTnBTYjZ2WXZseUJtaWlocWVWcjNJdFRybmY1N3U2ZmFnMVJrT0RxS0daTGhZb210aVQxYmlZb3JoUE5PU0REK0lHZ2VlTEw4QzlhWk5SV0VoRnR2SGpaVERyNjNNdWdpeWVPMWNGMDdkL3Z4eWgzMzkvbkp2SUNVQnpaUlo0d2F4WnF2bnlmdnR0MG1NU0UvZFVUTE1HdEZ4VDYvbm91YWZpRi8wWWtMV3VXc1g4TVBXMy9PV1hRY0JVUjIvNWRXbW9rZ1RyeUpUN2xjWk0rbUwrTHRteHlSTCtKRnk5ZWpWVXZmTU9lM0tTOGppTjU2SnpWRHovdkpxcXRMMzdMdHZldG00ZDZ5c0ZSeFd2djY2L0hIUEY1Sm9jRHFoNjZ5MVZPMTA3ZGtDVXp3THM2L25vWFBtalI0TTRiRmkvK21hZk1RT3EzM3lUblkvQWExNjJUTzBiVFRXNXdoLzcwYldxRUdpVHc2Ry95WTFpMzNTTGFpZFBodW8xYTlnb1o2WVdmVk52Z1l1V01sNWZvOWJZUWVGNDVSV29VTklrMU16R3hZdTd6UmNLMU5aQzI4Y2ZxNkRTdmRBOVpac1VERm1VRzVJZ1lCV2dNSnNhYWNQa3ZmQ2VlNWdRRkNJd1cxZXU3TEV0Q1pZQ0U2cjBrUFlrSFNSangzWlZmakJTVGxWb29MbEVzVDVVTFVXaUx5OTk3REhWWXBDdmJFRXRUV1UxUERnQXd3ME56Q3hUMzZyUXAvcW5UZ1VuUnIvWm1qQkdHQ3FBU2dGSmNGb0ZLU3VBVnFKZzhxKzdMaTUzSTVCYzI3ZURiOCtlM29zRE5Ja01oY2I4Vm9xa1hzMDdNWGhKQktFY3RhNHdvVWdROWZ0VklJdW5UMWNqV1RLeGJreExhTTV3YjlTQm10cUFrWGtsZ2tsOXM0OGJCL2ExYXpVTjBvd1VhUkJEd3BKTXJ0UWVGUzVsU3p1cFhLZUF5WURjdFFzdXpabWpDVXlpVnZSVEpLU2U2cWdzcUtKSWxJS1h4QnMvZnJ6YnNUUWpnZjMyZWxVd3FYMERUZmpXQUtZNk1GRWJHK2JQWi9kRTUyVWx4WDY2RDYzRU1aUklReU9ORWRQcDRXSjBZall1VE1DSjFkWFFjZmd3QkpQTXUrM1ZWNkRHOVdmRWQrQ0FjbFhMLzJnWHBpbWJ1SzVvTWZXTmZHN0U3ZTVUMzFUaDRpRHdJS2ppTmRka3plUmVSZ3dKU3dJMGRLaFRQSFJMWHZpcGJHbXBLNDFSbjJsaWs3Tjd1TDRmVFdlbXJoUHBSNlNlTHYzWUtkSUxIME5rY29QL2RPY2Q5c3MyMktCQlNJUWRZdmdqWWNrQVJZZnFPaEUwN3pkRU16aUpzQ01NQ1V0bWNwSGRHOTE1dThaWGhLYVoyU3R3REJvc0ZNRS93bzR3WkNiM1JJMlRYclRyMlJldy9Gd1hGUGNaSWhwczJpbnVKK3dJUTRvWlRUeWg3a0J1WHU2MGIwSFY5Um12aXhrY1RGZ3RjOXFwVE5YTU1WUnJ1V1IyVzArR3pML3M4Rm4vWll6N3dVR0kxYlpUSVRPbEs2MGNReG5RdWhvbkFVNy95Vk8vMG1YZmV6UW9IakRFbGR0MERERkNyS2dhVTgreGsySTFsRUFONHFJRitkY0ZWd28zbmcyWlR4aGl5MDBpYk9ZalJvUVZ4eXlvN0V0OGZFWkZ6WXVlcUhCbTNwWEM5UmZDNWxPRytIS0x6b1hNSndrYndnamtqdzNFdlFnNURsRFUwZ2dWY21nUVhJbVlmcDdaVlBUZWthQjQwQkJqYmhCaDhVUnowVnJDQnVRUEREamx6Q1VHME1USTZhY2FaNGlyOFdtL0pKejVjM1BScGsyZWZDUDYxVG1hM1l3WUVCYUl5UzhnZitPbGhXTVZSMGxuL2VHQndSdnJ5NXI0K1lMdnR0dUN1LzNXazB0TC9YKzhPUzk4cThrb1BtU0ZvcWg5UnpyRkg1YTc3UDlCdjBuQnp3V3VtUVJtTUZrYjRXeVNGMU1vaEtCYWNFR1AvK2s3SWpSZHZHcXNOVHgwUVhGZ01nSjdjNEVnbFJoaXp6ejVKS0VkZ1R6eUQzZCs3ZkdnZUpubm1iOXluK21LMVV6RVNEdWd2QUZwSXozYXJ3VDVxMHBEQ0dSUkFQc01lM0RrNVB6UWIwZUlrWnB5azFSWmFKSktMSUprTlRSWXV3YUdKQ0hvalFydHJWR2hCWVBRK3RxQTVjd2V2L1Y4V0dMQkRzVXpEVHcxSVRmby8wbU9jNkRQZ01ZMHBJL0MwS3dHZWdMOEc3NHNSczRIK1lNeEltY0JkSHl6eWlBanhVMkdPWk1acGFra2JsNHNhT0pMYnlvVDJ3MVErOWduMCtrQUFVVm1tS1ljRkhGQWl6blFOZzZzR1l6L0RFOURTVm1VR3VTbE95OEhrOWpEdDRVZ2pmOG5FL3N3b29LY1Bkd01XRGxiT0ppR2hxYXZvUkVPbkNMYkVHajhPbUVpL1UrQUFRQkx5L0ZiT1E4TjVBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJleGNoYW5nZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWltZ1xcXCI+PGRpdiB2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCI+PGltZyB2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiLz48ZGl2IGNsYXNzPVxcXCJiYXJjb250ZW50XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiPjxpbWcgY2xhc3M9XFxcIm1vbmV5LWltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIgdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIvPjxkaXYgY2xhc3M9XFxcImJvbnVzLW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJvbnVzTW9uZXlcXFwiIHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCI+PC9kaXY+PGltZyBjbGFzcz1cXFwiZXhjaGFuZ2VcXFwiIHYtYmluZDpzcmM9XFxcImRvZXhjaGFuZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiZXhjaGFuZ2VCdG5cXFwiLz48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJjaGFuZ2UtYnV0dG9uXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJ1dHRvbkJhclxcXCI+PGRpdiBjbGFzcz1cXFwiYm9udXMtYnV0dG9uXFxcIj48aW1nIGNsYXNzPVxcXCJib251cy1idXR0b25cXFwiIHYtYmluZDpzcmM9XFxcImJvbnVzQnV0dG9uXFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwicHJpemUtYnV0dG9uXFxcIj48aW1nIGNsYXNzPVxcXCJwcml6ZS1idXR0b25cXFwiIHYtYmluZDpzcmM9XFxcInByaXplQnV0dG9uXFxcIi8+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxSZWNoYXJnZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTllMWQ4YjY2L1JlY2hhcmdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LnJlY2hhcmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYubXktbW9uZXkge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1zdWIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjI2YTMwO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NGQ1NzM2NjdcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUhBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxXQUFBO0NBQ0FcIixcImZpbGVcIjpcIlJlY2hhcmdlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXHJcXG4gICAgLy8tIOWFkeaNoiDllYbln44g5qih5p2/XFxyXFxuICAgIGltZy5yZWNoYXJnZS1yZWNvcmQodi1iaW5kOnNyYz1cXFwicmVjb3JkSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInJlY29yZEltZ1N0eWxlXFxcIilcXHJcXG4gICAgZGl2LnJlY2hhcmdlKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICBkaXYuYmFja2dyb3VuZC1pbWdcXHJcXG4gICAgICAgICAgICBkaXYodi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJhcmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5tb25leS1pbWcodi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIsdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVxcXCJpdGVtLnN1Yj9ib251c01vbmV5SGFzU3ViOmJvbnVzTW9uZXlcXFwiLHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tIOWJr+agh+mimFxcclxcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5LmJvbnVzLXN1Yih2LWlmPVxcXCJpdGVtLnN1YlxcXCIsdi1iaW5kOnN0eWxlPVxcXCJib251c1N1YlxcXCIsdi1odG1sPVxcXCJpdGVtLnN1YlxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcucmVjaGFyZ2Uodi1iaW5kOnNyYz1cXFwiZG9yZWNoYXJnZVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJyZWNoYXJnZUJ0blxcXCIpXFxyXFxuICAgIGRpdi5teS1tb25leSh2LWJpbmQ6c3R5bGU9XFxcImZvb3RlclxcXCIpIOaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nXSxcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuXFxyXFxuICAgIH0sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9leGNoYW5nZS1kYXRhJyksXFxyXFxuICAgICAgICAgICAgcmVjb3JkSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nJyksXFxyXFxuICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nJyksXFxyXFxuICAgICAgICAgICAgZG9yZWNoYXJnZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZycpLFxcclxcbiAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIHJlY29yZEltZ1N0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyOCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OTUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbW9uZXlibG9jaygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYnV0dG9uQmFyKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyNjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYmFyY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJvbnVzTW9uZXkoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBib251c01vbmV5SGFzU3ViKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYm9udXNTdWIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMS41ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4ICcgKyA2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbW9uZXlJbWcoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDExNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAtMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICByZWNoYXJnZUJ0bigpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM2NCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZm9vdGVyKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG5cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LnJlY2hhcmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYubXktbW9uZXkge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1zdWIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjI2YTMwO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cclxuICAgIGltZy5yZWNoYXJnZS1yZWNvcmQodi1iaW5kOnNyYz1cInJlY29yZEltZ1wiLHYtYmluZDpzdHlsZT1cInJlY29yZEltZ1N0eWxlXCIpXHJcbiAgICBkaXYucmVjaGFyZ2Uodi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxyXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xyXG4gICAgICAgICAgICBkaXYodi1mb3I9XCJpdGVtIGluIG1vbmV5RGF0YVwiLHYtYmluZDpzdHlsZT1cIm1vbmV5YmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVwibW9uZXlCYWNrXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XCJiYXJjb250ZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XCJtb25leUltZ1wiLHYtYmluZDpzcmM9XCJpdGVtLmdvb2RzaW1nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVwiLHYtaHRtbD1cIml0ZW0uZ29vZG5hbWVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tIOWJr+agh+mimFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5ib251cy1tb25leS5ib251cy1zdWIodi1pZj1cIml0ZW0uc3ViXCIsdi1iaW5kOnN0eWxlPVwiYm9udXNTdWJcIix2LWh0bWw9XCJpdGVtLnN1YlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5yZWNoYXJnZSh2LWJpbmQ6c3JjPVwiZG9yZWNoYXJnZVwiLHYtYmluZDpzdHlsZT1cInJlY2hhcmdlQnRuXCIpXHJcbiAgICBkaXYubXktbW9uZXkodi1iaW5kOnN0eWxlPVwiZm9vdGVyXCIpIOaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXHJcbiAgICByZWFkeSgpIHtcclxuXHJcbiAgICB9LFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvZXhjaGFuZ2UtZGF0YScpLFxyXG4gICAgICAgICAgICByZWNvcmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmcnKSxcclxuICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nJyksXHJcbiAgICAgICAgICAgIGRvcmVjaGFyZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvC5wbmcnKSxcclxuICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHJlY29yZEltZ1N0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OTUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb25leWJsb2NrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnV0dG9uQmFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJhcmNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvbnVzTW9uZXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9udXNNb25leUhhc1N1YigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib251c1N1YigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxLjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggJyArIDYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9uZXlJbWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDBweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVjaGFyZ2VCdG4oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzY0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb290ZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogMTM2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogNzEwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG5cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYucmVjaGFyZ2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcucmVjaGFyZ2Uge1xyXG4gICAgei1pbmRleDogMztcclxufVxyXG5cclxuZGl2Lm15LW1vbmV5IHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbn1cclxuXHJcbmRpdi5iYXJjb250ZW50IHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5pbWcubW9uZXktaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG59XHJcblxyXG5kaXYuYm9udXMtbW9uZXkge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG5kaXYuYm9udXMtc3ViIHtcclxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XHJcbn1cclxuXHJcbi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuZGl2LmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBhZGRpbmc6IDElO1xyXG59XHJcblxyXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB3aWR0aDogNTAlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFJlY2hhcmdlLnZ1ZT80ZDU3MzY2N1xuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGdvb2RuYW1lOiAnNTAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogNTAwLFxyXG4gICAgICAgIHN1YjogJycsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMC5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICcxMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogMTAwMCxcclxuICAgICAgICBzdWI6ICcnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzIwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAyMDAwLFxyXG4gICAgICAgIHN1YjogJysxODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8yMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiA1MDAwLFxyXG4gICAgICAgIHN1YjogJys4ODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzEwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogMTAwMDAsXHJcbiAgICAgICAgc3ViOiAnKzI4ODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwMC5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2V4Y2hhbmdlLWRhdGEuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTXpnMFJqZzNPVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJNemcwUmpnM1FUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpRd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZek9EUkdPRGM0TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrM1EvOUtRQUFFajlKUkVGVWVOcnNuSHVNWE5WOXg3L252dWJPWTJmZlQ5dHJHOVlQY0luQk1ZOGFremFRSWtJTFVWWFJKRzFwMWZ6UlZnbi9KS21hL3lyMWpmTlAycXFKcXFocVVLcW1rVWlhSm1sVUpTQklLNEpGd0FFTXh2WmllMjN2ZXRmN252ZWQrenFudjNQdmpCa21NN3RySUI1am41OTFkR2ZtUHViTy9kenY3M1d1bHdraG9PemFNVTFkQWdWVW1RS3FUQUZWcG9BcVUwQVZVR1VLcURJRlZKa0Nxa3dCVlVDVkthREtGRkJsQ3FneUJWUUJWYWFBS2xOQWxTbWd5aFJRQlZTWkFxcE1BVldtZ0NwVFFCVlFaUXFvTWdWVW1RS3FUQUZWUUpVcG9Nb1VVR1VLcURJRlZBRlZwb0FxVTBDVkthREtGRkFGVk5uNzBJeE9mdm1CN1NOdlB4a2RLRllaU2xVTk9xUDNUS0FudzdGVTBOQ1ZFdkE4Z1Z1MmN6Z2V5LzdhbmNIRXhTVTIzcFhGbGwrNVM0eG9ZTjFuWmxqUFVKL0lKSHJzaEVobE5XYW1ndFdjcUNTejVzckVqbVJ4YXJLMDhzd3orYk8zMzJUTm5UeVdQeDJXblBNTGMxVzhjZHpGYi85bUZ3YjZkWnk3b0dOaUlvWGhZUWF1Ry9pdjcweWo0akFjK3AreUF2cU8zUWJCNUFLWVdkV3hYR0xZUE1DMzNMUEhQM2p6dUhkd3g3WmcvN1poTm1GM0czM0RCQUJnY0FJZENjdkF2cjBldlU4QW1RRmFKR1AvUTI5QngzTEtaWXplbGNEQkI4ZUEwTVFkaFhIZjF2VUxyNzJVZS9HV244NGZNYXI1SHhjV2lpK3N6T2tJeG0wd3pWQUtmYmZHV0R5bWwzV1lHaEwzNzNVZStZMzl6aWNPN0tyY3YzMkxiaHA5YVlUVkpGelBoT2ZxV0x4SXA4OFpkRktTWjNBZ1BRcTlleFJzbFVQVGRlaXBMb2dpYlJMNEVEeEVhY1dET08rQkdRRzYwcTdKYkd5NzY0SDB0cnNldlAwUlFNZmNLOU9uK2c4dmZGY3JPbCt2TEphT212M3ArSVFVMEhjRzB3c1lwaFlOM0wzVC9keWZQbFQ4N0wwM081dk5McUNNUWN5VlRQQlZ3Q1EzYk9nYUFTUHhKUVJCbzUrZ2NlaVpMaGlqNDlCSm1TeVpCSGNDVkJZWElaaUY5TmdJdEs0TWJTZC9yZ25oQmdoSXNXNXVCWVdmekNQa0oyQVA2Qmk5ZGZmRTZLMDNmOTdQelh4KzlVMzMzOCs5ZE9xdmMvT1ZFMVkyL2I0QnlqcjU1MVgzYnhxTWxpTDZweVB2R09PZi9PWHlrMy8rVy9rN3RCQ1k5ZExnM1Z0SVpVV3djaEdtR1lKckZGOFRGcEpaQzM1SXI4blZHcnFBMmQwSHZXZVlRRG5rWGgxeTJWWGFyb3pFNEkzMFdSclpMVm13UkI5OUdSM1lzTUFzaSs0SU83cW5nNFZGNUNlUG9yUjRCcjIzanlPN2ZZSStEK0dzMkhqeThXZisrTG1uMy96cVYzOG1GTkQxN0o3eFpCd3pDVklGdmFNUDdpMGUvWXVIQ3dQbmw0R3Fua1p5MHdTY2M5T3cvRlVZbVRTTXBBblg1OGl0dUpRc0dlZ2RTU0UwR0tuUUlMZExUak5yb3hxUUJsTW0wcHQ2WWZSMUF3UysrRHFCOURneVcvdmpIMDMrUE5xQjFZSzF6TWJTNU1aUG5jYlpwNTdDMEgwNzBiTmpzN3c2dFBXTitQSm52dm5aejN6NTlOOHJvT3ZZb1QvN2RKVFVWSDBkWjQvOTZJblAzWDN5RDRiSXhTN21pY1B1UGZBV2M5QldMa0R2U3BPTHBUelcwR0RUaGVlVU5aWHpQaXpKb1NjQnU4ZENTSEFxZEJ4N3FKdFlNUVRWa09JbWcxK3QwTEZ1SmcrUXBSdUhnK21rVHQyRzBFejZaak0rcms3eGw1RnlNeHFxcjU3Q2hhTXZZTnZIN3lTZlFaOG5iOERzc1RMRzl2ekwreUtZZGpTR2Z1R0xYNG1XUG8yLy9NTVA3YXdXVHFKQ1dha2hjeDFCc2E1YWhtN3JxTjkwVVp5VlN1dE9Jckhad3RTeEZZcC9ERjFETmdKeXY4VlpGekxpbHVkTHBNWmVNRC9BMGlzTDZOclpoOFJZQ0JJNmdVMVJrc1RKOHlacDZERHNrTlN2UjVrd0toN3M0UjVpeXhDV0M1UmdEVWJIeS9TbFZHUGhjc3lrc2UvZ3dlT0hYd2Q2S2JRRjVEWlpkUW5HMENaNDVaQk9Nb3hveW44eUdWcGVMR0h1K0NvMkRTY3h0TVZHdWVpRFYxME03YlJnZERHTTNya1pmVGYySVRuYWk1MmYrZ0EwY3hkS0p3aE9NQTRXak5FeGVtR2wwN0Q3TllKSjMwNEFZZEV5bmNUc2M2L0NHRW5DR3RoRW54Zm96TVl3KytxVUFyb1JlL2pPdlhqbzlsL0NweDc5QXJUU2kvM2p2OXFMbjB3YUdLQ2tNcGlmZ1l5c3hyWmRCSmhVNmpwUjJLczZsS3dVQWd6UVJUY3BQaFlxcEhES2pqa1ZuSXgxUXdRSmxCZkxsT0NzSWpsc1FPc1pSSG02Q3NPc3dzd2tZS1E0eFdJamN0K1JneklwTWVycFFaaDNNUGU5cCtFbWN0aDA3MjIwanR5dGZSTzhtUk9ZZi82SFhHVzVHN0NkYVlaVnh6YjJkRmUvOWZpbjhiRzdIdDJPWjE4TUVVd3VZMHlVMFo4bFR6ZzhCSmVUeTNPcjBNaUZtaFFIRTExR2xOaG9NbHMxQ1JwZGZMTnZrTXFXRzBoVkFhcjVDa0dYQmVneXRNd3dyT1FnTXB0NzZmWk54ZjVjTmgxMFVtVFZoME1aYm1YK0xOejhOTXhoQzRNZmxEQXB4bGJ6S0o2YVFmbncvK0xFR3loKytFc2lxMkxvT2paSzllR0JVZjc5UXc5WEg4Z0xDL25URGo2OFg4ZTVMWU5ZT05jRlAxZUNOYjFBR1MxRFlxQVhoQk9oYjhDaDJLZHpLbGtvYnNwK2dxQXNWU3Zrb1NXWHdESjlTUFgzSWIxMUszZzVnRnR5eUxXU2NqMHFUK2ltQ0gyUGxsVFdlRVZTZm9rZ1YyQ1AyZWkvZXgrZFVSck84Z3pjcFZsVUowK2pjREtQaEVmM2lKYXNxTWJDQnV5bU8rLzkwQUh6eVFleWxBZ2RuOVBSU3drT24vV3cxZkt4ZFc4Q2M4VitsSEpabEVvdXltVnl2NVNnR0FRdkxlTWRLWTFScGtxQ2hVNUtEYndxL09rM3dicEhLQjRtbzNwVGRvczBxbG1MTTdOVXcvTG8xNGFVeldwcEhkWUk3WnZPUmdvT0tpNXlreWRRdVhBZTFkbEZCRXVVTkJGclRqZVBsdVl5eERyWFBkRFIwZEYxdC9uS1AvM3o2TGtudm9Fd2pQdXRrSzAvaXlLbkk4QUtWUXdsQkVZSERaUUdiRXBBN2FnNXp5bGpjc2oxQ2lLWlpBNENxbUdGNFVNVHBHSWVVS2xSQWs5UUFwVHVJcGRNUUdpZGpMMmVyRmZwaFMwN1MyNkFBcW1melV5aHNyQ01jS1ZBK1E4QnB5UlplT1RBWGJwaE5EcUhoQ3hYaFR3M3ZwSGZzeEdibTV1N2RoWDYwUWZ1dVBoWC93cWNtYVhzMXZhUUt3Z01qaEJWUnhiN0RLNnNaNVlDTU80alMxQzBCSzFMNmFpRVp0UVBrTU1MaFV3RXFNWWs5Y200U01vVXVYbUljbDVLbHhSTXRTZUI5dWxnWHRtbkxOZURRVGVFWCthSWttZVNINmY2VlFRR2xVQ0lRR3BXZkd5ZHhmbEZvYXBQS1plN0FUdjJnMzlZZXVEaExodzdaMklpdndKL01vZjViQytHQnpWNHBCaGYxdnR5SG8xZ0JYVHhSWm1rUW5BWlhXM1pHcFFYUEZFcklZa2JwVWEwbnVBS0NTWW9nSlAwWmFjdmpNRFJ0b0lLSU1xSWZkK0tkcEw1b053bjZnaVpVVXM0K2t6dW41U3pOSlJSSHptTk55ODYxbU9xYk5tQWZmc2ZEeFgzakdUOGovNWVEM0s3UjZnRUNmSGFVOHM0KzRaSHRhT0dkRmFMeXNPb1JjUGlzNDBBeDVPbFVjZUl4RWFBaUI4bEx3RkZ1ckEyQWxkSDZNa2tpdFRNRFFJdEZVanVtYVNzV1ZUUnl1UEtvZGVPalhqYUxtRVNlRU5nYVlWanh0NktxZFN1SC83dDA5WkpwZEFOV05kZ2QzbjZnbC9adTUxMzMzZTNoYW1kWXlpZEwrSGtsSXZUVXdGR1NLbkRJenFWaVl4eUlFWlpxWWpneVlGYTJLM0RpR0RqclZqOHRpRnEyOWJYaTlvcUtYNkNSNWdqZDF0eU5Dd1ZEWXJWUUg3UlEvcVdBWHpzZCs5KzdPTENkeTU4N1ZuL1VOUHBDd1cwcVFiT09VeEdNZ2N1Ni9hWEhOeElnVEs4TllVdHU1SlluUGV4ZERIRXdubTY2R2NGTWhaSG10eGdTczVmcHdWTTJSTXdhcnhFemVYeTJGM1dsOUVJNjI0MDhxL1J2RTdnTTVrWDBXQ29lanBjTCs1T2hUVTMzcHNNa0IzZ21DOFhLVk11NFA2UDMvNTNYM3YyK1M4MndXUlhJOXhPQVkwdXh0ZGZ0YjFQUEJUSUhqbTRyc0VwMG5YSk9jaVNTK3diMVRDeHhVVEZaVmpPY1JSb1hhNGlVS1lMZm1GRlVBMHFZSnNpbXVEbWdaeDhpK01IYTFBaHI4WEpDTGpRSXhXR2dZamhTOUF5b1lvbTd1bzNESWVweFlxZHA1ektEeE9vbENvd1UxWTlQTFVDMXdoWFhHOUFXZlByY3pQaXBkdEMvTHBOcGFORDVUc2oxK3FSV3FxTDhvb0hVYmpjVEtwa0JGakdQSTlnbEt1a01Db3haR08rV2hYdy9Kb1NKVEFlUzFiUWZTSS9RMWp6dDBUWEpPb1NHRVZVV0hMSmVFeUoxZ1dVN2NyRXk2TmoybjZJQW1XOWllRUV1ZVIrTEU2K0prOVZmK3RXdVRTdU9yQkdCMkEyTHRrTHI0YVA5ZmZnZy9mY2E0eWtaSysyUkRCWW5QeElaVWtlRHBVeG9oeEdTcFNmR1JEUkEyVHlFTjIwMUpJaXZzSlJoaHRudVpFQ3BScERFZTBYTGVYUTRtUEs5ZktHQ0dwWnJUeXVSZkdVRjBLY3VranY3OTJMemZ2Mm9mRDZKSXJIRHRNV2cwYmM0TDBFazc4OUt2OGNXSEU5S1pUVlBlUVRMOXNYVjhydWdlVVYvMXY3YnRYM0RmUlNuRXhSOXVxS0tMYTl0VFZscGtiTmxUYkd5Rlp4azcvbGF1UFhyT0YxRFh6dDBMcWM2MllocW5rZXpjTldoMGFRZmZRMjlHL3ZSdTZWSTZqKzdBZ01qMVZxMTZvT2t0Zk92eGx3STh5T1FEVTY1R3ExeHZHOXljVHlqazN1djkyMEcvdk9UTWZxeTZRcEM2YVJzdU1kb3FRbHFOV2pqVWRpRFVkc05ONndUVzBIMlh5SUhrUWorckpHZFVzY3BTb2xSMVlhYkhnVTVoMUQ2TDJoQzdaWXdzcFQvNGZpcVRKcytjU0trWkN0UDZzQlpxdlJyTmFPUURXdXNDcWJZZXIxUVdXSnVXdUhUb21Jd013MFI1NWM3Mm9SVVlKaTFHS2ZyQTl0MmNiVjR1c201MGFaSHJ2WjZJcldmSFNVOUVRM1FJaEF3Z3VrZ3VWenZTeDZ4dGJWYk9rR3dFYlNFTjBwcElkUzZCa2lZdDVGckI3NUtSYlBCMUZOYTRVRzBpbUtzMFVROXVpQlVQazFZVzAwdnE3L3RrYTRIWUhhQ1pkYkgzV1k4aHdNeDRXb1VCYWJvdVJvMjFZdGF0NlVxS2dwbEFtQ1ZGRW9HemNFeTQrVEdObnVrNHJsUGwxd0ZpYytnU2RxZldFWmgrVWpLL0w1V2swbXd2RGwrMTRMbWUwU0VuMnRyYU92aC9aMVZ5Rld6cUQwWEFVbE9lTkdaWXpobW5TSDBURk1XU1pSRnF4RjkyUXowS0RoeHF4LzF1Z2ZybG1GdG5LTzlTckRxQTF6YWhHVHVUd0JIYVR5WlRIcTQwVVo3bUEzYmRoTEFNbFgraktybFowaG1jeklYcnJzRUhFOTZyOUtjVlk5UkFxUHZvUjIxaTBkQ1pOQlB1QVhQZlhBSzBnYUlVSDA0TXk0Y0NmRHFCa2Z5cTVTWUVWbGpqeVdtWXhqc3F4SlpZeGRyUmpUa0pPa1B3OHphUGhkV0VPWlZ3eXNjWVZqWjF1RmZ2KzRkWHpQZjN2ZitLUGZOMzRuTlVCdWNWbEVjVk8yOXVxTmdVaVpOQ3dhVWk0WnVxU2FXYzl3NmJWOGZKYlZzMXhPa0doUWh1eVRjb1ZzREF2NUlCbFJrSjBtK2N5U0hISnZQVzd1czRhRUsyWEpQakhIMFJuYi9lNVIrMHMxaFRZclUyc3FWWnBMR242bHk1aE9OQlpheGRFSTZ1TS9zZzdseTI3aGt3L3BmN0pqRjZtTHRnd3BsbGJkdDJlNzlXYThiQXdJcndZOGpPTmt2V3lKQjRzSDRnWkV0RjF0TmlYcUhOVnkwL3BERy9Ka2JIS3g4bUh1ZklYaCtUY3pKNy81c3YwM0wwM3JzN1drS0d3QnN4a2tiNkhZSzZiU1g5Z2pLTFg1dytZeXBhNUtzMkZZVGNQWVB4YnNlbkMvZU9UZ2Jld2oyOGRaS3BPdGxTc2VqOXQwWGkzeHFRT3NseVRSYS9IVzZ6cGMwZnc2bG5Ua0poaVBYQ3VqNGJvTUt5V0dVL1BXMmVkUFcvLzVIeTliUDJpSWgyR1R5L1ZydzJ0YStyWDFZVU9TZENuei9VWFBoM1lDNktXNDJRS20xYkRlR092aVBmZnREdTdaTzhFTzNMZ1p1OGVHMEpmTnlLbXRPTFpwTW5hR0lpcGxvZ1FweW5ERkpiV2lCckV1UXhZMTVlUEVLZkJGRklQTGxQVVdTSTBYVnZRenB4YU1WMTZlTmc3LytMVHhXb3Y2Y2kyZ2phTVJhSGc5QU5YWEFGcFhiUjFxZlIvV1pZbmtCOGJDR3lhRytZNlJYckZscEpkdEd1Z1JveGxiWkpJMk1wWkJpYW1NaFN4V25vUVo5VzRsdk5vc0RXWFNUc2xCcVZEUjhvc0ZkbjZweUJhbWx2V1Q1MWEwNlRmbUk3Y3Eyc1REeG5vejJDRFE0SG9BcWpVQk5SdEFOZ1BWRzRiV0lxbGlMZHFKYVBOK0xXdlZrMjFPYkVSVDdWbUgxZ3FtMTBtRlhzbWtxTjBkSHphVkFLMjJiVXhDdEJiTkNyYldCTUFHWVlvMjV5cWF6clVSTEYrallYOU45bkpGbXhwTk5IVlltdGZWTDZEZTNDWnNxbWVid1Y0dTBIWWcwZWJtNHczcUMxcTQxdVlrNkpwdHpvc1dIVmJXQUxYNTRobTFkWHFUcTJZdGxNcmF6T1MwYzhXaXpibXRGVCtiWFc3UVl0VFYyMUhGR2xjSUptdHgxNi9samh0aHRsT3B0a1k4WmU5QW9jM3E1R3NBYlFlMW5TdStKcWZQR3R0aHpRMXMzc0xOdGxPbnRrNlMxQXJzUm1KN0szVzJjcmxoaXhJbWJLUFFhOXJsTnJzNzN1YmloUzA2U1d3TmRXb2JWQ2hiSnhscWw5M3lGb2tSYjZGWTNpS09pbXU1OWRjTXRka1Y4eVpnMm1XQVhFK2RiSVB1VnJRSkFhMlV5dHRBNUozTWRxOTBMN2ZWakQ3SDJ4NjR2RFN2MkFyYWVxNzJuV1M2WWgzWHk5dkFiYlhzaUNvNzNaeHY1WDVGbTlxU3I2UEFkNnJNOWNxVzlXSXExcWhCTzFxTGR1b3hUckZPR2RFdUhyWXJVVnBCWEt0N3RGN3BzaDVjckZPYVhCZFAvVjB1MkZad3NRRjQ3YWF1TnRyMlc2cyt4UWJxeTQ0K20zdTEvT0Vwc1VieDM4cEZyd1dRdlVmbnNaYmlyaXFJVnlQUXRTN09lbTVaWElZaUwrZDcxMXVuL20vTGV3aDRvd0RZdXdSNTFRTjhQd0s5M0F2N2J2NFRrY0Q3M0F4Y2V5WndIVnRILzZ5TnN2ZmUxSjhvVjBDVkthREtGRkJsQ3FneUJWUUJWYWFBS2xOQWxTbWd5aFJRQlZTWkFxcE1BVldtZ0NxN1pQOHZ3QUJ5TkVyUFBSOFBwd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpSVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZelJqUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpORE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pSRFFUTkdOak5FTkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrWjRnMmN3QUFHSWhKUkVGVWVOcnNYUXVNWEZkNS9zNjlkMmJ1dlBmaGZkcnJSeHpIem9Na0RpRXZRb0NrSkU2QlFBTWswTkpXZ1pRV1FkV0tGbEdwVlYrb2FrR2xWVkVGbGRxR1VCQlZCRUVxbEZaUUdzb2pJYzA3VHB6RVRteXZ2YnZlMSt6TzdEenYrL1E3ZDJhVDhUQzdkaHJpM1hqdmtZN25kZWZPN1BuTzkvM2YvNTh6MTBKS2lhaWRQVTJMaGlBQ05Hb1JvRkdMQUkxYUJHalVJa0FqUUtNV0FScTFDTkNvUllCR0xRSTBBalJxRWFCUml3Q05XZ1JvMUNKQUkwQ2pGZ0VhdFFqUXFFV0FSaTBDTkFJMGFoR2dVWXNBalZvRWFOUWlRQ05Bb3hZQkdyVUkwS2hGZ0VZdEFqUUNOR29Sb0ZHTEFJM2F6NmtaWjlNZk16SXk4bklPRngyUFgvRzFDYWFucHlOQXoyQVRwL25jenczZ0NOQlhIMGh4R3VESzF6S3d4Z1lCVTNUcG5jREtqcjc4bkhndGdXcHNJREMxdGx1dEE5aDJJSU5XN3didSt2K2oxOU4xaWo1NVV3cTl2UUszdkdNekF0ZkgxSlRFNFJjcTJERUd6TTY0K1BxL2xYSFZWVm5FOG9uY3p0MDk1eVJ5NXJiakJYLzBMVy9Oai9YMngzTUhuNjFsNHdoNlRETXdwVjNYVUMzTFVzR3g2cTVXM1Q0Y1ZDWUxLUC93UVcwbW5RaG1aNWEweWYzait2SHhrbGpxQU5OdjllWDczWmdibWFLWHp5MkpSdG5CNG9rcXRnN0Zod1ozOXJ6cFkzKzI0OXFkbHcvczNYRmUvSFZXMWVydHlYRzhwUTkzMFlkMExJeTlPUUY0Zk1yaHVBY3BCUFVFZTRHVHcwT2ptc0MyUVE5dnZNZ0hEOFhNZ2dldllWZWVIUThPSHAzVzl4K2NqRDN5eERIamdVVlBUQ0E4UzlqUndkaDFMNy9yaTZIN1V1akpBemRmM3dldkt1Rm44N2ZIQjFJZnVQQzZzVjh3KzNOcG9BUXNsdUVVSkVFeTRGb3h5Q0FHWFl2RGlNZWgvaFJOMDZFWkd0eHFHUjZCZEwwQVhtRUNkclVLeXhhd3lYdy84Q0hZb2Z0SW1oTENjT0dWRzVpZThlMkhYa2cvNFRudS9DVVhad1ozMzNUYnVRMnJ1RFJ4WVB6TFAzbGsraS91L203ZC84TmJBL25GZTRCa1VzRFF1LzhkRDQ3UFJJQ3E5cnR2alNNdVhYejR0Ni80NE1pbHc1L0s3Y3hlQlBUQUxiMkFwYWRuQ1Y0RzhmUVFFajJEU09SeUVBUVJCc25qazB4dURYYWhqTWJDSEtUbndPenBnNUZPd1BOOFdPVUs2dU12b0ZGM1lkc0IyZXFpWVVsNHZvUkZOanN1VHlFRDlPYzliQnR5RWNzSzlGMTlFNUpqWXkzVnRXRk5sSjZwN1gvNEhSZmRXUnZ2OTZRMFRheExRTmVWNURvMUYrLzduUnZ1MmYyZTNiY0J0WEFncDM1d0gwUlJRLzdjaTVIZXVRc3dLYXRPZ3k4NUJLNEc0WERBWXpxczZWbFlGUmZKVVJ1MXlWbFVwdWZodXhxRW9PeHl6dFlhUHVwMUI5VmFRTlpTenEwQXBhTEQxeVN1ZW9PQnNXRWdZWkRCVGgzVm9Xc0k1aWpRZUFxSVo4bmtHTXl4MUFWbWJ1L0RuM3piLzF6eXQvL3FUYVUzbSt0U2ZkZVVvZGZzR0Q3cDhaLyt3Wjd2M3ZpYmI3NFIvbVBVeml5bS92dFJCRE02eHQ2emp3T2JBc2lzWnJHU0lIbzZBdHRYSVpSUzY2QTJWVWRxMUNFcmo4T2RDd2lVZzlMeEl1T3dUVkFEVkJZSUtGbnBrSkh6c3c2S1JROE9UM2JMalRGczNpMWd6UkJvQmJxUVNGOTJIVEpiYytIbjJDY200VlFkWkxmenU4YUhNZm40ODgrLzRSZWYyWjJzQjNKVGp3Z25TMmQ3NUhqRTBMQzk5YmE5TndMMEpDS0QrdFFFcktObDdIejMyMmxKS0t0VnhWZ2R2b3F0VHNDNFY0ZlFiRWhSSmFJMmNoY1pxQjZjd015OWg5SDd1aEZLcndVdEpoZ3ZUVlFLTlNTeU1RamJ3NGtUZGRRY0FaRlBvMGU0Mkx4TlEyT1djZFpWQWRpRGtlOURJcE1JdjAvcHlVTlllbUtLY3ltTDhqTno2THVtaGkxN2QrKzY2NDltLytuakgzLyt3LzFiOHB3U2NsM3hkRjBWNSt0VkZhOWlKQWE1aytDZ2tsbW8yWHpxNUs4cGRKMWdObE5JSVdLaDhnV1dUbVUwWWZhYVNQUW1FYzhsbEVPQ25tU2c0N0VxVGxxZWlwWEtHQW1VcXdHMmpqYW5kTkR5c1VKblhLVzhHcmtrSlh3UzVmMEZqRjEzUFViMjNZRGU3WmVnOU1CeDJQTkhjUFBIOW43b3p0c3pOOHhPV1loejBsRHhUK29Sb0NFd3dORWYvSWozQmpuSUF1YkFJTEtYanVISTkzK0VvRkFCOHZrd2x1a1pBekZLblpGTVE5UDcrQWNNRTdldHFENmZnNUhkamkyM1g0RGtwZ3p5NXpEMjBZa0dubzFVWGtPbGFLTmFEMEtqNUFjQ2l3VWJJNE9pbVp5MHlndVN3SnNtSnd0QmJreVUwSGZlQmRDMnFJSi9BcW1MOW1EdzhodFFlbWlLNEZmeGtVKy80ZTZFOEZBc3VaVHhBSTc5VXQrd2dEbzBOS3JiRHZORVc2Snk0RW1VZi9KTmdrQlFrZUVBWG9MOGxjT1lldkNIS04zL0VMeUtRMVBFMkpZZ1dFYU02WWxLT1R6b3FUak0vQkxxMHlYVWo5b29IcHBHNFZBZFhpMUQxZzBoU0c2R1NLVGgrRHFxRGFZMGZLK2VOcEZLS1VEbGk5N0dKeFp4VGhqcFVNYTlPTkpqMjJtK09FUUJhVmZuNXd3Tm9uZjN0U2o5OURqNmQvVnUrZlU3Ti8vRzRoemxQcXNoblJZdjlnMWJXRWpxMWVhc29qVFcwVHZpZTNGWmZPQVpVWms5Z2Q2OUY5Q0RES1AvZFZld0w2QzAveWhLaCsrSE50N0RRZC9Fbm0reU5KRU05VEl4c2dWYWZBbTFlY25VSm92VVNDOThoVVBWZ2pPN1FOVVYvQnlEVXExY0xobElKaVZpclpKQmk2UUJIWTZ2SjlTTDZ0dEJwSHNJZGdESjNKWDJrY2RRWXJkdmdiVTRCeFNuOGQ2UDdmcVRyMzVsOWg4bnBnT2trdXREN05ZVTBIZTgvNDV3S0MxWHgvaUI3LzBsWWdWcXBJYnlnUklsN3dIRXRxUmhiaGxBWm13YjhoZnZKSE5kZUtVeS9QSTBQSHNhVHBtbXg5WVp0MVFjcGVzVk9oTEpKSTlqN2prL3gvTXlQV2s0cUo4NEFac3BpME9DVzNUR3JnS090TlIwNENTVHJ4NFlCdE1kSHdZWnJTUmVwVTZCby9HNUFQRmVOUk9xeUoxM1BxclAzWTlOVjJIempiY00zLzdsTDgzY3MrdThaRE1XYjJSQVAvWFpMNFMzOUN2NDh6dXVPeThJeHFISENiRm53QzJUTWMvWDRCeXJvWm9kUjZ5UFJtZXdIK2JJSUpLRFBaUlBEUW1oeW5nRTJXcVFSUUYwcHdVS1dhaVpIbUpPRFc1bGdVLzVWRkE2NUJnZHFTRkQ1dHBDSGFxZHROU2lhYXI2dzVUSFV5NDZFWm9wRldORlhMR1VqdHFtVTZZSlVybXdTTkpSRlNmeEt4OGUvZjF2M2p0M1Q5M2h4SXBGcXkxaFUrTncyYlhYUGx0LzR1R3JZeHFsalFNZW10Y2dSdmVxYXJOOFhMSGhUVTZpWmt4Q1N5dWZRcVBTbDRLZk5BbFNBbVpHRFRZbkFobnVhV3FTV1BCRUJVNkdYTlExQkVzU3hBUmVndmVKcHFUeDhoazBoZmFTS1ZLQUJwYkRWTWdQNzRlVGc1S3JxS2ZGYXZBOWs0Q25JZXNWcElaSE9kbE9ZT2VGNHZKTDl1WXVldmpSK3RPREE4YkdCdlNXS3kvaGVQa1kyUE4ydk92eXgvckxLUk16WlI5RGVROFZTcW55SWd4N0hHOE92bVQ4WS80SUowdzc2WWtvcDNTL3VsRm01OU04dHFIek9HV1gyY2xYZ2hxSFJVY2JNRjdHNmpRdWZHL05GNGd6YllsN3FpcUVrMVpFRmJiVnNvTmtRcjJiUUhvcXoySDg5RldheEprVmVQQ3RGRldFcjVseHBrSjV4RVVCNzM3dndJZCsrdEFMbjBqRU5qaWd6ejI5SDhXR2FWejR3bWUvTWJRVjc3cnFqaDM0eHIwbXlyTkY3Qmh3b1JPZ2hpZkNORU14S1dTdXdrc3hTZDFSdzg3WFFnYnpPVUhqb29XM3lzT0kwT1FZdmd5ZGFtQUZqTGM4bG1BcTBpbnlXUmIvMGJXbTRDcEM4ck1Nbml6R3llS0g5V0UzbkhCQ2ZUQm5sOVFxOEN0VUJEcHozV3dna2U4SHB1YXc5L1dKVzg4Wk1RaW96L2R1WUpjN01qcU1hMGFDYjMvbUZtdmZrb3hqNlhBRDc3MVZ4NEZEUTNqODBRcDZnd2JaNmlPVERFSUQ0MUZPRmJoQnk1WTJ3VzI3RGNFa1lPRWlGKzhISWp5T1lSRWF3ZEo1RHRXMThGaUpZbGtCMmlKcGFITTFhSzVGYVNXSTVMZDBiTVpQQVk4UzZ6UU1wTGE3eERoQWZhcEJSMDNaN2RzRWE4N0VsdjdxdHJmYzBIZlo0WU8xeC9JOXhzWUY5UHdycjcvdW10alg5Nm1penJQVE9nRWtXQ2NjWE5nbmNPR3RHUnlaeldMaW9BVzNZTU1rYzdLbVJEWXBLWWxTcGFFaHVVVExxWVlndHNCVVhUbE9WYlFScmNKQnVNQ3BXTW5uRzNSaFZVZXRpYmJWMTFWYXcxNHJXMlNxeDVTSzhtcGJFTXh4Nm5NTm1FTUpMRDQ0RGlPMWlOejVXMUE5TW9mR29zZUowVU5XVjNEUnBlbDNIenRTZXl5Yk9Vc1planBiS3IvdzkvOHdjdXp1cjRWaGFubjVXTVNaa3pab2pEaXcyd2pjT1ZjWXFNb015blZnYnRySGpLck1sTlI2SnVNY3RWTlZCUTJ5TFVFbXFSQ21NZzNSQWpWY0hpTXphd3gvUzN4L2dXbnZRbDJnVU5GUXFHazRQdXMyVjhkYUJQVjRiQ3hPT1pVRTAzVWdhbFhZekVrVGZjdy96UnBxNDJYRTBqWGt0alAzZFJhb0Zna2tjd09jSlJxMmozaHZTOFhzUDQ1UjlsZjcyMS90WFExcnl0Q2I5MTB4OCttN2dDTW5nRjdUUVlrU09ERE1vVzNJc1B4bnEzeW1RQllFTHZwSXQwM3F0VEVEZGQ4SVZ6bFV0d2xhTTNhMmdHVE1Dd2kycDVrME9RWTBHaUpSOStDV1BLUVhtT1l3dDFGZXgya0lMSlowcGp4YUtNTkJDMWlOT2FnV01QZFVlYTNkWUZvcTRjd2ZZMzQ3Z040OWczQ3FOcHk1ZXVqTlZaeldPYVBjUlEzRHljcGxuRlI5ODBXNXVQcnUwTE5ZY2c5ODUrOEsrMjdKNHNDeEdNNWRXb1I3cUlUWlhDK0dCalE0NVlBcGlKSlVFZHBQVHkyVDFTVEJjZ2t3QVZRYkRnaGtRbTl0QmxMWkJlLzVmRTNWOUlWVERuTlR6MWFGZXc1OGpjYTB3Vnl4Um1rbGlBYmx2VlFSS0Zja2VuUDBQeTNIYXhBa3AxU2x1NmI1cVJhUk8vZDhMT3lmUW1PdWlIZ21nY0pUTTRpbjlKYWdVQ21NQURaWjMyOVU0bVlxZHVVekIvQ2ZHN2FXZSsvblAxTzVjRGpqM3Z6QkhwVDJERk5XZlR6MVh3c1lmOFpoM3NjMEk2Y2hIbXN6TFZvTFlOVU5WVlFTWVJtUFpoUWVBZkVhVk5EbHpqeEd1Z2Jqb1dLUzN0eWFRZ29iaHBKVmhFVUFpNU5pZm9FVElMR2NpS3JnYThCZUxIRnlOTWg0RjM1NUNka3RXMUdkYU1BdDE1QWR6WVRTSUMwck5GWnFkNFJ2MVhrT3NuUVRyamcwdFlGWFc3SUQrZHJFbEZ2djhXcTQ0WTB4Ykx0cEZBT1habkh3cUlNZjNsZkhnY2RzbElwQkNHb21MWkEwRWNaSklkcEVUYlNEM2N4YmxTTldYVDFXT2VxeXUxWGQwR1c0ZFNTdWJ2bmFNNGVEOEwzS1dLbnpCcUY3NG5QV0lqU25DS3U0aEhndUJUUFRENjlhQzZ0SWxZa3lHZTVRTVlyd0NsTVFOdW12eHpIYTUxL211UnMzRHhXbGhxZ3Awd2xiNU4xQ0F6dHpPdnhMVXhqYm5jUThEVXRoeHNmY2NZNzN1RVNHeVh5YWJqaVZVT0RLRU5nUTNGYTFMMmdXZE1JYzA5ZWFQWXlycmRkOXhscVh6TFFKV04yV2RNZ2lmTzI1WTVSeHhtd0Z0cEoxZFk0NFJKaXlCUFY1Qkk0Sm4wcGg5bWJSbURxQlJNeEZJcTNlNDhPMTV4aWYxZVkwZmhHYXJLMkR3YTRVUDZPeUFRRU5DZll2VDVyTys5K3ByS1hLMnpVMEdNOVFhaUJIeDlvM291SGNzUmdIWDJDaEZJU3hybFNYcURGdVRpMFNBQUpreGhTU2FzMVRoaW5LY2hWUHRuYll1cTFpajhPUHFEc0NGY2JTSlpKcGlZWkl1Vi9scnFlWXVoUjR2azI5elZSR25jUndaV2pJUE1WMGF4N09oQ3BOYVRSUVNpMThNbHNMM2JFamFiSmNHZTRnZEhuZWZFWnVIOWtrQjJZWHhQeEdBZlJuZm1keWJGSStzdGZIMjAxbUFnMmFSOEVZNXhBRWExNjVJQzhNbDF2VTVnVUNyT3E3anRyRVFHQnNHMkdSUVZWNzFHNkVjRzlSMEZ6VGxDckdLY0E4aGJjTVV4aWRLRE9ORFFGV3I2c0pvRk5qUzJUV1lTckE0REJCVWhOS0xYK1N3WjRxeVBQRDAzUmZGbk1ldGFVcG5DajhnTVZaaXk3WlEvK1FTWmZ0OE53R014ZWxJbXJkSU5pS0JXMURBQ3E2M0lyL2ZkTC9lSDhQWHYrbTY0MWhta2RZMVNZQXl2eUVVc25lb0NUS21oOHlNVnpob3NjMFJOTm41bFhLa216dTYxRWIza0l3V3pzN0ExZUdERkxMWmcwT3VOcVZwR3E0d3FlWmNtaTRXam5zbzg4R3VQcHlyUldiUlRncFlveVZ0dERJWXBvZWluRGdOSzIwQWxJdHIzbjhmdlBINjhnTm12UlJsSE1xZ0FvRmZPOHcxbkJEOWxveDlNWGZtdHo5dURteldMT3ZXVmgwdjNIWnBmcGxTdnJVVGdLWExBbUw1eThlTGNLdElaQXZ4Y3IySG5SNUhMUVk2eXEydGpZbUNLMjVRVHBPRU5RQ2Q1THlQbFVJTURjWG9DL2YzRmlvUGl0R0thaXJ5aEZkVWtvNGNCc0dGWUxQTGFtdG53SkRZeG5NMHh3VnB1dm9IVERwY3VOOFc0QmNVdmEzZmVzekRxcTJSbEs3L0lPaFVQbStkU2l4OE1LRS9FckRBbzVNU0R4M0tNQnNRWVl4enFUSlVPNVdPVjJqVlp4SHA4TnRQMlA3VDVGYXhRYXRWWGhRSmtyRjNUU0JTUnNlRXFTeDJnbFlkM1U4ZFlqbk4wVVRBYlg4VmxmbVNNSlNPeGFrUXpNVk5NdUFqS01xMzNYS0RyTFpCSklaSTl4UEhLZ0NCOStjaUFVWnJQNnp4ZGM4UTd2OUN1d2tRRlZuZmhqYnZVdUh5NEdabkFpd1JPa3RWaEJ1azFSQXFuWFNoS0dNVUZNbTBkcHhvSGJxS1prTkMvWXRqUTdaU2NuMUtJMHVBVkZWSUVQRlpjYmVlbFhEa2hkSHphQlVrbG14VFRIa1NQMG5aaXU0dG1hRnFZemF1NjFrM3lSTGF6UnJGVDV2OGdXN0pwRk1hU0hMbmJvYnJ1YkVHZk05bXhMc0JXRkk4RDBadzhtL2FqdWpURjBMeVYzdXkyQ3E3MkEwYk1nNlhXeUs1bWo3TmkyYzdXcVhlN2xHRUN4VjRtTWNWR0M1VFZNanBHekZ5U0Jrb0JveXo1R3R1ckNLd3lwQVVncDVxMUpMaXhUMSt1S0liZEVaZHpXNlpBMDl3a2UrV0VkcHRvN0ZPUmVIanlWd3dTNjZYcXRwenR4S2dFU1A4a29TV1dHam9pVTVNZXBoVmNMem1yOWxVdDlIZldZc1pMV0RjaVBSYUFQeGpNdXVzUVpBTGpOVFd3WlRGVWFQenVOUWFZbUFEakI5bVEvcmVLSERIV0JjMDNwbHVDem1LbGVyS2tPOFZibC9tRnFFcStCTnMyUXg1aXFHaHgvQ04yc3h2Ymx2MWtCekd3cDFWQ045N1lxTHhZS0xKYVpEV2tXSFVUV1FDalQ4K0pFQXUzZG9vU0tvZldFcTdxWkkxMXJhd09KOEhkbDhITlU2V1YydlFtcXgwSVFKb2hub0NVb000eTNQVzNORXFlMXZsV2M2bmhwbk9IYXV5TkJ2UHh0LzlzSi9kNzcya1Y4emZqbTFpV25KZ2d4VERGWGFhKzRFYVVxcnF1UEcyZFhlOW93cUhzU1dIUzZhVzFORTArVUdkRU8rK3VWWm1mSE9idTYyMThoS3hmWUdwVmVvUFVDZUFWTVY1cFBOYlM5MXlzQ2hvd0o3ZGdEemhXYlZ5ZVg3czMwQmpqTTFNWXRGSkhvSFlETnZSYmtJUGM3NDJYQ2hqMnlpNjY1amdSTnlzU29XMnJ4SjBDYTlaMjFob1ZzY0RVSDlxKy9GUDdOVXM4c2ZlS2YrVzd0MjYxQWxWdlhUQjhzKzJlMHVGK01sS2FSMks0U0ErODF0bU10cFM3TUxBaXRDRXlPbENGZktWQ2t3Ym9acjJmREo3S0Jsb0pSQ3gvbE5tRVpoeCtabURWbkp2SHBQb3VJajIyL2d4TGlMYmRvYzNOd2daREpOWTJSQkcwbkJvREV5eWxPWVdVcTRNMlY5SEN0ZncrRlZCMVpiQXpDN3NmVkZLZjdpL1ltN1B2RjUvT29YditSOTY2bkhnN3JhSXB2T01jZkxNOGxQTll2cW1taHp1KzIxM09WdEttMDlyTzB1MTNtMVpvMVhGWHFVd1VyU1FlZkp6djZNeEdBMlFFK1N4b1lPNnFIOWtQbHNxNzZyOWlveGdSMlNIcXhlRTBkUEJFaFdwdmk4QTJPd0Y3cEtaYVlta0tBNWUzdzh2bitSR1JCKzlsb09PTnNaaWxXQUZZK2NNSTQ4OGkxOGJ2UUh3VC9mc01kNzB5WG5pbXQyYnNHZTBVSDA1WmdVSkJQTjNRb0tJTVZNVllNTkRaSy96TnlYZnEvUzNEOGt3NDdXZmNkdFZwZ1VZZzFMUTdFcWNMeWdUejQvWnh3Nk1LMC9uWDFNeG5hTXVoOGQ2RkZsUVlSYk4yMGlkVTZmaTRkVGFRUXpEV3p2bmNXU1BSdCtUcHFNVnd2dzl6MmQrSSsxQkRNYzBGZnI1NFN0VmZ2T1FrSjczRlQyUHQ3Ulk2MitiSmFXM3lPeWNabThlTlEvNTl5aFlOZHdyeHdiN2hXYk4vWElrWXdwTTh4VE13eG51bHBKMFVUVEZLa2xMbFZVVUE3VTg1cmxRZWE1RFE1OHRWVFR5ck5MMnVSY1dSUU9GL1FqeDR2YTNQaWlWbWd6YTdqemF1Yzl2M2ViZTVQRzhWbGlIRlVicmRVK1lJdHB5LzNQSjlGSDZiaDR1QjdLdE1xVDczb2dLei8zL2N4dVY1ZUtvY3MvNlYrK1ZzT0xGOTU0dFhjc25HbEF0UTVBWTIxQWRnS3F0M1Z0SlRhdmtNQ0wwNmxTZGN1SDI0NlhuN2plL3VnZCs5eHJrMGFBU3FXWloyWmpsTjQ0SGZIQk5BclROZlNsWEJ3djU3MnYvamg5NTdRZGZBZmhSdE1Yd1R6amdKNUp5ZTEyNlpqbEs0MW9PT2wzWUQ5emJFZjlwMnNzWG5FQm9NdmpvQ04yK3gyUHc4LyttL3NTZjEyMXhPUXZYZTI4TDI5Q3IxSldueXZ5eHNKa3JWNDd2S0R0UEhMUVB2L2dRd2NPUGpGdEx4N3VNRDN5YkpUY2xRcDBuZExiZWF1M3NiUmJVVzhsWUU4RktGWjVqOVlsYjF5ZWRPMk1jOXB1M2JiYjl0N096ck9Tb2JJakwxc2VUTDl0OE5vSDBHaTlwbmRNQXRHRnFXS0ZsWnlWR0NvN1h1LzJ1SnVhdElQcXRoNjdIZkZ5dGVzYW5SV0ZCWFFNV1BzZ3JTYkg3V0RxSzVmZVY0eW5wMU1jRnl0OGgrWG10MzBmMlFaWUo2anRQZWlJbXhKbmFlbXZzMUFkZER6ZkhsTzdBYWwzS1VpSTB6Qks0bVVxaU93eThUcTcxd0ZzNStNMUFYSXRKTGV6VWhLc0lHOStsMHFTV0lXZDJta3lWS3dnZjNJRmhyWXpVM2FZdU01YnZ3dndhM0tkd0xWaWFEY3BEdEQ5QW91bkErU3AyQ2xPZzVseWhjZkJLbXp0Qm1Ld2xtNzNURmVLWkplbHBhQmpkVUswUGFkMWNjbmlOT1gyVkdDdXh0QnVnTW91b0FWZGpsblRxM2V1UmVtdm0vektGWExMNEJRTS9QOHlFNnZJNzByQWRocTZBQ3RmWTNmTmN0RzEyc2E1MmpxaFhDVWVycFNpbk01VnE4VXFBeTFmSnJnNFJXcXladGVpV3V1ZkhKOXFBVmllSXJkOHVjV0UxZGlKVTRDemtubGFWNWMwWHkrWGhwTmRrdi9WSlBwMHludXY5SHVzeHJoMWUxMzY5WGdCWkxsQ2RXZTFZZ1YrRHFES2wvbmF1cndROG12aG12TnlCYkJPQndEeENvRmM5d0MrRmdGOXVRTXJYZ0VJcjhuL3ErVzFEdWhaRDhvcmFldnFFdVZSZStVdCtzL3NJa0NqRmdFYXRRalFxRVdBUmkwQ05BSTBhaEdnVVlzQWpWb0VhTlFpUUNOQW94WUJHclV6M1A1UGdBRUF3T2cxRkFzcDNzQUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpRVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZelFqUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpNNE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pSRFFUTkdOak01TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNlliWmtnQUFKVGRKUkVGVWVOcnNmUW1ZWEZXMTdyL1BVRU5YVjgrZDdzNDhFVUtJWkFJQ1FzSVlNSUFnb3dOeVJmVHE0OGxUcm9Kd0J3TlByeUI2VllTbjkrT2lQZ2Z1MWV2NGxDYytCY2xGSUVRZ0JBSWhKQ1E5cERzOXBNZnFydW1NKzYyOXo2bXU2a3AzcHpycHBGdFNKOS9KcVRybjFCbjJ2OWRhLzFwN3JkMk1jNDdpOHM1WmxHSVRGQUV0TGtWQWkwc1IwT0pTQkxTNEZBRXRBbHBjaW9BV2x5S2d4YVVJYUhFcEFsb0V0TGdVQVMwdVJVQ0xTeEhRNGxJRXRBaG9jU2tDV2x5S2dCYVhJcURGcFFob0VkRGlVZ1MwdUV6Rm9oM3ZHNTdPMkdIUEVXZFl0S2FBcUE3TVZvRzVEbER0MGtySGFxa1h6cUsxaHZZSGRCV1Zpb0tRcXFCY1VSR2l5NHRFNHlDdCtuajM0QnpjY1dEUTZyb3VMRnJqZEgyRDFoaGRvSS91MTBHbk5kTTlPdWxlM2ZROCsyaGZld0NJQjhUdkMzalhsNmNnNTFtYmJ1b2lEYWlEd0UwemRGeXhaQ1l1c05PbzZoNGdKR3VBVUpqTzhYV0tSUzJzMGRNSENUcGQ5ejdMenNER0JQQ1E3NllKMkxhM0VyQnlNY1YxbWRjYkREcmVOd1FrNDhCOHVyL0MwTjBSd3pQdEpqYUhnSjlHNlRBS0JQZDRMZXg0Wjg2UEpxR1pQUWVCajljRThMbDNyOGJTOGhLdmtmc0p6QUFCR1kxNjU2aWExNEkySFhOOElNUXJ1Tnpici9uSCtXaEErdnN6anlDMlRQRTZTZVk2Sk9YeXUwYXJTL3RzQWJ4QjRDYnBPMjBySTlTSjZKelhHdEcvclJ2ZnF3QWVvRWZ0Y2FlSmhFNDVvTDU2blV0Z2Z1K0NaYmo0dkRPQmdSaUR5VFZvSVJWMTlSb0NKREtNeEVPaGxoWmJWV1VFSEsxNlVJSWl3T1N1QjVicitpZ3lIMEFmUkFFTzkrL24ySmI4QVJmZnVQaHV5cE1aWGN3eTByQkovSG5tdDdTcXFpZTVYVDIwSldETDZlekZWVUJyTi9EOXpUZzR4UEdGV3VEZitJa09xTkNlMUQ3bjlRSy8vTXgxUzZ2WHIzYXdaWStEK2lYTE1IY1dnV3FwU0JzSzBpbWIxSjRKdzdCaG1XVDQwaFpCSVl5bENrY1lROXVWKzZReE5NVm5rMEJ4NExnRU9obFg4ZDJ4MHJJemlIK3VZMG1rWEU0R2xQU3RZNWwwTGE4ZHJIUmFmcmVkckhSblZIczQ3SUhiMGttR2xwVHQxU3VBRll1QnJ6ME92Tm1MNzg0QVBpbjZ6Z2tKS1BQczVVWDl3UC83NG0zcnRGT1gxdUNmN244Qk5iVmgxTS9RRUI5TVVVTTZaTGVvMFVrZm1vWkZLK2xZMXlhQUhBUkRuRHFFSzFWbVFNK3FXbkZoY1FzaHNXSXJBTWhJbWJpbnkwZXFZcDc1VGVaWTV2ZitNK1kyajFETGhpRnRxV1JQVFczQTdSY0Rhd25VV3g4Rlh1M0JVdzNBZTRUUW4xQ0ErbXAyYlN1dzVmN2JMbFp1dW1VZGJ2L2JyNks2SVlFU0FraG94RkRJdDJXK2RHaDZqczN6MWF5d29SeFpsZXZ5a1FCa2lBOUhsdlF3SHpCeDdZeXl5QkF0Y1YxaG80WGFacm5HUGVjakgwWWFHQ1QxOHRKTHdOM3ZJU3BPS3ZpVGo1Q2s5dVAzZGNCbDdna0dhR1VUc091MmE5YlczZlBnUjNIamhqdGdETVp4NnFua0U2UzhSaE1zbHZza1NJRGhTUllqRmFzU0t4WElDWnVxU1JXcWtlK2lFOVZWU2IwNkR2Zk9wNjE0Tjl2T0FpcU8yWTVMeDBnMVd5NkJUWi9sKzd2eStvckNTVVhUUFJVdTk0dnp1UTlpUmdWbkNKaXdxV0xwSUVwZVIzN01qKzhNSUVFQWYrTGJKbnBOL0VzbGNPZUxKNGpib2hLMytObFY1NTlUZCs4dnY0ditwdDFZc1c0RHFralYycllRUFZOYVIwMFBVTU82S0NuUlNWckRaTDhDQ09vTXdRRFpRQkpIbGJuMG1TNG1mbUtud053MG5jK2tlSEVwcm9JbE9mSmEzUDhzdHJabFN4VXViS3hZeFdlSDBISWM3M2ZDSGpQcUtKWXQ3TEVsN2JaQnY1SDIyK0x5dkRTcC9DVFpiTkVwaE1ib1Q3cllNeGpHUmFzQ3VPdkdJZHo3V084ZGFZcy9TKy82MjNlOGhLNWc3UHEwcXY3czMzKzRFYXN2UEFrZGUzc3hvMGFWaElhUmZYVFNmWktTQ2ticnBHTnd6TGdrVCtJeEhhS1kzRXg0cXM4VmtRR1B3cnFrb3lWVGRiTzJrd215eEgyS3dyUEdrL251RFpNcWxza0xzeHhHSzZ3ZlU4VHo1QnlELzN1bVNTTEc2Q1pNTW1uWjllU3pIK3l6RVEyVHZpQ0ViMzB3aHIzOTd2NDluTTk3eDBzbzNYQnJ3T1didi9xRi8zdkJuVVFxU2txQlJzS3dMQ3BVbmFmS2hHMjBmTnNuVkc4aTRic2R0Q05sZUtBSlljejRvaG03bUhFK3hYRnhERHduME9EbTJORGNhSUFQV0VEMUNaVGZLVXFDbmk4cTdrbEt3anRPUHd3b1dZWWVvSmNoNFVXU3pFUTFQWCtLVk81OXZ3TDI5YU9uakh6cUV5S3djSVlmbXpzQVBIWGhFbHowcFM5NG9QM2d4MEIzcjBlQ1RJTWhiWElZcGthcVR0aEJaOWlmekFBRjV0c3pkd1IzZ2U5YURrdHFmaVFubit4a2RxbzVKQ2tUb0ZCWUZteHdVdjBFY2xuSWxpNk9Ubjd3WUpKaHhSd1hONTFIdHA4NjNiMC9BNTV1dyt1emdDdnBjczB2blFnMk5QT0tNNEVOVCszQml6TWZ3ZWxmM09SRmFINjNROFdDRUtrMDBuT0NvRGl1VGcxbkl4eDBobituNjFsZzJCaGhQYVptV1N6M0dmRHd2ZmtZWWFyTWRYeDE3UHBCQ25HTkpQbkNLVE1BbHJEUlJzQXE5SHlHcmFBcjVlQ0tsYTZVM1AvNWMyQnpHM1lRbU92bzFvTlRGUTZjc2xpdTBHWkU3emY4NTNONFkva3ZNT3VPVHhQbGY4dEZXNmRHTmxXb1dHSzBza0VWNmJZTWc4WnlwTXovTE5Wa1RndUt6cUhxdnJUYTJiQmdSaDNuZ3NueU9sbys0RUpLVTZhT2lPSVFBeGJFaWRnMWlYTnpwNHRQbld2ajZyT0FUNUc3OGxRclhpTXcxMDhsbUJsVE1DV0xQeVF5UU83bTFkOGdwN3lqaS95NG16bE1FYmx4bVI5ajVmSVJNMzZqNHZ1Z3d0WUp2MVJJSzVGaEJFTGV2aEdyNW0wbHVJcjNQUk9ubGF0L0RRSDg4TG5LeUZVR0l4UVBlVTMxRExLNFoyYy9zSEtPalZzdkErNG5OZnRFSTlwSjQxeXFUakdZVXdwb0J0UUs4czE3T2U2NDd3SGduTE9CODg5eTBIWFFsYkZhUm9DS05SK3NETUFDRUMyUVhUTkFNSllGU2F6SUNlOW1nSk1kZ25wVUlPajlWczBBbjNNZllVZTViQ0pGZGk1eGZDak5FRllzZk9FR2pzZTNBbzl1SXo4VXVKeE83Wm9Pb3k1VFBzQXROR0F0OFBYTmUvR1hYL3lhSFBPYmlWV0dIQm5oMGRRc0NJZUF5a2VDR2d5UEJERWp1U0t3RUIvMEpIdG95QU5iZ0JndTlZNXJRUS9Jak9TUEFGUVhIY0Y3Q0Uzak1oYmNIN054K3hVdUVzUzJ2L1JiR2FpL2dXNzE2blFaUXBzV0dRdkNrRlA3ZnZpaDcwTXl5UnV1Y3RIWjQwaFFtT3FOdEVpd3RKRXEwYld6MHFpSFBGQ0ZWSWxPTUVocXNiVVZNSWg5M3JacEpiNzIrMnZ3L2h2SzBkb0V4R0lFbE9LQkx2MU1KMC9WYXI0NlZyTnVUb0RPUGRERHNYR2xnM05QQmU3NmtSeFkrQWE1SnorZlR1T2gwMktBV3pUSWZVOWo3MjBYNHFGdmZSdWZ2dXZ2aVA0LzUxRERxeWlKUUliM1JEZ092dTBUQU1USXhUSFQ1RVpVVVdlb0ptUGM1eEVld1RndGtwNXpMNmxFU2YwTUxIOVhCR3V2VkFtY1JmallQNTlCeUh3YnJiMUpOTzdvUTV3UTBSWFA1eFhnQ2hBVmFwRlFKQW96bVpSUkJ0bFo2TG85Z3dvYXlpeDg2bkxnVzZSSlhvOWh4M2VleHVmdXZ4RFRhcGxXT1VWa2kvN3gxeS9EM0xNWCtPZ0hPUWFHUEZzYUNIRlBhalJQQ2tYd1lkR3lLcHgvN2FuU1JXbWo4OCsvY2drdXZHNlJkUEt2K3ZCeTNQN29WZmpJcGxPdzV2S1RZVGNTTTkxTitsWmJoZzk5Y1JIdS9OWXkvTjAveklGTjUzYVFReHdpTUZQVU9SVGR1LzZzaFl1cDR6aWVsSXJnQVRIYm9TRWJkMS9qWWp2ZDZ3ZXZBZzNBTlppR3k3UktRZm5DMDRoLzlrSjg0OEZIY1Bjalh5ZVNkSG9RMjNjNnFLNzJTSTBZZyt4cEJsYWNXWTUvZXV3V2xGV1hZZmZ2L295V1hhM1krUG1yeUwzb3didlhWV1BwS1RPaHBnYkFXM3FseDh1cXJvZGlQUU83KzJFNGd3ZWdSTTdBeWhzK2o4L0VObEZuMklsenIxK0cxNTVwd3I5L2J4RGRQUXpMejFtQnh0ZTNTelVPVnlGWHlzRXQ1enRZU0NoZVMyYUJNTCtIbm5WZkVkQUNGbkpCdi9LWGRuem1ENXNSdnVrNkM5M3hlV0RPSHFSSXdNNDRid25LNTgzSG1yUERpRVIzd2Q0VHhPS05IOGNwNy8wOWxMZGZRcWppV3B4OGNSSktyQXRLaXdvV1dBNlg3WU02OEN4WXpRb1lmWnZCOUZVSWlSaHQ1MWE4KzdLWUROMngwQ0pjOHBtN2NOTFpqVENTTG5UTndvNC9NU1NHT0pLR2l3dE9jZkNSRGNBWGZ3dzBtM2p6ZnoyTkwyS2FMdE11alhNYjU3RW84SjJIL2czWS9xcUJlZk5tNFpVRHRhaVlQUTkzZmZjNi9MZE5jN0htblBWUXV1YVNaUTNBNldwRytrQUFwbElHTmJFSG9kNHFXTzI5c0tOWGc1VVFCMDI4VGIyMkhCWTVTSzRkUjdqOEhMQmdCRWJ2SzBTWVRvWnJYUS9lWVVHSlYySEpTWC9DaXJVaExMdmdLdno5ZDc0R3ZYUU5lbU5oVklSZFBQRWkrWnM3WmZMWVp6Q05sK2tHS0x2OFZCWk9xMWgxM3J1QmVTZFhZZjRTQS9jOS9DVmNlZk5LT3RvR3ZORUNKYlVFZ2ZwUElCaXhFVGo0VTNEdFVpUkxseUVaZTRKZTZHU0VRak5odUNTbFJweUkwbnl3MmcydzAzc1FWdWVUbTlTSHhPQXVtRVlLU3ZRV0JFcE9vL01Ib1hmZUI2V2RLTEJOOStsK0VndktIOFVuYnRxRzJ6K1Z3RnN4aHQ0QjRHRnlxUmFYNDk3UGJzVGFVU0xDMDZNQnAwUFduMWorL21ueUFhNURiY3NnZnZzM0YrQ3NEMjRFS3QrMUR2VVh2SS9zSDFGWjNnQkc5a3prZ1BCME42bE9HeXoxTXBEdUJJK2NDY2Z1Z3AwOENEdXlHQUh6ditER3lGOHBQWU8rdndzQmZwQmF2eDR1aVpmWjhSVmlyYk1ScUNHN3lvamVwc2kzcVpoUDl2Yno0Q1VrclRVYjRCeDRnTnlWRXJDWkZVRFV3aE1QYjhVVFB3SHV2SXB1VCtUcG5wL0RlcjRGbjN2NFQzajRLeGVPbmNaNVFtYjlaY0t5UElnR2tlOTY0M3FjZk5lbmdSZTNSM0hhaHJOUnYyb3hXUHhrcUhXZmdCMzdFNXlPSDRDWExpV3lRcHlrNXcyeWpkZEoxYXAwL0pKQVBvM281NVZ3a3EvRDdYMk85R01OM0JtWElLZ0dZWFVUbTNINm9LVk5zcGxMNFpiT2dkdjNRem1nemNQTDRDWjJRaWxaU2VRckRTWFpBYVhzQXFtYXVkMko5TUVuMFpsVThNYVQ3WmhOdG53K2thT3YvQXI0MmF2NFB2bWh0NUlQYlU2WE5NNHBWN2tDVEpLVE9nTHp2ejV3TGs3KzhpYmcxK1RuUGZ0R1BScldMSVF5U0NxdzdIellBOFJJa2lSTk5WY1QrbStDOSsyQUd6a2J0ajREcHIwUGFmWTIwcndKeGlBQmErMkZQdmQyNmdUWEl1RFlCSkpJNmlVZlpaQ09WMStCbExVTjZmNC93Mkoxc0lPcnlJNXE0TFczd25YSmxpb1ZZQnJCRkYxRTl2ZDVXanRRTXZNbUxMcndMdFFzQm42OGhmb1JzZTFON3dkdVg0OWJ5T1Y5cHArbzlIU3hYY28wQUxQMklQQm5BblBKcHJ1b1Y3OUUwcm03bW56S05XQjJFSWh2SnJXNkZhejNsK1QwMTBKVEE5QXRoYVJ1TVVMUk5TZ3BZWWowUG9sSXhjMEloMHVncDFyZ0dOdGd0OTFOUHFvQ3Rmb3lNQkgrRVNHODBCd0VVbHRSNHVnb0xkdEF2N2tlSmRGekVTQXBETkxUNk53aWhqc0RHcWx0dC85cEpMdTNRUTNXa01TM2dlM2Jnak5YMStJOWZ3UDhZaHR3c0J1NDVSSlN2Ky9GV1NHR2wzcUFNNVVUR1ZBQkpua01NNmhkdG55UXdQekh6d09kNU9SLzVRSGcrayt2eDRZYnk2RDAyYVFHNTBEdDJRbzFlaEVVNXlueUwxK0c2dFpCcVRzVFN2cHA4Q0VDejB3ajdaUWhhWWRnT1JFQ1lRM1p0VTZTcm4xdzAvdkF6ZDBJelB3eXRKcmJZR3F6a2FTYnA0MWRjR0svb3hZSWtHM3Voejc0TXZTeWRlQldMMVJuQUJwVEVhcTVuRlJ1UDlMZFQ4Qk5kZE9wcTNENWpZdFJmMllVano0QkdXbDZ6eHJnL2c5Z1pvV0dMWjNld1BhSkI2Zy9nRnhDRGJEbHZhdXcrTFAvZzdUcElQREN6anJjOGZWMXVPUlNVcEd0RG1DUlZMbmtlcEJrUWlQbDF2Y01OWEFabklvMXNGS2JrVTdzUXFxdkUyYnR6ZURHY3dpNUFYSkxGc0hxZndHczlLUEVZbGZBUHZBd0FmYzZqTGF2MGoyN1NhS1hrblJYd05FcWtVNitoQlNkYTFkZlQrcjNBTm5STGJDSGR0RjlPNkVGUTlCREpTU2xmMEQ1akZQcHZoM1VTWVRHbUlPckxuZlFIV0Y0L0FVdkJXVVZhZWV2ZmdEcTNBaCtReDMwUnVWRWxGQUM4MDhYbkl4RmQzM09pOC8rSy9tZEwrK3F4L3FQbmtxc2swQ2NRN2J6SkxKTzFWdkFaNlhoUkYrRVhSZUNXZFVHSzBBZ1ZLMEduemNmU25ralNkOHBLS0Z6MUxLWGtRelNieFpmaFVCdEEweTJFMnFGQlh2V09RaVZQazYyOWxHazR3OUNYN0FSa2JvNkJEUUZMTm9HdDJFNTdOcHE2ais3d2VyQ3NKWjlnc2pVSE9vVVE0aldoSWhjeFFqY0RnVEx4TEJMR25YblhvWXZQMWlPM3plVCtuMFdHQ0pKWGI0QXVPOTZNdkVCUEVZbTlvYXBhdGpqem5MUEpKWkx2ZmluQzZONC83L2NUM3lIK01jZ1NlZHZIaWV5UVZoYzliNVNtS0ZhMkNrWE50azlKbXBZMUpUTTZURTUyVThsQVYwMTRMRFpjTzBZR1dFUnNRK1RtOUVCVnhra0thb2hZbk1xNXB4eUpscjNQa05TUjc4dERaSk5mQW1PNWNoUjlVRDBISmdEalVqSGVoQ3RySVVUWG9oNHovT2tiamtpRVJXQnlyT1JpdTJCTVhCUWpyallhYThpallrRWNQb2VyU3FCYXlUeEpKbjNDSkdBYTgvMkVycnJxUjl1SlFILzV6L0tWNzF3QitlYjMvR0FMbWZzOWxCRSsrWUQ5NVJoMlRJSEIvWlRneE83TEkxd0dFUGVrRmVLQUU3RVNaMDVmcnFsNW1mNE9mNW9DK2xySytrbllMdWVudEVpTXZlYVZDWTFjdWxzNkZVS0JqdjJ3NkpyQmNxOWV6dUV2eHJ4em1maWQ0YW9aWUZNNHhlQitVQ0puOVZnZXVPa1VMMHNQekVvSUtSWnhFbURJaC9HTkVqaW82aXIweEV1RFpEdEprb2x5Rm9vaEprTlVkenpyVWI4Ykd2Nzl2MmNyMzdIeDNLcGZXOWRNWDhXTHJyallWaTlhWlF1N3lmN1JMNGZ0YkJqREdDK3pLdTBpTWpFUkZtUmpNcGJoRFMzNGpKZlZnUVh4RC9YU3BHVURJcWNkOWpNbGtuU0trbTB6c1dRVEJWU3hnRm9iZ04wVjRmQkRKbWNIUlFOTDdMcEpVcUNESEU2UjRjaTBrTEpWMldFcUMxeWc2bW5NRG91a3IxRkVyYXFsMUJuMGIwUkFqcUhPWXpPRlNEcTFLRTR5dnhVUTRXUUQxZUdTU09RcjR6MktkRzZ4eDFRNnZSTmlhU3h4T29qTnlGVVJnMFNocTVyVUVRMUw5ZTlESGN4OXNrVWFzUk1EWVRsNVlUSkZDTS80NHZPcyswNHJRbFppaTJPQjhsL1pDU21oaFZEbVBZSFZISmpXQWdHcVdiYlNaRzBlZCtwNjhCd2h1UjF4UGxpbnlwRVZDUVFjUzh6VzNZWTI2dDM0Q0xiWGlTQzAzN0g4ckxPT1BtM0lybGJoVWdjY3hBZlNzblV6djVCanFhM08wVE1kK0NFQURRQU5BOTBENkRqN2QyWXU3Z0JHdlg2cGgzNzhQMnYvNFFRSWJYbWVseE5aQ29vVE5TdWtDOUprcUtRZElwc2VvVWtSNVEwcUVHUnhlQ1NaREZQdWsyZEpKMUpYYXFHRGE4TzFOQUlEUHBOZ053ZmphVGVaWEJTQVZuekF0VWlOV3Y3bWZXa0N5d0cyNENVWkpGUmI5dWlaTUtXdVVTaTdOQVU1ZHowZTV2MmlXUHkrdFNSVXFhTDJmVmwrTWhOYTZrREtXUXlCdERUTlNUZXMvTkVBYlN4TDU1RzEvNTJ6RjFVUlQ0bHZYbExGMTdmK2haT1d1TFp4VXd5ZGFaQWFOaFdpa1owWlVXQ2wwenRDNVNvZ2hERVJiNlFJRDBSenpkS0QzcHBLbXJBMzhleisxeWV0Wm1aaEcxWk5wcXA1R1paZTUzSkhPUmVFdUp3YVlZWS9CNFlFTmtUL1hEU3A1RmRWZEd5cnhOZGFSc2hiNDZHZHo2ZzFONk5vdXNlYUR5QU04NWJEQ2R1MEVQWUlDOEQxWFY1ak0xUGxCN09nUGMwOGZBSzVnTmg1UGhod2F3ejVxUzhFZ3JSQVZRL3QxZVUxVHRXMWlGV0F2NW5ueHZLa2dzN1c1Nll1VytHTzdvNU9jQXl3NURBWGpTbmtqUkxIRHlsWW45TEw0alBnVHpwdDA4SVFLa05kNHR0eTk0RHhKQUdZQ2N0Q2FpUVBKRUxKTkkrM0J3UU15VXJycC9saDl3Q0pNVnJmT1lEbXdFWm1YcFJKMXVBNVBwUzcvS1JvTWg3WlZJOTNheTBjaWY3eklkazVyT1JwZnExNVNFRWVCS0pBUnVOamYxUXZWdTlPYTBCWGJCZ3dhVGNzQnJZUyszZTE3eTNzOG9pUUlWdlNCNG1ldnBDYU5tZmx0bDFxdC83UldOcm1UemNuSWt1Y2pQeUZKYXQxRmI5SE50TUJiZVZ5amE4WHVwM0FzZFhtYjVVeXF3K1BWdnNsQ21IY1AwT01hd1pSaG4xRSs2TXlDQ01CbDFvVGh6ZHhOcjNOZzZLUmhXVE5ydzVHVzNXMU5RMHZTVlVESHZRVFhlMk5IYXY2Ky9xUVRpc3dvNFA0clRUVDhMaTFmT1JHRFJsN1lnb3YzZkUwSllzVXZJcWxkSXBDNmxFU2hZdkNYZEJsZ3k2bGlRNXdzVlJOTC9PVTlTSTB2ZUF3V1Rab1hCRlZOMnJEelVOTGp1UmJYbGk1NHByd1o5ZEJSNUJFa1hCVnViK3JvZThZM041ejF6cEZqWStuV2FvQ0JOSk1vZlF0aitPam01RDJNODNJQ2QxZVdlclhObkhlK2ZQUjBsejg4Nk85c0YxemZ2YUllWldDQk1RSWQxQVdiZ2I1UUZIems0aUdLMUxRTmgrcWJTWW9VUUFKMll3NGI1eEV3MmNUcGtTRk00ODRBVVFZaFlUcithRllDWXhNMFFOSXZPcXNSMVJ0RXRBT1puYVVwZG5KVkJxQmE4VENDYm15aE95dGpNWFRGbGxUdC9OSVFXVlFSTjJ3a2J6L2dTNkhabDh2WVBlODVDeW1iOTJRTWRNMGFBZXZLT2JHclN0cFJzcmxwUWdGT0RvYjIvSE03L2VnN0pTbjhuaVVMV1htZEFpMTY0eDVWRDdocnh6cE8xVmM1cVhIMm9YaCsxMlppNGpuaTJLNGp4YkQ1T0JSNXliSXZaVFNVeTVNaEFuKzhteHU4bVFNNkRScVZ2R2FRZisxd1lvTzl4K2tyWnRwdkEvOS9iQ1Bxc1dLa2xWU0E4aVFVeFI1TVVPMTREbU5HZytRU2wwMy9Cbm5nVUxmT3pmNTVLbE1hL2wyOCtCSVdLNHRTNmllbEtXV3pSMWVQYlpWWlRuTVVwaFcxNDc4T2tPS0N0Z24veHVCd0p2S1liUnQ2ZWx2YW8zSFpPSnJoV1ZwSzcya3lEVmVoTEtNVDVJaGU3am81UVI4c09BZGJqam1UY1JHZmRWRVM1aS8yaHNCMXA3NUt2c1MxWld2cDFEME5rWTBubE1nTldPQTVnc2YxK3NvU0dwa3gxdFBXQ3U2eVFTTkdjbTJaMHE4bUoyZUs2TExMUFBLZW5MTUY2ZVcwYlBjMW9qNXpQUGxVUmtQMmVxejNKYk1CY2dOb29tR0czTjJOSTBnUm1pMzh5czlNeHNjemZRWlVyL2MwdGZOTXJIVUxWc0RJbmwwd1hRdzBrbEcydGJ3dGpMSGQxOFhTZjE3TVh6Z0ZLeVJRa2pqSllPVFJJaE1UdUpaVG1TdldaSUM4dHhJU1RJYnZaN3ByVVVkU1J3M3Z3THpKOUNUaGxHejd1V1Q2NGNQa3lPWE1tY2ZWWHZqZ1F6TTVlRFdPTmtMQ3ZvY2czVUVVM3FnTHNQeU1FYlJCbDcvakJnc21NcHJaTnRROGVTU3BiL1dXTnM2d0Mxa2hndXMwNEh5Z2pRVld2bjQ1d3J6c1pRWDB4T09XTVlsdWRpa0E1V3dHVThWYmdiTWtXSVBIL2h4a2kyS1djWnM4ajE4R0tCZ3VWbUZpOG02M2p1UzJZcUc5ZHpZZVFVY2NMQmNjU1VjOTU1Y3NvNDF4MUpzcEN0TzlYOEdodUZiT1pzWW5kbEVXQW81WVcvNU4wMTdSbmt1THFqZ0RxZXRFNnBoTExEZ0prUDRvanZaRWUzTyttMDFkZ0VYZFJ3VmxKUFQ4VTYwTEZuT3pURmtxZHgwcjhLTmJDWURGZk1MNlNZSm9KQ0Z6dkNYVWtqNEl1TnJwTGJFL1RFeWhGQXFjNncrblJVUnc2eHVVeitENjY2L3B4RTQ3eFpqcHJPVjc4Q2F3R29xT0p1SVA5a0JxM2I5Z0p0dmNERmErdmJicnp6dys5OWU5dC8vdkMrbjZpeE1VRExsMVkrbWVwWE80NWdqbGdINitzN2xPYm1YZnYzNHpSUmlGdGJSOTNhR3NEelQyeEhkWlUvbFJzYm5mamt4M2VSbzQ3SE5BSjhwRXN6RnVrWjdWNjVMUzJ1SVVpYkNBRXZtT0h0aTRVamVPUnJOaFpzbURzbnNtendxK2Rkcys3dVovL3k1elhQTm1xZEJZQTVxYUJxeDBETnNzTUFtb200Q2p2NlN1c0JmbG9iMlovVFYxT1Bid0M2cWVkWDFIZ1o2bU1SRTg0bnhrcnp0N2t0bGh2U3k0OGZaN2JEOHdpNlhrY1Q4eWFKVWFMWjFjQ0JwSTVyYmdySnNWeHJaaTJTYjc2R1VHVlYxYjFmVzd6NW9tdWJsNDJ2QjhZRTliaEs2T0VZN1doZ0txTjkxeFRsaFQ3YnVibVZBSDMzV2Q0a2pWMmt1c283UGRVMlBGK0Ntc040Y3lZdEhzdHRHVk9xL2VHMzNEbjdNc1JLZ3VVSE1qSmJPWHluYUpnL1YwTk50WVphV3NVVWRTaXRRU1Nza0psSW9YZklSZE5CQzNxQW9hby9BVDI0REVxd0ZndFh0OHkvOTZPdG43MzNmenZmUk02VXF3WGEwaU1HZURKWjdtaEVTQm52c3gwT3Y1aU94ODA5YnlNZzdHaE50WmNXMmQ0K2NxaHFtTW42Mjl3cHlUTnNkNFFrK2cvaDVBUW9iRDgvS1RNUlpNWWV5Z21RWGUrK0dYWXJoL25JdWZ6WWV4a3VXeDlHVU9kUXhmU2dvVkpnM2tLaXNyUTFDTmdRUGZDTWtFeHdTcmZ2ZzBVOVRRUVlhbXZEWU9sRnVQNURCemM5OU5qdVIvcXNRREpubkFnand5YWpmc1owVUxuajJVd2xaenY4T1ZGVDA2RWtFbTgyTnZLVlBTU1pNK3VCUmJPcGpXWjZnOUJPM2dCM1p2Q2I1OFJWTS90enQ4TXFRczIybnVJUFVBOVBYSlZocjJ4a0s0cnpvalgxMkhSbEp4b1cxcUN0S1NWTHZKbHFvS3hPaGR2WVRFVExSWWdlTWhTcUJPdFZ3WUlOOUZtRk12UW1vaXVTc0R1Nm9Ea3pVTEo0UWVDS0N4cXYvZEVmOGRoaHdvQlRwbkxaQklCVXhnQlRXVEhUcUY1M21yVjg0UnkrMGh3cWk1YVRkNTZzckVZREFmcSthRUxtOHFSdGh0N0dYblMxa1F0anUrT1NsL3lCOEJHQmhRTERoYm5IVnAyM2pHeDVKOUtORHJsWGlxLzZ2VmRnV2hDSzV0SjNNZU9aSm5zTkZ5TTI1RHR6a1FJaG55TU5KOVVDRlRvdU9hZnlRei82NDhCLytOS3A1S2xmVExiRUhxdkFBaHRGOVNyTG80bExQM3RkNHI4dk96bTBVaVdsRmdycDBLcG5RNG5Vd0VxVFMxSTNBNHRXVnNvUmtYanpXeWk1WVNFQ0RkWDQ2UU92NGJjLzN1VU5rN0hzbkVMQ2xtWlNRdzZKc2VWRmtqZ2ZHUmQyM2F4cnduM2JLaVJjekxWd3c4WVhNUCtjZW5UdEV6Ti9CaENnQTBJRmN4WkFLRklQRm8yU3BnakNTVHRRYTFLd2pXNFlMdmt1M0VUUHozZWdjdWxpdUVZUFNzc1c0TXhWZGV0WExPZ3RlYTFKVFl3VFdKaHlsVHVlZEI2eUwyeGE4NzV6VS9kdjE2NEt6ZTBab01ib3RSR29FRjJWbUtGSXZsSmFTSVhOSUY5UkY1T1hRZzBFVWJIcWJKaHRqWWp2M0lNUC9NTVpJck1UenozdUpRR0l1SUhNMDZWdDJoclpHcTZiMSsxNWRpQTg5L3Z3SEVqTVczVi9icUtMYnJnWVR2TlRLRnRmalpMVG9oam9NY0JraE1tR3lXTncrbmFBT1RWU044ZUpCS0hSSmtBdFdEMEpwSnNINGNSMFZNeXRodGsvQ0RQaUlCQXhjZnJzb1kydk5WWDhjaFF5Tk9ucVZ6dEthVHljRzhQcWRYZnBReDlzMzNyU2trcDB0SEVFaVIvd2dJNWtMSTJLaUFvSGNiaHBEY24yTG9UbmxWTGpjRm5TcDZnbXRIQUlSdHg3ekhmTmorT3NXejM3S2Y3c2hpQlJZcWpVOEpQRFdCN1J5UjBxRys1cFR0Wm4xWDJXbkFFMHFIcHoxOGVqZThEbVZlRE5WeEpvcU5NUTBVUjJJWU50dWJERXhNbnBOSFhJZnBsbDc2UmQySEZISm12YkluUFFWVERVVUVmcXFBck03SUxkdVIrQldodlJvTHFHYnZXckkzQlRKZ3p1c1F6OXlmWFRmN3Z4YXQ3NkNHSkprajA3QVJid3BoVVh0UVZpVGovUktFcVpnOGlzQm5JVmFxQ1hWeEl3Q296K2c5UjRyWWdzVzRUNGxtZlIrM1liT0RueXVqOHBsR2o4YU1TYjA5YWI4QmpaM04wOFFMbWI1WmdTZEQ4TFAvTjNYd1RESlNGRHloUVMzNDYxSDI5QSsxL1NHS1I5UXdSU3VwOUlrUGpUSWdTVjBBcXVUZXJXOUdiS1RnbloxVGdDekVhNjFZSjlLam5UQXdmQnFHTW0rdzZnUkEyaG9VYWRtYWUxcG1Yb3J5QkpycHJCWXRaZ2lDUXZnVkMwQkE2MVByMC93cVdrWHZVUVN1YWNCSWNIa0doUElsUWJSN283QmhheG9GU3JNSnM2MFBXOUo2SDFjMnorU3dDdjdUSlJVUVp2YW5MVk04eUN0YXBLOW8vbmNENkdJdk5WclpCc3l3Y3liWGhBaXJKQW9jYUZPeE9sNjIrYW5jVFNSYXEwMlNtU3pJVEM1WjhQa1ROb00rNU4vNnFLVkJZWEd0Rnh6WFJrTnIrK2NoWk1laSt6djRNMGtDbmp3Nlh0QmhySzNlcGpPY0p5UE1aRGgzdGp6eXVQcFM3NmNCVzZleHdNZEZzb3MxSUlsb2RoS2lwc2wyeE81eHR3cTJkQXJ5dEIwbTRrOVR1RTlKNHVHTTI5Y09LS3NLZ3lvYjZwWC8vTjY3MUtpOXZ0Vm9nRUFwS09Tc0ZZNUovVTRGenNDMmVWNnZpaEdkK2tKb2k1eHBqWEQwenFFU0xUbmJPNEV2djFIKzJ6Yi8ra3RucXd6NXVLM0NKcFl5U05PdlBTVjhSM2tadkVpZkZxTldIcXBBcDRlUm01THhxMDE3Y2pVUmVSOGVhQXptQWtUSkhzSFJ4RlFvOEpzTnBScXRYRExra3psRktKRGRhU2MxNDlVNE9CY2hncEd6bzNQWWRmL0pFY0FpK2RkS1Q2ZGRLK3J3bHFySUFyL3Y2WThSOWJvLy82NTk2eVg2QStHNXhnMmUxNHNlVHhzQjBtdzA2ZWtoNTBrdDNoS0ZzZEpoc2Y2NkZuRUNNMUp0bFJjbGNFZUNKQjN4WlZjV0VDTUVoYjE0SWE2d0E3bU1ZUVBYL0NKZHRMQk0rSUdhaWNGVVJQakJzVGFOdWpVc2ZIUEVuc3FkZTFKeGM5Wi8zaHd2WGFwWnhVbEJFbmhpdUhyc1JmUlBMK0VJQXNZYkJWV2ZZZ2dxU2tGbFBkTWRiK1drdm91Y2QzbHY3cXJXNjlCOGR4R3BtZmJpdlpIUGxtSW5yRHBmakFvdGw4Vm5tWjU5czRLVTRrekpOU1JUdzNtUkdyejVGekRpWk1CWDFXbUpkVmE4d21WZHREbmJNcUVrUW9uTVRlL1lHdTQvWHNCWmNUTGxpd2dJMUhma1lMSU9TdVY1d1VYM2J1YWZ5RERiV1lweW04TnFEeVdick9xelhpdkk3RDQ2a1Uycm9IMmM3V0htWG5qamI5cmEzTm9aYUJ0R0tQRW1GaTQ3aEtFMkhqZkpUdElldmx5MUx2V2x6dkxKeFJ3V2RXUm5sbE5PU1dLb3d6VXJ2T1lJTEYrdVBvalNYWS91WmUvYzJRenNOM1htZjhNQUFMcmYwRWNrK2FOQTl3OS85cDJOaHFCcmY2UVlYY05UZHRuSS95VENJdmwwOFZvSWVFOW5KV05lK3ptcmRmSGVVOFpZeG8wMWcrN3hHcDNEd3c4NEYxUjlubXJrNys5bU5yaHk2K2VMbnh2cTd1OU1GZWJlbmV4MThKYjMrMXVYdnJHRUM2bzNTaWFRZm9tRkphQUxES0VRSTZFVHZLQzlnV0N1aG93RHFqN0hjTGxNNmpCblN5YmVpSVljUlJWamZ2dUZ0QTR5dDUyK01KNkVSQWRjZjRIVDhjYUZQRmNubUI5cWxRVU1jS1V1ZXV1YXpQelpQUUl3RnpvcUM2WXdDYkM2QlRvT1FkQ1pqSExUaGZhSkI1UEZCSFc1UzhjNVE4SU4wQ0FTMUVRbzlXU25tQmtqb2VxUG43amxweXRVbFNzZU1GbVhtQjBqZ2FpTzRvdGhNVEFQVklwYlJRU2VYajJNYlJBTVlvQUdJeVZiQjJsSkk1WGo3cGFPRGsyMFlVQU9aRVhSVjJCT3FzSUJkbUFoTEx4MURCN2pnU2k4bVExTWtnUmVNQnkwY0JOMTk2UjdPVHh4ck15UVIxTE1BS3RhZVRTcEMwU1FhVGpRSWt5d01KZVRITmZQWjZ2TUNjREZESFk3WHVPTWNtVFNJbkE5QkM2amJ5WTVHakFacy9sRFFlZUVjS1pxR2xmSVdDZXJRZ2oyV25KODJlVHFiS0xTU283QllJM0pHUW44bVEwSW1TcFNNQmVyeDdUSm5LSGExTWpoVUFMaThRdUNQeE15Y0wwSW40cVJNRnVoQXdwOHh0S1FUVXc5bmJ3MlhkNHlpbGNxTFYwNGVUVmh4R2JmSUNQaDh6TUk5MTZBOG9yRmhuSWdHQ3lWS3pFd1YwSWdFSkZDaU4wekpqZ1kvU3NQbGdUcVFDYTZLU2VLd0JQVkxKUllISHA1M2JNaEhtVzBpbjRFY3BpV3lTQUR4U3laM0lzV01pcWRveDZOM2p6U25BanlJK1BKMEFuUWhBL0NqdlBhVTJGT05JV1NIZ2pqV2lVeWpBZkpMZjRValA0WlBRaWFZTm9JV0F3TWVSc0tOdFREYkowbmtzZ2YrckFyU1FGMk5UK1BMOHIrU2FFMXIrdndBREFDZUpmZjFxcW9xekFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMjAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dRalV3TWtGR1JEUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1FqVXdNa0ZHUlRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pCQ05UQXlRVVpDTkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakJDTlRBeVFVWkROREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtMMzNJYVFBQU1kWkpSRUZVZU5yc2ZRZWNYV1dkOXZPZWMyNmZPNzFQeXFTSEFFa0lKVURvUlZRUUVCRUxzaXFmNHJvcWxoV3dyS3lyZ3F1N3NwYlYvVnpVUlhGWFVjUU9LeUJGRVpCT0lBa1pra2t5dmRjN3Q1M3lmcy83bm50bmJvWnBhVUQ0NXVSM2N1NDk5OVQzK1pmbi8zLy83enRDU29uNTViV3pHUE5OTUEvby9ESVA2UHd5RCtqOE1nL28vRElQNkR5Zzg4czhvUFBMUEtEenl6eWc4OHM4b1BPQXppL3pnTTR2ODRET0wvT0F6aS96Z0w1R0YrdTEvSEtCUU9CZ1hrN3N3N0VIcldyQXR1MTVRRjhtQU1VTUFJcERCZkE4b0FjT3BEZ0E4T1drMytVOG9LOE1rT0lBeks2Y1FZc1BPYkR6Z000TXBwaG1PNVBKbGROc3hUU2Y1d0U5UkdCT0I2U1lCZGlaZ0pRemFPZ2hBZlUxQmVoeFlsSTdXeTk5dlVXT1Uxc01MR2U4MXVnQlZaWkFGVnUxMGpTeGdHdUV4RGpPTldZWUtHS1RCNlhVb1YyUVRTL2tOQ2JYY1dFN0RoenBjWlZJY3B2eVBBenhwMTV1OTJROWRQQWlQZnkrY3dUWTBXSlpQWWNLMVA5dk5MVGVjZDYwSkliM05TekI2ZWtFU2thVFFIa2xFQW9ESmx2QmRRRlBJV2VwY0ljdGJVSWphSERyeVFsOW02eDI2Z3ZCVktEcXJjZXR5d3VwY3VjSVVYUzVyMzhVeUthQWtvZ08vQWVYcFoxSG0wWndCeS85UHdRM2RUQkJGYStsUXV2Skd2b3NOYlRCY1U2S0F6ZWVmaHpPS0lteWtZdUFzVFNCQ3dGaHJ0UWdEWnBxQlFXRUFzVExBYWYyVTJ2SEYzV3NJQ0pTM1VjZHc3WlR6YWUrR3FiUTZxYk85L1dPcXMxakRYNDJEVjlnaGdiNG5RREgrRDNBYXozU2hKWW5lbkJEcjJYZFBCMm8reHFIdnV5QXZzUXNUdVBVMUd0UWRPTlVsZ1ZzMDBWc2p3cTJRUVYvcTJKN05CaktUQktYZ0lreU5seVlqVlpDQU1LOHZIcWhrTW9yOEVPUTMwTUJLM2RQb3FGdXIvSFFyMjFva05RTkxTSW5MQU9Cc0lsQXlLVG1Xb2dWQmFpdDNCZmdSU0lCQ2tNQWtxZzdXWnVYNG8xb1c2WG4rTUFTTWMvTlF0OWV1c2ltazVDTzV3dUI4TFUrVEd1UXBEQU4wUmhYOHZ1NmFtQkxOL0RqSi9DL0pjQzdtaXlyL3pVRnFISldmRitUZnVhSzZnQXVhS3pIbVU0YTViMXNnQXFheDdBeVdVYitSWDBYR1FyNWpaVjNsOU5kZnZKcnF1L1piTTVjT3I0R3FTV3JycXNBNE9jTWZ4K2d1VXdtYUxJcmxiWUtETHNtM0NBQktUZTE1dmsybUlCU05WVmJLbzFVR2k0MDJQNTkxQ01wVFZmUEtIeTVRbnUvLzdJM3ZoWFkyZzU4NXJkb3BXOC9hNGRsN1Rqc0FjM3ZJVk40WDJVUWYzL3lCcXhXNWxFMThpREJEQkxJZU53L1J2azc3YmRjM3orcFk5UXI1UDJjWlUzNHVwY0FtZHVmZndTdHJZWXZKUG5yS0RPcnZsTlp0ZmwwRlBBWmdrdWY2M0ZiRnFNUThaam45Z0NqZks0MVN3VWk0WnpaelpsWXk1SWFiS05nbjdxbEJqdG4xaFhBUFh5M2dUYmdoa3VBMy80VitNSWZNRVJOUFhxN1piVWR0cW0vbkhsZFJEQy9mK1lhbkhQNkNUUkp3d0paYWNHaStWdDVqRVdpSXJTSk05ZzZhcXMweGVJK0t4RFNEYWw5bnVlRHBVMW9YaTJrLzFIbWZGdWVWcnFPclUrUThIMmg2MlQxd1lJWHN6TnBPR3hFbVQ5WCtvMnZOTGU3ajFzQ1MxbkQ1YWNEcmIzQUR4K2s1U2dKb2pocThYeGZKUzJsamFaUGp4MCtrTkpXai9zZGQrS0JiTWQvbmhmNDRzbGg0TlpQUnRBMWtpMzl6aVB1M2VzYzU4aG5sVlFjRHFTb1VFUFZDN045VHFmMStjVkhMMTFkY2RvR0Z3ODN1YWhkdVFhTEdnaXFiU0tkTVpCT09UUjdXV1F5RHV5c2kweWFQa3g3SzVvL1plN29xOVErajQxblo5WG5MRUZ4U1hJSU9sVkZmWGZ0dEJZRzljOXpiZDJ3SG4yZFIzdnIybGxleTI4SE81M1czeDEzUXJ2enBqMFM4Y0hkMHdVTWsrQzhlUjM5NEhMZ1gzN0wzMnBLOGFaVHEyR1NHaHZLVWhqQzk5RlVmY2w3Mkh4RzlVeWVGSHBmT3MwNGgvdGNLYlNwdm5CVEJBc3JCYTc3VmcvdTJwYitTYnRsdmZPdzBsRGhrNTZ6YVhYKzk0WVBuMm9kdWJvUy8vRGxSMUJaRlVGdHgzWThPSkppUTdvMFU2NXVnR3pHNXFyaUFvY0F1U1F0U2dNOGJUS0RnUWxUaXp6cHlaRVJtUXMvbEprVU9RWmJhSXFsOENtVVpxZzVPcFVqc1hteU9yNG9zNXppUTllVzB2VFM0ZDJ4aGFhbERyajVLdUNETncvaHYrOGN4c2N2Sm9HeWZEOGNKcUVLODlrQ3ZHQ1UyeUMxMWpRREJKMkN4b2NLME5JNG5vbmhoSWQwWWhRWllURVFWcFlENXgwMllZdlMwSnlaM2RnS1BQemxENTlqWEhIbHFmalkrNytLaXJveFJBbVFzb2lLRVdwZmx0TU9LMURnODNKbTFzMlpyYnpKOWVUZUFPU0pqOFFFNmNtelhIWHR2TEhJRXkwZFlsaTU4R1JTUGtnVSt1U2NPUitoZVhuOGNlQlRyeWNWTHdjKzhGMmdrOCswYm9uUVdocmlNMGRJb0lnallpRkpLczR0M3l1Y0ExemRMODdmajFvSUxRUmZ2aDI0c3huUDFnS1hQR05aelljTktlSjdsTzBDdG4zNGtvMDEvL2oxOStMeWN6K0p6RWdDUng0SkpGSitvNm4za0NnSStxWGZyQzVWemxGTVJTcWZhbWtUYWpGMlVYMmZKczJyU3orbGozZWxObVdPTXdHbytzMWgyT0Z4dFcyUFlQdStUYVVVMVBVTncvZC9waUgxZm5WOGpzU09tK0E4QWN2bTJybVRsTHlHb054NlRSQmpCUGlxYjJjeDVDbXJJY2FKbUtHRmpzL3VCQkVOT1RUSFVzZXRyZlNkSHozVHdmdlBBYTY5aFJyL0loNG9GK0oxTzAzVHljZWxoNFBKTmNrdGZuYlJHWnRxUHYrTDcyRncxM2FzTy9WY2xOUFVPbzVTUFQrV3N3SkJOcXlIS0cxVm1QRktoS0llVXZGZ2tENkk2bWlTZ0lTVTlLdFRuQlNFbCtieFBvMlVXbDA5SFErcWE4bmNaN1YxeUVhVUNWZitUUHMwZm5hSmx1djY1eWwvTENnb3l1ZlpSRTM1N1F6UDBmN2JsdnE0TkUxK2tqNWJDWVd5R0lOSkQwMGpFWng5VEJEWFhUNkt6Lys0WDV0YWxieFF6NmRXeDdIMEkxazBCd2FmczNzUU9IbWhqWGVlQ256eE51QjJnamxzV1djUEhtRFc2R1VIbFBKMlNkQTB6L25nKzhyZ2RmNG5rbTM5K01RblNqV2hFZlNQYmpxaEthbGl0RzU2R0c0Mm9TVmNhWVpMaWltelk3N2dleXFZOXhtalo5Z2tRQ3FvblBDZElwZkYwZm04dkYyR245SlRGeFFCWmZMOERJTW9ZTFJ3bFZrMytUd0Z2eUYzUG4yY0ltS0t0WXBjaW9paXA0SHFZY0RhMFNLd29kRkFRNUZBODRpSDZvZ1l0OVdlc2lTV3A4T2hNWVkveGRUVXoxN3E0YlkvQS8rMUdWdWxhWjUzTUhwaVhuYVRlNndRQzdQQytPRVJqZDZaMTN5QUlVQVJZekV5eHVLNG55SlRwa3o1Ump2bis1VEZHUnZMaFIzY2tjcjRvQ2xsek1laWViK1lid2IxdS9vTnNpRFI0Qlg0MEVsOUl1cGpNSmZtMCtFUDEyaklqMFhWUFgxQzQydGEwSmhnNkNydnE4S1BKTjFFUmR4UFVOeDRCLzFxSjMxS2lVQXc3TCtUcEhEWVdWb1lranhCbGU3bzlmQzVOOXVJOGZ5cmZvcmhtQkJIdHBobTk4UlRUcVNNWC9VbWwrL1hHcExlV1gvZWhYc0RQOERaWC93Y1VNM0E3cFpiZ2Q1K253UmxNd0xwckVRbWE5SFVLVC9vanNlVGVhQ1FTOStORTVnQzlpSXhvYW1UT3l2RlZKMWZ1WHlyS09qY1VzOWhpQW13SVFNNjkxc2NkblNJbzlLSkkwbUJkUXM5WE1HWU5FR2grK0l2Z1Q4VGx2cHlBMmJBZDU2S0E5Z1pVMTlIRWJ2Mlhva0xOdGhZVkFWODZIc2tRMEpjUkREN0NycnBEcWpQOUdVSE5QK0U5Y0M1OXpiaHNmcnY0cmd2WE85bmFINi8yY1FTVWtHaFlqa1NCOWNMc09FY1JFTHUrSG41dWk4eG1Ya1c0bU5Pc0ZpWlk4RGo5NTZoK2tmbTlFTGtWQ1dmaDAweUZrNVJ3OFNZZ3pZQ2EvRDVNbzZCN3BTTEM5WjdXblAvNmVmQVE0eFBhd21tb1Zoc09LaGRDUCtEVkd5ZHp6UTRKckN3ek1GRkc0R2JxTWtkanZqc29HaytPZWwxRHMvdU0yV0phZ2pxYlEvaCthTnVSOE1ucndhMnZ1Q2hyY3RDZGFVeXNVTDNmaWdUcGNJV1dTQzNvZ0JSa2RQR1FsQjFMMGtncDYxT1FmY1hKc0RkNjFxRk9FOENYR2xwS3FzNlNGMkNvb2dUMlRYVmVYZVhodytkNHVETkoxTFRHSzdjMTY3OG9vR3M5TU9zZUVVbEVuMGQ0OEtWcHRuTlpEeTgrL1VTZjN3YXVMOERmeG0xelA4N1JRZjZBZldUdm1KMXVia1lmb2h1NXMwMzNVejZUMVAxZ2ZkSVpGWG14aE81SEt2dXhKcklrK2E3bzB6ZmZDbHRKUm4yZlpVNWFiWDhyUVkzWi9yeWVWcTk1cTZoZ0I4LzF0aDdWZnVFNGJlelN1V3BCMUgzN0NJVlhiL1F3UWZmeU5qeFo4QzliU1lXTlJoWWUyb0VGVlYrYjBvb1ZxK1QrenJHRllvMFNWeDh2S3ZmNVhzUEM0ZHM5KyttcUlnNHZEdTRGVnlsNUJBZEVwKzg4U3Y0MS8vNEJuREdpUzcrOUtpQmhXd2cyL0VkWjJHZjVMZ2s1a0FTQlNLcExGeWUrT1NUK0lxbE9nVzlIcnJ2VTdrM3l3ZFQ1RXlyNTB6UzN0dzliTWZRUW1VWWpyN3VhRm9nUWxiOXVjc2tmdnNvY0RNTjVybHZxa0p4Y1IvQ3RVdXhjazBEZXJ2R1VCUU5ZcVJkWUd4VUNTbHcvSEliSjZ3RS9vMm1scnp1eTRPRzBUK0Zkb29EWmJtdmVPVzhha01LOWRmdTM0Ry8zazVTY2RWN3lDckRyczd3S0wrVDczcWF2T3BxQXNQWE1vdGFHb3BNYUpwYTg1cXJtR2RpeE5mczBWRWZiQlVmcW81dTlic1Z3bmpQeU9SN3FHdEw2VCtFeXBXclhQRGdzSU9QWGVEcDBPT0x2d0dPMjFnR0t4cUdheXlDMjhzRFEzRXNYZ29zT3FvZUYxNzVMc1FyRjZCLzFFUjUxTU9EejFONkI5RXlHalp2emJXOU1RbkkvU2toZlhVQm1qY1RiTjkzZmZNSGZoWEJaUmQ1Nk9wek5TakM5SHRhTkZqVzNpYlJjeWEwTVJEMlFjMzNPWTdRTExhMlVodklQajk4L1hyOHkxMlg0RzJYbGFCMUZ6QThERTFVOVBYOS91aTlUYTJWTThmbVJKZ1Q1TEh0ZlJKdldPL2lsQ09CNjM3RTBHUlpNVXFyRklOZEFpa2E0WWtVM0w0SDRHWXNPTU1wUnF4UDRPd3oyM0RaSlRhYWVFL0I1LzNZS1NpcmN0MXJZa1V3cDlETXc5dmtGcHJlRysvRGpnK2ZoVzkrNDl1NCtycVBrMlE4NUxMaFRVUmowT2s5bFk1RHp2Y3BBSVpwc0xKcEVwRnlDa09GWDk2aFRLWmluRGExNTVUWGxTRmFXNDJqam81aDQ0VW13Vm1HLy9PbDQ0bk10OUhhbjBUejVnRWtrZ1RWOEdOZUJhNENVWm5pY0N5T2JES3Bzd3hhV0hqZHZoRURkY1UyUG5RKzhBMWFrbDB5aUkzTEdjSll5eGdMOTlLc0ppQVl2QnFwZm1wc0Z1Yklrd2lrc2loZnZoR0xUa2tpRm4wTzdkdUE4NDlGZkVFNTN2K051OXhqMmozeG9ZUmg3TUJMS3c0UFg1TmJ1SkQxZnZhWFR5RGJ4RmQ4N3pza2hrWTkzZThaREV0ZmF5eGZDMVh5WWRtYWNwenhsaU0xaTJ6ajhXZGN1QkpuWGJwTUIva1h2ZXNvZk96bWkvRHU2NC9Bc2Vldmd0Tk1acnFkOXRaYWczZCtZUm11K2NZYWZQd3pDK0h3MkU2eVUwWVlTRkU0aklCLy9ZYWx5eWs0cnErbEtvNGtzeDBkZGZDcFN6dzh6WHZkOGd5dzdwZ1MyRlkxc3U0UTQrWk8ySFl2bkd3S2p0WEFiWTlPUjhyZ1FtcHJHWnpPU3F3L2VTTXUvcnUxdUhNTFVFY2h2ZWtLSExlKzFMdW4ySFhQZmMxcGFINzUzSDFJZk9JczNQVDE3K0pUMy8wYXNPbTRFSjdlNHFLaXdpY3lxZyt5YnpjYjg0UVMvTU9QcjBSeFJURzIvLzVQMkxPdEZXKzQ5aUtHRjMwNCtkUUtyRDZpSG1acUNISlB2NDU0UmZsYllkZ1B3dW45RnR5UmRoaXg0N0grc212eDBlSHJLUXhiY01wYjErRFpCM2Zodjc4L2d0NCtnYU0yclVQemMwOXJNdzdQWUNqbDRzb3pYQ3l0QTk1Q3Q3RGlpRHFZVWRQUE96TW1NZ0w4Ym5sK1pZSlZ3bjE5M05aVHpUdzQxRlFqWGdsUnRRbWhvaGJVcmRxTXUvOEtYSEVDOEpYTFVmeXZ2NVkvdmIvRnVYYklzcjU5VUxvbFh5MDFSWisrejkvZWVCWktxRFNkWDdrS2tUVXJRN2pwbHNVb3NwcVFwSUt0UFdVbFNoWTM0dGlUSWpqNk5KcTczU0dJNVpjaFlOMEY4OFVXdUtWdlFTcitFTXpoYmtUNlRTU0NLK2pYZHNMS2hCR3RQQnBqQS9jVGhBWkVBaWFNNHFWdzNKK1F4YlpCaE44RVVYRXBkajNXakV6UzQvVnMzUFR4THpIc29KVklCTENreE1YbjMrWGhDNlF5djJ1eGNOeVpLNGx6Slp4TXErNFVzQUlSaE1JbENMck5pTVliRVNYRGpZV3lpRWRkaElJU3BURVBJWE1RWldXTEVHOFl3ZWFIdXZIRTdVUDR1emY0bFlIZnZndjQrUlo4YzlDeXJzbm5OQXBTZi9Ld05ibHFlVkxLNFRqd25XLytKL0QwTXhrc1h0eUFwOXFyVUxwZ01hNzczcVg0MitzWDRkaE5wOEhvWHFUcW9PRjI3MGE2UFlpc1VReHpyQW5oL25MWUhmMXc0bSttVHlzQnhsNmtHYUo1WklEazBjOUZTalpCaEdMSTlEOUZ3clFLbnYxV3lFNGJScUljSzFmOEVlczJockhtekl2dzZlLzhDd0pGeDZKL09JTFNpSWM3SDRNMmw2dlcxdktjVVpwU2FycVhvU2FXMGFlclRvUit1RllkWEpkYlo0akg5T3JPODJDMGhpYTVGeUVHc0o2a2MwOHR3NG1iNHBEMUFyYzk2UGVYZnBUeDdIdlc0K29heC9tdmc1Q3dlVlV0NHZ3alJTUnQ0cGpUVHdZV3J5cEg0OG9NYnZ6V0YzRWgzeGlpRFhoK0Q0bkhTZ1JycjJMdzdpRFk4MU1Tay9PUUxGcUQ1UENkZktGVkNJY1oxSHZkTURJSkVxVkdtcnR6NGFTYkVESEpSREdBc1pGdGJPUVVUZUdWYlBDMVBINEVnYTRiWVhTUUFqdThUKzg5MU1xYmNkVVZUK0pqSHhyREM4TUMvVVBBdHhoU09lMURTQ2I3NkFMb0o0MnNwcjhHa21UaWRNZ3hCbUJXbXZmc2dJd3ZnaGVySWNBZDNKZUZZOXJjMzRwTWl0K2o5ZmpnSjVkak0wLzUwVDErUGZCSDNrQ2F2eGJ2ckhLY0g3NW1UTzVObDZKcXp3aCs4emRuNHNSMzhBWExqajRWdFdkZVRQOUhLaXZyYU40b2Y1a01aTG9YSXNCQVAvVUVrTzZDakoxQXJlaUdrK3lCRTF1T1lQWUJlTU9NVjRxTzUvZWpFV1RqQzFDelNIS3luZjlNMXJvQXdVcjZWVUZBVW94dFNodnBiNitGakZKYks4K0YyLzRWaGl0UmlQcFNJRzdqem04OWlqdC9BbHh6RVc5UDhuVDl6NEZ0U1lNeFpraG5OcngwR3FHUVJkUExjNml0cWk4MEhvOGlSQlpuMkNPSUJpU0N3dSsxSWVkQ0JRMUhNWW5SODg5SlJFand6bG5uZHdDVWM5OVhmdy9jMDR5dnRmcm1kNTlON3F1bWpGT0dVTmVSeGYyWG40WlYxMTBOUFBaMEhHdlBQUW0xeHl5SFNLeUNXWE1WWTdzL3d1MjhCYkpvTmIzTVRqS2s1eUVxTDlXbTFlajhCVUZlU3dwNUlkemtjL0Q2SDJLOFVRbXYrblgwWHlIWXZXUXo3Z0FWaUVRbXZCcGUwVUo0QXovVUhkb3lzZ2JlMkJZWTBmWFV2RFNNWkNkOTdKbmFORXVuQyttZWU5QkZBSisvcHdNTDZNc2JTWTcrK1E3Zzl6c0V5cXNOWFlWb2toeFpiTXRRMEVCRUZXb2J0aTQzaVVXaWlERTJpak9raVlWTnhFbXBvMFF2RWdxaW9TR0dXRkVRS1RlSVFDQ0VwY3NyY044RGJiajZob2ZjRnNzSzdBK2dyNG95VHVwSlRXOFdEN3o5Rkt5ODRYcmdoL1FrellsYW5QZXBwUkJEYk9UU2pYQ0d5RWhTREVBcjM4enRMeUFIdGxNek4wRUdxdG5vVzNtaEZ5bWRjWWlSWHlBZ0RRUVdmUXllbDRMbERFS1N3T2lTdEpGZHlOUjlBSExvTnNqQlhkUkNCa3FoV2dqYmhhejZJTHpSUHhHY1V2cEZhbmQ4R1RENEM5cllLQzNrRlZpMmFBRzZkbjBVdDVLTGZ2Qk1hdW5ieUovdmt2alI1aUJXSEw4UXNYaVE0VThBMFVnRXNSaFhnaHFMQlZFVUQ2TW9ZaUZlUkdDSmNFd0JHL0VyTUlMOEhDTFladHBtSEoyQXVhSUsvZmNNcXlmdFB5ekRsaHlZVlQzQW45NUJNSysvRG5qaWNXcm45Z3BjOXRGaklSeWF0QVNaS2VOUU1YQUhSUEg3R1hlcWdpT0QyK1ZzZEI0VDVmYzJPcUxTOXhEWUhYQlRlK0NLQVhodHo4QmMrRTh3Uzk0SUwvR01YLzRYWG9oZzZsR1liZ0Npak9HZkVkUjFSMjdmYmZwcHBMUVpmbFFydFlJOWVCOHl2VStpcVBiTk5PVnRDT3hzd1FrYnFqRDZONzI0L1ZmQTI0OEhybndkVUYyU3drMTNONlA4aUFhVTBHWUdMWmZtTTAyeVl4RmdrNThGd2lHRFZrTG9XcUtRWmVocXhZQ3FNMVpoRFI5LzZZSWlyRi9MTUtkakJMdGYyS1VLTHdieWJiUmt5WkxEQTFBRkpoKzh1aGY0QzhGYy90bHJnUzdHSy8vOEZlREQzendONTE1ZURPemlFZEdGTksyUEFpVm4wMlRlU3pEcGdEeHFWazA5d2I2UFdsaE1ocGxtQ01LdEU0WkJoaEdJTFlGci95OFo3azU0VmlWa2RqdUM5VGZBSXhuS3BQOUU5dGtCTTdNTmdXd2JqTktMNlpzSFlZMDhBVmw4S3R5eEYyQ0pKSTh4YWM3UHA1QU1JdDFQSVNnN2x2Z2ZnL012YjBaN1J6ZHUvdjBvUG5JSjhQcGo2ZnVLSFByVlBXaU5DZ1NDZnNXZnl1dXBWWUZvaVluYUlpTzNYeGV2R0g0djA2a2JxM0g2OFhVWTd1N0I3cDM5Q1B0RER3OGZEYzExSUVlN2dJY3ZQQWJMUHZFUklEa0NQTEtsQnAvODJrcWNkaDREbDFhYVYxdlZjcGI0VDJtUjhuYzlTUC81TG5pbEREZkcvb2VOM3dNM3NaZzYvaDZJNUVOc2lGcHFaQjFTdlhjVGdQZVN4YTZEM2Y0dFhxTUlkdi85TUl0UFpJeTRtaHJYaEF6RERYZm9selRUTlRBclNJYkdIb0F4TmdwbnRCdFdKQVFydG96QUJKRm92UU1sdFNmRFRuWFN2Tk1xSkJiaW92TTdjTjBEQXI5OVJPTGlUY0F4dE01ZmZUdncrVjlLSlBtc0phWENIeCtqOHNXbXYxV2tKNUJiRlpCbXJwNVlEZkZZVEEzMVVvUG9heDlHeTU0aEJXaHpjWEh4ZmczZmY4WENGb0w1eHpOWFlkbDFmKy9uWi8rRGNlY1QyMnB4Mm51UHBQa2tpQXNaUHF3WUpDVjhHTEloRFRmK0dKeWFNTExsYmJDRGo4QXAzd0M1dUpGNE4xUDdqa0NVeDVqRlR5QVo0am5MTDBLd3FnNVpzUVZtcVEybllSUENSYjlGMXJrWjZjVFhFVmp5QnNScWFtZ2VhYnJqYmZEcWpvSlRWUUhiM0E1UlEzTzc1aXFTcVlVUVJhTmtzbXpld0RBQzRVNkVWQnN6TEtrNTVZMjQ0ZXNsdUdzM2NQdWZBVFhXOUtnbC9zQWpjMEFpTlNyMzZyL05meTRjVTVQdm5sTm9WY1l0TXZFRVduYjNvQ2RocTM3aUZ5YkovNXhUZzY5RVRSRm9abis2T280VHIvbUluMUR2N3ZLN3NzVGdzN2pueXp1UkRWZkJTU24vb29iNHFjN2xwM1ZOVDVZYUV6QitUU25QMEU4dWdPY00wd21yMXZvQ0c2bVRjZUVJRzZpSERYVWtGaDV4QWxwM1BFaE5Kc1Vvb3VrZFZFTWN0dWhlOVdEODE4Z09OU005bkVXOGpENDNjak1TZlgrQkpLR014VG9STExzVnFXRnE4VkNQN25GeDBsdTB4Z243TjdwWU9sNGVoWmRKWWlXanFUNTZPMVdvMk1KdEkrWHdtak9BTDkydE9tR0Y3cVpUbFlYYTlHcVQ2NDkzeVJkWksyQkgrQW9sWVlaZzJXSHMzRGtBaWlQb3haOFBCQUlpRW9sNDAzU255VmNOb0JUbWoxWEVyTGQ5NW5QRnFHMTAwZDZpQmpEYmVQdmJKVEtqcXNzcmdkUklBbU5zSk52TmRVcGJ1UW8vTjlmYnd0ZTBrLzErUWJYblM0a1Y4NGMxT0tOZERBVXM5TDM0SWtZNlc4QXdFTUVTLzk0TUVXSEcxUEYvVWFVK3VxZTVKODFBMys3UWlmbGdsRnpZZEdGa0g5TDlwTWhWTWFpcWRxWE5xckZDb1pBV2puQlJDZDczZWpWbU5JZ2t5VnZRRENJVER1UDhFK040YktRWnYzcXFDM1cxcGg1UHFycnFQRDNrVU9qeVR5Y24yS3BpTUVTSmlRY3k5Tk45YU40OTRvK2RzcXhucCtnUGxYTUI5bVVIbE8zN3dYV05EVGo3azkraVgwdWo2Q2lHRlE1alA3YXdteGxDbzY2cnRFbGtodFd3SXAyVnQ0bTB0Qk82WGxZbEZ6UlB0RlBVa2hGVjgwNWxjSFNSdEVtTkRralZKVk9PVktZZGxsZUhnQmRBUm1SMGNYYUlEYThiVk5WaVdrR2RXTGY0dTZGSGNmTTNJdXFvMm1CS2l1RHZxdGhiRldHYmdTaUZKZUQzRUFSVjhvREFVUDJFR2FCQVNSVG5TZzBOeTBLa0xFS0xjQXVmdFFPVnBYTGNaMW81WCtyN1Q2a0pVc29tb2ViN1ZBU1RhRzkxc0lQQ3pidHM3YTZvNkRFTVk2b3BjYVlxY1pPdktLQjhyMTFqeWN4S2U0Q01NRnpNQm9rd3FMWmdxTkc4TXVCWHVDdWFLQXcyWW40TWhPMDdFVjFpbEovc3dJWGpKTGlPNmRIVGVzeVJ4YWFsbW1ic1lVUzRQMmhHRVJCaFpHaWFIVGVGb09GL3ArZ2c0NDdxNjZqajFUNVRxYWdlYisvbnhiWEFPSDVOckZUVjlxb1FuUHRkMjY4Nms2NmpoeUdhVUlWakxoS2pLVjNhT1RnaXNldEYrdHZjK0ZKVkM2N25hOGhaRXFXdHJ2QnJlZ2RwTVJwS1hWUkhodkZzczRlMlB0M1IvNGhOd1pCU1RqVmppcGhOVzE5MlFJUEE3cUhlSVhTK3VCMkxsdGZwN01xdXpUdnhnNi85QktvVkxNLzN0S3BTd1JCcTdJcXFjUTNTOUptNm10Nmc1cWdoRFdaSStGMVcramhDbEExUTA0VnVPVE9TOGNlQlp0Z3dqRm1Ob01QemJHM3kzSlFmZThLMGFXYWRYTDhHYllFdDRHU2dOVm41UGNkUlF5WWNYYWltaGgxbVZjVVh6M2RjUi8rbXIwOUJTbVU5TEtndHhydXYyRWdCTXVneWh0RFhQWXBJYU84QnYrTURmM1ArVTdrT05TeFZsYWFvQVV0N0dMNG8vMWtzeE1OQ2lLbW1scHZUbERpdkJLRE5BNGswdWxzNnNHaFpPVXcyYUJmZjVybEhYOENLbGI2ZnpCZFQ1d2NJamZ0SytJbHM0dXdYVStjVVNqVU1yYmIvUW9yMHhQeFhUby80WlNwbU1MZFBUdXp6Zk9zNVhqU21ycStIamVaSGNvc0pmNTJ2SEpSK0VlTDQwQXpWK2EwcS9JYjdCK0dtMTlLdm10aXpzd3ZkYVFjMVJYNVlvdVBPSEpnYURkN1l5WTJVTTF4L2FLTE43eTkyYUpjT0x4QjRXRDA5U1pIRTFITUdUbGZxcWIrLzdJQ3l2WnRKYXRIZTNJN2pUMS9PT0RKRHFYTEFLQU1WTlpNY1JLNVFlcndDM3JmRTR5dHlROXpkVEFHTERrMEVZN1N5MnV3cEFUQnp0YjFxV0wxclR6U0JFZHpiaU9raEY4N0U4TVQ4ZmZNcGI2K2dCbGlISWdSNzJjSXlXcFlFWk1wa0hOa1A4am1VVStNVmV5K3NCRE55eVFWVmVaR3gvWkhnaTZ2SThpa1VUUVNVUlArNWdhcXFEc1BYVUFOVFQxdzFJNmd2TzZCOGd1MXF1MmRIT3huU0VJTjhXd09xTkUvVkFxbVV0RmNBWXY2SnZWeVZId29ISUJsKzR3c3hNZVhNK0ZCOGIySThETnpjZERPNW9ZQ0ZvSGc1SCtkcno0UzJTcmVnSmVYVWdwWWZxbDlWRW1ZY21jVFlrSVBtNWtFZHBoVEZDVkEwQjJDdXhsZUZMUUZWbzZRMG0zUy9qdHZhTWpZSW02S05ZVTlVaUFjZDAxUWRKZ1lteHJsZ1gwQ2RNNkQ3bWxPY2Jxa0FkdkJwQjNidjZDcTNDYWpMMklRUkp1TzVNUGEwcEhWMW5abVRmdFhZbGpuaGQvS05XVmlSbC9kTHVzRkNma2xuZmdTM25acG8rRUJSN3JYZEF0SFBDWTRJVEF4MnlnK0h5RTl1TVc0WnBnanJsYWFwQ3NKNHlJUGxKdEJMMXI2amVRUnFhR2hadVc5eXpaeUpGdm5VWDI2ckJsblZzVEVxaTRIZlBlNG5iOHRNOHdHdHlFTElHV0xObVRUMEZVbjlwWGpUTFh1YWUwOGQ3TzVESkdMQ1NZeGc3WEVyc0h4REk4WkdzbnJzaUJwKzc2cXVMVjFyN1JkY3A4bnpVMk1wUFhoSmhRdDZ5S0JuYTVLalFoekR5bzN6VkdORStUMllFVG1mNVpCWStlTkRzeG1waGNqSjlVcDU2bHJJRldiREowaHFVTENkdjcvbnQ2SHJTSDNQUXUxV1BqNmRGaWlOcU1UQUtOcGFFdWpzemFBMDdLZjQ4aVdnSXA5VXlBdWxxU016TEs2a2h2TWFUZTFhem9iR1Nrc2YxckpzS08rSzZiUjBLbUlrWGdtV3ExK252N0VSMGQyN3QzUjJqSnk2ZTJjSDFOd0tFUUlSWm5CZEhPbEZTZERWczVNb1J1c1JDQ2MzVkZxNUZkMHo0dGdhSk4rZlNZS2MxYUJJNFFPdmdGQ3ptUGhqWGdnejFTeWp4aUFLZnpTMnF3YnRxc2txOG1OTHZZblp3R0Q0STYzMTlkVkVVdnFBQ2Q5WkNLWWVaYzd2MlZFRFphRXNuREVIdTF2RzBFc29WbFZaV0w3RVFuV0ZoU3F1a1hBUWdaSktlRlRYWkRxRnpzNE1LbHVUYUdpZ0FQUm5vYnhQUklpSDdGZ3NDejljeVlNNUc2alliNU83dndCT3RWQ0FOL2V5UWR2MjlHTGR5aWpDUVluQmpnNDgrTXNtRkJmbG1DeGVhdmJ5RTJJVStqVmh2TlMvWWRJeFJyNkxJOThNOHFWK2NkeHY1K2N5a2hPRG9xU2NHQStUYnpwMWJJcnNwNHgrc2l5WW9QK1VlR0szeEJjL0VNWkZaMFFRSWtrMTFVUVJZYjZRS3FXUGM1dWhQd2pUemxhSFZhb0w2WTZkNkdzYlFjV2ZYMERMTTRtN2JWODc4OW8zSGFoeW1zVENJV081czA0ZVRHMTdNcXZpengzOWNFNnNna210Q2dkQ0dDTlRWSFd4NDJOQUN4cDBNa0daNjc3eHp3V1RMMEpPZjM0aFdacjJXam4vT1RSS2hsdkZPREtReEYvYmF2SHB5N3BRdDdRU2JidFN1dGhYbUxRNk5TYTg1dDF3R1orRnErc1JEcGRCOUpzUW9UcCtObEZkc3hXM1BuNGUxcFQ5NGI1SnpMWVFUREZGUEhySVUzOWlEdnYwZHljWWZNSElaQWFhOW5TVTk2ZUhkYUZOYVJuTlZRc1ZxU28zbXlWbUJtbXUrK1FVd3dqbExHRE45bnYrVFZURmZYbE1vb2hrckhURkd2UU9kQ0hkN01JU1JxNTN4VmMwd2VEWXNEeCtWMk5mTGUxRXBmTGRkQ2VTd1hBMjQzckprcExCWEQ1QlROSlFNVXVtcUZCVEQxcllNaE9ZZXZ1V3RZbUtvMWQ3NitwcXNLRWlYblRNWjc4cWdxM3RhVFY3RmhiV0F5VmtoU09iL2RCRkQ3TXZHTktYWjd5eWNCaTlMSGl6Z3MreVVCTXg4Vm5LbDdaR0lVQmlDa3N3MVpyM3BXbUNHZVk1OVF3Ny90UUVOQjc3Q0JyUHFVWDN6akdkUGduU0I0ZUl0QlJCaEdPMUVQRTRMVThJYnRxRldVbGlsK2xGeHR2Qmk1TGgvMnlYblJ2c0w2ZGdzVk9OU3B2Mmp4UlloMWdyeFlhU3hCdXZmc3ZZeDFldWlCd252RkE4SEE3QUxHL0FtU2YyNEtjLzNva3VCdFRMRnpOdWk2ckpKQ0xZMDJscElxUm1KN0Z0VjdQWFBHa1JCU0dFQnRtYitEN3VlTXhKOWtuNG11SlBJV2VNbytkZkswZXVYRGxPanZ4ZWtaeXA5L1lHTXorWGcxb1RoS0NVbDZ0VDRja1I1eUM5L1Y0VW4xS0I2Tm80aHZveTlNRjZZamhrNVREY2djMFFicVYrNk1RZ0FXL20vbVFXQSswcWpWa0Q0OFZ1VjRoRmhabzVYU1pvMW5FdjFpSHluNklvblczODVydjc3ajErWGJpeGQ2Z1kyVDRIa1JJMUdXSUFiaWFMSTFhNXF1ZEZqeEN6andPS0NlZ3hHeHV4NllLVE1Eb3dyS2VjeVdSc1A4U2dEVFlnZFQ1VmhSdTZZNWlSdndwak5OdlVzNHlwZWlBL0YrZ1VURFRoNTJSZFAzekpUMlhqK1NHTW5pSk9CVGl1bW5MT1AwNVBHZWQ1ZTVNc1RIUlFXN2t4TmdZZmZrSFlMOGRNcDVzUVcxdUtyVStOb2E3R1FzeFNlV2FHUDZUQnRwcENKNTJHMHorbysxdmR0SWYyL2pCcWF4d3MzYlFPc1RYcitYdGpaT1dEajFZMzlacWRVM1JxNzlPWVVlc2dhdWM0bUl0QzNwcXZ2TDF6ODRvVlplaG9rd3l3ay9BWVpTZUgwd3hOVFBySU1TeHRET25PNitaZC91UlFLaEJQRFhlaXMrbHBXSWJ0VjkzUS9ocFM2c2x3MWZ4Q1JqYUxrTExGcmdwWDBucitjRDJxMm1UWUUvTFZ5bFZBbWU2NCtYUk5WM2V4ZVVML0QybDZ1VG1KWm5pekFqTTkyZnpxdVlZc2Z4UjNYWWtxRWdPZTZlbkFHZStvUThkZjB4amhvNDk2QnRLREpFR3FNSXlpcU9UR2MyaHVzeEw5cEF3bm5CM1NQVXQyZlJXU1c1OUZ1S3hjL1B0M2x2N3lkVy9kYy9JTVljcTBYV1lIQTFBeGs3Lzh5QWN1dUZRMi93ZUdraVFCVGhKQ1Jka3F2bE56MjdsY0thVVZaSDhybGhlaHBXVlVEOFN0cXFIVTIwUDR5NTFQbzZJOE41V2JtSnI0VE03dm9zQWNUK3NFNU40aHpYU2taNnA3N2NVNmhFL2FWQXA0U2JXL3IyazdnYjByaVRYTFRXM0dVOVRNTVVZZmFpSkpQWmVTa1A1RUlDYTNTaHBvTGNhTUFBVE5ieUMwQmthb0NpdU8yN1B3dW5lMi9lMVgvc2Y5emh4QVBhUTFSUy81aXdtVk5XTFlMZzRSdUNRQ1JSRTRPak51SUJKVFdobEdySDRaZ2tVcmNQVFNFclNxUENiWFdnSmFWK2YzSDViUzNSUlI4bU54Zng0anRVWmlmbTVVaFRWcVZTVXJnVkJ1Ry9SVGZvSGNuSUQ1ZGE5Qnd1YkVFNHBKY1d2aC9IOTY1TFk1c1ZYdGJ4b1Q0Wk95Sm9NMHQ2cVhhQUZEU2pYY3ZtbVhnLy8rZFJZcFQ2Q25YeUl4VFBlUVVLa3REd0hIZzZXNlZ6TGNsNlE1RjM3M2p1dG1ZVVhLWVpYV01YamtDNldYNFlyM0xMbzJacXJhMVFNcjhUbllqRmIwUFhsTDh2Z0x5aEZaVllUaEdGOG1RRWtzOTVBSnFEK1hNSUt4cnExSTJoMVlmM0lNQTJ3UUJhcks0YXJaUTdyNy9Sb2pOUm1WeXBNcTdWVXpZS29oK3ZrNWlmS1RPdVpuc2c0RUpsWjFIYlVXZmxiWFZkdHdidmJyL05COVlVelFTbVVSVkZLSzdrNFBCRmIzSFJnQ2V2dEFrUGhNdlVCbkQwMHQxMjBrcDlVVXNBWFVVRFhiOW9CWmk3Y2VsMEVrTGxDejBFUW9hc0FMR0hwMnpUU2xJaDIwa0NFWmRHSWh2MndoTitHU1Nnb0pOVC9oV0xkT2lNWldMQWxjY0pwNTRTd0ZZWWVVRkUzNWgybVNkamhsa0o2WFd4SWx0WHdaV1V5ZlI3cXU4cTRxWFpZYWhUc3lnTVdHQzVkUDBQU2lML21WRlg2ZFRVZkgzbDFWNDB4V1RzemZucCtTUE05Mjk0b2pjOC9oNWhJVWlxQ1VscGxZc01EQzRvVVdhbGRWSWx4Y29aKzRyMnNNcVRFYkE2TUNlemIzNDdtbmgvWDBNL2srV01Nb21IQWoxMjJuQm5jdnIyVU1TZ3VpQmdDdlA0MW1NM01mSHYxZEJuWExlSjhHaG1IRnZpTjJVeEtadEo5dU5HaCs5cVFjdjFkWStmRnNpcDVJeGFkcFhTQnVJb0R6VHkrOTlMYjdoMzlTRU1MSWZTbmx0QTZpeVIzWDBNZTNHMytvZjlqOS9hYVR6Zk1GL1VncTRTS2dKdDkzcE02bHFqREJzUTJVVWFLWDFwdG9aakRlUnkyb1p5TXRXMERwcjh1VmIwenE0RmFybmUrckxPanF5ditlMzQ0L0VOWHk0ck1GVGo0aGlnaHRzd3FacklvRk1HS1ZzQmxJaG1xcVlaYVU2V2RLN0g0QjBZOHNSYkN1QXJkOTlWbjg3dFp0Mmg4cVRjNERxK2VHNUZyRVoyMnM4czN0L1Z1QmQ3NkxNZWdHUHdiMU1nWmVlSWJhUjVzdkFoWmRTOVJQL0t1OHNnaGdKS2lDN0NGNDZRenMwUkZZZGhkTmNRdlA2ME5SOFJLY3VLSDJsT1YxZytFZG5VWmlDczJVQnh2UW1mNmsxUGo2dTZiWTBPK2FjTm5iSGhsZHMyNFYvcWFtQW8zOG9ab05vdjdZVFJYNUFlTnVNWnJKb0tVOFlwb3R6ZTdxZGpWeFU3RkFlWldKQm1yU0lxNGxpeXJaSUJYYS93MzJqVEVZdDVGSUNmVHQ2a2RYeTdDZUVYcXFqdkJreHNTNTZ3MmNma0lZZlVNUkdLTU96RkxGTk1nczllUkJleEN1cnRZTmJLcjVHNElobEI1ekVySnR6VWhzYWNMYlBuMjg5a1ZQL0hIclhqMHJDdGoraE05c0YxVDZmK0hocERlZUEyOFBZOURUSjJMUTRqby9sUFNIVmlRZ1N2d1kxTTRTOE42TS9xTUVRZlhYZWdaN0VDaXRnVXdPSWt2SG5JMjVDTWF5T0hYcHlMazdPa3QvVmREek85VmZhWnBTZXc5VllrSHZ2MjFML0lYYnR1QWZNTkZ4LzVJMTNwaytOeGdKL2lDZEVGalZHTVhmWHprSFRYcTdyMGsvLzlxenVQdTJiWDVTSUhmVExNT0JxOS9vWU1YS0VuUzJxZEZnU2NoY3lGUWFZOGlFQkxYRFFyS2pHNUhGUlJRU0ZkZVdVbWdVU1Franc4Wk9qWHBJOUEwalZockdra1VXNmxiU1JKZFVhQzN0N2hoRG5HR1ZWY2FRYTBjLy9mMkxXSFBTM0dQUUVLMVZmMzBGR2lyb1gwZnBrS1BEYkloeWlHdzNuSzRXQktzY0ZJZk5EWHlWTzZZQWJUb3RIZi9kT2xobUZ0TlBvalRWcXNFTTJjNmlmN3RhZnVua1kzMU5zdnNjUlBkQms5NTY3ZkZJa0pUYy9iT3Q0MkhGbWhPUGcwdzhnbUVkTW8xQkJQMUprbFYxczVxaFREV3FVZXdpMWxCSHMxNkpBQVZGRlFoa3FDMVBQdkk4aXQxTzFEYnR3SnRPQ0NKOFd2V01nclh5cktXbzI5S0daVWQ1YzRwQlZUSkRWeUgzdWxoSUMrUU9wSkh1M29hUVFVQXBXTW1CZGtUTk1PcXJ5TEwycnMyWUN0UURMaElUK3hIR1RBZW1xTFRrcXUrOG8vM2VGU3ZMOWx1VDFPTWZ0U0NCMWU4bTB4eFJCY3NHR3RkTHRENFg1dkZqQ01lamNOWDg3dXJQVmhWUktBSmhSQmV1WUdnVXhGaEhFdUdxQk5LOXcrZ2FUcURyM29leFlZbUh2cEVJc2d4TDVpcFlwdWhDNStNZTZzdkZyREdveTk4c3o4Rm9yL3JEQW96RlBCT3BUQW9pUGNqM3p1cHNWVkVIaVZXSlYxRVFpM296Z1BpU3Y0cDRzTWUyekFsTXRYNzR2ZWRjSUJtcitacVUwVnBrcVA4dFkxeVRSSUNhdElBQnF0S2thQ1ZWT3FnMUtUbXlCN0UxeTVCNCtNK1F2VzJ3YUtLckdSS3RYUmxIYjlOV2JMeXdITkhWY1l3VVVSdURDWVFxWFdSRGZzaVU3SG9lS1lmbjFLU1I5SnF4dldremV1KzRDNnRyRFFxV0NVTk5zc3pHVjRKbElzTldTdWlFdWhJc0dBTVVsQkY0YkhpWjlnV3JvaWFDWGxFL3B4alVNVUt3S3VNb1cxcUUxZzR5NzVEUWFjc3hOZUdTSy9XMDVwbXhMTTJ6RjV4R1E2ZnpwNGUwQkdWR3Y1b0h0cVNjRmlxMWI1b2tZamFNQ2hQWlhaM28vdjQ5c0FZbEhucytDRm0ySGh2RGoybmhrTFJ4SmdHb0NraFUxRE5rUWdreURCVUNNdXVURy9VblAzYjNJNTEwdGRCazBuUlg0NEsxYnliYVNiZHF3UXB0K3dzaTlRSVJXcGJoUGw1VDVZMno5S01Xd3gvR09hcGMyRkZqZENJV0xJSm9NWHpyYVhXd3FKWUNOQ0F4NW1VUW8vWm5oak1vYXdqUjJzajBITUNVaDZLM1pYLzlLbnFmL1huNmdpdkxHYmk3R09xMVVXeW5FQ3FodVNPbGRhaEpMalhKcTZoR29DYUtwTk5NOHp1S2RGTTNNZ1REVFNoZE5uV2gvZjNiekdjWEgybVViYWdKTDFMQ1VWRVd4Vk9QdXpoMm82a2tuYWJaUVZBbjR0WGZkL0duTmRjRjJZNnBiVUpSM01GZ3lZRUpWcGlDZGNzRHBZOXRPamxRdjdSQkxwZ3VCcFc4aHozZzZoblFTbHdETy9mRTVPSUtpQmQ3SFBSUmNNcGpJWVFqU2V4b0NYVE5FY3lEMHNFdDl0R25Ubm1OcEIxSzdZc211ZWxjNFRWb3RvS2Vtcm8wODZPSGk3Ly8xRmo4MThjRnQ3K1JadmFqZWVHb3BYQTBidzlqSUdFaEd2WW5ZTlRKQi9vdlF6RmlDbzMrZ3dLcExCS0o1M0RTaFFjdVdOczd6Vi85MHovRy9uRHgwYW4xeTJyY1pUVmxzcjYwU0pTckVmbUdNSVNka2U3SVdIaG9lQXk5bzBteHAzM1FlbzVoYXV4REY3ay9XeHluMytmTDlUQTBhMmtEZnY5TStmZjJBY3hYdk9wUEwzYytFM2hnZFdQMnZ2UE9OTSthaXlhcDVLbnRJTjB6SkRxZjJSMTU1RGZQeDM2N1l5Q2c1eUpJMmNIMFZNSlJWdW5tM2xnUkVodnVaT0ZRQ1p1UWlRTVZySjgrRnYvM24yNk8zNjFFNWxmUFJaN0FjL2lyN2d6TkpmbHk1dE9kdE5WckxEUnkrU21yNVdVOXZhbnVvZEJSVGI5K3F1aXAzZG11UnpIRi9QTnowRkE1NTFsUWxpeFpNdHVmTkRZS1E1SXBWbk9LclhuNjR1U3FzNC94M3RKUUxSZVNwRmFHTGE4MkdKVGxGcHZiY2VYWVdCSWRCSEhiN2g3emhjM3RnZTFQdElaYVJ6TzUvclhjdFd0aWJ0Rm4zcEs2OXNMWG1TY3E0VWdrcEI3R2x4Y090VlZtejFPZkhhbGp4RlNHRWNPZzZINnlPZmpNMHFYVzRvdk9NOWZ2eTdtOVE2SmpjMHZnejcvYkVydDlXMit3b3dBc2R3b0Fwd1J6MGpwZG1PSmg1ci94dmRmK2d3bG9JWmhpR2pESGdad0I1TW5uRkFxTE9ZVnZIbWZPNjJveWpXODQxamx2VVkyc0N3ZGthVFFncThOQnI5UVNNbUE3TXBrWVExZm5rTkcwdTl2Y1R1Rm9lcVk5MkpySUdsb1ZlZTZpTjJ4d3psdGNLMnRDQVZsV2VLNFNMSjdiMlROc2JHdnBOYlkrM3g3WStuaHJhTmR3V3MwMjlSTFFDci9QQlVodkJrYUxTWm82VTRMK2tBRTZGeTJkRHRpWlZqSEZGcE9BQldhZlRIaHllWWVjSm1jcXAybnNRb0RrTE5yb1RnTE5uUVhNNmN5c25BM0lRK1ZEQ3h0cnF0V2I5THMzQzhFcVBMZXcxc2FiQkNBbVhVdk1rSGZHTFA1b2NnTk8xZWlUVjNlS3o4NDB4N3VUOXN0WlVueHpCbk5mQVpWelpMWnpCZFdiQmNEQzYzaFRtRngzR3UyY1MvR2FuRVZiNVRTYUthZlFMbmNXTStwT3MzOHVZTTVXTlgvUXVzL21VaU9LV1VDZHJzTzk4SmpDNm5GUkFPeDBBQnB6U0ZYS09XanBiS1ozS21EbTRpdTlhWVJsVG5uYVE5RjlOaGV0blR6bVFzNVJHNmNDMFp1Y01wd2k4N1N2MnJtdkpuY21UWlV6YU9aTWZsTE8wQTBtOXhYRUF3RjBxcUhoMDkxMEtuQUtyMk5NMFdoVGdUbmRPaDJJeGo2OEMyWUJkU1lMTXhlTjlXWWdWelAxYys0emtBZVRGTTBFN0ZUak5DWnJyNWlDN093dm1QdmFJM1F3UUoySkRjdDlNTFA3RGVLaE1ybFRBVnRvTXIwcFRPWms5aXBlQmpBUHBxYktHY0NhRGNpNXhKYll0V3ZYSVFkMHRza2NKaE9qNllDZFBBaEh6Q1dwdjQ5Z2lqbjZvN21DZXFBZzcxZHMrVXFaM0xuOEVUWnZqc0NKYWJyZFppSS9CME5EOTVVczdRL1FjOG5KdnV3bWQ2cHhpbUlPNE1vNUFqY2JpSE5sc3ZzREtPYlE4SEkvZ1o1VGd2MlY4cUZ6QVhVMmZ5dW1TU1ZPWjFMM1ZTdkZQamJXYk5xS09XUnpadnQ4eU1BODFLay96QUtzbktNR3p1UXJ4U0Y0L3RsODYxdzFlQzZKaTRPK1dBZXBBY1FNaVlXNWdDcjNVeE1QTmFEN3E3bVk0KzhISFZ6cklHdm1UTm82RjZHUUI2aUo0aUFCdUwrYXV5Ky9IUkpOdFE2QmRNODB4NnM4Z1B6d3F3blFmUUZJSHVDOVgxRWZDc3hoSG9BWndKV3o1RjFuQTA0ZTVIZlkzMlBrUVJDaS9Wcitud0FEQUdDa0lLaHE5blBWQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMFEwRXpSall6TmpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wUTBFelJqWXpOelF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakJDTlRBeVFVWkdOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQkNOVEF5UWpBd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzU2RkdPZ0FBUUFaSlJFRlVlTnJzZlFtY0hWV1YvbmVyNnUzZHIvY3RuWDJGRUpKQUNBbUVSUVZFUUdYUndYM0RiZHh4UnNVWlI4Y04wSmx4L3p1TzRqZzZPb3FLdUtBd0E4b2l5TDZFaElTczNVbW45NzFmdi8xVjFmMS85MWE5N3BmbTlaS1FNUHIvcC9PcnZMM2VyWHZPK2M1M3pqM25QaUdseEltLy8zZitqQk5UY0VLZ0ovNU9DUFRFM3dtQm52ZzdJZEFUZnljRWVrS2dKLzVPQ1BURTN3bUJudmc3SWRBVGZ5Y0Urdi9pbnpYWE53WUNnV1A1dmVJSTNudk1rczJGUXVHRVFGOGdBWW9aQkNpT2xZQ2ZwMUwrUlNpaDlRSUxVanlQaVpOVFhwZi9QeWpobjR1RmlqbE1qRGhDVFo4NmdjZExzSC9KU25oY0JDcG11UzltZVo4c2MxK1dtYUJ5OS85L1ZjTGpKbEF4aXlERkxJS2RTWkJ5aHNsNXZrTDlTMVhDNHlyUTZTNTZwbU11azFQdUtEZFJSenRKZjZsS2VPUUNQVU9Vak5zcS85YUZ0dDFjQ2F4Z1FMdllCZW90Z1VZK1hXZWFtTThqWWdWUVNYSVpNd1VxcEVCUVNoMzdodVFNOEdYYktEZ09iTmVGemZkbnBLdVBFYjQwd09jNjhpNjZlWkkrUHQ2ZkFQWjFXRmIvWENkSmpUY09MUGZIMjhEeE52QUQ5Y1h4QnZ6eEdnWXFNRG5lSU04cXBodXo3YURBTWR2U0cyOWFqWmZqSFBYSGU5QWZiLy9SalBjRnM5QjV0djJLSlRHOG8zVUp6czhtVVpWSUE3WDFRRGdNY0dMVVJjSlZNeEh3ZE1Fd3ZhR3JXN2ZFMXFhcXNYcWdQc3NKZ3NPREUrSWRmRDVpZU04Tmp3UDVERkFWMFptUmtXVlorK0U5Q2R6S1UvK1lrNVVwTjBsVHh6dnVqemVreHN2eE9jWHhXaXE4NFV6elpHS3U0N1VueCt6eTF1R0paTWw0aDQ1aXZFY05rek1WaVpWYTZOTytoYmJhOWxtMHlCdk9Qd012cW9weTBCVkFLc3RKQ1BKKzJMc1k0ZWVmSE9rTHhaOEk5YnhWbkNEaENVcGRvVkRmbzk3RHNhamhxSWNtVFVlZFJrMFFMWnYzYVNwOHdsQ3ZHWjRBUm9mNW1PZVA4WEdBNTNwNER6b2U2OGYxQTViMW5lSzRweHR2TUVUbEMzbGpVRUpUUTFKalY5OVhISzk2WGlsbjhjLzFyMDJXR2E5QkNCTCtlRDI3bTMyOEQzRzhqM3ZqdldrNm9SNXBISHBFQXEyMTdXdlhONFcvY3Mxcm9wQ2NEVHZTaW5qY1FFMXRBSVdjaTJ4R1lZK0xmTUdGb3c0RU9Ba0MrYnlEYkpZNFN1ekpaSW1sQmQ0dmVCZGV5S3ZIQlU2VTRCeW9HYlgxWkVqT1hpR2JRNDdueldWc3BOTlozcGM4RnkyaDRFMlFtbXVsTU1YN0FkTlRvbXdCQlo2TzcwYUFseEFLV1A1MVVCcnFrclE4cEpmNTFFb2xsS0taRUphQlFOaEVJR1RTY2kzRUtnSzBWajRYNEVraUFTcERBSkpTdC9PVDQ1VWNyeFlzQitFNmVaNUtTZHBCUHB1RzVGeG9KUkNlMVN2MDRtVmdsR0JjejhmcjZKeDIwSEg4NkhIOGR4WHd4ajJXTmZTQ0NGUlp5Z0ZxK1l0T3F2KzdENzFqTTM3MnUxM0lJSVpsSytMSXBuSjZ3QVZlWklyMzg1a0NKNzJnaFdZRjFMbGRYaVF2bk9KMTFHUVFtMngxb1p4NU5Ta09yMWc2eFFueTlIUndsSk9UZHRCWUpXRVRrQVk0QVhVS3poVmtHY1VMOWFBOEZQSW1xK2ppeFRTZWVlcGxxc2RhT1d3ZjNoM3YrYnc2cnhJQTcrZnlIcnluazRUc2VtV3RBbU9PQ1lkb1ZGOXJhc3Z6TUZncG9LTUZxeXhTV2JqUXd2YStSdzFKV2JvYW8vQ1Jxa3VKanNLOTRhK0FuVjNBMzkrR1EvVHRMOWxuV2Z1T3EwQk5UNWczYmx4VTkvRWYzL3hlZlB2clA4YnVnL3ZSR0FNeXFjbkoxSDdIOEtGS2VQNW9ndW9KSDlLa09JeitxY25UQmlLOTJ3NWUyRkMzeFBxVDZHK2kzaVNQVUpoQkNyS3kwanVmOG5kRlAxdTBUblVKUlQ5bldaTys3am1DTEVLL21CUytHck5oVEo1SHdheDZUR1BWOEdrcndlY29YUHBjbDdjMXZHNGFNTFlmQk1ZNXJ0VkxoWFkxR25aOWlMVXNxWVZ0bER3bml2UGl3N29TY0QrdmJiZ1R1UDRxNExaSGdNLytEMFpwcWFmdXRxek80eUxRVFJ4bEwvRG14bGpvQjNmKzhYcDg5NnMveGYvYzhoak9QYy96UTY3dmQ5UWtTbUZ4VWsxTkNBdTBhVHV2L0l2SjU0UytFcE16cFh4UG9VQ3JVNVpLQzlXV1FVbmtjdzcyZEtXd1laR044ODhrSkkwUnBxVUZpL0RYMUd5UnFBaHR3UVpuUjkwcVM3SDRuQlVJNlluVVBzLzFoS1VodEdnVzByc3JpNzdZZDIrT3dteGxRZkEwemJIeitzM0tseGR5V2UwQ1pQR3owcHQ4cFh4OWc3eWxZRG5wV0Y0TEhCb0FmdkJIZ1hCVkVQR294Yzk3SnFsNGdtVjY5RmhSZFdXdHJwVDZtb3NES3RqZWVIYVI3NTYvQVBqaFJ5SzQ4ZVk4L3ZVaDU5bFc0SlNubFZZY2E0R3VGbUp6cERyNjBFOS8reVVzMzNJV2ZuVDlseUUwTVNDSTJtbkt5ZEJhRjdCY1JLSmhXaWtuMzNESUVEMC9ZeGllRHlsd0ZoelNQSWNYVk5DUXkwUDVITjRlT0RpRy8vaDFHOTc1OHVVNDczUUhEKzV4MEx4eU5SYTJVcWdGRTltY1FkOU1INXJNMDRmYTJ1Zm02Q1NGOWxhRVB3VjNoSEQxbkt2OGJsN2R6MU1vaEhqNmI0dW1vaDQ3aGF3ZXQvcm5PZ1U5c2E1VVk3RDVXcDduOHVhaGtNM3F4N1l6YWQxRmFJOUVQT0VlcEphUGtlQmN1WTUrY0Rud3o3Znh0YVpxdk9MY1JwaUVHME1oaFNFOEg4M3JsQ29PNHhqVm1KU0NxK2NVcDFDdVI2R1drc0VydDBTd29GN2d1bS8wNDQ1bnN6L3BzcXpYSC9Qa1BJM3dpbE1iZ21nTTNvcitlMzZBUzg0Tm9ZYnFLVnhlY0haY2E3UzBjeWhreGpuWkZCSnBTRHFWUVNiTkNSUUtxaVE0bHpBVktlSjlsMk1UdGhxbHgzM2FPNENiYnBmNDlIdlB4U2tuMWVNZmJud0k5UTBSTkhmdnhuMkpEQ2ZTb2NJNGVnTHlPZnJtbkswL21DT3hDb1dWQmJnYU1vdWhVZEVFTmVueHlZajB3dzhGazhKbnNLVlFyTDFBeUxOYy9WckkvOXdrV1ozNFU3Q2NvVTl2cmliMDB1SGR1b054YlF1djRWM0FlMjRheFgvZFBvWVBYMEVDWlhsK09FeENGUTU0ekN6SzJ5Q3QxalFERkRvVmpZTUtFR2xzMThSWWtvUXl5VGtreWtVQ0NqbHc4WEVKV3pZS0VTSEtmUCs4RmJqNkh6NUttQ1hjN05ycit5NGVPZm9VSlRET05aSkpqMXlRM0NLVDl5WkN3WEd1SVBSRXFmdU9mMHRGMWVkNnJFUGl4dmRmaURkZGN5NnVmZWMvb2E0bGhhamhzVmpGQ0xVdjg2M0RDcFQ0UEI5bUhSKzJpcERyeXNNRlVDUStFcE9rcDhoeURXUFNseGFKbGc0eExEODhtWklQRXFVKzJZZHpGWHMvOWhqdzhaY0I4d25CNy80MjBNTXhyVnNpdEpXR09PWUlDUlRsaUZoSWdoNEVNVjVYMkJlNCtyNUt2cjZHa0t1VTRNWmJnTnZiOEhRemNOVld5Mm83NXBCTGdVTE5BejMwcmRlY2p5cy8reW5nWTU4RWZ2dWdpZm1WaWdYUy85bUVQVWY1dER4a2tSS0xJZ2NSRXhQdStscnYrZ1JoZ0JiNzNpczM0UisvK2phODRhS1BJSmRJNHBSVHFCZ1piOUxVZFVpVUJQM1NtMWFISm1jcnBpS1ZUN1UwaEZxTVY5UmFwMGw0VmJDdTMrOUlEV1cyUFNsUTlacnkzeTZQQWpVdm4vZDhtMklENnZ5RzRmay8wNUQ2ZWZWK244Uk9RSENSZ09YOWVlNUpBRTBVeWc4L0d0UksrcTV2NWpIcUt0U1ltQVF2bnVaNEhUdUlhSWpzbitkWGNldWhNZUJETDdieHpnczVyOS9uSk8vRnZiVkN2SFMvYWRyRnVQU1lRcTZlVUI1TjFKai92QStQblhFYnp2anJhNEFISDFWV1pxR2lraGZ1R2hyVHdrSFBBcVVzc2xxaFNWT1JPT21nM1g4OG1wQjR4ZmxiOE9sZmZCY2o3YnV4N3R5TFVFdW90VzFsZWw0c1p3V0NuRmdYVVdKVm1QRktoS29lVXZGZ1VGbThTOWh5ZVovalV4OWhiQ1BjTE4vdjBVZ3ZublYxUEtqT0pmMzc2bGFGVXdyQ2xUL1RQbzMzSGRzTHFYUmNhU3NZdDdUUFU2R1k4dHM1ZmtiNzc0TFU3OHNTOHRNcTJDMTRrRCtTZHJFbkVjRUZwd1Z4M1J2Rzhla2ZEV21vVmNrTE5UNTEyTGFsaDJRUkRneU9zMjhFT0h0QkFhOC9GL2pjVDRGYktNd3h5N3BnNUhsbWplWWNoL0tMYWtNQ0IzNzVQVlRlZHovdzVlOEZzS1RGOE5ncVk3TlFLS3V6T1U0UkFqVm45NFNyaEtrMFdzTXRZWG84WmVDL2ZuQUpUbi9KQ3ZUc0cwSmp2YWtKamFCL2RMTERtcElxUnV0a3gwaW1rdnI3TllTVFhNbDh5bE0yVndYekhtTjBpZEdhcWJxVHZsUDRXUnl0UVVXWThFTWt5R0lZNFdVWVJBbWpWUmNnREZNblJDWmVnLzk1K2poRnhCUnJGWDZLaUtxbng5NC9iS015UXJ5Z2hOL3oxVEcwSlZ4ZWwvQmdYSWRvUVcyWktoeEs1WVNtdWQ5K2w0TS9iQVUrZnc5MlN0TThMU0Uwd3pnc3NYOWNNMFgxdG4zcFMwL0M3Mjc0REhEdHh3VTZlNE9vWmZDZkl4dU5SQlNMbEw0bGV0YXByOFRQM2loL1c5QnhJOWtyL2UycWVTNCsrbTRnV3NGWWpES01WM29wTWkxNDVZdDkzNmV1SjVYeXd3NCtrY2w1UWxNVFZZeEZpMzZ4cU52cWRmVWFaRW1pd1MzeG9WUFdSTlRkb0ovbWs3NVNSRU5lTEtxKzB5TTBucVVGaS83V3ovdXFhMHJUVGRSVmVoemlobHZwVjN0SW1xb0VnbUh2bWlTVm81QW53cERrS1lGM0Q3ajQ1SlVGeFBqNWQ5Mk1zWmdRcDNTWVpoK21oTy9IWGFEcS9UVzIvUjlmZlEvZVV0OUkzUCtNaFlVTHZOQWlFczdSTDdnNkVGZmE3ZmpKQWhIMC9LYTZjSVo0T3BSZ2lJbUJJWWt0aXlRKzkwbFBhTi8vb1hyT0kwRjVhbkNXL2ptWHQzUzZUNFU1eFhpeUtDajQ2YnNKQWxQQ1hpUW1MYlhzaW5PWm1nU3poQ1FWRXhTR21CUTJaRURuZnVOaFc0YzRLcDJZU0F1c1crRGlUZWZUOTFQcFB2MHo0SDZHTlBPcVZiclFTeTVvb2VjSTRWVDZpb2lEcmdHQlM5Zm1jZmtad1B1K1MrU3p4WXU2VGZOaFRIcWt3NVlJajN0TkViWHBmVi82ZDNubDk3K0MrSVhuT1hqZ1VZRzZCbzk2S2dJamZNdFJJWW9mcjhPTUZCRkxLQmVwTTB5VmNZRS9IZ0MrOVcwSlJiWlVodVozMjB3c0lSVVVLcGJUMWg3Z3hObUloSnlKS3l6V2VZbXB6TE5VUHVZa2k1VStBNTRRN0F6VlA3SUVqdDFpTXA0UDBsVFlEQzFNcEd4MFVyQUd4NWV6RGZSbEhMeDh2YXN0OXpNL0J4NmdNSnRyNlNNVml5V3BVQzVFQmU3U1g1UVlTUWtzcUxGeCtTYTZMRnB5dHkwK01XS2FUNVJaSDM3aGxzODZUVE9UeXR1ZitxK2I4ZFdycjVCNDlHa0c4Z1ZEaHhhbVo4UUlCcjBrdEpvTUJaZjVjYUM2eVVLZUV6RE8reHZPYVVSOGZsUTcxVi8vb2dOcmJuSHhrUThDTzNlNWhIR0x2a2RCclBCV2JvUjNibG15bkMxS0pDcDhheXdWcWw0bENmaldhcGNzZjJGU3VJZWRxMVRPVXdTdXJEU1RWd3VrRG9XaWlCUDlJazN2UUsrTDk1MWo0OHJOdERTR0szZDMwWHBEQnZMU0M3TXE2K3FSSE95ZVVLNHNrVWt0Tkx6bFpSSi9lQXE0cHh0L0dyZk1meXV6Z1A2ODFrbVBxdEI2eExMK3o0L3ZSMStDd3JucUVrbklyZkRXUVRtSktUN1gxUUdzUDJjeHJybmgxYmprNnFVNCtaUUt2UEt0bTNIZXBVdHd4bmwxV0xtNUJSVzF5cUpEMkhEZWNuejVKdEovZXBCM3YxV0ZRYmFHWlMvSHFqUERrM25TNG5LVTZjV2x5bHJWc2wzUVg0TTk3TEM4V3kxY3czdGN6TlBxd3orSEd2UEVlNDNERC9XY3R4UW9kQ3BQRFVSOVp5OFo0dm9GTnQ1ektXTkh3dXp2TzAwc2JEV3c5dHdJMGNwYlRRbkY1dW5rdnVHSGNmM0RFbGRzZFBTMWZQZEJZWlB0dm5lYTZvMFh6RUlQKzFJcStoZHUraUcrY3QwSFhlenRyOE5JYndxWlpCSkxUbXBGc0tZU0w3MnFFVzcxT0VJWFhvaGxHN2NqbXlxZ2VlVXBDRGZ1UXA0c3lFNUY2UnRKRE9KQjFLMXJ3QTFmSE1DM3ZnYThhTE9EUHo1c1lBRW5xR0I3anJOMFRYSkNFMzBoaVJLVmRPMUo0bE5NNGl1V2FwZXNldWkxVHhVYldwNHdoUSt0ZXRYT2ZlNTNGR3hESzVWaDJQcTg0MW1CaUZIQUo2K1d1STJlN3lZQzVrV3ZhRUE4UG9odzgxS3NYTjJLQWM1RlJUU0lSSmVnZ2lzbFpVeS92SUF6VndKZklkU1MxOTA0WWhoRFpheFRQTjhxaHFPeTBOWHJwQkFMelcvOW9RMER2N2lOa3pIY2p1cU5yMEx0Z2dYNDhEY3V4alYvZXhaaU5XZlRWSE9Rd3dtU29TcGtSdEp3UjFJUTR5YnkyUmhzcTVITWI1U3hvSXZXNWZQd3hGQVF0L3lTck8rdFpKVmhSMmQ0bE44cExqMU5QWFExZ2VGWm1VVXJEVVVtTFUwZFJjdFZ6RE9aOEN4YndiMFNpb29QMVVLM2V0MEtZV0psWk9wM3FITkw2UTFDNWNwVkxuaGt6TWExTDNjWmVqQisvQTJKNDZZYVdORXdIR01oSEJJZWhDcXhhQ213Y00wOHZQS2FONkt5Zmo2R2VNMjFVUmYzUFVNR1BJS084YkQ1UTMvdWpSbnFySEEwbG52RUF0MThuaFR4S2hpQlFlZkN0VlVJbnJJdWhpMlhuNHpORzFyd2xvOWZRMjFmQ21kOE1XZHlQb3pLWlRCVEQ4QndsOEFPTmlDYjZTYWNWdlBJNjVqU3RlTndBMDF3Q3FNNCtmVDUrUHIzdkNxQ3F5OTMwVHZvYUtFSTAxdHAwY0t5RG9kRTE1NjB4a0RZRTJweHpURkJXRHgwaU5aQUgvNytUNjNIUDk5eEZWNXpkUlVPdFFOalk5QkVSWi9mVzQ4K0hHb3RINDdOeVRCSDhZS3VRWWxMMWpzNDV4VGd1djlrYUxJc2p1b0drK2EwaFBIMllyTDVESnpCZStHUTFkcGpHVVpzaitPQ0YzZmk2cXNLMkRQbTViR3ZQUWMxRFk3ejBWZ0Z6R2tLMFY3NG1xS09CNXczTEt6QTkvNysvVURqNGhCYVhuNHBRdzJWa25zVHhudHVSbjdrajhnRjFpR1hiRVBPYkNMajdZV1pHYU5nV3VCYVVVN0FpRTRndUtFbE9pSGd1Qld3SWltWTh5MTg3WnMycnZzd1NjWUREaWZlUkRRR25kNVQ2VGo0dms4SllJeUFsU2Z4aXRjQ0ZYVmVlWWVDVE1VNFZmTGluSmZXSU5yY2lEV254ckRwbFNhRnN3eHYvL3hHU3VhYk9EU1VSdHUyWVNUVEZLcmh4YnhLdUVxSUNvckRzVXJrMDJtZFpkREt3dk1PSmd5MHhBdDQzMlhBMTRnazdUS0lUY3Nad2xqTGVBMERoTlVrQklOWEl6TkVpODNEVER5QlFDYVAydVdic1BDY05HTFI3ZWg2RnJoc0F5cm4xK0tkWDd2RE9hM0xGZTlMR3NhK01oV0hMeHprSHJqWGVjdjhHTDczYjljVHdoaFE5K1pQcFJsVUVWb0pvVU8vSWFzMDRZU1ZFTGZDU2RFaXhVSVVPRXY1YkRzRnJwYXhhSm1DRW9pdFpSaFRUU3RMOHVqait6TlllUEk4L09wSmdUMjh4TGU5VG1KMDNOWHJuc0d3OUt6RzhxeFFKUitXcmE3RmkxNTFpbWFSblh6L2kxNjVFaTk1OVRJZDVGLyt4alc0OXFiTDhaWlBuWXdObDYyQzNVWm11cHQ0YTYzRzZ6KzdEQi85Mm1wOCtPOFg2R3FJSHJKVGxiYk1VRG1NZ0hmKzFxWExxVGlPWjZVcWppU3pIUiszOGZHclhEekY3L3IrVm1EZGFWVW8wRzNrblZFcWN3L2p6QUdHYVJtNmtsYmU5dXQwcEF3dW9MWFd3TzZweC9xek4rR0s5NjdGN1R1QUZpcnBsOStFTTlaWHUzZkZIZWVpWTJtaFJ5VFFSdHUraHRIR3YzL25SaStOZDl2ZGRXZzllUVh4N1Q2SVFBUWk4UXVZYmhCV2ZCMnNaRHNaNGNrSXhGYkJ5aDJnbjJNc0lzY2c4MjF3czN0NHdTTmUraWV3aUVjcmZaVkZLN1F4ZjBrTVgyVVlzSGtEc09XTUVBYUhwUFo1eWs4cVg3aDNGMk85UlZYNGg1OWNnNy85OW12d3lYKzVFQis2YmhYZS82VXJjTTNuenNmbnZuMG1Ydk9PNVVTRVVjajlRNUNIT05EYXY0SlIxUWw3NEJ0dzluZEJEQzdBK3F1L2lROTlZajNlL3U0QWJ2aXZkWGo3QitNNm05WFpLUmhpcmRNWktGMWk0aG9NcFJ5OGZvdURwUzNBRFl3M1Y1emNBbE9sa2xUZTJjNFNwdm5ZV2tRL1hFRWxuZSt0R1Z2emFHWXViRnFxa2V1RkNKOUs5OXFNbGxYQW5Yc0oxM1FSWDN3RDRoY3NrRGRYMi9hN1g5Q3FQM1ZkUGNEYk9ZL2YvZGN2a0xSUWF6L3pML1JOWDd3Q0o1OFpRbUdnQXJtTXlXRGJSaWJuSUoyU25Qd2trbmtUaVd3S2laNG5rTUFHTXI1MnBOT0NWalNDbkZoSDV0dkQyTFNibDAyTHRSb2dDNTFRWnZQUTNYMjQ4ZTBTcTFlRzhPWHZMMEtGdFFkcEd0amFjMWFpYXRGaWJEZ3JnbFBQSTl3ZENFRXN2eG9CNnc2WWV6dmdWTDhLbWNvSFlJNzFJVEprSWhsY1FUVFlUNFVLSTFwL0tsTEQ5MUFJcllnRVRCanhwYkNkbjVERmRuS3lYd0ZSOTJxMFAwb1hrWFo1dmdLKy9PSFA2OVdrMFdRQVM2b2NmUHFOTGo1TEt2UGJEZ3RudkhnbDVWd1BPM2RJTHdwWVZPWlFtSVRDYVVPMGNqR2laTGl4VUI2VlVRZWhvRVIxekVYSUhFRk56VUpVdGlhdzdZRStQSDdMS041N2lWY1orTTA3Z0ovdndOY1pEbjUwU3NaSXBmN2tNYlZROVlaKzRIV05RWHozaTU4Z2Uxc0EvSEZiTTk3ODRmTTRxWTNBTVBIRG9VRG9VMlN3Q203cUVUZ3lBanRTU1YrMmxlVGdBTnpvcVRDZFBsaEdFeTJSOU45b3BoOU1Vb0JrQ2diaFdzRnVucGJqNW1DRjY3QnNjUmhmL3c3dzFOWWNGaTFxeFpOZERhaWV2d2pYZmZmVitPdFBMY1NHTGVmQjZGdW9VaGh3K2c0ZzJ4VkUzb2lUZ08xQmVLZ1doZTRoMkpWWDBxZFZNVERlUzZKQWVJUUg3NUdxTFJDaEdISkRUNUl3clNMVS94VmtUd0ZHc2hZclYvd0I2emFGc2ZyRmwrUHYvdldmRWFqWWdLR3hDS29qTG01L0ZCb3VWNjF0NW1mR0NhVmRKSHM1V21JTnIwVXRJZ3pCc1ZyZ09MeTFSL21lQWIwd0VZdzJFWklIRUdJQTYwcENRR1laTm0rcGhKd244TlA3dlBYU0R6R2VmZXQ2ZkxESnR2L2p1RUt1ZXBGYzR5VVZCbjU4L2Q4eG1ENk5BUlF0OU9CSUs4NS9HNkUyWHc5Wkg0TWIyd28zUGdJN1FMOFpDY0NKRWU0c2tvU3ErWVNtY2NhbEMyRkUrYnBvbzNuWGNLSWJ5VEpIWVlTb0JLVDVSbUJZclpCQ21vUXdQcGNZeitGOFJqMkxWdFZpOGNvY2J2akc1L0JLWGpFRUxmaVpneVFlS3hGc2ZoZURkeHZCL3B2NVhSY2pYYkVhNmJIYk9lWlZDSWNaMUx0OWhEb3FqYnNZb3VFaTJJVDVpRWtteWl0S0paN2xKR2ZJd3EvaGhLL2wreE1JOU40QW81c1UyT2IzRE54RnE3d0o3M3JURTdqMmZTbnNHaE1ZR2dXK3daREs3aG9seWd4U01la25qYnltdndiU1ZGSTY1RmdEa1NiTDcreUdyRnpJZVNHRGQ3cjVYQjYyV2VEemg0aGtmQnlkaC9kOFpEbTI4U1AvZVpmbnZqNXdDZkRHdFhoOWcyMy80TGhCN3VsQ0xLRU43ZjdFR3hDNCtPVWtRTDNBSCs3MjBucW5iMUhMUUJYSTVsd1VYRlVnVlNEa0JwQXBXTlRRQklsTGxQQWJKcnhta0NWUnlqbHBFZytiYkxDQkV4RkNLajFHQ3lZekpwZDM4eW12dHBZc3BMOHpqOWRzZHZFNlhtRE5xZWVpK2NWWHdDaVF5c29XV3JDaGwyMWtkb0ErbTVhZWVSekk5a0xHenVSMzlzRk85OE9PTFVjd2Z5L2NNY1lyRlJ2NStGUUVPZmtDdEN5U25IelBGOGhhNXlOWVQ3OHFWR0tac1UzMVlzaURINE9NMGxyckw0TFQ5VVZlVHhSaVhqVlFXY0R0MzNnWXQvOEUrT2psM2dMRHAraEhuMDBiakRGRE9yUGhack1JaFN4Q0x6OURhMVZyb1pXVlVZVEk0b3hDQXRFQWVZRHdWbTBpcWsrRXdCRW5zRDJ6WFNKQ2duZmhPbThCb0piUC9kUHZnTHZhOEtWREh2d2VNZVRPS05BV0laNTQ5NVVyVHIvdWhwUFJ0YmVmL2lXRjZqajk1TmdvdWpzTDFQUlJVbjlicjRlcXhlSk1WdWlTRk1WQ0ZXdFVLL2daMjh0alppbXdiRVl0akVmNFhFWm5Ud281b1d1UDlISmxYcVgvSEZ4OUZtTzhEd0tQUGxXSnRSZWRoZWJUbGtNa1Y4RnNlaGZoK3c5d2VyNFBXWEVTUDdDZnNjUXpFUFd2MXRCcTlQeUNRbDdMUWI4U1RubzczS0VIU0xicTRUYStsUDVMK1hrR3VjNHdEWWdvRUQ0SmJzVUN1TU0vMEF2YU1yS2FybUlIVVdROUxZOGtKOTFESC90aURjM1M3a1cyL3k3MFVvRFAzTldOK2ZUbGkwbU92bkFyOEx0OUFyV05ocTVDTkYwSmkzTVpDaHFJcUVKdG82RExUV0tSS0dLTWpTcEpvbUpoRTVXazFGRktMMElrYW0yTklWWVJSTVlKa2tDR3NIUjVIZTYrdHhNZnZQNEJwOE95QWtjajBCbmpVTXBqMVlvelg0TElTWi9HZ3NidHVvTEFpTk1Ya1Fnc2NGVFZXcEtrSXEyckFQS3BNZVJKUTFVMVc0YnhWNUl4emZqSUlFYkhFa2ltOG9TcGdoYm9lREtEQkdPOGZOYlY4VjgybjBNMm5jZlREeC9DcXpZNXVQNVR3QS9vU2RxU3piajQ0MHNoUmpuSjFadGdqNUtSWktnVjlWZnk5aGNNazNiVE1yZEFCZ2pmOWs2cTVsNXFaNlZtMmdGcElMRHdXbzR6QTR0c1dwTEE4RU5rNCszSXRid2JjdlNua0NQdHRNSW14aW5ORUZSRzJmQWV1T04vcEhDcTZSZlZjdEF5WU9RWHhOZ29FZkpOV0xad1BucmJQNFFmZmhONHo0dHBwYThCNXQwaDhaL2JnbGl4Y1FGaWxVR0dQd0ZFSXhIRVlqd28xRmdzaUlyS01Db2lGaW9yS0ZoS09LWUVHL0VxTUlLOEg2S3d6V3lCY1hRUzVvb0dETjAxcGtZNmROU0poU1ZMbGt6N0lnRmwxNkc5N1JzZ240YklqOUFpeC9Hbm4vd0tDVnBXd0srVzBxVW1xdXhEMStVS3ZYYVo1NUZoMUo5MzhucXROTWNqbmFZbWN1QnBWUW1ZVSswUnBsOXlLYkZyNnlGY2RVWWVuN29PZVB3eFd1ZnVPbHo5b1EwTUNUaUNKSmtwNDFBeGZDdEUvSjJNTzFYQmtjSGI1WngwdmlmS3g1MTBSTlZ2cFdEM3dja2NwTlVQdyszY0NuUEJaMkJXWFFvM3VkVXIvd3N2UUREek1BbGFBS0tHNFo4UjFIVkh6dUJQdld1UkJjSitveklyRkVidVJtN2dDVlEwWDBrbzcwUmdmd2ZPUEwwQjQyOGV3QzIvQWw2N0Viam1wUXpscWpMNDhwMXRxRDI1RlZYRXpLRGxFRDZ6SkRzV0JXenl2a0E0WkJBbGhLNVlDRm1HcmxZTXFEcGplT3ZIUytkWFlQMWFoam5kQ1J6WXhYaGRVeGZ2YnliNUhMR0Zrb0FkN0c3djNvREJIZzdBd0w1OUIvSHR6LzRiWW5HL3I4U3Z0Q3ZXRW5tTDJvUlJWWW11MWtYOTk5REYwSktGZnF5KzBmRXJFVlI1YkhyY3hkVWtRSi80R0gwMGcvd3ZmSkhoME5mUHcwVnY0SmUwOHhOUjB1ckJoNEdxQy9pQjMvT0RkRUF1TGF0cEhvVjlONVVwVG9hWkplenoxZzdENEJjR1lrdDQ3djhtNXUrSGE1RzQ1WGNqT085NnVDUkR1ZXdmcVh6ZE1IUFBJcER2aEZGOUJYM3pDS3pFNDVEeGMrR2tkc0VTYWI3SEpKeGZSaVVaUVhhSVNsQ3pnZkkvRFplOW9RMWQzWDI0NlhmaitNQlZ3TXNZTDlkVzJQU3JCM0VvU2tVUGVoVi9mckdHVjNZaUptdUxEUDk1WGJ4aWVLdE01MjVxeFBrYld6RFcxNDhEakozRFh1dmhNVXY5aVJLQjd1OW82MFdxdXhmUjZnbzR4TXhGU3kzTW4yZnJYR2l4R3M3MVcrcFVlYVk2MU9wRzNpL1h6T1k4ZjVyMzJ3clUrcnQ2WHFYdERuVzR1SXlFNEc4K1FNRW1nSWQyTk9FalgxcUo4eTZ1NUl2cVpHRWQxdWhSV2p4UjczMzBuMitFVzgxd0kvVmpUbjQvbk9RaW9PR3RFT2tIT0JITnRNZ1daQWJ1cEFEZVJoYTdEb1d1Yi9BY0ZTZ00zUU16dnBreDRrbTB1RDNJTWR4d1JuOUptRzZDV1VjeWxMb1hSbW9jOWpqRHEwZ0lWbXdaQlJORTh0Q3RxR28rRzRWTUQrR2RxSkJjZ01zdjY4WjE5d3JjOXBERUZTU0hweEdkLyttMXdLZC9LWkhtV0t1cWhkY2ZZM2dOVk9wV2taNkFmeWhCbW40OXNXcnhXRVFMZFJtYkQzYU5vZVBncUJKb1d6d2VQNnIyZldPbUJERUJiMjkvOXdnNjJ4bDgyeWtFa0VNcUpkSEY2R0ZreUR2R1NZT1Q0MTRCc3JKRVhUYnArS3NoMGx2RjBPdVdmc0xiOHZ0RytycGRuTXVKdU81dnZmenN0eGgzUHY1c004NTcyeW1FVHdweEFjT0hGU09raEE5Q3RtYmhWRDRLdXltTWZHMG5Dc0dIWU5lZURybG9NZVhkUnVzN0dWRyt4NHcvam5TSW4xbCtPWUlOTGNpTEhUQ3JDN0JidHlCY2NSdGR3VTNJSnIrS3dKSkxFR3RxSWp3U3Vpczc0YmFzZ2QxUWg0SzVHNktKY0x2NlhTUlRDeUFxeHNsa09iMkJNUVRDUFFpcE9XWlkwblRPcGJqK3ExVzQ0d0J3eS8yY0E1S05OVXU4eGlOeldDSXpMZzlidnkzZUwrMnBLUzdQS1duVlYxcGs0a2wwSE9oSGY3S2dYZDAwWGZCenNsQXhuWldHaE5nOVFITTZ0TGNUcTliVXdDQUp5c3Q2dFBXVHBwTWdxVjRPUjVjVlNIK04xTlYxcjdxanpQRHJjZUVYV2d1dnRraVYvZzhQT0ZoTTRYNzBBMTVDdmEvWFc4b1NJMC9qcmh2M0l4OXVnSjFSL3NYVVpTdVcrWlN1NmNuVFlnTEdyNm5sT1o1dlBseWIycFJYcy9WWmpxV0g0VkNDRTlUUGlUb0ZDMDQrRTRmMjNVZExwcVpWRUhwSFZJdkREcTJsd2NwZkl6L2FodXhZSHBVMTlMbVJtNUFjL0JNa0NXVXMxc080K1lkazhyVGkwWDZ2ZVRtN1ExdWNLUHhHRjB0WDFrYmg1dEpZeVdocWtONHVtd1E2ZUx1WWV2alJGd0dmdjFOQmx0QXBTOE52K1BKZzErdDNLUlpaSzhFbWVBbFZZWVpnK1RIczN6K3MyOVRweFo4SkJBSWlFb200MDZDbm5BdmtQbWN0VGxqV3puU2hrTm0vdXl0eVlhSVZOcjk5M1lhRldMeStCYm1rUS84bGRiMXFQcGZYZGF5cU1EbVp6R3FHbXl0NGZhSTV4bzA1eGpFRlIycXlOSGhvSEJVaWg3Ly9aQnpOaXgxMGRXUjBiOFJyWDh0emphc2xyeVF5aVNSU1NRK2E5YUswNVZmNE9mNXFpNEx6OUpCWFVPMDNEVnN4cjJUVUh1OWxLR0JoY085ZUpIbzZ3REFRd1NxL2xZR1RaOGJVKy8razg2MXFwYmsveTBDLzBLMFQ4OEVva2NaMFlPUWYwT3VrOEtzWVZGVzdzbVkxV2FGUVNDdEh1S0lLNzNpWjZoa05JazN5RmpTRHlJWER1R3h6SlI1TnRPRlhUL2FpcGRuVS9hU2Vja3RkL2FmS1AyMGZHbFhoWElnYVV4a2cweDhhUk51QmhOYzdaVmxQejdMM3hMU0N0V2JhT0dLMHRYVlVIaml3ZTkvZTN2V0ZrV0hHVHhLcHdXN3NlbkFmb21HdjBWR3h4RUkrcit0emxmV3BiakpMT1ZISEl3ZTZ5NHNZYlBpbjdodks0OHpsaTNEQlI3NUJ2NVpGeFJxR0ZTckJyYXc5TjRyRnVxNnlRQ0l6NWhXRHF2TlQwcktRMVBXeUtybWdlV0loUXl0SmVLZ2diRjBrYmRLaUE2cWtNRlNMVEs0TGx0dUNnRXRIUVFWU3hka2hUcnllVUZXTGFha2lMbzZWcnh1Nmk1dXZVYUsycWcybXBnaStyb3E5VlJHMkdZaFNXUUllYVFpcTVBRUZRL01UWmtBcmRkd3ZOVFFzQzVHYUNCSGgreHhyTitxcjVZVFB0SHhmNnZsUHFRbFNob1FpeHV1cEM2YlJkY2pHUGlvM3YyVm5YMTFkdjJFWTViYkVLVmZpSnFlRDNMSzMvSUtuNmFqWGozU1BJU29ab05NQ3UzdEhPRmlmNWJxWWJCZVk2R0VSRXowc1NyWUZ2MDVXM1lZREFxbDBEb1ZoTXNKd25KK1A2SzQxUTNYenlvQlg0YTQwUVNuTFJIZFJ3WE1pdXNTb3VObUJvK05nbTc1ZGRVL3JuaU9MVTh2dnpoWEdFT0h6UVRPS2dBZ2pSMmkyblF5Q2h2ZFk5WmJubkhHdldZUHZWOCtaUnJIQjFjdUxhNFd4QzM0dHBlMFZncXRDOG9KWGRTWVpoNnUxWEJPZXdpcFVVcVdkSXdtSjlyMzB0MzUvcVdMK2VyOEdIMG1rSHdHbzhzNFJJa1pydFlQR3lCaWViblBST1VoZElEY3NVREdrbE9WMlRCR3pXYXVGOHR2UVRMeXhRb2l0SFYycHQrenJmRkt2ZnNRWmR3MHc3bzdFL0laZGQxS3dSU0lrVkhlMnFyOHQxa01XOXgxd3ZLYWQwWUZSOU96ZGpZWExXM1IycFgzYmZuenZTeitCbWdYTDliaWFxbFF3aE9wZFllQk5TekZvbmFxYTNxRGxxSllHTTZTcUdGemRJNkt0T3grZ3BRczljMllrNTMxZGpoUERtTlVJMnZ4Y1FVT2VrL0ZpVDVnRndxenRyMnNRQ3dvTXEzTFFscXo4bm0ycmxnbGJGNnFwdGtQbFZoUUpzSFZDeGZiTzc2aDQyOFg4NWpqZThxWk5WQ0NETG1NVWczM2ppSVFPYi9pZGFQejEvYWR5SGFyTVZaV21xSWFsZzMyNk93RnhJUjRVUXBUYldtNU9XK0tVZzl6RDdsdUc4ZFFReldzdkE2WjFteFFoQUlZWXA5ZFVlajVOR0ZNcTE5MWljNDVmcHlQOFhoZmhhV2VVZ2hnazFQWjFkR1Boc2xxWWZIOHZyMmI3dzd1d1lxVjN6bUl4ZGJGQmFNSlgrbkd0c0h4VThBMUtUUXhSMjdzZ1JYcGkzdWl6Q2E5TXhRejZ6OG5KNTF3UFBTZUt4clJpRmp5R0x1WGtwRXQzc25KUWVrV0lFNjBaYXZGYlZmaU5EYWtLakxYMHF5WU83dTlGWDlaR1U0VVhsdWk0MHhkbXNZWEQ5dU4zdy9GYUV4Vnk3ZTNXTGgxdUlQQ2dHbjBnRUpBb3YyZmdkS1dlK3JFMVRkWFp4SFA1cXFydHFlSGhrWTREcUZIc1RPVW5FYWhCeWlXVU1jQXMrQjFjamxQdytsRmNyMnRMRVFvMVNYbEZsalRrU2krcjVLajFqZ0s2MnJxdzhmemxqQ056MUNvYmpESlExelNWbFdGaWw1RmlJYlJXSVA4bzdxVGk1RXJpc05Ca01FYVUxYkNuRk1EMGEzdFZXNzFUbUx4aUkzZzRpT21XQzN1eVBiSDR2Y1dVdDF0U0E2eERFVjduc2dVMVJKWWtaTVprSERrRThqblUwdUlWZXkrdEJDc3F1S3E4VUMyWTFDY3NhaUN2b0ZMc29VQTV0ZHVIR3hxNkRjOUNEWlRmdUdwR29WclRDSFBpeU1iamVXTms1TW0yZG5tQjJ1OUFXZWJwWnkvRzVndlhJekU4eXZpemdGdzI1KzNSdy85VXc2L3FJblBjQXUrVC9SWlVzNitOVE5ack4weU1aTENQVjNwd1h4Y2ZqRExJTDJpQkZodVpWS3pxbGdoUmxQUWFHY1lrQ3NDM0Z1a1hpaFczbkpsb3hYY24rMkhnK052TitLMkFwVUp4ZlIrSGtvSnR2MWx0MmcwM2lvcFdiTlZ2cUFvemprd2pOV3FqclcxRWh5a1ZuS2R3MUJlZ1grT3J3aFlWajZ0amxMRnJDMitiYTREZG5JcE9oajFSSWU2elRWTXRtQmdsZlM0NEVxRmFNd2h6b3NRd0pzVGpIUWZsQlgwREhNUTg0SjZIZCtLUjJ6dDBXc3R4dlcxcUJHZGJyYmdVTkY0YXZGQmJDMU5acGUxNm14WXB3dzNBQ3dNTzdPdGxTREZLYTFHYjMrUVp6NFZ4c0NPcnErdE1YL3ZWWkZ2bXBOOHBUbVpwUlY3Ukwra0o4MHRWaWgzY2hjemt4QWNxL010MlNsVGZWeHdSbUhRWnhYYUk0dVlXRThoUUpscFhscVlxQ0N0RExpd25pUUc2a24xdENhalcwSnBhRDNKTkg2SkZNZlhuMzZvU2w1WTZvRDRPL1BZeEwzbGJZNXIzZWsxeFFzNFFhODVrb2RNSzFDaTlEWmptRTczakx0b1BBT2R1SnV3R2M5aTNJNGY2ZWwrcnhlRnMxNW5DZlBXK0FpVStzWkxZY3JCdEFDTjlnNGhFVE5qSkJOYWVzUUxMVDErTVZDS3ZlMGRVKzcyamxyWjByYlZYY0owbEdtUTBBbmd4c0c0WmRBdWE1S2dReDdEOFBrK1YyT0RqWUU3NFBzc21zZkw2UTlVMkFZN3VEZldUSWVwY3hkMVYvQjU5bFJ3cEZML2Y5ZWJRc2FYK3psTHJWdGVUelFwVVIxUmlZQnlkSFVuMERPUlFIZlpTZk1VU1VGRk1Lb2pKM2h0R1psaFU3NlZFOTNScFBSdE5WVmMvcUhYWk1CeC83dDA1Q1BXdzhNV2FUWmpxMXFtb2VEd3hNcEp0YTBmNDVTOGpOQkJLRXFxRnpzLytGRnZaUmNsWml1M3hPb3p4WTlTQUQzbTF0SllldGJLd3YxdnZyUkNoSU1JTXJ1T1JBVlFGUGF0Vy90aWxJR3kvVlZydjU2Qjh0VjNRUXZMOG1hU1E4MW9vWHBPeDFJTFFHMW5CYStOemFXWTUxWU1vdkc1c1J6WHQra2tRenhJbmR3T0Q0U21mUHIvYTFBTnlZa3FMVzlUSkVyK3F5RXgrM0VCTmlIRjR5c2FCamhRR0tJcFZEUmFXTDdIUVdHZWhnVWNrSEVTZ3FoNHV6VFdkemFDbmg4WndLSTNXVmlvQTQzTGxmU0pDUEZDSXhmTHd3cFdpTUdjVEttYURYS1BNclpHcHFrcUowZEhIOSsyVDU2aDhiYnhTSUJ3elVjZUJMMnpsd0ZmVUl4eXYwejVzc0MrbE41OUtaQVM2ZGcxaDM3Tmp5Q3JpQkM5VG91YlI0TzBBNzNRZUhNQzZsVkdFZ3hJajNkMjQ3NWQ3RUsvd21TeWVDM3ZGRFRGSy9ab3dudXZmTU9VOVJuR0pvNlR6Y3FwZm5QRGJ4YjJNNUdSVGxKU1QvVERGcVZQdnpaRDkxRkM1YTRKSitrK0p4dzlJZk83ZFlWeitvZ2hDcXAxUU5meUVlVUdxbEw2U3R6bjZnekJ4dGpHc1VsM0lkdS9IWUdjQ2RmZnZRc2ZXNUowRnp6cGx5ZHlYRTZxY0pyRXd3WEl4ZzFBblNGcllNQjdzNkRiUDJibGQ0S3JMb25qTnk4TUlod093NnViRGlOV2pRTklUYW1xRUVhL1JWcEE4c0F2UnR5OUZrSTdpcC8veU5IN3pvMmNKTDE1SHRHcXJWNTJHN2Z1R1lHOXVnRW1yQ2dkQ1pNNUpYUmM3MFFOYU1xRlRDY3Bjbnl0dEU1ellrRXBPLy9sU3NqVHR1WHovT1RwT2h0dkFPREtReGlPZHpmaTdxM3ZSc3JRZW5lMFpYZXdyVEtKT2t3bTM3UUFjeG1maHhubWNzeHFJSVJNaTFNTDdKaHFiZHVLSGoxMk0xVFgvYy9jVVpsc3FURkVtSHAwMjlTZG1FS28rd2dWNzBkZXZOZDk2enNZd0JrY2pjSWZwazZyVk42azkvbFNMMVVHRUdocjEzbjRxeFdjR1E2Zys3U3prT3Rzd3ZtTVBydjdZUm4zQ3grN1o2UysxU2V4bElMM25ZRGVHc21PNjBLYTZobkRWUVVOcW1QVEJNd2xwcnMvSk1tMkVjaFpoemZaNmNiWlV4VVZ0VEtLQ1pLeDZ4V29NRFBjaTIrYkFVdnMzRlRlbFZEUEM0Tml3MUdLRzZuMjF0Qk9WeW5mVG5VZ0d3L21jNDZhcnFrYjhmSUtZWXFGaWxrelJZVzJJMWt3eHFEb2FBdktrYjc2dTY5NFZLMnZRMDZscVp0SWNSQURwc1N5cUNic09veTRuWThIcDdrTmtVWVhlcThnd3FnbUZxaVF6cEJQdXF1Rm5yQ2VGb1dFTEMrWmJXTExJd3A1RE5nNTFaZEZMRXJTQXpMbUtyREN4elF0ZGRKdDlTVXRma2ZISzBqWjYrZHdtWGxsaWphWDluckprYzdIRHV2SGxjME9SVXVHVk80cStWTlZPaGZtWmVRdzcvcmdIV0x6aElTeStzQmw5KzFONkpUbElIeHlpcEtVSTBqMDFRMVJXRW5sQ2NMSU96SG9TdTl3QWN1NCtucFFNLzJmdEJiL1pYNVpoc2VXNjBxYjlrUUpyaHE0bnJTVWZ1T2FscjVEZE4yRXNiZW8xVVJIMHRwSlJhMEMyYXNyTnFEb2pCN0hXRnZxN2VsanhhcWd3U2kwOTJabE9SRTllaXVTREQyQk5YVDllOGVFR0RkTm1iU3Y2aHZweDg0LzJvNWNCOWZKRmpOdWlxb293Z29NOWxpWkNhbmNTRmZib2pSL2xKR09jMk03VW1DUXBwUnRGR2VZVWZCS2VwWGhieUJrVDB2UE81Wk1yUjA2UUkyOVZ4SWQ2OTNCaEZqTmk2a2hTQk5VOFhZc0tUMDYrRU5uZHYwZjhuRHBFMTFaaWREQkgxNkkzaGtOZWpzRVozZ2JCdVZHRFRvNVE0RzE4UHAzSGNKZEtZemJCMk52bkNMR3cxREtueXdUTjJ2ZGlUYk9RT2lIazZub2tDcWt3TlNxRmNHVVVqdG9GUzIzdVcwSEJCTUtJTGxoQm9oTkVxanROMkUwaU8wZ0lqZVloYWszazIzdlErNzI3WUtxOVdweTRUblhaTWdDSE1IM3lLZ2NKZUIxaWhUTkl0Q2pRMHpZdHhwYVhuNFh4NFRFZDArWnlCUy9FSUFhckhWWlVQbFdGRzNwaG1KRy9DbU0wMjlTN2pLbDZJQzhYYUpmc1MrRGxaQjB2ZkNsdVplTjZJWXplSWs0Rk9JN2FjczU3bjk0eXpuVVBKMW1ZWEtDMi9CNGJnNE9mSC9iS01iUFpQWWl0cmNiT0oxTm9hYklRczRUZTcxZTFTdXF0dWNrazdhRVJ2ZDdxWkYxMERZWFIzR1JqNlpaMWlLMWVUOFZmSEwzQnZ2c1hHY2ZldnEwOWZKc1pNenB1ZlNUVWNUUTlvN04ybncwK2RYUG1rcmZXWW1EUXdlaEFBWEZHNjZHcUNITDBBd1UzQWFmM0diaDFqYkNhb2tqYmJYQXo0OVRXUG1RUERNTkpDdjBWYWozVG9NWXFtSTR6N25UY0ZKWXVEdW5GNjdaMmIzTW9GWWhueG5yUXMrY3BXSWEzbWE0ay9ocFM3Y0JsNk9TRmtTZnhVbGpzcUhBbHEvY1AxMTNWSnNPZWtHZFdhbkhkTlowSitIUk1SeSt4dVVML0QybTYvcDVFTTIvUUpNdVFwU0xrS29HcUx1NldLbFVrQm16dDc4YUxYdGVDN2tleTFINWczRFdRSFNFSlVvVmhWRVZIYjRWSHVNMUxERkhmejd3Z3BGZVdDdk1ha043NU5NSzgrTE5lczJwalpGZjd4amRmSXE4NTBPZjBYTG94czNQVUNYL25JOThTZDg2MlpIWWtBaFhwUWloakV2ZnBTMUUzejBJT1ZjaW1iY2FVZWM4QzFFYUpCNGFRU1R0YSs1eHNjYWZKSU1tUjFLbXgvdkV3RnJZWU9wbXVZTnJtKytySS9sWXNyMEJIeDdodXhHMW9vdEFMby9qVDdVK2hydGJmeWsyVUp6NVQ4N3NvZ2VOcDZ5L2s0U0hOZEtTbjNIY2R4anI4ZlpkVUNuaEpvL2ZjbnQwVTdCMXByRjV1YWhqUDBESlRodFI1YnIyWGtwRGVSaUFtYjVVMkVDMVNSZ0NDOEJzSXJZWVJhc0RpelFmeDZLTUhFSXFHMExxZ3VtWFJ5ZEdXUkRwMzdrOFd1MjA5S2VNamYvUFpvZnZtWXFGbWRYVjFZS1pjN3RnNGVoc2o5cW9WSzR5bEd2YlNycTZzMHdFbE5jNVZtektxdllQMExtQ0d0NytmWXhaSTZjMlJwS3BIclVCTmxhWFpiNlF5Q0NNY1JhUjFPVVNnQVh1M2oyRDcxZ1RPT0IxWXVRTFl0NSthUHdDMEx2U2JlSU9UaDY1SEt1NkhZRTN1bVRDeGQ0SlowaERzUHhZbHRUeWw4YXFZRXJlV0hvWmZ3Q1g4Vy8zNUVzS2xGRTN0OFNlcHVCZXQ4U0QzdGdkZDdPeTFjUGJtSUlhSDFVN2NGR2FHd3FOZ1ZibXJVQnMrYzU1VXlXcEdxZ0pySW94YTdXbGFwU3NVb2JhSmxWV29ibUJzMnRtSFVIVVV0bUI4WHRkaUxtaXRxMitPSjErMThSUWpmdHQ5K1QvTVZvSXlxMEFIMG1idXRpZUR0KzNjbXI4ak9lYm1rbW1pNzdCSUpNWVphMllSeXFSaEpsSkk5ZzJMOW4wOTV2MlA3Z3ZlZW1EUWFMdjRxdmhwNGZvQVkwdUgya3lZcnJaUVVOQXBjaVJTSThnSFhlcUR4QjIvSDhMYVZjQzZVNEh0TzRDbmRrQzNFcWgrVzlXV3I0N2k4dGxFN3RhWWJKczNqUEl0KzZYUFczNnJmc0FxV2EwUmg4ZTRycjlzcDl5dmlzUlV5NE1xUjFLYlVxckc0SEhlSnBMZTQ3Wk80S1JHcjRSem1MNzA3bzVtWFBPU0pCYXNpYUlpTHZUbWsxa2lVWUVLN3RLdEZEaVlBalhNNWtEeXJvbldaZ3BYdFg3VUxZWVZaTGlYSHFEQ1Z5STQzOFNPKzlzUnRQTUl4QmxSMU5LQU10V0lMem5WV2pnL3ZQbnQ3NGkvUDlUVGM5c2orNHpCdVVEdWRMK1BvbCs3cXkyMis2NDJYTy9uWElvSkI3T0VtVTNjZjl2WjZjc0NKQisxWkU5VnpZUnBHZGY3MFpzcTc2clNaZlN6VG1JWWk4aVNISTVnejE2dldyQyt6b1ByN3U3RGw2b21tS3ljM0wrOXVDVjVrZTBlRmtmNmczYjhCSVVpS05VMUp1WXpaRnEwd0VMektpK3pwVVk3cURiN1NCVXdQQzV3Y05zUXRqODFwcmVmS1NxUllaUnN1T0VyZzFLMjVjMk1RU3VoRzREWG4wZll6TjJOaDMrYlE4c3lmazhydzdDNDU0aWRqR2VaS3Qxb0VOVU9xdDRRQmRqS2orY3pER3RVZkpyVkJlSW00L2hvY3hNcUdoblJWd1l3c21zQTFhY3MwcHMrV2ZINXNMcXlWVy8veEtsL2lBYTNuM1hqcjYyRDB3bFVUcE9Ca0NXQmJUbGhGMTh6U3g1cnluM245dUFENis3SjNmL1NGeHZuQ3ZYREFVa09VTzgzTDNVV1NZVUpkc0ZBVGFYQTBua20yaGlNRHc0eHB1TWtMWnRQZjlUaWwyOU1XZURXbXlrWDF5cExscnFLcjA5WThrUmhjUkJYWENCdzlwbUUrV0Q1ekpaWlZaTForb0NmMmZxbnAvSGJIejZyL2FGcFRnclc4SFBYRlJ6cjRnYm8vcHg3ZGdLdmZ5TmowTk85R05UTkdkaTFsYVNNL2tHb0RhRVpqK25Fdjhvcml3QVNRUlZrajhMTjVsQVlUOEFxOU5LTmRmQnpnN1R1SlZpMW9oNTVKd3dqT29iSzVWUVV3ckg2TVFVemFDTEdpR0pveC8xMWIvLzg1bTJQdFQxYS8vdnRSbjQ2eUowcHVURGRyaHpUL3BMU2VON0kvL2UyNEYyUFBPcmNuUmlWaGVFUm1WQXRtMk5wQk5LdVlhVmp0U0pUTWMvTlZkWVhPdHF5aFQzUFpLek5HK21QQ0ZmN0QxbFlzRENJVTllRXNmYmNlVGgxeXpLc1BXc2VGcXlvd3RLVHE5QzZvZzZWVWIyVEl5SVJDYnBvZnM0N2FtcThJeFExY2VWNUZqNzBoZ2pxNHBVd2FDR2hFT05vQ3RVMWczQXdqRkJqbENTdEZtWklaWEZDaUN4Y0FtZWtnRXpYUHB6KzZuVkVrRHlTZ3dPSXhieGlhRlh5cEg3amhYd1FwQVM0OEZTdkxrZ3V1eEJWL1h1dzlNeHFWRFV5cmlTcnJxd1RxS3dWaU1WZFZGVGF0TG80SW5WQkJDb3luS0FzSXZEUUtrZVdhRmxWY05NOXlETlVNK01OQ0VhemVIYnJRVlJGbXhBaFV6UTRacE9EME9WT3VTUUtJeU1JTlROQVM4bXFPLzZVL3U5eXkyZXlqQlc2SlFHdUxFa09seE93TXcyM2xLVG96UzNWbVJXbnJBeXRObVV3R2dnRllGVFBnNGpVSXBmSkc0RzZ1dURMWGxXUHh4Ky9HMW1HT0tzV1IvRzMxOHpCa2w3cldkTFB2L1EwN3Z6cHMxNVN3QjlFbnVIQUJ5KzFzV0psMWJTWkxUZHJJVDBsczJXWWVWaVJNRGhueUl5N0ZPWVlZdFZoTEZsb29XVWxJYnFxVGx0cFgzY0tsUXlyckJxR1hQdUcwTmU3RjZ2UG1uc01HaUphRGMyclEydWRoZXg0UDJQMk1VNTBMVVMrRDNadkI0SU5OZ1k2QjdCZ0pkMFFmVThGclRKN3FFQkJWeUF6MnMzd1VPM3lZZUdVall2VzBtRk16UlJOSk9kTGY2K3JYSWJmbUFLL1U1ZHZqTU5hS0d5bitTdFhEM3p2ekhXaGVZT2pGWENHR2ViRTFacW9sMVJ3NVNFRWF1dlIzVytqZnZBUjNQOGRMMGRjR0tRMlQ4a1JoeHNiTlZTWkpUbmlmR2Nia2p2MjRLOCt0aEhKVWVET24rMmNHTmpxeldkQUpoOHFtOWxTTzVTcFNTM05iQVdvS0Rxek5kS1BKeDU2Qm5HbkI4MTc5dUVWWndZUlBxOXhSc1ZhK1pLbGFOblJpV1ZyM0RuRm9DcVpvYXVRQnh5ZEFuV0dzOGoyUFlzUWtVS283ZDJIdXhBMXd3alFOU1VmYlNlMkJ6RGV0ZzhWeXhhUnNCbUl6cWN4OEJ5SEhtbkRTS0w2MnBsOEtNcGsrRXVGV3R3TDJTbHBueWk5TFZxeVVXUEpWVisvdXVzM1M1ZlZvTGRMa3NDazRaREZwQk5aVkViSTltU0tXbXVoWTFzZllnZnZ4UnFkSXphUHlwTFU4TmZNVCtLa3R5aTJxUXFXRFN4ZUwzRm8rOXd5VzJHVjJSb1lRKzlZRXIyL2Z4Q25MM0V4bUlnZ1QrWTZWOFV5UlM5NkhuTXhyMWJNR29PcUh5ZXlYQnZqQStxSEJlZ3J5SGd6T2NKd2RvVFhuZGZacW9ydUhLSUJSMmU5Q2drYmN0REZTTmR1S29SS2kyelQzMzJvVy83cG1wL1AyMWFtNWtqN1VIT0doaVV4VGYyblFQbWZXTVNIMy96aTE5ZVBiTjFreGlzWXEyVTRNRDhvVk8xemhGeTFhYjZxaHJMRGRFSjdkOENxcXRDZHdHcWJjYUYrM1lpYUhZalF6eEU4akNnUW8xWktPUTlCdGQ1S2RwRWJIVUF1MVlIWXF2bElQZkl3QnJZZmdCa2gxT1VkckNiTWRyYjNZY05sVlNoRUF4aGpIQklXRkZ5dGlRS0Y3YWlDNit3d0NtR1N0RHJWaER4QTJPekErSjBQWTlXaUtBYjZoTzdma1h5dm5TVmFWRExzQ0hvYlNkb3BFb0NhaUxabTlhVEtEeHVTeWlXRzBUVldnWGd3TVdzTXF2eTNWUlZHcUNhRVRGcWdvVUppakt6WFVkU0c3OUVwUmNkRzE2alkydDZOZXhoQ0diVVZUbU91WUxnaFMvWERHZWdhTkRxVGVmUGR0KytxNkNvWGsxclRCS2x1bWVXYlVuakZGTDliZks4WnI4VllJZXRaaUdKNEtyMnUxa0RETVdxM3hZdHBXVUxmRWtBb0laR3FPakpMRWpGZVlaMlhJKzc3OTd0Z2pVZzgrZ3lKU00xNmJBby9xbUZXL1VyVDFNeVcrcW10MHN5V2MyQUlXVCt6bGN1ZXp1QlNIaFZFMjlsRGlLMWVodEN6ZjBKa25rQ0V5REpHaThxcHZIR2VTbUF4L0JFcTl1YjNxaDRkS3A0VjRpMEpVZjhoR3d1YkthSmh6b09iUTR6V254dkxvYVkxaEtFeE9mTGhXK3JlZWRIS1RLUXU1TVJYTkJiT1VtbjFjTUJ0R2h3M2YvUFQ3UlZQVDJkUTFneFpCM2NhMWl2TEVLbWlBbURrbVYrbUxuMWpEZnAxN3RlbTVXUVJxZ3dqcitzNngySDJFejZxNlpNeUtXeDY1WE56eEhrVmdKZmtpQVBGSEhGMkhOazlmY2hSR0U1U3I3cnFRdnU3ZDVvN0ZxMHhxazV2Q3M5WHlsRlhFOFdUanpuWXNJbXZxOTZhcEkyZzYvMDBsN1M5YmMxMVZzczJkUkczWXFFanoxT3h3bFNzNzk5Yi9laVdzd1B6bHJiSytkUEZvSkxmVVJoMmRDdGxGWDNpL29NeHVZakFzNWRjWXBDS1V4c0xrVTJuc2E4ajBLdGovejBSdFJhblN2eC9qdksvblRwdGI0dWNvUkNwbklVNlUzem54RWJnT1R1WVVoWlN6ek5YTjVQSjZhU0NEY3ZKZTBWanVRSUtoMGFRR2FBNUw0ek0yWkpVamxnWG1TRUVLK2lxOWNqOHZ6OFEvOUZUNmNyZm5XYnR2b2pLOGRkRjVXaW1jclR0RG1NNGFla2VIUDBMVDY2M1hhZWhHTEg2bFNmMWd3SnE2NERrZHB4MURCUnJkNC81cTgvOFkreC9yamcxczM1Wms3T3NxVWJPcTY0UXRhb2ozeENHS09Ta2swaUZSOGRTR0JoUGk0TmRJOVoyaHFteDkxM3UvR3hSSmYwK0w2NS9NSVdPVHVCM1cydS9pOWwvQ0ZmT0JMa0NzLzhhTGNxc25EL245ZDl2RC94K3hjTDhYZWR2TVM4U1pIWlozMExVVnFsUy93aVBXdThTK3JkTEhud29qeTFiZ25PeUpGVmlYN0JKQ2tkRTN4UHRrY2R1MjFGeGUvdUlwVnZYMC9sZ3Boek0xdFE3L2dBVklTbkFtYW9jS21IRCtQUklJSHFxWXBFejVXNSt0UEwvM0x5dFVxMkt1TC9hSG5rYzIvRUl2QVoyNmQ4V0cwSktiL1VSQ3lYZWNNNUo4dXIrZ1V6ZmFHak5ubDgvV2ZIa2dYenZ3eWl6Ly93Y0xGU0t4WXNYbXpQMXRreVRjQ2hsdU0rcFAxSzNGeTVKcno1N2pmdWFwbnE1MEZTL29HdWcxVEpsblpBeVdIQmtLcDFHNTJEQzJORTNMQVphR3JDZ3RSRVZkRi9Wa1lEYkhBcklHa3ZJQUpVZ1RTN1MwenRpN0c3ck4vZHM2d3pzM2RvVjdFcm1kWVprWWtHNEllckUvdjVWMmIrNTRtSmpvMUtPWkZMcU5yNmljcWhiQlh1dXVtOUxIU05tY3I1eXRBVzNMbDFxTGJyOFluUDlrWHgyWUZSMGIrc0kzUC9iSGJGYm5oMElkcGNJeXlrandMTENuSEtVbHBETEtiVkZNLzNHOTJIUEs0RWFNM1dmbFJIaVZNR0ttUVJia3VjMXA5d1hVNTR6cHVTSmpXa1VaK3JLL3NTNFRtM01MYnJrZFB1aVJTMnlLV3pKbW1oUU5rU0NibFZST1pJcDlIYVBHSHZicVJ6Yk93TjdudTRPSHZLVlE2NXJ5aTNrWjErNnNGazJod095T2hxUWplR2dXNjArYTFNQitkbWUvakhqMlk0QlkrY3pYWUdkangwS3RZOWwxVzVUenhGYTZlTzVDSEk2WVpZS0ZOT1JvSElDRlpqOVYrREwxaHZOVXY1cGxoSHkxTVMrTllNU3pFV3dNeW5nYkgvbEZpRXdaV0xMVFhhcGdPUXMxdWhNRVpveml6Q25nMWs1bXlETGthSzVsRG5JS2NrRVVTYUxaRXg1MzlRSk5LY01jS3FneTZVZ3haUkVoeWl6cloxUmhzakpHVmI1cDlOOFdTWnpOdlYyNnVHVXVXOVA4MzVueXZQVEVaOVpHZTFNTEhmV0F0NnBiTGJNL2FsUTdFd1phRG5oR3FVeDdBeXdMVW9nZWpwM1lFK3p3VVE1b2NvcGl1eVdlVjdPWUsyeldWMDU2M1hMbkdNMlljNVdOVDl0NmsvTXBjeCt5dXZHRE9ITjFEaDFydkJubExIS1VxaTF5eVEzTUFVZE1NMytCT1ZxV3QwWnJFRE9BTDNsQkRNWFgrbE9veXh5Rmpjd3F5Qm5pa1BGSEU0Z3BsbEhMYlhZcWJsZ1l3NytVc3hBZ01RTWpjbEg2ME9udTUycnBjb1pMSE1tUHltbktTcVlscjArbjQyblp2anRvZWRZbnBqR1NxZjZVMk9HNVRsM0ZtRk9kMHduUkdPT0V5Sm5FZTVNeDF3dDFwMkJYSld0REpuRlp6Ny9NczQ1RWlWakZ1MXl5NUNhY2xYaTVYTElNd2xUenNETVo2eG1QSVpDbllrTnl5T0EyYU1XNG1FWEp1WGN6bEd5aWVCMFZmYVlJYlNaRGo3bmFvMXpzY3lqM1lULytRaFZ6aUNzSXhWa1dXTm9iMjgvNWhZNlhZNTNUZzJvMC9oVlVhWUpaeWJoSGEwd3hUR0czK2NyNUtPS0xZKzNRREdETUdlTFpkMDVDdTVveU0reHNOQWpKVXRISStpNTVHVHhRZ3RVemtDV1poS3VuS1BnWmhPaW1JTTFIcTFBTVllSmwwY3A2RGtsMlA4M0JEcFhvV0tXRlp6cEZnTG1VbUU0RnlHS0k1eXMyYXdWYzhqbXpNVkhIaGRoSGl2SVBSSmZXazd3czFuZ1RMNVNISWZ4eitaYjUyckJzMW1qeEhINHM0N1JCTXlVYXB1TFVPVlJXdUx4RnVqUldpN20rUG94RjY1MWpDMXpKbXVkaTFMSTUybUo0aGdKOEdndDkwaGVPeTZXYWgwSDdSWnpTUGpQcGhUeXoxeWdSeUlnK1R5LyszL1Zod0p6MkFjQU15Zjl4UkdtSTQvSEpNbm4rUjU1REpUb3owYWdjeEhDYkVuLzV6T1o0aGhiNS9FVS9GK1VRT2R5WWVKLzhlTGxYOGc1LzJ3RmVqUVRJUDdNSnZWL1hXQ3prb2k1SnVkUC9QMWwvUDFmQVFZQXh6TW1pVHJNNFJrQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJZ0FBQUF4Q0FZQUFBQUJmK0h2QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG94TkRCRk1UaEJNak5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3hOREJGTVRoQk16TkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qRTBNRVV4T0VFd00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pFME1FVXhPRUV4TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZ21hU2tBQUFDVWhKUkVGVWVOcnNYSDlzRkZVZWZ6T3pQN3VsV0VpNXRrRExJVkJORmRTVEZFUWhKeUhSUU9wNVlEaE11RVROOGNkZERJbnh4Mm44NXhKeXAyZzB4QmdUSThHRFJPVU9NUm9NNUlpWTQ0UVVrWUFjQkRsYUxXaHBEeWlGMHYyOU8rUDd6TXpielA2WTJkbnR6SFpMM3lkNXlUTDc1dTNNOTMzZTUvdmpQU29NYks4akp2RFI5aHU5TGFhdFdiL0dNZjR4UXR0UHRCMm43UlBhUG0zYzJKNG8xRkV3SWNpanRHMm1iUTYzNVlSQU4yMHZVSkxzTGtZUVNWYkkzMFNCUE1kdE52RkE1LzQxT3ZjdlVxS2syVFhSMkNFbEM2OXdja3hjWU83QmdheHI3RU1zS2E3MWlNcXozRXdURytCQTcrdG4xbVlSNUhCM0tPRHp5Rzl3ODNDbzJZbEhmblAzMDcyQkRFSGFwOGZXVVhscDVxYmgwRjFORStYRTQrcG5HcENJWGtuNUxUY0xoeEU2SnlRb2lKLys0eDV1RW80Y2d0d05iNk1TUkJLVkJtNFNqcHhnRlp6d2l5cExCT0xsSnVFd1F0QTRvU3FJV0lrZlBQcS9PSGwxMXdqNTkzOWpqbzZMOFhZZGlsajJ3ZmN2NzdpaFBrT3BpQ1dVQ1IydmVrQ1dTdnpTbERxUm5MNGcwNVlnYzZkN1NmTVV5WkZ4OTU5SWtrbEI2MWM0OFgyYVhMaXNrS0MvdEZmZCswMlVuT3hOay9VUEJoMTczbHdNamNpa2J6QTE2bkdtVC9XUStsckgxN3BRTVlMYzJ1Z2x5eGNreUJmZnBzbU9BMUh5d3BwYVIxUUpFLy9VQ2k4NWRUNWgyZzk5R0FyMU16TnVPSzZvcEg3bG54SHk1OGRxc2tnQzhueDRNRm5TODI1L0puL2ZxK3U3ZU1uakZNSzZwVjd5OEwxQlZ3aFNNWFIyQkNsQlJqTFNIZkNOanBzSFRtcUduZEVna2I5OEVDM2FmL1BIc1pLTXUyWkpEUW41TlNJVUlva1RtRW1mZmQzUzh1OC9kQ2FWdFFBY0QxYWRHQVQrM1M3YVcwUnlJNnFRVFR0SGl2WjlZa1ZBVlo1Q2dCSmdkWGUwU1dxZmRVc0x5L1QzLzVmSmtiTnA5WGZuejVKTUo4a01JRTROZFUxYjl5ZXlTSUxyZGxmczc5OFlOdjN1amxZZmJhTWhpR2I3R3I5UXZRUXBqY0gyKzBiajVuMC9QNnE1aW1WM2VETVRhUmFnQW92YVBHVFpuWUd5M2cvM1hSNld0VmlxdGlJeGZjbVlXaWRXTDBFSytWYTJ5cG1zUDczS1R4Yk84enVXdVVBOW9BcFlnUXc5QThrOFV2WDB5NWJ4aC9GK0s4RGRPT0VXelJUWVRUY3g1Z1F4U3cvZjNSZlArUGhjY3VEN25mK0prSUVoaFd6c0ROazJQTzc3K0xBV2U4QlZHYkZ0Zjh6VTBIQVJoY2x0LzVDY0crUUE3cG9ORjVjdTY5NWhLcERYd3NyNElnZ21jY3RuWWZYQmx5K1FDc28vakIwS0NGUUowbW84OHNlVjlnSkFOcTRWbmw5ZDNKWEFSVUdGU29tcE5xMmY1TW9rUUozV0xDbnZYaGJmQktzNUJza0ZsSUc1Z0xVUDFGZ2FocEFJK2V4SXlsYVdnTlFTNDdZMENKYVNiTWR0ZkhRdzdsQk1WUjB3QythcmppQUlDbEhyQURuc3VBNlFwS0V1bHBjbDVPTGkxWFNtWHZCSWg0Kzh0U2R1U1NRbll5cXpMS1NVN0MwWGlKZmdFcDJNWXhoVzNPVXRPeUIzalNDb0NMNjdMNUtSN1Z1YlJQTGx5VmdtVjdlelV1RTZ6RWlDZjhOZHpab202ZkdNT1VHY0tEdzVuNzNsWjJoT0twVnhyRWhjcVQ0RjZiNll6UExwY0J0MkFIZkJNTGRaVk5YSGpDUndWM1lDUmJPc3lxM01vZGp2RlZJZ3VFRVdJQmZManRqOVZyK0RCZXBDcWQwNWdtQlZkN1NseU94ZmlGbkZKNWJtYnRsUW0vVUM3S1Z6QTc5UVFJdEp6dlVsOHdqaVZoYmhOcERGRlZOZVlPVkNuMlg4aFBRKzEzV3doS0J2VUNHcjczUE90YmdTZy94cFpTanY1Um5zc2hzeHlYMjNwMGRWMHJZVEd3eEhLa2NRcTRwcmtKSWVGVjY0eGRNWFlxU3pJMFZXTFF3V1hBeEk3enZhL0pudkVKZGhYNHNsQk5nRUhUZDFFT1oyQUR4OEtYQnI1N1FhZ2NrR2dSYk05cW1URGZYczZROFgzRUZHakFhMXdFWW4xQVNFd2JYT0RvOHBxYXFhSU9jdnB6TUJheVZocDE0Qmxia1dyaDZpZ0F6SSt2WWNqWktEcDlMazZnMU5SYUVTREFqU0VhT3grT21Xa09Cb2hicWlCSUZ2eElzQ3JRMmxLd0pTMVVXMytWMEp2Sng0dDNKV0s0NG5XRTBteG1RdXR1OUtpcno5ZVZqZGFHVEFidmpBa0pZcGdoeWJuNmgxUFM1empTQkljU0YveUZMS1lUaDhNcHFkak1STzF1QVVJTzA0cEZST1ZSVzFtNWFHaE9tOWlObHdQc1M0aFkvZGFrWVNMQmFvRE53TVNJS0NwTjNNcnFvSUFpTWFpMXJsRkpGeVUyQ25zZ2FHY3M1UnNCV04xV3NNd08zQTZrQVRsT1hyYzZrTUVUQSszQWtVQTZRNGNuWTRTMlVZU2VCdWpuV1BrUFcvOXJubVpod2xDS1FYUHBUVlFCQThsZlBnUDExT2orbzU3SnpUWU9jb2lzRVlBN0J6SlJzZXFpblo5ZVh1TWpOYnNlT1FiRUdnQ21yTVZNeGNFWXRYWUdzb1UzdExjbFJIR2x3bENGYjg4WjZrR25Pd2piU25WdmdzSDVidHArQWdjKzZ1TEV0QllheFNWcWQyTmxXeFhLME11WDNuTkhrTFRzcmhNL0VzWlRLU0R5c2Q3NHN4ck9vWElBTTcvYmJrZGs5bWtzTXhyWm9LMGowNDMxdlNZbUx4eW0wekV1cStFanZ2aTh6R3lYcUl4d25WMlBWVlBGTkZOVXFqRmVCNlBqMWl2cU9LY2V5K1pPNVJRck9qaFZiM1ByODZmNU9QQmRvZ3dvYUgvSG5mLzJxT1Z2blZ4aWorbXhnSGdiY3g2T3pzeUs4UndVWGJMWmZqbVRhdDk2bjNkSjFOcVFVektGRFZLQWlZakFyZ29qYVp6UCtsejdiMFlyVTQ1VGZ0eEJ6RmdJUExoZDROeERCVEZ3U0lzNmJGMWFDMUdIRG1ZL21DUUpaOXpHd0ZjdVR1SnhWN1J5eW1aWGNTeHc4MUNhUitjZlBBbHROOTQ2M0FCRm5IR1FpM3RybkhPbzN1N2s5bXFjUllvSEZqKzNSMTJhUmtJZW9SbGVCNE11SllHYTBTZ0FLTTlmdkpDbEV6RFdpY0VrOEtWd2tIaHdIeHBBaE9LQ3BCaHNMU0Q5d2tIRVlNamtqbkdFSFNKMzRNZnNWTndtSEV0eG9uWkJBaytkS3VwbjJSaE1qZERJZVdSU1hFb1pkM04rNmxIeE1nU1B6U3NPZks3bU9UMytlbTRRQW9GN2IxWC9OZUFUY2tFcHlKU3BYMHIxT1RydDgvTDl3d1kwcHlMamZSeEVWWFQ4M2VKN2UyN0tBZkw5QTJMQTVzT1EyQ1hLZnQ0dS9lYVgzdm05NmFBOXhNRXhQSGVvTmZVZzVzcFIvN2RVNmtwV2NmOVpQWDkwM0RqbFFxSlF2aUIxMzEzYlVCZVhCZVk2TFY3MVZDM0d3M1A0YWowcVcvSDVxeS9RL2JadjZEY3VBOHZmUWowZjZldTVMNVU5eU5HOXRSTkt1bkRmL1hmR1pkTUQzMXBWV1hGaTJaRzc2N2NYS3lOZVNYYnhFRkluRnpqbi9JQ2ttSDQrSzFnZXZlODRmT2hZNy9kYyswTGtxU1FaMFlJTWdRQkFOOXMvNVd1MDRTWEdpa3JVa25EQ3FzcUdlREhBSTM3MDBCN0FUQ2E2Q2VIOVVKQWJjeUFFRmg1RkFKUXVvWDU5Nk16Q2FnRTJVcWJaTnBDK2trRWJsdGJ3NFIwY2tSMW1PTlFaMFlNZjI3RER3bU4wZjB6cmdaVzY0K25Sd0NWNUdiUWowVWZaNXhHQ2F1dDRMbkxuNFdZQUNlSnpqU0NkOGwyUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUJzQ0FZQUFBQ2NsRUFRQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTjBJeU1FWTRORE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJOMEl5TUVZNE5UTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWTNRakl3UmpneU0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZM1FqSXdSamd6TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrYXFIMGFBQUFLRnhKUkVGVWVOcnNuYzJQTk1sZDV6TWlzNnI3ZVo1NVp2d3lxeFZpNEFpblBZRnZIREFIVmtqSWUwQUNXZXNUSU5tQVFXSlBDSUVQMkh2Ym0rMERDTzBKc0pFNElYRll0RnF2OXJqQUh3QlhCbkZneGpQenZQUkxWV1lHOGYxRlJGWmtWbVJtWkhaMVA5MDkzKzlNVFZWWFoxVmxWZHYxaWU4dmZpL3Fzei96dTRWU3FpanN2L2lQM01ZUENyZTF2ZGIrOStHMlhHdDczeGZzMVJmdER6OXQ3L3dKZS8yajlvSFA3TzJ6d3BpaWFRMnVWa25ibDlpVVpYSFgyamROMGJickhvdVBxQ3I5WjJWbFJ0Nzg2RWVTT3Q3ZTFaajFueU5GVVJSMUg5VjlxVi9ieTJ2N0pmOHY5cjUvc3R6NGUzdjdCMFhSL3AyOWJ1Mi85bTUzRWFhRW4vRjQrL01QLzkvLzZEMXJaZnlUcTBKM01BOGdGNERyM3ZWNzluZS9aYS8vcTlMbGp5a1AvaUlzQWp6WTVIWUxxSytrSXg1dmdhNE9QOTNOeDl2YTkxbXVvMmRsUHg5dGdSNjlneVRVcDk1TDczakEzSDZHaFRKMzh2NHBpcUtvdSthNk9iUC9QYk8yN1hQMk8vOC9xY0w4a29PMitXY0w4ejlYcHYydS9mbDlnRjNKL2ZZSWUzRlFQK1pyRlhBdWNBNHcxNEI3R1Y5LzNsNy9rYjMrZGZ2N3JZWDV3YzJIUlVCeGNQa1EyTlpheDd2R1hjcEQ3T3RxdlI1bHdTa1BZWW43VTZCdEVWSFE2OTI1eGdKazhKb3FCZXJwWlV4M2ZBdG5YdHk5TlkvZkFpTURGRVZSdCswa3ZXbVRMMXpudkMwQmZrd1o4M3NXM1AvTnRNMmZXcGgvb3pETmg2WjFyQjM3YXE0a3RPNFBjREF2RDlkeTBiOXM0ZnBkZS90ZE9IVU5tSXQ3RHhBL2hua0FaMlZkZjkyMEs5K25qd29zZ0hZT0xNZGNjbTJhUXExY1B5RFVYbFo2RklTcVdCaUN0NHVMdG0xWG44OU5RUjdmUjZoVEZFWGQxaGR2UkFMakxad0I0RnYzNVd2YXJRWGhiMXAzL012V21YL2QzditYQnF4cXUyVkFuMFdIc0xtMlQySEJkSUI1WlMvZlZycjZHbjRPSUZjZTVuSzdnMm8vT0s2OHM4WnpOY1U2bCs2aUEzb1Z2RmQvc0NzaUFob0xsMDNaWHpDb1kxQ3JSTFNnNThxalNFR05jSXErbXh5QzJZK1ZRS2NvaXJwZG0yNGNESlFIdXdWQTRmYlBMUWN0d0MyODMxVkdmZDhVemM4cVUveTJQYUpXN1loRGp4UGVBUFZLVjA4dHpQL1NYbjdSd2J3NkFOWW55WFVMZ2RpVkR4dzFmcjBwVmJGZjRkS3hUMkN3TDcwQzVPRWgrRnh5UXNoR0VzOVVid0dSN2M0clJDMzBLTUJUcittY3J6bDI4YTBMdGE4NWo3VXdWLzVNRGNsTlVSVDFab0FlLzFjNXdEdkcybTltaE5sMUkvdm45bzZ2V1ZhOVoyLzlpajNrNGhqb2hYZmJzbGZ1bkhsVDZPOXRMTXl0T3krVTdBMzczd2tkRDVuY1hiaDk2S0JWQkF6NzJNWVVBcW9sYWdPUUoxenpIT3VIdng4N3ZtNThlc0hDeFFNV0c1dXFURHJ0MU9LaWYzOS9MeCtmVHkwaEYzWHJXWUF4eUhPT1pkaWRvaWpxMXI2Um8vK2FnNzN5WDc1Z29FdUVhOXd4YmZHTDFyaC96OTcrSmVCcjROQmo1NDJ3ZXZrZGUvMmxCazVkQWZCVkw5U3U0dEkyZnhZcFJ4a3h2eWhMNi96ckZTNjlHRVFBYmdsMGJyR3gvTW1ycWp4NjNCVFl4NkF1TUc5Y2xPQzJOUmJ4Y0hrVWhsQ25LSXA2STB6M0hKSm84YUgrVFA3MStEUmFCYWgveVNqekhYdnJhNzN2OTE1NW10YS9ZaDM2VnlXTEhjNjZDSTc4c0gvdTRPMWRwRktUTU8vQVY2NExuV00vK2VEMGwzNCsrUTh3N1hKYXlkNjVWcU43KzJwQlJBR0pnN2NOVE1uRWw3OVhjYWZKZGhSRlVWUXUxUTlzRGRGd2xKUkxUdFZSd25yNTFYZi84N2UrUE9CUzJFTXZVWnIyblVLRkxQWlNuckF4amdBNnptYnY2dFhWRVRTT3d0eitVbFhMOTRWUnh6NldIYTVtL3NrNVJsd3BzZ3RXMU10dnFzUFdnM3pvQ1VxcUJOamp6d2p2YlYvZlBzeDErUHVwNmNYRjFDS0lpd0NLb3FnM0FQYU92ZnJBWm44TlpyLzc4OS84RHoySDdrUHUzN0xrZjljMWtDbTdlblRBeGpubGZqZTVGTXluWENyY2JMa3dpL3k0L0tzUDdGUElyT2pFaHZkUmxhbkl4RGpZVTRDRU0yOXZrZWF5M1dIUGRVazlQNkZPVVJSMVg4QStnSHFYbkY3NnFIcjVPWHZqbXoyZzI4dVBXL3YrYTcwREpaVHU5czJienNXcXJDOTZOWEprQ29KenFsdHpjb2ozb3dETGdZcEVPS1hHdHdKeTNEcWMrWnJYWHVMS1M5MlBJdVFDV3JFM0hVVlIxTDJEdW1OeTZOenFqTGRsOTY5YWwvN2ovbnRmRHZnTmU5bUVoakdIWHU2SEowVGxHUUEwNTh6VGJ0UTVWMm5Bc3RDbE54TWxiekZVMTE2V05yN0JlNmpLak9qRWhGdXZMY3pYTnR6SmRlV3B6MW5SWWxNVVJUMU1xQmVleVJHanZTSGZDTU9kUTFlQStsYzZXeC9pOUhFYzN6OGhJQlFETmhmbVEzZTdSTU9ROUpRelhxT2xJZTh0OXM0TE5icTRtSHYvcU1uZjN4TE1neXNQQ1lnNUg5RlNsODQxQVVWUjFCdUFlc2RpTldqeUp0eit5cnMvLzBjU2hQK0MvZWs5eWFRckRobnNTcVdSQUJnMWliYWtLc09odW9sa2FuSG9QYnplcVdHeTFDVnZKTUtnRndNdmZBN1lQdGpYdHdQejRNcm5QcUlsb2ZlbGl3Q0tvaWpxZHNGK3FCcjNtZkJ1YS93OXNCeWQ0bjZ1aUVoL09QcTRQM3NIOWJvVk1JU3dybG9JRGJoY2w4RStmL280Qm91SXFVWEFXc0RzRjVTTDRUVzJtekxwWW9mMTI2bG1NdGl1Mk8yYlczTGxnMlkwcHIvUU1wbnZMNVdFeUE1eUZFVlI5OFdsbTlBeGJyQi9MQXovSXNyV2Zpb0EvSURuc2JTMkdPcU5aTDh2aGJsQVNDOXo2Y2NOV1U0VGVsOFNiUSsxOUdQbFhtTmhlQWhoL1YxOWVwaUxLeStYZDVialhqcEZVZFFEQm51QzJmWjcvYWVCOVo4YzBsSDFIampobkZGRHZSRG1BWUNiQmMxbVpMU3BPZkhlZVh0b1hKUGpncmMrczMwcUlwQ0NPc3Jpcm5iMVNXdk5YWTk4TFIzNGtzbDNLM0liSmdJOEo0MktVQlJGVVRlQmVmU2QzbytzL3lTSThDTTlnT2NaOUlQejNEZCs5T284ekdNbmk3M29zc3dFT2hxd2pPMTNyMHh2UnhsZWJrSWN6bk9ZTlQ2YUJCZDljSGo2NjMxelVwaUgvdkg2Nkh5V1E1MlFwaWlLZXJBR3ZROTR5M0xFdlovM3YvSXphZTdWdEtIYm1abUYrVkN4NjgyQmVoTGlLNVZiQTQ2WE9OdU1uMmU2TzU2N0F6QS9WYTE1Y09YU29XNEUwa3RENlF5OVV4UkZQV1NxOTBqd0hFRGYrdkZicTRWczhUaDdPd2Ztb1Y0NmR5KzlXekNjQ0VJbTB6YkREWGZKZnhOcmlONllWdnZQOWE0NVdhMjVEalg4U3h2em5NaWxNK3hPVVJSMW45a3VYOFpicmZWcHZwVVJFa2ZpVnk3TWc4NDNWUllZcEFaK3d1MnFCWmUyTVZtd3hYbWRiOG9zVng2L3IxMTl1bHB6Z0J6WjlWMjVuRkxMSUQwN1luYjlYam9uc0ZFVVJkMGZhWUNpa3VTcUUwQzliZ1ZtWXhCSWdSQ2NPck5RbjNmVTBmUzF4R1dKMnN6KzdlZmJ5czFqSHlGNDZtNVoySnlnUEMyVXlia2hNRXNlcDI3Qzk4em9CbUZPVVJSMTM2eTZEaERZbE9YaXRxd3BBV2FZN1oyQytaaWp6YzE0WHplMVBBV2tlUnE1ekhhZFo4MGptQ09qL1JTdUhJdUpzYi9IbkV0WGFrV3NmZVp2aFcwRWdweWlLT29lTy9RZVNLcFM0SHBUdDM2OXIzc2pTYWRnM3JuMDdYeEwySkJSUCtWTzV5Nm1jTWxxOCs2OEhIZTdBN0NIbnZBM2hia2t2dGxGeE5ZbnZxa0p5QzRPdlM5WkFBeEEzcTZZU0VkUkZFVzlJYUNITC9WU01xbHY1dGJ4NVErNHBWckVKZ0d2WEYzNlhJSWM5dEJOdEk4K2hIWHV5YzFsbnVNOE5uN3ZmREtrSDFxNk5xYTR2R0d0T1Q1dnVQTE5pVHJpTFhYcDhmSGl4QWx5aXFLb2h3ZjA0WmMvRXVWay8zYkZ1Tk0rMVB0bFc4bUlkV2htbzVXNDB4d1h1d2pnaWZPYTB6WXFEWXQ1cUVZV0daZlhONE01M2pkZ3JsUDk3eGRBK3lZdVBjeUZ4L3NoeUNtS29oNndRMDg2VlFzYTFHRHJsZkJzZlplMDBRWXVnK2QxMmR6VHIzVzV5MDg0UzdXSXZab0p0OE9kbnlFWmJ1UTk5MXFtZTVpM0srbUh6eFVnUHh2MmlKLzR2RStaSUJkQWpraEtBRGxGVVJUMVFJRSs1Zkp3RzRERi9uYTEwcTBERkhEcVI2d1ltUlVPd0UxcG4raUpQdFlRTG5YY2ZxYW4rbm0wbHo4MTB4eHZDREJmMnpnRzBZOG5aMVUzVzMyS3ZVdGNlbzR0Ti83dkVrQk9qbE1VUlQweWh6N2VvOXgxUzl0dXlsVUpjNUl3dHE5SFh5Z09aeVA4UExkNHVNbHdscWtCbzVYUEg4aUJKaUlGYTJyTnBiYmRMbHBDaUgwTnFKZkFmN2czRG9Eajc4R3dPa1ZSMUNNRytxaFQ5MUFRVnpsUlRqWHRyRnR4NmtYR3Z1K1RDWmN1ZS9QWDY3TEowYjF0S3F6ODlLeWE2QVIzY090NEgydHF6YkZnZUhhK0djMU5tTXBrWCt2U0VWSnZQY1FEeUNtS29xaEhEUFNZQ1hQd1FLaDRqVnRIdVZnTXdyRXBZQmlHc3QyVWs0dURzVVhJMUdVS3dySi9YK3BlQkNBbFBNZlM4clRRRHg0TEJuMjBvRm1YbnpEMzJXTi92NjVkUzE2RzFTbUtvaDYvcXFVUENDQkJKamljK203aEFKSkw3NjdQTnVPaGJWeWo1U3IydStkQXRBaUhJd2NEc2srMlpjSWhINklDenVIWHhjWEM2RUFvUjR1akduamVxVHpCMGQ4VnhXUWRQbjRITjk0eXdZMmlLT3JUNmREVkJQUFVvSUZLYnpXZ1hibFZUcm5aRU9yRDVpN0RzSEU1VVpjdUNWMU51d2ptMGd1K1NVTU9FWUZxcHY1N0RjeWRLOTlJNHR2WVlpSGwwbnUvbTBwYVZPSHphUDJBbklaaGRZcWlxRTh6ME1kQk5wR1k1ZEVpcFZlYlNzTHdTMEx3Z0hvWWtESTJTLzNwK1NhWk9DWnoyT3QyOHJ5SEZ4eWZBaDJlSC92YUFaYXBldlA5dmwwRWM1d3ludk1jSWZaeWZFR1Uranh6L3c1NEt3aXBveXNmdytvVVJWRlVkc2g5RWtaK1ZuZHBJWGE5SVB2NzRxb3UzbnF5RVllY2VpMFpyMnJkZjJydlcyVXNPb3FKeUVQM0FmaXRnOVR4VXQ1bDM4dnJxMzMyQjRwb3haTXcxQ1hqTTEwQzRSQlNENW5xRkVWUkZIVXdxQm5ReTNXVGNMdFB6MTJqbEJ6T3dqRmZTSmMxMHdGdStEZ0FQeVVzR25KWmlOY1pXMlE4dDg4L3RpakFhYjIreW1zY0U4clI0TXlQUnRLcVBKYyt0b0FLNTQrRnpmVytJY3dwaXFLb1l3YnZtM1FwbDhxRVVPcDNhTTRDc09VMG82a25ISEFJZjRlUWVBL29kU3NoNXh5RmJPK2gzb3Bnbm1vaTgrcHlsd1ZQdk0vblQ3YTlwalJySWgvRGhSS2NPQUF1VVkrNlhkM0VocUlvaW5yOHFqQVVEY2xVamRGRnRVRWkya3paV3BIWDhLU1VtbXZsR3JETVpLc0RWaGNXNnM5RzNEakMySEQvdWNsZVV3bG9jVFJocW9uTXE4djlhSGxjL0x4NERsZS9ybnBqV1k4eTBxUDQrbFNvWGZiR0c3Y0FZWEliUlZFVWxRMzBjRVBDdW52c2Y2TWtyU3JLU3MwMmtKa05IL3VhZGV5dnUrbHI0NEFLV2U4QjZ2RlQ0enp3UEVNbkQvREY5ZXJKT2Q0bVhiY2UycTZtbUFtWXo5V2E0NXdrZ3ozSzhCOUNmWWxxbjZtT0N6bE9VUlJGclFaNnp6SERJVnI0Vm1VcCs4R1Z2ZWdsY0IrUTFiVnozY2grK1pUckRWQWY3cHNyNVNheEFhTHhvZ0RQaDB6eXFZVkgyS2Z2dldscDhhcDdweG9nbWdQemJXZ1NvNDhYQkRIVTUxdzZvaU83dW1HU0cwVlJGSFU3UUk4ZGNHRVpXeXNIOU8xSVJ2Z2s2Q1BRWVM4ODdKbVB1ZEFoMUVNSUhCQUdTQzhYMW9LbnpoYnZZMWc3ajVkNWVURU5jeHp6MXZtMjJHeDBpdEhaa3IxeFAxcVdZWFdLb2lqcTFvRWV1OXkyY2RPNXNQY2N4cHlHL2ZRcGQzN3N0TXZpN2FkS25QQllDQjVRbDVEMklCa09ybmpZbVE1bFhHT0xESndmempsVzZubkY3Vi9Wa3pESDQ1NC8zWGF2WmRMR083bWd3SytNTHpjTDQyUWZHOGZqUHp2WEtCUkZVZmNVNlBFWGRlUEhodUlMZkZzNXNDL3RGS2UxTHQ1K2RpWndHM1BjR0lDeXNRdUhlSkJKNkNPUHhVRFFpOWU3NHZQdm5IY0FId3EvN3k4S1hMTWFFeUVaMndCVHpoOExDYnh1UHR3T1lYZTNMMjZrQWN4REJ0MnlPZXlFT2tWUjFMMEcraER1SVR5K2FSQ0sxOFhaUmgrNTB4aHl3eS85SjM3L0cvQWU3aUhEeGI2MjRIN24yVFlxTFhPUEdSNmZPK0FrekNBUGp3bFF4d0loRmZxdS9IUzVNMStPTnBYRkhrTU14MTM3U01LYXFXejNBZHBqN1doVG9EYUZJZFFwaXFJZUt0Qmp3ZUZhSk5wcnQ5Y09SNXRyNlJDK0J6Z0J3S0ZMQnJUaHNOOTU2NnozZE0vT3ErS1RnZlBPMGROaHNwMzk1Nk9YVjhtRXRDZmVsZXRlUGY1MEZydnhDWGp0QTBoeWt5WSt4YUhIL0hoem5YVlVKc3dwaXFJZUlOQ0RHcjlQL0tMWnVhNXhDRy9yK2Zhc3BWOEU0S2lyd2N4eVpOeC84dXE2QjNVc0F0Q1ZMZXhIZi96NnV2ak1zN09qNThYOTRibHcvRmxVZHc1WCtiRjkzbUVIT1p3TE90MkY4cmtwTUNuL25nRndnQno3OWZjSlpCMnNQYmlsZVU0Y09rbTY3ZE85TnFGT1VSVDFRSUVldXpQc3RiKzgzTGt3dVl3UDFWM045aGpmZ3l0K2NiSHJsYmNKMUMyYzMzbDJnRHJDKzRnSXVLRWtaaFJtSGFTM2ZaakQ0UTlMNkpBTEVMOUdHbFRPcFlmR0x4ZVpyV0h2eW0zSDBPNXVEMERkZlY3cXhCU25LSXFpSGhmUWgzQy84RWwwRzU5RUZ5ZVlwY2ExdnYxMEsrSDN5OTBoa1F3QUJkUS9BNmRld0VWWDBvV3VhWnZaTnJVSTZaOXZ5dTU4QVBONGIxc211NTF0cEEvOW5OTU1VK0oyR2JQYWIwUGFseEFPb2UxYTEvYlAxZEFpVXhSRmZYcUFEc0FhU1JDN2ZiQUhpS0szT3FBMDF1cFZLVmRhZG1hZC9Rc0w4VkNtQnFoLy9QSzYrT3h6bDlXT1d2V1BmVTkzaE4vamhjS2xOTEZwQklCeG81cVBYbDMxbkRuZVA4TDVtTzBlTy9paHBNd09EWGZ1Y0crODlBMTlBc1RIRmtGM2lXMkcwaW1Lb3U0cDBPRmVWVm5hQ3pxZmxZVlJaUUYrNG1LTTZnQjN5aS94dlc5WUE1ZUxVRHpBWHVyalhIVzBab1VqUjJKY2FNS0N4eUtVajJFb2xRL2o3eElUeU1KODhJMzBwM2V3ZmhtRjhnRkpqRzFGaUQwNWMxMWV6ejNtdHZiR1E2aGN6c2ZEZTZvckg5MDNSVkVVTlFyMDRQaEMyTmFCVG51b3FBNXVJZm1yQTU0eE41NytGUWFSSU9rdGxJakJLTWREVTNBZW4zbCtadUZ2UVc3Qmp0ZEZsN1h6YlN0bGFDaHIrN2VQTDQ4Z0dDQ04zME03Y2ZGTjk3dTM3ZjFJZmh0eThScWhkSi9rZHNwTTlYSUFhcnhmTEVoQ1lLQVA2L0ZJd1drV0Vvb0xBb3FpcU1jSTlIa1lvYzc4NENvRGRPQmNZNmJmSkNSZGUrY05JU01kN1ZualJEYjhEQWpEWWFOMUxKd3pZSTF6UTZnZGtEL3pKWEI0TG9UZ24vcXlNeXc4Y0R3V0F3aS9ZOEd3alJMMHBLYmVnbnlYS0oxYkl5dzBFRGxRMGFKRUloQnFzTFV4QTlXNFZ2NU5pZkNuS0lwNlJFQlBmOUVYL1E1eFFrWXRBMGVNN01vN0dBRzBkZFIrTlljTmdQSDFIdnZnV3FJRmJtNjU2MHdYdXRNaEUvNmpsOWZTSlE3Zy92RDZ5cjZPa2ZHdkFEZ1dGdGdieCt2OThNV1Z3QndMQUN3VzRuTjU0VVBxUzZhY3hSRjZsM0RuSWd0NGZKZHA3Zzk2NkRBa3pDbUtvaDQ1ME1kSXA4dTR5NWdxcWlmOTFxMXc4Y2hlajhQM3hoUkhwVjh5OXRRN2ZyUk5SVlk3c3RDVmQvREtRaDJkNUQ3NDVMTDQvTnRQWERNYi94ejRyNXRSWGhULzlzbUZ1UGkzbjdnUWV5aHpRMGo5YWpmZGpqVWtvd1dvbGI3VFhLVVBUdnRvb3RwZzBYSmZIRzdxUEc5eTNIMkxKRkFVUlJIb3R3MlNRY0laUXRIUHEyMEhEOGlGeUp2ZVl4RCtEcERIRmVDTEM5dzVwclloT3ZDNTUrY1Nwb2NEeDMwSUJNaGVmMk1FNGg5K2NpWDc4Z2pWbzU4NkhqODJGQ1lNbllsMXZpMjdLSVNab1BZVUJCK2F3eldKdjkvY2V5RE1LWXFpUGdWQUJ3eEcyNHA2R0ZZU1Z0ZTk0L1lXcGdCekRBMDBjWkZPZEJldUV4MWdpeEQ4eGo2MjlVTmpzR0M0dU41TFhmbnpweHZoN3NldmRyMEZndmFqWEh2Tlp6QWp2ZFRaa0hwb2U4dm1CbjgvaXFJb2lrQ2ZiUHM2MVJBV2NGV0RzNU9zOU9qbjJpZklJY2xORXRIc0JRQ1NVanlGNFRHdDFLSmpEeDc5M3dPRVEyMTN3bXgvNmtHM0p1Uk9VUlJGMGFGUFFqM1VraDhXQi8zZlM4TGMwNjBMbDF0bi90UytuUisrdkpKUVBJNnQwSjYxTFYxbnRjaFJTeGxlaEMydFZMSVduYnJwWW81TmFDaUtvaDRFMEVOVzk1d1E2amErTWN3VW9BOHVVYm1FdUxvWnJYVVBXZStodGx0Wk95K2didHpvVWhuTDZrdlFXaG4xT3A0QUIwZVA4SDBJdVU5QktHVHdJNnNkYzkxZGM1aFRMb0RlN1A4Z3pDTjZMeFJGVVFSNkFtTEdPTGR0L0JmMTRiWVpnRmIxM0huaE05aUhNRjhyaE05RDh4c0FHQ0Yzdk02VjlJdDM5ZDV1bk91aHYvbno4MDFSTjFVM1VBV0pjYkdRbElmTDVZTHowUDY1Zy90WEUxQThOTzA1bkZONC9Kc0EzNm0zQzVqbFRsRVVkUStBampLeXBrRHhlR1BKQmxJaFJLNjlmVlpIWUw5TEFJWFdxRWh1SzcxN0RqM1g0YmgvNkd2SVViWUdzS09jRE1jQjZnQTArc0YvK09KU011aXhoeDU2dlovNWJIYlVyYVA3M0pyV3RxMWZyQ3p0bGhlUE5KMTgzeU5UMDhLQ0tSWGR5SytqUDIxQ0gyRk9VUlIxRDRBT3FDbUZ4aThJSDR2MXZvTlJMZU1nQzhCR2w3alFCQ2FHRjBMeHI5Q1QzVjdENVFMbXlHREhCY2NiaE51OWMwY28vZDEzbmtqNUdpYXNJVXYrK2JOdEYxckgxZllkTitqbDZycVJzallIK3R1YmE1N1YxdFdrZkg3K1FpSCt2SHFUNkdiQm5ILytGRVZSMUQwRCtwcytBZkFHVFdPY2M5YTlQdTR4cU9DRUFXMFhZbmY3M3VqOEJxaWpqQTJOWkpBWTk4b2VKMjFqclF2SC9mL3g3R254dWJmUGk0OWZYY3NpNEtPWFY4VmI1OXRpdTlGU3F4NjhiNWpGRHRDaTczdVlERGZYZk9hK3FMZFFNTXN3blpzUEdFY1Y1bHc1d1U5UkZQVXBBRG9BNGdheHVEM3ZLcXIvVG9FQmZkZ1JRZy9oYlRTQWVVc210R21CdHJSZkJZek40VEg0ZVNjejFGM1BkMXl3ZDQ2RU9UU2pxWFl1Tkk5cGEwTkliYVcrWFhldmhYcDQvQk1XRTQ5TnVlK0pvWFdLb3FoUE1kRGpVTEMwVFMxbFUxaGdtb2FMNmZaNDBaNFZUam1BSE0vMTl0T3R1SGpjQnBqaG9KR2hYbm00STF5T2F4eUhZL0I3U1l4N3NwV09jWUE4WnF5N1JMaEN5dHlrNUczUWFDWkl3dk0rYUlEWHhYa2hreDV3RDVDakc2VW9pcUllSmRBQnhqTHNoVzljKzlTcEJqUERldlFRV284VHpnVG0xazBINTR3U3RkclBOZzhPUDh3dGI5ckQvY2hzQjd5UnhJYncvSm1GTWx6NUp4YnFZWHhyTGYzaVhRT2F1UDNyRU5TbDlIVjMxOXZObVp6M2Z0L2V5ZDQ3UlZFVVJkMEowQUhMTURLMEdvd1B6VlhvNlg2OWI0NFdDSERjTWN4ZitNUzQ0TDdkY2FwM2pmc0IyNzJFM3E4RjVLNEpUU25QaCtjSUFNYmlBZUY1Sk5ZaElXK1QyQVpJWlladnNPKy9jYStQQlFZaUFEZ3VsTWhSRkVWUjFMMEhlaGhvNGh5NUQ2UEhkZWlSOHg1MmpJdWIwdUQySyt2STZ4RUloakI3ZU14T1dybzZGeTZaN1JON3UvZzllcnp2ZmFKYnlKekhlY1B4Zi9McXVuYzhGZ0E0RGxHRlo3N21QUVh6MUt3V21jWVdvZ1YrengvdkJ5TmtDWGVLb2lqcVhnQTl3TmNOUlhFenlVTnpsRjQwUGJkOW5IZmFFbHB2VEJKNDhaNTVVTk1lOXE4RHNLZUU3UGRMM3pFT1NYRUFkZWd1QjhlUG1la3ZmUGk5T3kvanVzMGhZdEROWTEvd29YYjk0cVBYY1pQZ25JTVBXd0prUEVWUkZIVW5RRDkwTkZOZDRsa0s4cmtNRHk0ZHdOeGJZRjVPbElUaGRkRlFKb1k1SGc5SEhlRHZGaFVqcjFXRVJEcVhSUi8yMFZHKzlsbmY2ejNBRms3OWxUU3A2WjhNZm03YXB2aW9ibVI2RzF3OVhtOXEvdm54ZVJUZG5IaGRIc2F4U2pjN0g1Rkl6WU9uS0lxaXFCc0JYWHNBRmxKT1Z2YXkwVU1mOHd4eWQ0UWZKcnhkSTZUdEU5WEdKT0h1ODQxUFFqdUU2ckcvSGtOWDJzRDY4NVB3ZGhzTlgybU5QQjRQUmVnOGhOWnhQeHo3MC9QRFd3OU8vYlV2YTB1OUhVUUZFSXJIL3ZwVTRseXVaSUhVSmZNWnlRY0lHZlNFTzBWUkZMVUs2SUMwakJ5MUFBZkU0U1NWYi8yYTc3Nm5qd09vSkVGdEF1UlFhUENpQnM1ZWVxMzcwSGxZZUJSS2RVREZQblZZSkVqV3V2MDVRRnY1NHdNb3c5ejBPUEVOdjNlMTdVcks1VktTZ1RHWGJiSHh6MTNPSk02Wll0ekt4OHgya1FhM1NHZ3IwKzI5TjFIdFBVVlJGRVZOQWwyUzJnVGlibTlaRmRNalQ1ZEFQQnowK3FyT0t1bkNmdmU1NzdjZU8zc3dEZnZmc1hQZERJQjhsTFEyT0Jidk01U1h5WUNXaTEzeEdldktlNjFSN1cxWGo2NTYrL1Fwc0wrODJBdUk0ZjdWU09KY3JvWVQ2S1JXSDRzcFA5KzlhY09GWlhFVVJWSFVDTkNQUjdETXdHY2k3QjRESHQzVmRuV1RER0dQT2ZNQTg5amg0dW5pNWpJQmVtRXZPaGVVZ1A5MU5KOGJ6M2NkWmIzSEM0SHpiZGsxdGhtVFRKQnIzSjY4bExwdCtyWDJ1ZTU4U3NwUFp3SGdrVXBnak83Z2ptMEZOcldoS0lxaU9xRG5Pc2d4Sno3OEhYNE92ZEJ6OTRMaHpNKzJWZkoxcm4yVG1kNUphOTFOVE1zVjlyNnZkcm9YOG9mcngrTGt6QU44dU1DWWMrcEJydFJOZGZ2cnl6TGk4MzVub2tSQXlTMG9YSzVBbDFUWGN1K2RvaWpxVXczMFhxMTRNVjQzbnVQU1E3SmJQYk5QSGp2UUoxc0g4ekZkcGx5eTZrTk9aWmJKU1FMZElHQndjYjJYUVMxamk0Qnd6QndyQWROUTd4NUMvRXZkZVZ4UFA1czU3OStQTWo3Y3IvMTgrdmF3QjA5UkZFWFJvUzl5NlFBSVhPcVNCQzR0KzlYVjBXQ1dtRU1YZy9hdllSSHdsdThNRjd0WE13SzlXTmp2eGpaQS9CcDRmamoxWjROYWN4TkJIWTU0dUljL3ByQ2dRWVFDcFc1YXIzUG5TeVdMR2l6Q2ZQMTdnTHRzRFJpRzVpbUtvaDY3ZERFQndxa2tMeUFVU1ZvQStlc0VlQ2RYRWI1WlM0QjU2blVBeE5UK08zckVEMnZQOGRLN3diRmgzMTFnN3krcU9QU1lqM1h0NTZtSDl6ODhHMlRFb3laK2FpcGNhcEdENFRIWWh3K2ZUVCtFUHU3T2o4Ry9qc2FBT3pMeGNkN0lJWWliQVZFVVJWR1BFT2k1dUFoY2FYMUMyV1ZHR2RwUXJzYTg2dXJIVTlBeXZsTmJTbmlzR1lBM1ZkNGx5V09KYzN0Mm5nNUtvTWJkVEx4dnJmWFI4SlljSVFTUEJjL2xndmF2cWIzejlJSnJDZDFkaUw1RWdwMG0zQ21Lb2g2YnFoZ09PWHZwQU8zYTVpZUFPUkxncEg2OE9NNnVENitGOFBiWVB2eHd2M3pwV1l6dHQrUDFYcjdlRmMrZmJVZUJLV1Z0UGhOL2w1bTlINTRIeDZOWFBkeitXVldPdXZPY3ZmT2t3MS80OTNCMS9JVmtReGdma21mV1BFVlIxQ01BK2pTUVhLTFZjUDk1TGN5THhNSWhhTGR2Um1HT3gydTl6RklPVHhlUFJ4ZTZWUGI2M3U5OWI2cHBGNzRHNmhMWnNCOWVBRHVjdnFzM1A3M1dMSEpDaVZ3TTk4VlJBSXFpS09xTlNjOUJJZFJyNDdMMnl4M3dDaEFzRWlIa2NFL3IyN0ttb2VQMnZ3VTI1dGdCTDFGb0NadlN4VlZ0ejZNZFhkakVVRjhhZm8vQmp0eURZU3ZicWRlYlczQ2RrdmFoaDMrNEhBM2dvU2lLb3U2M1E0OHoyVVB6a25yaEh2a1FESmc5ZmxRem5raVpENDFjeGtMNVNPd3FTN1VJNG1QSGhFU3hNSUoxQ0Z0MHRwc2FuUnFFV25VY2M3MnZWeTEyUWtaODVjK24xemQvWmx4ck5yOG5FeHN6LzQ0aGpxS1dOOGVoS0lxaTdnam9JZnM3QmxxTEVaOFNlbDF2eThCQ2RGRGJkSm5zMDJOVzl6TURXK0RPUi9lL1J4dzE3dDhVT2drZ1BOKythTWRCNit2SjUwQ0lzalp3ZUdweVhBN1lVVEdBWkRYc3Nlc1pPNXliTkxlVTRITk9QNEJkK2hBb2dwMmlLT28rU2NkZjVzZ0t4ejU1M2R5c1p6aUE5Q1NDK1J5WjBFTDFjbGRQd0R6ZHpTMmNkOHBwaDBWQ0trUVBuVy83aytTR1FqT1pOaEVPVDMwc0xqOWdNd3ZpdVk4Q2UvalNkYTd1Wjl6blpyYWJoWUJlRytFWUx0d1lqcWNvaXJvblFHOHhSYXk1T2NnRGZCR0tEdnZkUTBDWXhERHhPWGNyKzdnUnBNSWxRR3pNMmRkK0pHa2FSR29Td0hqWXNKZTdtYUFlRXR4a0FwdStHZDBFN0xXYkZsZTNadEpVM3dUWXEwUDRCUzA1UlZIVS9aTXB0SVNYVHpURkN6QkRtRDBHWmVwNTQvdXVkczFrcUQyRTd0Y0N6VXpBRU04NzVTNXJjY3hOc3RsTWFuVWlrWW16YWxFRG1qR0ZqUGc0Ni85Rzd0eE1meWJIMCtyNGZ3K0tvcWdINWREdEYvbk8xeW5kU0lCWUFPVFF4WTFCWFp4b1J1bVhMdFdOVGk5MjliRzdMelBLeGhBQ3I0Y2gvV1RvUDRMNjlqUlFoNUNjdUU4TXV6bGxabnQyTnYzSUV4SCtGRVZSYjh5WWh5L2hIYWp6c3YrdGI0cWxkTWRlT1RMWmUxUFhNcUMrcStjejZHTjNibEpuZDBPYW5HL25TL0dsM2p5OHpnVE00NmhDVmc3QlFyQUh0OTdPSk1JWkVwYWlLT3F4VTN4SWdKZlk2UDVYRXg5a2xqRWQwQXIxMkhQOXllTW85ZFcreVNxSnE3U2VmRHR6UGVTUmNEZDMvblBhKzlCN1ljYmZUK28rTEJiVzFxcVBDWi9adnZaOTZsZTQ3WncvSzljREZFVlI5NXpsNXZDTkxqU3dMTGMwTS8vWVVTaEtOTXY1K2o4YUUxcmtEUjBKMDhobUZ3c280ZExUaEtsbmdBMFltOEZuRUYra1ZqNER1dGV5QUptdXcwN2R0NjJXejI3UEFXNE05cHNRbk9GMmlxS29oMFR6Nkd1OVk3Zjg4SS9ZUS8rSGdEZHpqUDlSQVlKd3R5WWpCRDJFZ2JqZERQWDJvVWZxejVvWmx6LzNleEM5eXN4TVJ4ZTdPVmVlZXQrYlc0QjZESGJzOGFkSzdBcHpHbmZPekhhS29xajdaOUZqWmxzVy96MkkvSVBDdEVYZnBmdUxPY1lBSEMzZ1ZFMTBOWnVDT3BMTWNnYTdJR00rR1c2UHo5UDNtSjhFZXNaWTEyR1h0akhodklldGFjY0FPSVJnbkRSNGF1RzhBdGlYc0pkNzdSUkZVUThJNUNZQ2VvK0Z3dkFmV0dLMi85L2VlTjlJMTdTMmU1QVpnVGxhdVdMQVNVNGkxdkN1dlMrUnk1SDIvZGJIM085aUs1dFlESVNMOUluUFRHREQrZStiZHRhVnAxNWVHdVJzcWhzMW9Ka0RPODROMC9ETWlkejVLWStuS0lxaWJnWjEwOXMveDVheXdQeDllL3Z2NE5BdEI5by9DNFF5UXZyMnlLVURRZ0htWTVDWWdycWJvVjVuZHg4YkpxdmRHT3htUGprdWg3TjRtdXVSMmVaVE1POFdLc3ExaTcxcEE1bzVzS09WYkVpY1c1TThOL1dlQ0hPS29xZzM2YzVieitxTzIzLzJ3ZDkrbzlVZTROKzFsMTBYZWkvQ1FlNEpBSjlOcGFTNzJwenppK3U4NHkvL1haM2Z2QWFMaDNJc3UzMWdzRy9DOHZoNThCNXpuWE5vK2hKREx3Zm0zWUtsY0RrSXR3bDF2SFlBKzNCL1BTZWFRbEVVUmQwVG1QZmNlUnh5RjM3dmhPRmdwNy9qZmRNMmYrcmczdGdmZzB0dnhWRml2OXcxWDAzUHlKNWpRWmdxbHFzcUd1Z3lCUnJuUU9mS3RJeUFMUlZ0UDNMcFZYN2kycjd4b2ZkTUJ6dGM2QVNvVnllc1ZjOEIrNUo5Y3liRFVSUkYzUU9ZZDlCeWJIYU1ic1NsVzNiL3p3Lys5Zy9mNzREdVhmbzNpcmI1TUQ2dzhqQTNYU2kreUlaNkFCaGdrdE1OcmdPZDM2ZFBPZWtrMEdmTHN1WkwyNEpRWXJaa2V4dGJDTWZ1TnczenNUVVhNdUJ2RytveDJGdGpianhQbm02ZW9panFibUV1QnFzTnZQYkcyekxiM3ZpRDhBaHRPdHR1WVc2YXIrTkEvRndxN0p2ank3L3g0WGYvaEpIbHozSHErM3JaUFBXeFJqSXhMTU9selNSTHpuSGhPYWRlUC9XWVhUVFJMVjJiUGoreERVRGYzQUhVVTJBZjNZNmdPNmNvaW5wRElJOVkyN0czRGF6dXJpMmZmOGU2OHc4N29JZURITzNiNzF2Ny9zZmEybnBWSUVUYitNMTNmOTA2NXg2L1dHb2VkN2hudnpEVUhoeXJpZjZaQkhXYkNmVFdqQ1c0SDBGdGJBYjZtR29mZWk5R0loUnpNTzh5NE84UTZqSFlrM3YvRTU4NzNUbEZVZFFkZ0x4b3ZaRVdKeTRYNFMrdTNlVlBQdmhmZi9BWFBYUG9nTzMzeUMyNFM2Vit4OEw4UjRxMi9sSklpdGVxTEl3dTVCaDVIZGUrVGVManlqaDRxVGhXclZ3NHZHNmFSVytuOUtWcS9WNTE4YjZ6U244QXVSOVVodkRXd05XbXpTZlh2cTd0WXc3bGFEa2dUOEZSaHNYWTV6akZHTnNsWU1kbkxIUE5EME5xQ1hPS29xaTdaSG5FcXE1czNNUVo3YzBCNXFiNWEvdnpidytmcGdvcDhNNnVLeHk4TTBwOTJmNzRWL2J5Q3hZelJTdGY5Z0E0cU83aStQTDFqNW5uUlFReDVZR01TV3I3Wm5IakVqZERmY0lkRnBrdDJoSWttdTl4Ym5vTGkyWkJaRUZDNzd0NnRJV3N5UUJqT0Q5OGZNaGJ1RXVvRDhFKy96ODZpcUlvNm1RME4wVy9VNnRjdVdoNHlHczdSTW1idjdHRys4dGc5VEhRdmJYWFVwTFdPbDQzeFlWRjkzK3g5M3piUHQxWDVVNExkcmxXRHR5QXU3SFEwZUxXVlh4ZTRtNmJkbG1vSFUrcEMrMDIvYVA3cHRTMmVZc0dDYm0zK2RsdU9oVHNMd0JZM2VCOFRiR0o5dURORWlZT011QWxTdENZN0R5QlU0STk5ZG5UblZNVVJkMGUwQSszZzBzUGRlYk5JYXU5YmY0WXp0eGU3eVVNbjNMb01jenhIRERpOXRpOUJkdlg3Qy8rYjZITnQrMzF1MFlqQzF4N3A5NUtpTGJGNDVUdUtDRGR5dmJONHJlRVBXUTFnR2hxTEdrUDBrMlRSUnBzS2VCUW5WbjNqY05LKzduVUN4Y2wrMTFUcUUwNStqcExrK2Ewcks3dUh1ckRoWWRTZE9jVVJWRzNDM1VmSis3SzA2SndlOXQ4Z0FRNEM3N3ZHUlB0cHcrQkx1eVJjSG5ob0M1TzM0VmU0WldWTnQrM3YvamZoVzYvV1pqeVYrMGQyeUs0Y3VVdUNMc0Q2amlkdWpHcmVvVGpkVEhxVkUzWTh2aFpHd0ZkWHVjNXZHMEEvWGdQZm1MeFVQaGt3SVhhNzl2WkNYUlRNQjkrSnE3UzRNMUFuZTZjb2lqcXRwMVRWSjdXZ2IwRCtnNTE1dmI2RDYyRC9TRDBpQW1KNmtkQWQxdmZCOHR2aXZiUVFxYjE5bCtiRHdxamY4TkMvYjlib0gvZEdQMFZDL0FmZFNBL1FGM0tvZHAxTUZmR2J4T01PUElqU0FlSG52bVp0UXBRWEJCMngrZlMxb3VOS1Q3aUdzbUZvVG5PQ3BBUGo5WCtqOTJTckJSRlVZOEk2TkU0VkhObzYycHYvNHRyeWQ1K1J4cS9kU1ZyYlJIZlBnSjZlSjRoMU4zUUVndk5FSWZYMW5VYS9iNEYrdS9aWC95K1Vmb0xGdVkvWjQvNktYdjlFL2FJOTVyR3ZHVWZ2amxnT2hPZWFGN1RqQmRMcGNEZUltbXN5UWRjcTlwRlFIZFF4ekNaNVJEZHkwNkFUcmFTSFlPNW1iSEdidEZqaW9XN0FCUkZVZFQ5dE9hQ0MzdDU1WWFybUgrU2NlYkcvQjhNV3ZGelZpS1FSN1hvUlRvaC9OOEZHQUQvZkUzMEN3cVdWQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUEvQ0FZQUFBQXhCZXlJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xTlVSRk5qRkZSak5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFOVVJGTmpGR01ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qRTBNRVV4T0VFME0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pVMVJFVTJNVVZGTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrQ2licnVBQUFDcGhKUkVGVWVOcnNuWDlzRS9jVndOK2R6NzhkeDBtZ1l4RGFVRVlxVFpRVzFtaWpxS2hUU2FzMW82V3F5cXFWUWRXb0JUWmF0WCswVUxXalF0WGFQMXF0R2kyTWRvSzFoV2xBa1JCYVFhaXROcWtJK0lNZkFScEVDTDlGZ0pDUTJFNXN4em4vdUwxMzkvVmhKN1p6TnNuNVhPNHBUMmZIZCtldjMrZjczdmQ5MzMxOTVxNC8rU1FVS1R4cUErcXZVUjlBclVlZGhPcEd0WU1wV21RUU5ZeDZCYlVkOVREcS8xQVBvU2ExbkdES0JVL0djNkdJUnRTaS9nbjFPZFRKSnBOYkVqdlRhdFI3VVo5bS83K00raS9VZGFnZGhYcVpWcWxoYjNBT2RaVUpjMHhsTXJQeE9XYnptdEVHdWhDMURmV1BxRGJUM3JxSmpkbWNiUCs3MFFBcVlDRGZnTnR0cU9OTSs1Wk15UFpiR1l1OHc2UWc1WDdOaGE5dDV3Q2FKTk9naGhCa3NSU2gxbkpLeEl3VTRxRkNBcjJTWUpwbU5CelVwb1FTTVFYTlFQR0E5UmFBMzVybU02WVFHMktrQ2VpZ0JML0hBMTQweldaNHFDOGlxMFhEUExqemlTZlVKOTBKYm55TlJXcmpsWG1SS1FZWHpHMzhWK0w4eitkMnVEdXplcWlYbDk0M1laYlZlRm8xM3BMOFMwYklsUlRTY0RIR1Q3VnlzQ1QxM05UeVVHUzIrTCtUd2xNelBIVHF4UW9PUSswS3JyaFNvQ21sOVZLQjJDa1BHZEJmT2hKMkp5YzlhNXFuUElYWUVVTVY2T3JxNkJ3TEJ4Tk0wNVJweG92c2lLRU1GTU10NytPbFJrTTJkTW9VOEsxWkEzZHMzUW9WSzFhTTZYdFZybHdwcS9XKysvTHVSNjlUZTJyV3JRUFhNODhZeGxiSWNCN3hKQSsxMm5tWVpjUUJQMzdoQW5BdUYvQk9KN2diRzBGQVk0N0YrL0RZY1p3UFBpaXJVRitmZDErdW9rSnVqN1cyRnBLaGtHRnNoUXgvUVN3SnFNMkdlWkZSdzBsdy9jMkNTT1ZMTDQzTkdQVHd3L0kyT1RBQTBlKyt5KytoMDZhcGo4VzJOc1BZaVRHMENUSlFUakxzbFpRRWVtbmt3QUZ3b2ZlUVYxQ1lpM3oxMWFpK2gydnVYSGtiYldrQng3eDVZSjgrUFRmUU8rKzhPVzkvL3ZuOGJlL3VocjVQUHRFSHFNSlFCbXJsT1hBWmVkRHYvK3d6Y015Y0NiSExsMEhDTURlcU1MR0RXS3FWV2twazcxNXdQdlFRT082L1g5T3hJKzBYNitqUXpVYU1vVldRa3lSSkV2UzZSRmJ6NFlkZ3I2OHYrRGdLaDNRY3FXL1pNazNIUkk4ZGc5N1ZxL1B1NDNuOGNYazcyTjRPSXU1dm1UZ1I4dG5DMDlpbzdoKzdkQ2wvbThOaGtDUjlMTXRxQ0JZaE5TSFZyU2U1aWdzR2xJaU10bmhlZUVIMXp0Q3VYZkoyWU04ZUdNaXh2NERKVXdvbzdUKzRiNS9oNmd5NkF3MTkvVFZZSnVTZTh2SnV0Mm8wZWY5dnY1VjdlakVTTzNNbTkvdFVWWUhuc2NmVTBLZ0ZqcVcyOXVhNVcxc05XVGpTdmRSSEhqQlNTRTZIMmZmeHh6bTloZk42SVhiOGVGSHQ4QzVkcW5yOXdPSER3MTkvK2VYaENkRmRkNm5oMzdOb1VkN3o1MnIzV0lzTTFDaExUQ293QktiR1YvS2FZQTZqdUJjdUJPL1R5b3JIWHN3aUN3MTlka3g4S0d0T0Z5bkhXSmtyL09kN1haNXVsUktvRVlTTTdGMndRUFdBM2c4K3lCMUtUNTlXRFR2dTlkZWhGeWY3STNsK2VxajFOVGRyYmxjWXAweUpyaTVOKzFycjZzQ3BNVVArVVFPbDhGbWRWdHJyZWU4OXVVcVVTMFFNczkyclZrSE5PKytBZ0VsTk5XYTlBWThId3R1M2ovaGUxVys5SlIralZRWlBuTkRjV1NqQ2xCb29id1NZQkNZMW50MUF6eFExaklzRXZHZk5Hb2ozOXNyUGZUaW1VU2pPSjVVNExxWkMrZ0JPVVg2TVV0SXhWUFpNREprcGovRnYyUUxSUE9NaGhVdjFzYzhudDdzZnZhZUtKU2dFbGY2WHkxTTV0MXZwRE5nSi9COTlCTTR2dmxESHoxdzI4QzFaSWtjQXJYUGxYR095dmlGWDB2L3RYVGloOTZKSENUWEtLdjk0VHc4NHBrK1hsZWFxcWZrcWg1NmIya2VMRU56RTFhdFpPMFp3d3dad1l6TFVpekNUekxQVnp6L2FOcENrRWdJdGdUaG56ODRBUlk4TEFaZFB4cjN4Qm5UMTk4dVZud3dQOHZ2aDZ1TEY4bGFyQkQ3L0hDSUZqS0dWVHoxMWV5WkZBd2NQcWdrRWhTb2FRMU8xVHl1YndKUFhEaHc1b2hZV0VwMmRVREYvdm5McENvL3BXcmtTa29HQUNzdUJtVExCbEpPZlYxK0Z6aXpGODBKZ21tTm9BUkxHWHA4Z0wycHR6VEF5alpPVHZ2eFN5VERiMmlBd1pENUhuazFBNVE0d0pCTWV3REFibkRZTm5BME40UC8wMDRJK1Y2NTk3VE5tNUsxc3BZc05jd0pqaktFbGttempuQzN0MGxWYzQvd3ZvMEt6YVpPc295WHVPWFBLejBPTkpMYjBDOGg1YXJHNlJaTDkrelYzTFBKUXM3Q1FKMnlKQmlpQVIwK2MwSndVZWMzQ3d2QjVwdjJlZXhTWW1DRGRTZ0pEQ2RMdEtNWXF6dU1jTWxVeGlodzZsTFZka29aRWhtUThacnZSQlFzZ3NIbnpzT2xMdG5QbU9sY1Zac28xeTVlYmhZV0NReTJHS3Uramo2cUdDZTNjT1hLN2Nyek9zOHFUbzc0ZWJLaGlTNHYraFlEYnJiQ1EwWWk3NzRaeHI3MTJjeksvWTBkbUphZlEwTzN6M2N5VXIxMjdwYmIxVW1GaDkyNXRZMmh6TS9pTVVGaEk0dWZtU3dUWDFkUUUxUmpXMUZDTDRURzBiZHV0ZmFpMGxRVnhIUmRxbFZLSW9RbzBKa0hVeG9GSHp3YTRFYVRua1Vma3NKZ1NndG45OXR2NUc1NjJITVgzeWl0Wmw2ZTRHaHJVMEIwN2YxNXpZYUVLenpmc1hMTm5nMjJxdG1YTHRycTZqTGFsMmh2Y3VISE03VWtNVTBDbHFNVDViWnlrQzlDYU45OEUxNnhaR1l1K3lQQjllL2RxK3VBMGpmQ3d5WDVxek0wbG9RSlhNbVE3bjZ2SWFVanFYSlN0NndHVUdCSkxHV2d3eVYzeDhwSXVONUpLQjBJZ0kwZVBRaEJEYkZ5ako0VnhQQk1tVEpDOTBKWVdXdE9GYXNEUnRqYndyMTFiVU5zaVkzQ050SmhxVnpGQ0RGTkFFNTBKdm4yeWtQeVZMcFVYQm9TK0Z4S21GWDFGSkQvVTQwZWoxL2Q5ODQzaVJhd2lOVks0TjdKY1JZYkVrb0RHRGc4S2h4K3d4eGZyOWVZQkhVS1FwZ3kyUUE4MnNod2RGT2lHanpHcUZJbi82TE1maVNneDJKUXlGR0tIREk4U1N4a29EcWlCazZKbHYybWE4aFJpUnd5SnBSeHlhVGpaMkdmZk9XdGM3RGNXK1JZNHBwU0xKUENQMkJGRE9lU2VyUFhUalhiNzkwV3RwMXRGWVo5cG9uTHpUbUUvc1NPR05ISGdXY1dScXNwZDcvcGRXOUIxdytidFlzcERpZFVhdjJzenNXTU0xY3RuRkhaN1RzVXNaM2FFYmY4MiszMTVDTExhMWhhejBIU2xoekZVZ0xiVytnazRmWk8yNC8yQWE4OHhVVGhnbXN2WWNod1pJU3U2YXREQjJFbnBIa3BRUlpwYm8xNWFmc096OFZ6TWN0STBtekdGMkN4RFJzU0tNUk5UcncxZHNVQTMxYjNjbitUT050L3dyTDhZdDdTWjVqT1duSTlaVGhFYllnVEtqdzFrM0FnNUF5aDZhWUlLT2RRSmJpVDQwd3V2Vi95dFJSUU9tbVkwaGhDTFo3c3ExaEliVUg1Z3dLL01YTktBRHMyY2ZxajF4NWdidDBjazd1d2Z1aW8yYmVwM21ObHZpYlBaZnlJRFlvRk1xUEJNaVZBM1k1VWhXUzlxNDQ3aXZSMVYxOW41eEw4R25lS3VpTzNVbjMyUitUUHQ4UWJlTEQ3b0lrbjB2cFpCNGRDN0FkZC9jTnlrNU9jaTgweUNLV1k3aGp2SDdnS1NUUkNxRlRlMG5vTXVyZEgzMGUrWVlZdFBYTzZOemtXd005MmNWR21hZmZRbExIRkJCTm55OXo3SDl5ZEU0U3FiWjE1aVkyWWczVE9Sa1hhZzdBRHlSdm9xMkhoUWZsWHBwd1JaNE1EVjVCS256SFhFZmxZbkpHcHJlR204aDVjcXJaeGtNejFZdXdmR0pFNE1KYmxnVDVMcnhpUzA0L3VvOWV6dWlPMUNYSktUSGNwbnJyR3BDUTJEa1IrVVBBZUtCcHAySVAwb0RLMXFvSytJL1lSdHZhZ09VSDR3Um1ES2djNTNWaWxqVVc5cnlKVENLQzBsNldQRmd1dHNHOG9WWW9jQmRjMTRycEFHRUNnS3c3UitwSUlCOVRMUVRnYldBZ1pid0cxc0o1V3pWSkdWN2tJTUptay8rMThNQ2xqbUt4VFJvMFNtL1N3TTJKaGFHVXpUUXd2MzBBUURsN0p0RERUK091RlErYjhBQXdCd2tiQ3g5aUlZdFFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxpbWcgY2xhc3M9XFxcInJlY2hhcmdlLXJlY29yZFxcXCIgdi1iaW5kOnNyYz1cXFwicmVjb3JkSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInJlY29yZEltZ1N0eWxlXFxcIi8+PGRpdiBjbGFzcz1cXFwicmVjaGFyZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZC1pbWdcXFwiPjxkaXYgdi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiPjxpbWcgdi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIi8+PGRpdiBjbGFzcz1cXFwiYmFyY29udGVudFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIj48aW1nIGNsYXNzPVxcXCJtb25leS1pbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlJbWdcXFwiIHYtYmluZDpzcmM9XFxcIml0ZW0uZ29vZHNpbWdcXFwiLz48ZGl2IGNsYXNzPVxcXCJib251cy1tb25leVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJpdGVtLnN1Yj9ib251c01vbmV5SGFzU3ViOmJvbnVzTW9uZXlcXFwiIHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtbW9uZXkgYm9udXMtc3ViXFxcIiB2LWlmPVxcXCJpdGVtLnN1YlxcXCIgdi1iaW5kOnN0eWxlPVxcXCJib251c1N1YlxcXCIgdi1odG1sPVxcXCJpdGVtLnN1YlxcXCI+PC9kaXY+PGltZyBjbGFzcz1cXFwicmVjaGFyZ2VcXFwiIHYtYmluZDpzcmM9XFxcImRvcmVjaGFyZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwicmVjaGFyZ2VCdG5cXFwiLz48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJteS1tb25leVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJmb290ZXJcXFwiPuaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1lc3NhZ2VDb21wb25lbnRcXFxccnVsZUludHJvZHVjZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNDFhZjFhZWQvcnVsZUludHJvZHVjZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuaW50cm9kdWNlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWU/NDgyY2JkYmJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0FcIixcImZpbGVcIjpcInJ1bGVJbnRyb2R1Y2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi5pbnRyb2R1Y2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIix2LWh0bWw9XFxcInJ1bGVcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHJlYWR5KCkge1xcclxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucnVsZSlcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxcclxcbiAgICAgICAgZGF0YSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBydWxlOiByZXF1aXJlKCcuLy4uLy4uL2RhdGEvcnVsZUludHJvLmh0bWwnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5pbnRyb2R1Y2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuXHRkaXYuaW50cm9kdWNlKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIix2LWh0bWw9XCJydWxlXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnJ1bGUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxyXG4gICAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBydWxlOiByZXF1aXJlKCcuLy4uLy4uL2RhdGEvcnVsZUludHJvLmh0bWwnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5pbnRyb2R1Y2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHJ1bGVJbnRyb2R1Y2UudnVlPzQ4MmNiZGJiXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImludHJvZHVjZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIiB2LWh0bWw9XFxcInJ1bGVcXFwiPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtb2RlbFxcXCIgdi1zaG93PVxcXCJkaWFsb2dTaG93XFxcIiB0cmFuc2l0aW9uPVxcXCJtZXNzYWdlXFxcIj48ZGl2IGNsYXNzPVxcXCJkaWFsb2dcXFwiIHYtYmluZDpzdHlsZT1cXFwiZGlhbG9nXFxcIj48ZGl2IGNsYXNzPVxcXCJjbG9zZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjbG9zZVxcXCIgQHRvdWNoZW5kPVxcXCJkaWFsb2dTaG93ID0gZmFsc2VcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PC9kaXY+PGRpdiB2LWJpbmQ6aXM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLnR5cGVcXFwiIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIj48L2Rpdj48aW1nIHYtYmluZDpzcmM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcXFwiLz48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIC8v5pWw5o2u5qih5p2/XG4gICAgbm90aWNlOiB7XG4gICAgICAgICdjb250ZW50JzogJz8/Pz8/JyxcbiAgICAgICAgJ2NyZWF0ZWRBdCc6IDE0Njk1NDM5ODAwMDAsXG4gICAgICAgICdpZCc6IDYsXG4gICAgICAgICd0aXRsZSc6ICd0aXRsZSdcbiAgICB9LFxuICAgIG9wdGlvbnM6IFsn5oqV5rOo6K6w5b2VJywgJ+W8gOWlluiusOW9lScsICfmuLjmiI/op4TliJknLCAn5YWR5o2i56S85ZOBJywgJ+i1oOmAgeWlveWPiyddXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2RhdGEuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9ub3RpY2UuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIC8vIOeUqOaIt+S/oeaBr+aVsOaNruaooeadv1xyXG4gICAgJ2NyZWF0ZWRBdCc6IDE0Njk1NDg2NzUwMDAsXHJcbiAgICAnbW9uZXknOiAxMDAwMCxcclxuICAgICdjb2RlJzogMCxcclxuICAgICduaWNrbmFtZSc6ICfmtYvor5XnlKjmiLcyMjInLFxyXG4gICAgJ29wZW5pZCc6ICd4eHh4eHh4eHh4eHgnXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHRpcC1tb2RhbC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi02OTFjMDMxYi90aXAtbW9kYWwudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuLnRpcC1jb250ZW50IHtcXHJcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXHJcXG4gICAgbWFyZ2luOiAwJSAwIDAgMzAlO1xcclxcbiAgICB3aWR0aDogNDAlO1xcclxcbiAgICBwYWRkaW5nOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjM1KTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLXRyYW5zaXRpb24ge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIC8qIOWQpuWImSBzY2FsZSDliqjnlLvkuI3otbfkvZznlKggKi9cXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1lbnRlciB7XFxyXFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xcclxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1sZWF2ZSB7XFxyXFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBib3VuY2Utb3V0IC41cztcXHJcXG4gICAgICAgICAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT83OTE4N2NiZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7SUFDQSxvQkFBQTtJQUNBLG1CQUFBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSwrQkFBQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLG1CQUFBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLHNCQUFBO0lBQ0EscUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGlDQUFBO1lBQUEseUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO1lBQUEsMEJBQUE7Q0FDQTs7QUFFQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBOztBQVBBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0E7O0FBRUE7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7Q0FDQTs7QUFQQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJ0aXAtbW9kYWwudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi50aXAtY29udGVudCh0cmFuc2l0aW9uPVxcXCJib3VuY2VcXFwiLHYtc2hvdz1cXFwiaXNTaG93XFxcIix2LWh0bWw9XFxcImNvbnRlbnRcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHByb3BzOiBbXSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgaXNTaG93OiBmYWxzZSxcXHJcXG4gICAgICAgICAgICBjb250ZW50OiAnJ1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICBzaG93VGlwKGNvbnRlbnQpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XFxyXFxuICAgICAgICAgICAgdGhpcy5pc1Nob3cgPSB0cnVlXFxyXFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmlzU2hvdyA9IGZhbHNlLCAzMDAwKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBldmVudHM6IHtcXHJcXG4gICAgICAgIHNob3dUaXAoZXZlbnQpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLnNob3dUaXAoZXZlbnQpXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbi50aXAtY29udGVudCB7XFxyXFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxyXFxuICAgIG1hcmdpbjogMCUgMCAwIDMwJTtcXHJcXG4gICAgd2lkdGg6IDQwJTtcXHJcXG4gICAgcGFkZGluZzogNXB4O1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC4zNSk7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS10cmFuc2l0aW9uIHtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAvKiDlkKbliJkgc2NhbGUg5Yqo55S75LiN6LW35L2c55SoICovXFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtZW50ZXIge1xcclxcbiAgICBhbmltYXRpb246IGJvdW5jZS1pbiAuNXM7XFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtbGVhdmUge1xcclxcbiAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGJvdW5jZS1pbiB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi50aXAtY29udGVudCh0cmFuc2l0aW9uPVwiYm91bmNlXCIsdi1zaG93PVwiaXNTaG93XCIsdi1odG1sPVwiY29udGVudFwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczogW10sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzU2hvdzogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBzaG93VGlwKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudFxyXG4gICAgICAgICAgICB0aGlzLmlzU2hvdyA9IHRydWVcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmlzU2hvdyA9IGZhbHNlLCAzMDAwKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpcChldmVudClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuLnRpcC1jb250ZW50IHtcclxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XHJcbiAgICBtYXJnaW46IDAlIDAgMCAzMCU7XHJcbiAgICB3aWR0aDogNDAlO1xyXG4gICAgcGFkZGluZzogNXB4O1xyXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuMzUpO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xyXG59XHJcblxyXG4uYm91bmNlLXRyYW5zaXRpb24ge1xyXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgLyog5ZCm5YiZIHNjYWxlIOWKqOeUu+S4jei1t+S9nOeUqCAqL1xyXG59XHJcblxyXG4uYm91bmNlLWVudGVyIHtcclxuICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcclxufVxyXG5cclxuLmJvdW5jZS1sZWF2ZSB7XHJcbiAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xyXG59XHJcblxyXG5Aa2V5ZnJhbWVzIGJvdW5jZS1pbiB7XHJcbiAgICAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XHJcbiAgICAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogdGlwLW1vZGFsLnZ1ZT83OTE4N2NiZVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ0aXAtY29udGVudFxcXCIgdHJhbnNpdGlvbj1cXFwiYm91bmNlXFxcIiB2LXNob3c9XFxcImlzU2hvd1xcXCIgdi1odG1sPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJhY2tncm91bmQ+PC9iYWNrZ3JvdW5kPjxtZW51LWJhciB2LWJpbmQ6Z2FtZS1kYXRhPVxcXCJnYW1lRGF0YVxcXCIgdi1iaW5kOm5vdGljZT1cXFwibm90aWNlXFxcIiB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCI+PC9tZW51LWJhcj48YmV0LWFuZC1ib251cyB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIgdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIgdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIiB2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIj48L2JldC1hbmQtYm9udXM+PHBsYXktcGFuZWwgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiIHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIgdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIgdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIiB2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiIHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiIHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIgdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCI+PC9wbGF5LXBhbmVsPjxzdGF0ZSB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiPjwvc3RhdGU+PG1lc3NhZ2Ugdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCI+PC9tZXNzYWdlPjxtb2RhbCBjbGFzcz1cXFwibW9kYWxcXFwiIHYtaWY9XFxcImVycm9yXFxcIj48L21vZGFsPjx0aXAtbW9kYWw+PC90aXAtbW9kYWw+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIiFmdW5jdGlvbiAoYSwgYikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYihhKVxufSh3aW5kb3csIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgZnVuY3Rpb24gYyhiLCBjLCBkKSB7XG4gICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgPyBXZWl4aW5KU0JyaWRnZS5pbnZva2UoYiwgZShjKSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGcoYiwgYSwgZClcbiAgICAgICAgfSkgOiBqKGIsIGQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZChiLCBjLCBkKSB7XG4gICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgPyBXZWl4aW5KU0JyaWRnZS5vbihiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZCAmJiBkLnRyaWdnZXIgJiYgZC50cmlnZ2VyKGEpLCBnKGIsIGEsIGMpXG4gICAgICAgIH0pIDogZCA/IGooYiwgZCkgOiBqKGIsIGMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZShhKSB7XG4gICAgICAgIHJldHVybiBhID0gYSB8fCB7fSwgYS5hcHBJZCA9IHouYXBwSWQsIGEudmVyaWZ5QXBwSWQgPSB6LmFwcElkLCBhLnZlcmlmeVNpZ25UeXBlID0gXCJzaGExXCIsIGEudmVyaWZ5VGltZXN0YW1wID0gei50aW1lc3RhbXAgKyBcIlwiLCBhLnZlcmlmeU5vbmNlU3RyID0gei5ub25jZVN0ciwgYS52ZXJpZnlTaWduYXR1cmUgPSB6LnNpZ25hdHVyZSwgYVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZVN0YW1wOiBhLnRpbWVzdGFtcCArIFwiXCIsXG4gICAgICAgICAgICBub25jZVN0cjogYS5ub25jZVN0cixcbiAgICAgICAgICAgIFwicGFja2FnZVwiOiBhLnBhY2thZ2UsXG4gICAgICAgICAgICBwYXlTaWduOiBhLnBheVNpZ24sXG4gICAgICAgICAgICBzaWduVHlwZTogYS5zaWduVHlwZSB8fCBcIlNIQTFcIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZyhhLCBiLCBjKSB7XG4gICAgICAgIHZhciBkLCBlLCBmO1xuICAgICAgICBzd2l0Y2ggKGRlbGV0ZSBiLmVycl9jb2RlLCBkZWxldGUgYi5lcnJfZGVzYywgZGVsZXRlIGIuZXJyX2RldGFpbCwgZCA9IGIuZXJyTXNnLCBkIHx8IChkID0gYi5lcnJfbXNnLCBkZWxldGUgYi5lcnJfbXNnLCBkID0gaChhLCBkLCBjKSwgYi5lcnJNc2cgPSBkKSwgYyA9IGMgfHwge30sIGMuX2NvbXBsZXRlICYmIChjLl9jb21wbGV0ZShiKSwgZGVsZXRlIGMuX2NvbXBsZXRlKSwgZCA9IGIuZXJyTXNnIHx8IFwiXCIsIHouZGVidWcgJiYgIWMuaXNJbm5lckludm9rZSAmJiBhbGVydChKU09OLnN0cmluZ2lmeShiKSksIGUgPSBkLmluZGV4T2YoXCI6XCIpLCBmID0gZC5zdWJzdHJpbmcoZSArIDEpKSB7XG4gICAgICAgICAgICBjYXNlXCJva1wiOlxuICAgICAgICAgICAgICAgIGMuc3VjY2VzcyAmJiBjLnN1Y2Nlc3MoYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlXCJjYW5jZWxcIjpcbiAgICAgICAgICAgICAgICBjLmNhbmNlbCAmJiBjLmNhbmNlbChiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYy5mYWlsICYmIGMuZmFpbChiKVxuICAgICAgICB9XG4gICAgICAgIGMuY29tcGxldGUgJiYgYy5jb21wbGV0ZShiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGgoYSwgYikge1xuICAgICAgICB2YXIgZCwgZSwgZiwgZztcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZCA9IGIuaW5kZXhPZihcIjpcIiksIGEpIHtcbiAgICAgICAgICAgICAgICBjYXNlIG8uY29uZmlnOlxuICAgICAgICAgICAgICAgICAgICBlID0gXCJjb25maWdcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvLm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3OlxuICAgICAgICAgICAgICAgICAgICBlID0gXCJvcGVuUHJvZHVjdFNwZWNpZmljVmlld1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBlID0gYi5zdWJzdHJpbmcoMCwgZCksIGUgPSBlLnJlcGxhY2UoL18vZywgXCIgXCIpLCBlID0gZS5yZXBsYWNlKC9cXGJcXHcrXFxiL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIGEuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlID0gZS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSArIGUuc3Vic3RyaW5nKDEpLCBlID0gZS5yZXBsYWNlKC8gL2csIFwiXCIpLCAtMSAhPSBlLmluZGV4T2YoXCJXY3BheVwiKSAmJiAoZSA9IGUucmVwbGFjZShcIldjcGF5XCIsIFwiV0NQYXlcIikpLCBmID0gcFtlXSwgZiAmJiAoZSA9IGYpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnID0gYi5zdWJzdHJpbmcoZCArIDEpLCBcImNvbmZpcm1cIiA9PSBnICYmIChnID0gXCJva1wiKSwgXCJmYWlsZWRcIiA9PSBnICYmIChnID0gXCJmYWlsXCIpLCAtMSAhPSBnLmluZGV4T2YoXCJmYWlsZWRfXCIpICYmIChnID0gZy5zdWJzdHJpbmcoNykpLCAtMSAhPSBnLmluZGV4T2YoXCJmYWlsX1wiKSAmJiAoZyA9IGcuc3Vic3RyaW5nKDUpKSwgZyA9IGcucmVwbGFjZSgvXy9nLCBcIiBcIiksIGcgPSBnLnRvTG93ZXJDYXNlKCksIChcImFjY2VzcyBkZW5pZWRcIiA9PSBnIHx8IFwibm8gcGVybWlzc2lvbiB0byBleGVjdXRlXCIgPT0gZykgJiYgKGcgPSBcInBlcm1pc3Npb24gZGVuaWVkXCIpLCBcImNvbmZpZ1wiID09IGUgJiYgXCJmdW5jdGlvbiBub3QgZXhpc3RcIiA9PSBnICYmIChnID0gXCJva1wiKSwgYiA9IGUgKyBcIjpcIiArIGdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGkoYSkge1xuICAgICAgICB2YXIgYiwgYywgZCwgZTtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIGZvciAoYiA9IDAsIGMgPSBhLmxlbmd0aDsgYyA+IGI7ICsrYilkID0gYVtiXSwgZSA9IG9bZF0sIGUgJiYgKGFbYl0gPSBlKTtcbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoIXouZGVidWcgfHwgYiAmJiBiLmlzSW5uZXJJbnZva2UpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHBbYV07XG4gICAgICAgICAgICBjICYmIChhID0gYyksIGIgJiYgYi5fY29tcGxldGUgJiYgZGVsZXRlIGIuX2NvbXBsZXRlLCBjb25zb2xlLmxvZygnXCInICsgYSArICdcIiwnLCBiIHx8IFwiXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrKCkge1xuICAgICAgICBpZiAoIShcIjYuMC4yXCIgPiB3IHx8IHkuc3lzdGVtVHlwZSA8IDApKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBJbWFnZTtcbiAgICAgICAgICAgIHkuYXBwSWQgPSB6LmFwcElkLCB5LmluaXRUaW1lID0geC5pbml0RW5kVGltZSAtIHguaW5pdFN0YXJ0VGltZSwgeS5wcmVWZXJpZnlUaW1lID0geC5wcmVWZXJpZnlFbmRUaW1lIC0geC5wcmVWZXJpZnlTdGFydFRpbWUsIEMuZ2V0TmV0d29ya1R5cGUoe1xuICAgICAgICAgICAgICAgIGlzSW5uZXJJbnZva2U6ICEwLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHkubmV0d29ya1R5cGUgPSBhLm5ldHdvcmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFwiaHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20vc2RrL3JlcG9ydD92PVwiICsgeS52ZXJzaW9uICsgXCImbz1cIiArIHkuaXNQcmVWZXJpZnlPayArIFwiJnM9XCIgKyB5LnN5c3RlbVR5cGUgKyBcIiZjPVwiICsgeS5jbGllbnRWZXJzaW9uICsgXCImYT1cIiArIHkuYXBwSWQgKyBcIiZuPVwiICsgeS5uZXR3b3JrVHlwZSArIFwiJmk9XCIgKyB5LmluaXRUaW1lICsgXCImcD1cIiArIHkucHJlVmVyaWZ5VGltZSArIFwiJnU9XCIgKyB5LnVybDtcbiAgICAgICAgICAgICAgICAgICAgYi5zcmMgPSBjXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIHJldHVybiAobmV3IERhdGUpLmdldFRpbWUoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG0oYikge1xuICAgICAgICB0ICYmIChhLldlaXhpbkpTQnJpZGdlID8gYigpIDogcS5hZGRFdmVudExpc3RlbmVyICYmIHEuYWRkRXZlbnRMaXN0ZW5lcihcIldlaXhpbkpTQnJpZGdlUmVhZHlcIiwgYiwgITEpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgIEMuaW52b2tlIHx8IChDLmludm9rZSA9IGZ1bmN0aW9uIChiLCBjLCBkKSB7XG4gICAgICAgICAgICBhLldlaXhpbkpTQnJpZGdlICYmIFdlaXhpbkpTQnJpZGdlLmludm9rZShiLCBlKGMpLCBkKVxuICAgICAgICB9LCBDLm9uID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgJiYgV2VpeGluSlNCcmlkZ2Uub24oYiwgYylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB2YXIgbywgcCwgcSwgciwgcywgdCwgdSwgdiwgdywgeCwgeSwgeiwgQSwgQiwgQztcbiAgICBpZiAoIWEualdlaXhpbilyZXR1cm4gbyA9IHtcbiAgICAgICAgY29uZmlnOiBcInByZVZlcmlmeUpTQVBJXCIsXG4gICAgICAgIG9uTWVudVNoYXJlVGltZWxpbmU6IFwibWVudTpzaGFyZTp0aW1lbGluZVwiLFxuICAgICAgICBvbk1lbnVTaGFyZUFwcE1lc3NhZ2U6IFwibWVudTpzaGFyZTphcHBtZXNzYWdlXCIsXG4gICAgICAgIG9uTWVudVNoYXJlUVE6IFwibWVudTpzaGFyZTpxcVwiLFxuICAgICAgICBvbk1lbnVTaGFyZVdlaWJvOiBcIm1lbnU6c2hhcmU6d2VpYm9BcHBcIixcbiAgICAgICAgb25NZW51U2hhcmVRWm9uZTogXCJtZW51OnNoYXJlOlFab25lXCIsXG4gICAgICAgIHByZXZpZXdJbWFnZTogXCJpbWFnZVByZXZpZXdcIixcbiAgICAgICAgZ2V0TG9jYXRpb246IFwiZ2VvTG9jYXRpb25cIixcbiAgICAgICAgb3BlblByb2R1Y3RTcGVjaWZpY1ZpZXc6IFwib3BlblByb2R1Y3RWaWV3V2l0aFBpZFwiLFxuICAgICAgICBhZGRDYXJkOiBcImJhdGNoQWRkQ2FyZFwiLFxuICAgICAgICBvcGVuQ2FyZDogXCJiYXRjaFZpZXdDYXJkXCIsXG4gICAgICAgIGNob29zZVdYUGF5OiBcImdldEJyYW5kV0NQYXlSZXF1ZXN0XCJcbiAgICB9LCBwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgYSA9IHt9O1xuICAgICAgICBmb3IgKGIgaW4gbylhW29bYl1dID0gYjtcbiAgICAgICAgcmV0dXJuIGFcbiAgICB9KCksIHEgPSBhLmRvY3VtZW50LFxuICAgICAgICByID0gcS50aXRsZSxcbiAgICAgICAgcyA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSwgdCA9IC0xICE9IHMuaW5kZXhPZihcIm1pY3JvbWVzc2VuZ2VyXCIpLCB1ID0gLTEgIT0gcy5pbmRleE9mKFwiYW5kcm9pZFwiKSwgdiA9IC0xICE9IHMuaW5kZXhPZihcImlwaG9uZVwiKSB8fCAtMSAhPSBzLmluZGV4T2YoXCJpcGFkXCIpLCB3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHMubWF0Y2goL21pY3JvbWVzc2VuZ2VyXFwvKFxcZCtcXC5cXGQrXFwuXFxkKykvKSB8fCBzLm1hdGNoKC9taWNyb21lc3NlbmdlclxcLyhcXGQrXFwuXFxkKykvKTtcbiAgICAgICAgcmV0dXJuIGEgPyBhWzFdIDogXCJcIlxuICAgIH0oKSwgeCA9IHtpbml0U3RhcnRUaW1lOiBsKCksIGluaXRFbmRUaW1lOiAwLCBwcmVWZXJpZnlTdGFydFRpbWU6IDAsIHByZVZlcmlmeUVuZFRpbWU6IDB9LCB5ID0ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBhcHBJZDogXCJcIixcbiAgICAgICAgaW5pdFRpbWU6IDAsXG4gICAgICAgIHByZVZlcmlmeVRpbWU6IDAsXG4gICAgICAgIG5ldHdvcmtUeXBlOiBcIlwiLFxuICAgICAgICBpc1ByZVZlcmlmeU9rOiAxLFxuICAgICAgICBzeXN0ZW1UeXBlOiB2ID8gMSA6IHUgPyAyIDogLTEsXG4gICAgICAgIGNsaWVudFZlcnNpb246IHcsXG4gICAgICAgIHVybDogZW5jb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhyZWYpXG4gICAgfSwgeiA9IHt9LCBBID0ge19jb21wbGV0ZXM6IFtdfSwgQiA9IHtzdGF0ZTogMCwgcmVzOiB7fX0sIG0oZnVuY3Rpb24gKCkge1xuICAgICAgICB4LmluaXRFbmRUaW1lID0gbCgpXG4gICAgfSksIEMgPSB7XG4gICAgICAgIGNvbmZpZzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHogPSBhLCBqKFwiY29uZmlnXCIsIGEpO1xuICAgICAgICAgICAgdmFyIGIgPSB6LmNoZWNrID09PSAhMSA/ICExIDogITA7XG4gICAgICAgICAgICBtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgZCwgZTtcbiAgICAgICAgICAgICAgICBpZiAoYiljKG8uY29uZmlnLCB7dmVyaWZ5SnNBcGlMaXN0OiBpKHouanNBcGlMaXN0KX0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgQS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5wcmVWZXJpZnlFbmRUaW1lID0gbCgpLCBCLnN0YXRlID0gMSwgQi5yZXMgPSBhXG4gICAgICAgICAgICAgICAgICAgIH0sIEEuc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuaXNQcmVWZXJpZnlPayA9IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgQS5mYWlsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEEuX2ZhaWwgPyBBLl9mYWlsKGEpIDogQi5zdGF0ZSA9IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gQS5fY29tcGxldGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHouZGVidWcgfHwgaygpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBBLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgZCA+IGM7ICsrYylhW2NdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZXMgPSBbXVxuICAgICAgICAgICAgICAgICAgICB9LCBBXG4gICAgICAgICAgICAgICAgfSgpKSwgeC5wcmVWZXJpZnlTdGFydFRpbWUgPSBsKCk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKEIuc3RhdGUgPSAxLCBhID0gQS5fY29tcGxldGVzLCBkID0gMCwgZSA9IGEubGVuZ3RoOyBlID4gZDsgKytkKWFbZF0oKTtcbiAgICAgICAgICAgICAgICAgICAgQS5fY29tcGxldGVzID0gW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgei5iZXRhICYmIG4oKVxuICAgICAgICB9LCByZWFkeTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIDAgIT0gQi5zdGF0ZSA/IGEoKSA6IChBLl9jb21wbGV0ZXMucHVzaChhKSwgIXQgJiYgei5kZWJ1ZyAmJiBhKCkpXG4gICAgICAgIH0sIGVycm9yOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgXCI2LjAuMlwiID4gdyB8fCAoLTEgPT0gQi5zdGF0ZSA/IGEoQi5yZXMpIDogQS5fZmFpbCA9IGEpXG4gICAgICAgIH0sIGNoZWNrSnNBcGk6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGQsIGIgPSBhLmNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgIGZvciAoYyBpbiBiKWQgPSBwW2NdLCBkICYmIChiW2RdID0gYltjXSwgZGVsZXRlIGJbY10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYyhcImNoZWNrSnNBcGlcIiwge2pzQXBpTGlzdDogaShhLmpzQXBpTGlzdCl9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gYS5jaGVja1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgKGEuY2hlY2tSZXN1bHQgPSBKU09OLnBhcnNlKGMpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiKGEpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVRpbWVsaW5lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlVGltZWxpbmUsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVUaW1lbGluZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nX3VybDogYS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IGEubGluayB8fCBsb2NhdGlvbi5ocmVmXG4gICAgICAgICAgICAgICAgICAgIH0sIGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgfSwgb25NZW51U2hhcmVBcHBNZXNzYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlQXBwTWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzZW5kQXBwTWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhLnR5cGUgfHwgXCJsaW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3VybDogYS5kYXRhVXJsIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVFROiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlUVEsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVRUVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVdlaWJvOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlV2VpYm8sIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVXZWlib0FwcFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVFab25lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlUVpvbmUsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVRWm9uZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBzdGFydFJlY29yZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdGFydFJlY29yZFwiLCB7fSwgYSlcbiAgICAgICAgfSwgc3RvcFJlY29yZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdG9wUmVjb3JkXCIsIHt9LCBhKVxuICAgICAgICB9LCBvblZvaWNlUmVjb3JkRW5kOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChcIm9uVm9pY2VSZWNvcmRFbmRcIiwgYSlcbiAgICAgICAgfSwgcGxheVZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInBsYXlWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkfSwgYSlcbiAgICAgICAgfSwgcGF1c2VWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJwYXVzZVZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBzdG9wVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwic3RvcFZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBvblZvaWNlUGxheUVuZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGQoXCJvblZvaWNlUGxheUVuZFwiLCBhKVxuICAgICAgICB9LCB1cGxvYWRWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ1cGxvYWRWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGRvd25sb2FkVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiZG93bmxvYWRWb2ljZVwiLCB7c2VydmVySWQ6IGEuc2VydmVySWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgdHJhbnNsYXRlVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwidHJhbnNsYXRlVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCBjaG9vc2VJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJjaG9vc2VJbWFnZVwiLCB7XG4gICAgICAgICAgICAgICAgc2NlbmU6IFwiMXwyXCIsXG4gICAgICAgICAgICAgICAgY291bnQ6IGEuY291bnQgfHwgOSxcbiAgICAgICAgICAgICAgICBzaXplVHlwZTogYS5zaXplVHlwZSB8fCBbXCJvcmlnaW5hbFwiLCBcImNvbXByZXNzZWRcIl0sXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZTogYS5zb3VyY2VUeXBlIHx8IFtcImFsYnVtXCIsIFwiY2FtZXJhXCJdXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gYS5sb2NhbElkcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgJiYgKGEubG9jYWxJZHMgPSBKU09OLnBhcnNlKGIpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBwcmV2aWV3SW1hZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKG8ucHJldmlld0ltYWdlLCB7Y3VycmVudDogYS5jdXJyZW50LCB1cmxzOiBhLnVybHN9LCBhKVxuICAgICAgICB9LCB1cGxvYWRJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ1cGxvYWRJbWFnZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGRvd25sb2FkSW1hZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiZG93bmxvYWRJbWFnZVwiLCB7c2VydmVySWQ6IGEuc2VydmVySWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZ2V0TmV0d29ya1R5cGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGQsIGUsIGIgPSBhLmVyck1zZztcbiAgICAgICAgICAgICAgICBpZiAoYS5lcnJNc2cgPSBcImdldE5ldHdvcmtUeXBlOm9rXCIsIGMgPSBhLnN1YnR5cGUsIGRlbGV0ZSBhLnN1YnR5cGUsIGMpYS5uZXR3b3JrVHlwZSA9IGM7IGVsc2Ugc3dpdGNoIChkID0gYi5pbmRleE9mKFwiOlwiKSwgZSA9IGIuc3Vic3RyaW5nKGQgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlXCJ3aWZpXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2VcImVkZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZVwid3dhblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5uZXR3b3JrVHlwZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZXJyTXNnID0gXCJnZXROZXR3b3JrVHlwZTpmYWlsXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjKFwiZ2V0TmV0d29ya1R5cGVcIiwge30sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhID0gYihhKVxuICAgICAgICAgICAgICAgIH0sIGFcbiAgICAgICAgICAgIH0oKSlcbiAgICAgICAgfSwgb3BlbkxvY2F0aW9uOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcIm9wZW5Mb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGEubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBhLmxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBhLm5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhLmFkZHJlc3MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzY2FsZTogYS5zY2FsZSB8fCAyOCxcbiAgICAgICAgICAgICAgICBpbmZvVXJsOiBhLmluZm9VcmwgfHwgXCJcIlxuICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgfSwgZ2V0TG9jYXRpb246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhvLmdldExvY2F0aW9uLCB7dHlwZTogYS50eXBlIHx8IFwid2dzODRcIn0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYS50eXBlXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBoaWRlT3B0aW9uTWVudTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJoaWRlT3B0aW9uTWVudVwiLCB7fSwgYSlcbiAgICAgICAgfSwgc2hvd09wdGlvbk1lbnU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwic2hvd09wdGlvbk1lbnVcIiwge30sIGEpXG4gICAgICAgIH0sIGNsb3NlV2luZG93OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSA9IGEgfHwge30sIGMoXCJjbG9zZVdpbmRvd1wiLCB7aW1tZWRpYXRlX2Nsb3NlOiBhLmltbWVkaWF0ZUNsb3NlIHx8IDB9LCBhKVxuICAgICAgICB9LCBoaWRlTWVudUl0ZW1zOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImhpZGVNZW51SXRlbXNcIiwge21lbnVMaXN0OiBhLm1lbnVMaXN0fSwgYSlcbiAgICAgICAgfSwgc2hvd01lbnVJdGVtczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93TWVudUl0ZW1zXCIsIHttZW51TGlzdDogYS5tZW51TGlzdH0sIGEpXG4gICAgICAgIH0sIGhpZGVBbGxOb25CYXNlTWVudUl0ZW06IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiaGlkZUFsbE5vbkJhc2VNZW51SXRlbVwiLCB7fSwgYSlcbiAgICAgICAgfSwgc2hvd0FsbE5vbkJhc2VNZW51SXRlbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93QWxsTm9uQmFzZU1lbnVJdGVtXCIsIHt9LCBhKVxuICAgICAgICB9LCBzY2FuUVJDb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSA9IGEgfHwge30sIGMoXCJzY2FuUVJDb2RlXCIsIHtcbiAgICAgICAgICAgICAgICBuZWVkUmVzdWx0OiBhLm5lZWRSZXN1bHQgfHwgMCxcbiAgICAgICAgICAgICAgICBzY2FuVHlwZTogYS5zY2FuVHlwZSB8fCBbXCJxckNvZGVcIiwgXCJiYXJDb2RlXCJdXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGM7XG4gICAgICAgICAgICAgICAgICAgIHYgJiYgKGIgPSBhLnJlc3VsdFN0ciwgYiAmJiAoYyA9IEpTT04ucGFyc2UoYiksIGEucmVzdWx0U3RyID0gYyAmJiBjLnNjYW5fY29kZSAmJiBjLnNjYW5fY29kZS5zY2FuX3Jlc3VsdCkpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvcGVuUHJvZHVjdFNwZWNpZmljVmlldzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoby5vcGVuUHJvZHVjdFNwZWNpZmljVmlldywge3BpZDogYS5wcm9kdWN0SWQsIHZpZXdfdHlwZTogYS52aWV3VHlwZSB8fCAwfSwgYSlcbiAgICAgICAgfSwgYWRkQ2FyZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBlLCBmLCBnLCBoLCBiID0gYS5jYXJkTGlzdCwgZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChlID0gMCwgZiA9IGIubGVuZ3RoOyBmID4gZTsgKytlKWcgPSBiW2VdLCBoID0ge2NhcmRfaWQ6IGcuY2FyZElkLCBjYXJkX2V4dDogZy5jYXJkRXh0fSwgZC5wdXNoKGgpO1xuICAgICAgICAgICAgYyhvLmFkZENhcmQsIHtjYXJkX2xpc3Q6IGR9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMsIGQsIGUsIGIgPSBhLmNhcmRfbGlzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiA9IEpTT04ucGFyc2UoYiksIGMgPSAwLCBkID0gYi5sZW5ndGg7IGQgPiBjOyArK2MpZSA9IGJbY10sIGUuY2FyZElkID0gZS5jYXJkX2lkLCBlLmNhcmRFeHQgPSBlLmNhcmRfZXh0LCBlLmlzU3VjY2VzcyA9IGUuaXNfc3VjYyA/ICEwIDogITEsIGRlbGV0ZSBlLmNhcmRfaWQsIGRlbGV0ZSBlLmNhcmRfZXh0LCBkZWxldGUgZS5pc19zdWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5jYXJkTGlzdCA9IGIsIGRlbGV0ZSBhLmNhcmRfbGlzdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBjaG9vc2VDYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImNob29zZUNhcmRcIiwge1xuICAgICAgICAgICAgICAgIGFwcF9pZDogei5hcHBJZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbl9pZDogYS5zaG9wSWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzaWduX3R5cGU6IGEuc2lnblR5cGUgfHwgXCJTSEExXCIsXG4gICAgICAgICAgICAgICAgY2FyZF9pZDogYS5jYXJkSWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjYXJkX3R5cGU6IGEuY2FyZFR5cGUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjYXJkX3NpZ246IGEuY2FyZFNpZ24sXG4gICAgICAgICAgICAgICAgdGltZV9zdGFtcDogYS50aW1lc3RhbXAgKyBcIlwiLFxuICAgICAgICAgICAgICAgIG5vbmNlX3N0cjogYS5ub25jZVN0clxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEuY2FyZExpc3QgPSBhLmNob29zZV9jYXJkX2luZm8sIGRlbGV0ZSBhLmNob29zZV9jYXJkX2luZm9cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9wZW5DYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIGIgPSBhLmNhcmRMaXN0LCBkID0gW107XG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBmID0gYi5sZW5ndGg7IGYgPiBlOyArK2UpZyA9IGJbZV0sIGggPSB7Y2FyZF9pZDogZy5jYXJkSWQsIGNvZGU6IGcuY29kZX0sIGQucHVzaChoKTtcbiAgICAgICAgICAgIGMoby5vcGVuQ2FyZCwge2NhcmRfbGlzdDogZH0sIGEpXG4gICAgICAgIH0sIGNob29zZVdYUGF5OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhvLmNob29zZVdYUGF5LCBmKGEpLCBhKVxuICAgICAgICB9XG4gICAgfSwgYiAmJiAoYS53eCA9IGEualdlaXhpbiA9IEMpLCBDXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC93ZWl4aW4tanMtc2RrLzEuMC43L3dlaXhpbi1qcy1zZGsvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=