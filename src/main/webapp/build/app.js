/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _weixinJsSdk = __webpack_require__(170);
	
	var _weixinJsSdk2 = _interopRequireDefault(_weixinJsSdk);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	_vue2.default.filter('time', function (value) {
	    var hour = Math.floor(value / 3600);
	    var min = Math.floor(value % 3600 / 60);
	    if (hour < 10) {
	        hour = '0' + hour;
	    }
	    if (min < 10) {
	        min = '0' + min;
	    }
	    var sec = value % 60;
	    if (sec < 10) {
	        sec = '0' + sec;
	    }
	    return (hour > 0 ? hour + ':' : '') + min + ':' + sec;
	});
	_vue2.default.filter('datetime', function (value) {
	    return new Date(value).toLocaleString();
	});
	var config = {};
	_requestList2.default.getMainConfig().then(function (res) {
	    config = res.data;
	    console.log(config);
	}, function (res) {
	    console.error(res);
	});
	
	var main = new _vue2.default({
	    el: 'body',
	    components: { app: _App2.default }
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, jQuery) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2), __webpack_require__(3)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable no-unused-vars*/
	/*!
	 * jQuery JavaScript Library v3.1.0
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-07-07T21:44Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.0",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.0
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-04
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true;
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
		// Known :disabled false positives:
		// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
		// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Check form elements and option elements for explicit disabling
			return "label" in elem && elem.disabled === disabled ||
				"form" in elem && elem.disabled === disabled ||
	
				// Check non-disabled form elements for fieldset[disabled] ancestors
				"form" in elem && elem.disabled === false && (
					// Support: IE6-11+
					// Ancestry is covered for us
					elem.isDisabled === disabled ||
	
					// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						("label" in elem || !disabledAncestor( elem )) !== disabled
				);
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnotwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? JSON.parse( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) ),
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support: IE <=9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox <=42
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			opt.duration = typeof opt.duration === "number" ?
				opt.duration : opt.duration in jQuery.fx.speeds ?
					jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in uncached url if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rts, "" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	return jQuery;
	} );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(9)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(169)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0692510b/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue", function() {
				var newContent = require("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n", "", {"version":3,"sources":["/./src/App.vue?1e0e9352"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgJA;IACA,UAAA;CACA;;AAEA;;IAEA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oCAAA;IACA,SAAA;IACA,QAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;CACA","file":"App.vue","sourcesContent":["<template lang=\"pug\">\n        background\n        menu-bar(v-bind:game-data=\"gameData\",v-bind:notice=\"notice\",v-bind:zoom-rate=\"zoomRate\")\n        bet-and-bonus(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        play-panel(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        state(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        //- bet-multiple\n        message(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        modal.modal(v-if=\"error\")\n        tip-modal\n</template>\n<script>\nimport Background from './components/Background.vue'\nimport MenuBar from './components/MenuBar.vue'\nimport BetAndBonus from './components/BetAndBonus.vue'\nimport PlayPanel from './components/PlayPanel.vue'\nimport State from './components/State.vue'\nimport BetMultiple from './components/BetMultiple.vue'\nimport Message from './components/Message.vue'\nimport gameData from './data/data' //  \nimport RequestList from './js/request-list'\nexport default {\n    props: [],\n    ready() {\n        let that = this\n        window.onresize = function() {\n            that.screenSize.width = window.innerWidth\n            that.screenSize.height = window.innerHeight\n        }\n        this.init()\n    },\n    data() {\n        return {\n            userBet: {\n                betmoney: 1000 //1000\n            },\n            gameData: gameData,\n            lotterynum: { //\n                id: '',\n                createdAt: 0,\n                lotterynums: ''\n            },\n            countDown: 300, // \n            countNum: 300, // 3\n            error: false,\n            bets: [], // \n            notice: require('./data/notice'),\n            userinfo: require('./data/singleuser'),\n            stageSize: { // ,\n                width: 640,\n                height: 1008\n            },\n            screenSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            }\n        }\n    },\n    methods: {\n        init() {\n            // \n\n            // \n            RequestList.getBonusNum().then(res => this.lotterynum = res.data)\n            this.getUserInfoByNet()\n                // \n            this.$emit('getLastNotice')\n        },\n        show() {},\n        getUserInfoByNet() { //user\n            var that = this\n            RequestList.getuserCodeFromNet(RequestList.getCode()).then(res => {\n                // \n                Object.assign(that.userinfo, res.data)\n                that.$emit('getUserInfo')\n            }, res => console.error(res.data))\n        }\n    },\n    computed: {\n        zoomRate() { // \n            let x = this.screenSize.width / this.stageSize.width\n            let y = this.screenSize.height / this.stageSize.height\n            return {\n                x: x,\n                y: y\n            }\n        },\n        lockmoney() { //\n            let result = 0\n            for (let i = 0; i < this.bets.length; i++) {\n                result += this.bets[i].betmoney\n            }\n            return result\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.$broadcast('showMessage', event)\n        },\n        getUserInfo(event) {\n            var that = this\n            RequestList.getuserinfo(JSON.parse(JSON.stringify(this.userinfo))).then((res) => {\n                if (Object.prototype.toString.call(res.data) === '[object Object]') {\n                    that.userinfo = Object.assign({}, that.userinfo, res.data)\n                    that.userBet.userinfoOpenid = res.data.openid\n                } else {}\n                return\n            }, (res) => {\n                console.error(res)\n            })\n        },\n        getLastNotice(event) {\n            RequestList.getLastNotice().then(res => this.notice = res.data, res => console.error(res))\n        },\n        cancelbet(event) {\n            this.$broadcast('cancelBet')\n        },\n        reloadinfo(event) {\n            this.init()\n        },\n        // \n        error() {\n            this.error = true\n        },\n        showTip(event) {\n            this.$broadcast('showTip', event)\n        }\n    },\n    components: {\n        'modal': {\n            template: '<div class=\"modal\"></div>'\n        },\n        'tip-modal': require('./components/tip-modal.vue'),\n        'background': Background,\n        'menu-bar': MenuBar,\n        'bet-and-bonus': BetAndBonus,\n        'play-panel': PlayPanel,\n        'state': State,\n        'bet-multiple': BetMultiple,\n        'message': Message\n    }\n}\n</script>\n<style>\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if (media) {
			styleElement.setAttribute("media", media);
		}
	
		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Background = __webpack_require__(49);
	
	var _Background2 = _interopRequireDefault(_Background);
	
	var _MenuBar = __webpack_require__(55);
	
	var _MenuBar2 = _interopRequireDefault(_MenuBar);
	
	var _BetAndBonus = __webpack_require__(67);
	
	var _BetAndBonus2 = _interopRequireDefault(_BetAndBonus);
	
	var _PlayPanel = __webpack_require__(77);
	
	var _PlayPanel2 = _interopRequireDefault(_PlayPanel);
	
	var _State = __webpack_require__(85);
	
	var _State2 = _interopRequireDefault(_State);
	
	var _BetMultiple = __webpack_require__(94);
	
	var _BetMultiple2 = _interopRequireDefault(_BetMultiple);
	
	var _Message = __webpack_require__(99);
	
	var _Message2 = _interopRequireDefault(_Message);
	
	var _data = __webpack_require__(161);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: [],
	    ready: function ready() {
	        var that = this;
	        window.onresize = function () {
	            that.screenSize.width = window.innerWidth;
	            that.screenSize.height = window.innerHeight;
	        };
	        this.init();
	    },
	    data: function data() {
	        return {
	            userBet: {
	                betmoney: 1000 },
	            gameData: _data2.default,
	            lotterynum: {
	                id: '',
	                createdAt: 0,
	                lotterynums: ''
	            },
	            countDown: 300,
	            countNum: 300,
	            error: false,
	            bets: [],
	            notice: __webpack_require__(162),
	            userinfo: __webpack_require__(163),
	            stageSize: {
	                width: 640,
	                height: 1008
	            },
	            screenSize: {
	                width: window.innerWidth,
	                height: window.innerHeight
	            }
	        };
	    },
	
	    methods: {
	        init: function init() {
	            var _this = this;
	
	            _requestList2.default.getBonusNum().then(function (res) {
	                return _this.lotterynum = res.data;
	            });
	            this.getUserInfoByNet();
	
	            this.$emit('getLastNotice');
	        },
	        show: function show() {},
	        getUserInfoByNet: function getUserInfoByNet() {
	            var that = this;
	            _requestList2.default.getuserCodeFromNet(_requestList2.default.getCode()).then(function (res) {
	                (0, _assign2.default)(that.userinfo, res.data);
	                that.$emit('getUserInfo');
	            }, function (res) {
	                return console.error(res.data);
	            });
	        }
	    },
	    computed: {
	        zoomRate: function zoomRate() {
	            var x = this.screenSize.width / this.stageSize.width;
	            var y = this.screenSize.height / this.stageSize.height;
	            return {
	                x: x,
	                y: y
	            };
	        },
	        lockmoney: function lockmoney() {
	            var result = 0;
	            for (var i = 0; i < this.bets.length; i++) {
	                result += this.bets[i].betmoney;
	            }
	            return result;
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.$broadcast('showMessage', event);
	        },
	        getUserInfo: function getUserInfo(event) {
	            var that = this;
	            _requestList2.default.getuserinfo(JSON.parse((0, _stringify2.default)(this.userinfo))).then(function (res) {
	                if (Object.prototype.toString.call(res.data) === '[object Object]') {
	                    that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                    that.userBet.userinfoOpenid = res.data.openid;
	                } else {}
	                return;
	            }, function (res) {
	                console.error(res);
	            });
	        },
	        getLastNotice: function getLastNotice(event) {
	            var _this2 = this;
	
	            _requestList2.default.getLastNotice().then(function (res) {
	                return _this2.notice = res.data;
	            }, function (res) {
	                return console.error(res);
	            });
	        },
	        cancelbet: function cancelbet(event) {
	            this.$broadcast('cancelBet');
	        },
	        reloadinfo: function reloadinfo(event) {
	            this.init();
	        },
	        error: function error() {
	            this.error = true;
	        },
	        showTip: function showTip(event) {
	            this.$broadcast('showTip', event);
	        }
	    },
	    components: {
	        'modal': {
	            template: '<div class="modal"></div>'
	        },
	        'tip-modal': __webpack_require__(164),
	        'background': _Background2.default,
	        'menu-bar': _MenuBar2.default,
	        'bet-and-bonus': _BetAndBonus2.default,
	        'play-panel': _PlayPanel2.default,
	        'state': _State2.default,
	        'bet-multiple': _BetMultiple2.default,
	        'message': _Message2.default
	    }
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(11), __esModule: true };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(12)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(14), __esModule: true };

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(15);
	module.exports = __webpack_require__(12).Object.assign;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(16);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(30)});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , core      = __webpack_require__(12)
	  , ctx       = __webpack_require__(18)
	  , hide      = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 17 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(19);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(21)
	  , createDesc = __webpack_require__(29);
	module.exports = __webpack_require__(25) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(22)
	  , IE8_DOM_DEFINE = __webpack_require__(24)
	  , toPrimitive    = __webpack_require__(28)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(25) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(25) && !__webpack_require__(26)(function(){
	  return Object.defineProperty(__webpack_require__(27)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(26)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23)
	  , document = __webpack_require__(17).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(23);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(31)
	  , gOPS     = __webpack_require__(46)
	  , pIE      = __webpack_require__(47)
	  , toObject = __webpack_require__(48)
	  , IObject  = __webpack_require__(35)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(26)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(45);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(33)
	  , toIObject    = __webpack_require__(34)
	  , arrayIndexOf = __webpack_require__(38)(false)
	  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(35)
	  , defined = __webpack_require__(37);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(34)
	  , toLength  = __webpack_require__(39)
	  , toIndex   = __webpack_require__(41);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(40)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(43)('keys')
	  , uid    = __webpack_require__(44);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(17)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 46 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 47 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(37);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(50)
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7658d6de/Background.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(51);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(" + __webpack_require__(52) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(" + __webpack_require__(53) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/Background.vue?b29085ae"],"names":[],"mappings":";;;;;;AAMA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,YAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,iDAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,sBAAA;IACA,uBAAA;IACA,6BAAA;CACA","file":"Background.vue","sourcesContent":["<template lang=\"pug\">\n    div.background\n    \tdiv.up-background\n    \tdiv.buttom-background\n</template>\n<style>\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(../assets///BG.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(../assets///dock.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4b4a6609b989655a4d67f245bd57e41d.png";

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABlCAIAAAADEh6SAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5RjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDlBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlGQzJEOTlEM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yDa1IwAAABxJREFUeNpisArsZGJgYGB+//EbiB7FA48BAgwAr7gEtOjH9QQAAAAASUVORK5CYII="

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "<div class=\"background\"><div class=\"up-background\"></div><div class=\"buttom-background\"></div></div>";

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(56)
	__vue_script__ = __webpack_require__(59)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\MenuBar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(66)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a5fa5098/MenuBar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(" + __webpack_require__(58) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/MenuBar.vue?542b96fa"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;IACA,mBAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,eAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;IACA,aAAA;IACA,sBAAA;IACA,aAAA;IACA;2BACA;IACA,wBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"MenuBar.vue","sourcesContent":["<template lang=\"pug\">\n    //-\n    div.menu\n        div.notice\n            table\n                tr\n                    td\n                        span(v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\",v-html='notice.title')\n        div.option(@touchend=\"triggerOption\")\n        options-dialog(v-bind:game-data=\"gameData\",v-bind:zoom-rate=\"zoomRate\")\n</template>\n<script>\nimport OptionsDialog from './OptionsDialog.vue'\nexport default {\n    props: ['gameData', 'zoomRate', 'notice'],\n    ready() {\n        console.log(this.gameData.notice)\n    },\n    data() {\n        return {\n            name: 'liu',\n            isShowOption: false\n        }\n    },\n    methods: {\n        triggerOption() {\n            this.$broadcast('triggerOption')\n        }\n    },\n    components: {\n        'options-dialog': OptionsDialog\n    }\n}\n</script>\n<style>\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA0CAYAAAA5bTAhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUI5QzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUI5RDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcwMzg1MUZGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwMzg1MjAwM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+mrp5MgAABkJJREFU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"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _OptionsDialog = __webpack_require__(60);
	
	var _OptionsDialog2 = _interopRequireDefault(_OptionsDialog);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['gameData', 'zoomRate', 'notice'],
	    ready: function ready() {
	        console.log(this.gameData.notice);
	    },
	    data: function data() {
	        return {
	            name: 'liu',
	            isShowOption: false
	        };
	    },
	
	    methods: {
	        triggerOption: function triggerOption() {
	            this.$broadcast('triggerOption');
	        }
	    },
	    components: {
	        'options-dialog': _OptionsDialog2.default
	    }
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(61)
	__vue_script__ = __webpack_require__(63)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\OptionsDialog.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(65)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-3d271406/OptionsDialog.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/*  */\n\n.expand-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter  */\n\n\n/* .expand-leave  */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n", "", {"version":3,"sources":["/./src/components/OptionsDialog.vue?53ddea8e"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,iBAAA;IACA,iBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;;AAGA,QAAA;;AAEA;IACA,iCAAA;IAAA,yBAAA;IACA,iBAAA;IACA,kBAAA;IACA,2BAAA;IACA,iBAAA;CACA;;;AAGA,6BAAA;;;AAGA,6BAAA;;AAEA;;IAEA,UAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,6BAAA;IACA,mBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;AAEA;IACA,eAAA;IACA,gBAAA;IACA,oBAAA;IACA,mBAAA;IACA,oBAAA;IACA,4BAAA;CACA;;AAEA;IACA,cAAA;IACA,mCAAA;CACA","file":"OptionsDialog.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.option-list(v-show=\"isOptionShow\",transition=\"expand\",v-bind:style=\"optionStyle\")\n        //- img(v-bind:src=\"menuImg\")\n        div.pointer\n        div.inner-pointer\n        div.option-item(v-html=\"n\",v-for=\"n in gameData.options\",@touchend=\"showMessage($index)\",v-bind:style=\"itemStyle\")\n</template>\n<script>\nexport default {\n    ready() {\n            console.log(this.gameData)\n        },\n        props: ['gameData', 'zoomRate'],\n        data() {\n            return {\n                isOptionShow: false,\n                menuImg: require('../assets///.png')\n            }\n        },\n        computed: {\n            optionStyle() {\n                return {\n                    borderRadius: 12 * this.zoomRate.x + 'px'\n                }\n            },\n            itemStyle() {\n                return {\n                    fontSize: 26 * this.zoomRate.x + 'px'\n                }\n            }\n        },\n        methods: {\n            showMessage(event) {\n                this.isOptionShow = false\n                this.$dispatch('showMessage', event)\n            }\n        },\n        events: {\n            triggerOption() {\n                this.isOptionShow = !this.isOptionShow\n            }\n        }\n}\n</script>\n<style>\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/*  */\n\n.expand-transition {\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter  */\n\n\n/* .expand-leave  */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.gameData);
	    },
	
	    props: ['gameData', 'zoomRate'],
	    data: function data() {
	        return {
	            isOptionShow: false,
	            menuImg: __webpack_require__(64)
	        };
	    },
	
	    computed: {
	        optionStyle: function optionStyle() {
	            return {
	                borderRadius: 12 * this.zoomRate.x + 'px'
	            };
	        },
	        itemStyle: function itemStyle() {
	            return {
	                fontSize: 26 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        showMessage: function showMessage(event) {
	            this.isOptionShow = false;
	            this.$dispatch('showMessage', event);
	        }
	    },
	    events: {
	        triggerOption: function triggerOption() {
	            this.isOptionShow = !this.isOptionShow;
	        }
	    }
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAFcCAYAAABhrZRpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUJBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUJBMTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQjlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkyN0JFQjlGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ePgOugAAKRNJREFU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"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<div class=\"option-list\" v-show=\"isOptionShow\" transition=\"expand\" v-bind:style=\"optionStyle\"><div class=\"pointer\"></div><div class=\"inner-pointer\"></div><div class=\"option-item\" v-html=\"n\" v-for=\"n in gameData.options\" @touchend=\"showMessage($index)\" v-bind:style=\"itemStyle\"></div></div>";

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<div class=\"menu\"><div class=\"notice\"><table><tr><td><span v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\" v-html=\"notice.title\"></span></td></tr></table></div><div class=\"option\" @touchend=\"triggerOption\"></div><options-dialog v-bind:game-data=\"gameData\" v-bind:zoom-rate=\"zoomRate\"></options-dialog></div>";

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(68)
	__vue_script__ = __webpack_require__(73)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetAndBonus.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7138c18e/BetAndBonus.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(70) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(71) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(72) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n", "", {"version":3,"sources":["/./src/components/BetAndBonus.vue?17f568bf"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2GA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,gBAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,kBAAA;IACA,aAAA;CACA;;AAEA;;IAEA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;IACA,eAAA;CACA;;AAEA;IACA,aAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;CACA","file":"BetAndBonus.vue","sourcesContent":["<template lang=\"pug\">\n    //-    \n    div.bonus-bar\n        div.bonus-item.bet\n            div.item-back.forzen\n                div.item-show\n                    div.bet-num(v-bind:style=\"betNum\",v-html=\"lockmoney\")\n        div.bonus-item.count-down\n            div.count-down-back\n                div.count-down-show\n                    div.count-down-num(v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\",v-html=\"countDown | time\")\n        div.bonus-item.bonus\n            div.item-back.balance\n                div.item-show(@touchend=\"showMessage\")\n                    div.bet-num(v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\")\n</template>\n<script>\nimport RequestList from '../js/request-list'\nexport default {\n    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],\n    ready() {\n        this.getCount(this.count(this.countDown))\n    },\n    data() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight\n        }\n    },\n    computed: {\n        betNum() {\n            return {\n                fontSize: 34 * this.zoomRate.x + 'px',\n                lineHeight: 3 * 34 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        // \n        getCount(fn) {\n            var that = this\n            RequestList.getCount().then((res) => {\n                that.countDown = res.data.countDown\n                that.countNum = res.data.countNum\n                that.userBet.idnum = res.data.idnum + 1 //\n                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {\n                    that.$dispatch('error')\n                    return\n                }\n                fn ? fn() : null\n            }, (res) => {\n                that.countDown = 0\n            })\n        },\n        // \n        createUserBets() {\n            var that = this\n            RequestList.createUserBets(JSON.stringify(this.bets)).then((res) => {\n                if (typeof res.data.errmsg !== 'undefined') {\n                    that.$dispatch('showTip', res.data.errmsg)\n                }\n                console.log(res.data)\n            }, (res) => {\n                console.log(res.data)\n            })\n        },\n        getBonusNum() { // \n            var that = this\n            RequestList.getBonusNum().then((res) => {\n                that.lotterynum = res.data\n                that.getCount(that.count)\n                that.$dispatch('cancelbet')\n                that.$dispatch('reloadinfo')\n            }, (res) => {\n                console.error(res)\n            })\n            this.countDown = this.countNum\n        },\n        showMessage() {\n            this.$dispatch('showMessage', 5)\n        },\n        count() {\n            // 30 \n            if (this.countDown === 30 && this.bets && this.bets.length > 0) {\n                this.createUserBets()\n            }\n            // \n            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {\n                this.$dispatch('showTip', ',')\n                return\n            }\n            // console.log(this.countDown)\n            this.countDown--\n                let that = this\n            setTimeout(function() {\n                if (that.countDown > 0) {\n                    that.count()\n                } else {\n                    // 0  \n                    that.getBonusNum()\n                }\n            }, 1000)\n        }\n    }\n}\n</script>\n<style>\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets///count-down.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ2RTNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ2RjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0ZCM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0ZDM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jqTgIAAAGLJJREFU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"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNkJDRDdGOTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGQTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0Y3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0Y4M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8Nwv7wAAFD1JREFU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"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAACVCAYAAACzfqM2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ3MjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ3MzNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBEMDg0NDcwM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBEMDg0NDcxM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gONmGwAAMvxJREFU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"

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],
	    ready: function ready() {
	        this.getCount(this.count(this.countDown));
	    },
	    data: function data() {
	        return {
	            width: window.innerWidth,
	            height: window.innerHeight
	        };
	    },
	
	    computed: {
	        betNum: function betNum() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                lineHeight: 3 * 34 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        getCount: function getCount(fn) {
	            var that = this;
	            _requestList2.default.getCount().then(function (res) {
	                that.countDown = res.data.countDown;
	                that.countNum = res.data.countNum;
	                that.userBet.idnum = res.data.idnum + 1;
	                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {
	                    that.$dispatch('error');
	                    return;
	                }
	                fn ? fn() : null;
	            }, function (res) {
	                that.countDown = 0;
	            });
	        },
	        createUserBets: function createUserBets() {
	            var that = this;
	            _requestList2.default.createUserBets((0, _stringify2.default)(this.bets)).then(function (res) {
	                if (typeof res.data.errmsg !== 'undefined') {
	                    that.$dispatch('showTip', res.data.errmsg);
	                }
	                console.log(res.data);
	            }, function (res) {
	                console.log(res.data);
	            });
	        },
	        getBonusNum: function getBonusNum() {
	            var that = this;
	            _requestList2.default.getBonusNum().then(function (res) {
	                that.lotterynum = res.data;
	                that.getCount(that.count);
	                that.$dispatch('cancelbet');
	                that.$dispatch('reloadinfo');
	            }, function (res) {
	                console.error(res);
	            });
	            this.countDown = this.countNum;
	        },
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        count: function count() {
	            if (this.countDown === 30 && this.bets && this.bets.length > 0) {
	                this.createUserBets();
	            }
	
	            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {
	                this.$dispatch('showTip', ',');
	                return;
	            }
	
	            this.countDown--;
	            var that = this;
	            setTimeout(function () {
	                if (that.countDown > 0) {
	                    that.count();
	                } else {
	                    that.getBonusNum();
	                }
	            }, 1000);
	        }
	    }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	
	module.exports.getBonusRecord = function () {
	    return _vue2.default.http.get('getBonusRecord');
	};
	
	module.exports.getMainConfig = function () {
	    return _vue2.default.http.get('getMainConfig', { params: { url: window.location.href.split('#')[0] } });
	};
	
	module.exports.getCount = function () {
	    return _vue2.default.http.get('getCount');
	};
	
	module.exports.getBonusNum = function (params) {
	    return _vue2.default.http.get('getBonusNum', params);
	};
	
	module.exports.createUserBets = function (params) {
	    return _vue2.default.http.post('createUserBets', params);
	};
	
	module.exports.getuserCodeFromNet = function (code) {
	    return _vue2.default.http.get('getUserCode', { params: { code: code } });
	};
	
	module.exports.getuserinfo = function (userinfo) {
	    return _vue2.default.http.post('getuserinfo', userinfo);
	};
	
	module.exports.getLastNotice = function () {
	    return _vue2.default.http.get('getLastNotice');
	};
	
	module.exports.getCode = function () {
	    var reg = new RegExp("(^|&)" + 'code' + "=([^&]*)(&|$)", "i");
	    var r = window.location.search.substr(1).match(reg);
	    if (r != null) return unescape(r[2]);
	    return null;
	};
	
	module.exports.updateuserinfo = function (params) {
	    return _vue2.default.http.post('updateuserinfo', params);
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	/*!
	 * vue-resource v0.9.3
	 * https://github.com/vuejs/vue-resource
	 * Released under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */
	
	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING = 2;
	
	function Promise$2(executor) {
	
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	
	    var promise = this;
	
	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}
	
	Promise$2.reject = function (r) {
	    return new Promise$2(function (resolve, reject) {
	        reject(r);
	    });
	};
	
	Promise$2.resolve = function (x) {
	    return new Promise$2(function (resolve, reject) {
	        resolve(x);
	    });
	};
	
	Promise$2.all = function all(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        var count = 0,
	            result = [];
	
	        if (iterable.length === 0) {
	            resolve(result);
	        }
	
	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;
	
	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }
	
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};
	
	Promise$2.race = function race(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};
	
	var p$1 = Promise$2.prototype;
	
	p$1.resolve = function resolve(x) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        var called = false;
	
	        try {
	            var then = x && x['then'];
	
	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;
	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }
	
	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};
	
	p$1.reject = function reject(reason) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};
	
	p$1.notify = function notify() {
	    var promise = this;
	
	    nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];
	
	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};
	
	p$1.then = function then(onResolved, onRejected) {
	    var promise = this;
	
	    return new Promise$2(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};
	
	p$1.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};
	
	var PromiseObj = window.Promise || Promise$2;
	
	function Promise$1(executor, context) {
	
	    if (executor instanceof PromiseObj) {
	        this.promise = executor;
	    } else {
	        this.promise = new PromiseObj(executor.bind(context));
	    }
	
	    this.context = context;
	}
	
	Promise$1.all = function (iterable, context) {
	    return new Promise$1(PromiseObj.all(iterable), context);
	};
	
	Promise$1.resolve = function (value, context) {
	    return new Promise$1(PromiseObj.resolve(value), context);
	};
	
	Promise$1.reject = function (reason, context) {
	    return new Promise$1(PromiseObj.reject(reason), context);
	};
	
	Promise$1.race = function (iterable, context) {
	    return new Promise$1(PromiseObj.race(iterable), context);
	};
	
	var p = Promise$1.prototype;
	
	p.bind = function (context) {
	    this.context = context;
	    return this;
	};
	
	p.then = function (fulfilled, rejected) {
	
	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);
	};
	
	p.catch = function (rejected) {
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.catch(rejected), this.context);
	};
	
	p.finally = function (callback) {
	
	    return this.then(function (value) {
	        callback.call(this);
	        return value;
	    }, function (reason) {
	        callback.call(this);
	        return PromiseObj.reject(reason);
	    });
	};
	
	var debug = false;
	var util = {};
	var array = [];
	function Util (Vue) {
	    util = Vue.util;
	    debug = Vue.config.debug || !Vue.config.silent;
	}
	
	function warn(msg) {
	    if (typeof console !== 'undefined' && debug) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	}
	
	function error(msg) {
	    if (typeof console !== 'undefined') {
	        console.error(msg);
	    }
	}
	
	function nextTick(cb, ctx) {
	    return util.nextTick(cb, ctx);
	}
	
	function trim(str) {
	    return str.replace(/^\s*|\s*$/g, '');
	}
	
	var isArray = Array.isArray;
	
	function isString(val) {
	    return typeof val === 'string';
	}
	
	function isBoolean(val) {
	    return val === true || val === false;
	}
	
	function isFunction(val) {
	    return typeof val === 'function';
	}
	
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	
	function isPlainObject(obj) {
	    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	}
	
	function isFormData(obj) {
	    return typeof FormData !== 'undefined' && obj instanceof FormData;
	}
	
	function when(value, fulfilled, rejected) {
	
	    var promise = Promise$1.resolve(value);
	
	    if (arguments.length < 2) {
	        return promise;
	    }
	
	    return promise.then(fulfilled, rejected);
	}
	
	function options(fn, obj, opts) {
	
	    opts = opts || {};
	
	    if (isFunction(opts)) {
	        opts = opts.call(obj);
	    }
	
	    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
	}
	
	function each(obj, iterator) {
	
	    var i, key;
	
	    if (typeof obj.length == 'number') {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (isObject(obj)) {
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }
	
	    return obj;
	}
	
	var assign = Object.assign || _assign;
	
	function merge(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source, true);
	    });
	
	    return target;
	}
	
	function defaults(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	
	        for (var key in source) {
	            if (target[key] === undefined) {
	                target[key] = source[key];
	            }
	        }
	    });
	
	    return target;
	}
	
	function _assign(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source);
	    });
	
	    return target;
	}
	
	function _merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
	            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
	                target[key] = {};
	            }
	            if (isArray(source[key]) && !isArray(target[key])) {
	                target[key] = [];
	            }
	            _merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}
	
	function root (options, next) {
	
	    var url = next(options);
	
	    if (isString(options.root) && !url.match(/^(https?:)?\//)) {
	        url = options.root + '/' + url;
	    }
	
	    return url;
	}
	
	function query (options, next) {
	
	    var urlParams = Object.keys(Url.options.params),
	        query = {},
	        url = next(options);
	
	    each(options.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });
	
	    query = Url.params(query);
	
	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }
	
	    return url;
	}
	
	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */
	
	function expand(url, params, variables) {
	
	    var tmpl = parse(url),
	        expanded = tmpl.expand(params);
	
	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }
	
	    return expanded;
	}
	
	function parse(template) {
	
	    var operators = ['+', '#', '.', '/', ';', '?', '&'],
	        variables = [];
	
	    return {
	        vars: variables,
	        expand: function (context) {
	            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
	                if (expression) {
	
	                    var operator = null,
	                        values = [];
	
	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }
	
	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });
	
	                    if (operator && operator !== '+') {
	
	                        var separator = ',';
	
	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }
	
	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }
	                } else {
	                    return encodeReserved(literal);
	                }
	            });
	        }
	    };
	}
	
	function getValues(context, operator, key, modifier) {
	
	    var value = context[key],
	        result = [];
	
	    if (isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();
	
	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }
	
	            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            result.push(encodeValue(operator, value[k], k));
	                        }
	                    });
	                }
	            } else {
	                var tmp = [];
	
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        tmp.push(encodeValue(operator, value));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(encodeValue(operator, value[k].toString()));
	                        }
	                    });
	                }
	
	                if (isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }
	
	    return result;
	}
	
	function isDefined(value) {
	    return value !== undefined && value !== null;
	}
	
	function isKeyOperator(operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	}
	
	function encodeValue(operator, value, key) {
	
	    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);
	
	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	}
	
	function encodeReserved(str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	}
	
	function template (options) {
	
	    var variables = [],
	        url = expand(options.url, options.params, variables);
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	}
	
	/**
	 * Service for URL templating.
	 */
	
	var ie = document.documentMode;
	var el = document.createElement('a');
	
	function Url(url, params) {
	
	    var self = this || {},
	        options = url,
	        transform;
	
	    if (isString(url)) {
	        options = { url: url, params: params };
	    }
	
	    options = merge({}, Url.options, self.$options, options);
	
	    Url.transforms.forEach(function (handler) {
	        transform = factory(handler, transform, self.$vm);
	    });
	
	    return transform(options);
	}
	
	/**
	 * Url options.
	 */
	
	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};
	
	/**
	 * Url transforms.
	 */
	
	Url.transforms = [template, query, root];
	
	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */
	
	Url.params = function (obj) {
	
	    var params = [],
	        escape = encodeURIComponent;
	
	    params.add = function (key, value) {
	
	        if (isFunction(value)) {
	            value = value();
	        }
	
	        if (value === null) {
	            value = '';
	        }
	
	        this.push(escape(key) + '=' + escape(value));
	    };
	
	    serialize(params, obj);
	
	    return params.join('&').replace(/%20/g, '+');
	};
	
	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */
	
	Url.parse = function (url) {
	
	    if (ie) {
	        el.href = url;
	        url = el.href;
	    }
	
	    el.href = url;
	
	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};
	
	function factory(handler, next, vm) {
	    return function (options) {
	        return handler.call(vm, options, next);
	    };
	}
	
	function serialize(params, obj, scope) {
	
	    var array = isArray(obj),
	        plain = isPlainObject(obj),
	        hash;
	
	    each(obj, function (value, key) {
	
	        hash = isObject(value) || isArray(value);
	
	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }
	
	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}
	
	function xdrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xdr = new XDomainRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith(xdr.responseText, {
	                status: xdr.status,
	                statusText: xdr.statusText
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xdr.abort();
	        };
	
	        xdr.open(request.method, request.getUrl(), true);
	        xdr.timeout = 0;
	        xdr.onload = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = function () {};
	        xdr.onprogress = function () {};
	        xdr.send(request.getBody());
	    });
	}
	
	var ORIGIN_URL = Url.parse(location.href);
	var SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();
	
	function cors (request, next) {
	
	    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {
	        request.crossOrigin = true;
	    }
	
	    if (request.crossOrigin) {
	
	        if (!SUPPORTS_CORS) {
	            request.client = xdrClient;
	        }
	
	        delete request.emulateHTTP;
	    }
	
	    next();
	}
	
	function crossOrigin(request) {
	
	    var requestUrl = Url.parse(Url(request));
	
	    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;
	}
	
	function body (request, next) {
	
	    if (request.emulateJSON && isPlainObject(request.body)) {
	        request.body = Url.params(request.body);
	        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	    }
	
	    if (isFormData(request.body)) {
	        delete request.headers['Content-Type'];
	    }
	
	    if (isPlainObject(request.body)) {
	        request.body = JSON.stringify(request.body);
	    }
	
	    next(function (response) {
	
	        var contentType = response.headers['Content-Type'];
	
	        if (isString(contentType) && contentType.indexOf('application/json') === 0) {
	
	            try {
	                response.data = response.json();
	            } catch (e) {
	                response.data = null;
	            }
	        } else {
	            response.data = response.text();
	        }
	    });
	}
	
	function jsonpClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var name = request.jsonp || 'callback',
	            callback = '_jsonp' + Math.random().toString(36).substr(2),
	            body = null,
	            handler,
	            script;
	
	        handler = function (event) {
	
	            var status = 0;
	
	            if (event.type === 'load' && body !== null) {
	                status = 200;
	            } else if (event.type === 'error') {
	                status = 404;
	            }
	
	            resolve(request.respondWith(body, { status: status }));
	
	            delete window[callback];
	            document.body.removeChild(script);
	        };
	
	        request.params[name] = callback;
	
	        window[callback] = function (result) {
	            body = JSON.stringify(result);
	        };
	
	        script = document.createElement('script');
	        script.src = request.getUrl();
	        script.type = 'text/javascript';
	        script.async = true;
	        script.onload = handler;
	        script.onerror = handler;
	
	        document.body.appendChild(script);
	    });
	}
	
	function jsonp (request, next) {
	
	    if (request.method == 'JSONP') {
	        request.client = jsonpClient;
	    }
	
	    next(function (response) {
	
	        if (request.method == 'JSONP') {
	            response.data = response.json();
	        }
	    });
	}
	
	function before (request, next) {
	
	    if (isFunction(request.before)) {
	        request.before.call(this, request);
	    }
	
	    next();
	}
	
	/**
	 * HTTP method override Interceptor.
	 */
	
	function method (request, next) {
	
	    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	        request.headers['X-HTTP-Method-Override'] = request.method;
	        request.method = 'POST';
	    }
	
	    next();
	}
	
	function header (request, next) {
	
	    request.method = request.method.toUpperCase();
	    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);
	
	    next();
	}
	
	/**
	 * Timeout Interceptor.
	 */
	
	function timeout (request, next) {
	
	    var timeout;
	
	    if (request.timeout) {
	        timeout = setTimeout(function () {
	            request.abort();
	        }, request.timeout);
	    }
	
	    next(function (response) {
	
	        clearTimeout(timeout);
	    });
	}
	
	function xhrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xhr = new XMLHttpRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {
	                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
	                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),
	                headers: parseHeaders(xhr.getAllResponseHeaders())
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xhr.abort();
	        };
	
	        xhr.open(request.method, request.getUrl(), true);
	        xhr.timeout = 0;
	        xhr.onload = handler;
	        xhr.onerror = handler;
	
	        if (request.progress) {
	            if (request.method === 'GET') {
	                xhr.addEventListener('progress', request.progress);
	            } else if (/^(POST|PUT)$/i.test(request.method)) {
	                xhr.upload.addEventListener('progress', request.progress);
	            }
	        }
	
	        if (request.credentials === true) {
	            xhr.withCredentials = true;
	        }
	
	        each(request.headers || {}, function (value, header) {
	            xhr.setRequestHeader(header, value);
	        });
	
	        xhr.send(request.getBody());
	    });
	}
	
	function parseHeaders(str) {
	
	    var headers = {},
	        value,
	        name,
	        i;
	
	    each(trim(str).split('\n'), function (row) {
	
	        i = row.indexOf(':');
	        name = trim(row.slice(0, i));
	        value = trim(row.slice(i + 1));
	
	        if (headers[name]) {
	
	            if (isArray(headers[name])) {
	                headers[name].push(value);
	            } else {
	                headers[name] = [headers[name], value];
	            }
	        } else {
	
	            headers[name] = value;
	        }
	    });
	
	    return headers;
	}
	
	function Client (context) {
	
	    var reqHandlers = [sendRequest],
	        resHandlers = [],
	        handler;
	
	    if (!isObject(context)) {
	        context = null;
	    }
	
	    function Client(request) {
	        return new Promise$1(function (resolve) {
	
	            function exec() {
	
	                handler = reqHandlers.pop();
	
	                if (isFunction(handler)) {
	                    handler.call(context, request, next);
	                } else {
	                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');
	                    next();
	                }
	            }
	
	            function next(response) {
	
	                if (isFunction(response)) {
	
	                    resHandlers.unshift(response);
	                } else if (isObject(response)) {
	
	                    resHandlers.forEach(function (handler) {
	                        response = when(response, function (response) {
	                            return handler.call(context, response) || response;
	                        });
	                    });
	
	                    when(response, resolve);
	
	                    return;
	                }
	
	                exec();
	            }
	
	            exec();
	        }, context);
	    }
	
	    Client.use = function (handler) {
	        reqHandlers.push(handler);
	    };
	
	    return Client;
	}
	
	function sendRequest(request, resolve) {
	
	    var client = request.client || xhrClient;
	
	    resolve(client(request));
	}
	
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	
	/**
	 * HTTP Response.
	 */
	
	var Response = function () {
	    function Response(body, _ref) {
	        var url = _ref.url;
	        var headers = _ref.headers;
	        var status = _ref.status;
	        var statusText = _ref.statusText;
	        classCallCheck(this, Response);
	
	
	        this.url = url;
	        this.body = body;
	        this.headers = headers || {};
	        this.status = status || 0;
	        this.statusText = statusText || '';
	        this.ok = status >= 200 && status < 300;
	    }
	
	    Response.prototype.text = function text() {
	        return this.body;
	    };
	
	    Response.prototype.blob = function blob() {
	        return new Blob([this.body]);
	    };
	
	    Response.prototype.json = function json() {
	        return JSON.parse(this.body);
	    };
	
	    return Response;
	}();
	
	var Request = function () {
	    function Request(options) {
	        classCallCheck(this, Request);
	
	
	        this.method = 'GET';
	        this.body = null;
	        this.params = {};
	        this.headers = {};
	
	        assign(this, options);
	    }
	
	    Request.prototype.getUrl = function getUrl() {
	        return Url(this);
	    };
	
	    Request.prototype.getBody = function getBody() {
	        return this.body;
	    };
	
	    Request.prototype.respondWith = function respondWith(body, options) {
	        return new Response(body, assign(options || {}, { url: this.getUrl() }));
	    };
	
	    return Request;
	}();
	
	/**
	 * Service for sending network requests.
	 */
	
	var CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };
	var COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };
	var JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };
	
	function Http(options) {
	
	    var self = this || {},
	        client = Client(self.$vm);
	
	    defaults(options || {}, self.$options, Http.options);
	
	    Http.interceptors.forEach(function (handler) {
	        client.use(handler);
	    });
	
	    return client(new Request(options)).then(function (response) {
	
	        return response.ok ? response : Promise$1.reject(response);
	    }, function (response) {
	
	        if (response instanceof Error) {
	            error(response);
	        }
	
	        return Promise$1.reject(response);
	    });
	}
	
	Http.options = {};
	
	Http.headers = {
	    put: JSON_CONTENT_TYPE,
	    post: JSON_CONTENT_TYPE,
	    patch: JSON_CONTENT_TYPE,
	    delete: JSON_CONTENT_TYPE,
	    custom: CUSTOM_HEADERS,
	    common: COMMON_HEADERS
	};
	
	Http.interceptors = [before, timeout, method, body, jsonp, header, cors];
	
	['get', 'delete', 'head', 'jsonp'].forEach(function (method) {
	
	    Http[method] = function (url, options) {
	        return this(assign(options || {}, { url: url, method: method }));
	    };
	});
	
	['post', 'put', 'patch'].forEach(function (method) {
	
	    Http[method] = function (url, body, options) {
	        return this(assign(options || {}, { url: url, method: method, body: body }));
	    };
	});
	
	function Resource(url, params, actions, options) {
	
	    var self = this || {},
	        resource = {};
	
	    actions = assign({}, Resource.actions, actions);
	
	    each(actions, function (action, name) {
	
	        action = merge({ url: url, params: params || {} }, options, action);
	
	        resource[name] = function () {
	            return (self.$http || Http)(opts(action, arguments));
	        };
	    });
	
	    return resource;
	}
	
	function opts(action, args) {
	
	    var options = assign({}, action),
	        params = {},
	        body;
	
	    switch (args.length) {
	
	        case 2:
	
	            params = args[0];
	            body = args[1];
	
	            break;
	
	        case 1:
	
	            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
	                body = args[0];
	            } else {
	                params = args[0];
	            }
	
	            break;
	
	        case 0:
	
	            break;
	
	        default:
	
	            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';
	    }
	
	    options.body = body;
	    options.params = assign({}, options.params, params);
	
	    return options;
	}
	
	Resource.actions = {
	
	    get: { method: 'GET' },
	    save: { method: 'POST' },
	    query: { method: 'GET' },
	    update: { method: 'PUT' },
	    remove: { method: 'DELETE' },
	    delete: { method: 'DELETE' }
	
	};
	
	function plugin(Vue) {
	
	    if (plugin.installed) {
	        return;
	    }
	
	    Util(Vue);
	
	    Vue.url = Url;
	    Vue.http = Http;
	    Vue.resource = Resource;
	    Vue.Promise = Promise$1;
	
	    Object.defineProperties(Vue.prototype, {
	
	        $url: {
	            get: function () {
	                return options(Vue.url, this, this.$options.url);
	            }
	        },
	
	        $http: {
	            get: function () {
	                return options(Vue.http, this, this.$options.http);
	            }
	        },
	
	        $resource: {
	            get: function () {
	                return Vue.resource.bind(this);
	            }
	        },
	
	        $promise: {
	            get: function () {
	                var _this = this;
	
	                return function (executor) {
	                    return new Vue.Promise(executor, _this);
	                };
	            }
	        }
	
	    });
	}
	
	if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(plugin);
	}
	
	module.exports = plugin;

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bonus-bar\"><div class=\"bonus-item bet\"><div class=\"item-back forzen\"><div class=\"item-show\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"lockmoney\"></div></div></div></div><div class=\"bonus-item count-down\"><div class=\"count-down-back\"><div class=\"count-down-show\"><div class=\"count-down-num\" v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\" v-html=\"countDown | time\"></div></div></div></div><div class=\"bonus-item bonus\"><div class=\"item-back balance\"><div class=\"item-show\" @touchend=\"showMessage\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\"></div></div></div></div></div>";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(81)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\PlayPanel.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(84)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-5febd0b0/PlayPanel.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(79);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.playpanel {\n    /*background: url(../assets///.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(" + __webpack_require__(80) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/PlayPanel.vue?dfc2404a"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+NA;IACA,sDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;CACA;;AAEA;IACA,WAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;IACA,kBAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,qBAAA;IACA,+BAAA;CACA;;AAEA;IACA,6BAAA;CACA;;AAEA;IACA,4BAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"PlayPanel.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.playpanel\n        div.table-panel(v-el:panel,v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n            div.num.single(v-bind:style=\"single\",@touchend=\"dobet('single')\")\n                img.chip(v-for=\"item in bets|filterBy 'single' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.double(v-bind:style=\"double\",@touchend=\"dobet('double')\")\n                img.chip(v-for=\"item in bets|filterBy 'double' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.zero(v-bind:style=\"zero\",@touchend=\"dobet(0)\")\n                img.chip(v-for=\"item in bets|filterBy 0 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.one(v-bind:style=\"one\",@touchend=\"dobet(1)\")\n                img.chip(v-for=\"item in bets|filterBy 1 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.two(v-bind:style=\"two\",@touchend=\"dobet(2)\")\n                img.chip(v-for=\"item in bets|filterBy 2 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.three(v-bind:style=\"three\",@touchend=\"dobet(3)\")\n                img.chip(v-for=\"item in bets|filterBy 3 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.four(v-bind:style=\"four\",@touchend=\"dobet(4)\")\n                img.chip(v-for=\"item in bets|filterBy 4 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.five(v-bind:style=\"five\",@touchend=\"dobet(5)\")\n                img.chip(v-for=\"item in bets|filterBy 5 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.six(v-bind:style=\"six\",@touchend=\"dobet(6)\")\n                img.chip(v-for=\"item in bets|filterBy 6 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.seven(v-bind:style=\"seven\",@touchend=\"dobet(7)\")\n                img.chip(v-for=\"item in bets|filterBy 7 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.eight(v-bind:style=\"eight\",@touchend=\"dobet(8)\")\n                img.chip(v-for=\"item in bets|filterBy 8 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.nine(v-bind:style=\"nine\",@touchend=\"dobet(9)\")\n                img.chip(v-for=\"item in bets|filterBy 9 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.big(v-bind:style=\"big\",@touchend=\"dobet('big')\")\n                img.chip(v-for=\"item in bets|filterBy 'big' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.small(v-bind:style=\"small\",@touchend=\"dobet('small')\")\n                img.chip(v-for=\"item in bets|filterBy 'small' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.formula(v-bind:style=\"formula\",v-html=\"bonusNum\") \n            div.num.bonudnum(v-bind:style=\"bonudnum\")\n                table\n                    tr\n                        td(v-html=\"userBet.betnum\")\n        img(v-bind:src=\"tablePanelImg\",v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],\n    data() {\n        return {\n            tablePanelImg: require('../assets///.png'),\n            chipImg: require('../assets///5X-.png'),\n            imgSize: {\n                width: 640,\n                height: 528\n            }\n        }\n    },\n    computed: {\n        // TODO \n        bonusNum() {\n            var nums = this.lotterynum.lotterynums.split(',')\n            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1])\n            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')'\n        },\n        single() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'\n            }\n        },\n        double() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        zero() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        one() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        two() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        three() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        four() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        five() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        six() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        seven() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        eight() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        nine() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        big() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'\n            }\n        },\n        small() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        formula() {\n            return {\n                width: 210 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                // height: 83 * this.zoomRate.y + 'px',\n                fontSize: 42 * this.zoomRate.x + 'px',\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'\n            }\n        },\n        // TODO \n        bonudnum() {\n            return {\n                width: 68 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                fontSize: 40 * this.zoomRate.x + 'px',\n                height: 68 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        bet(event) {\n            console.log('Height' + event.target.offsetHeight)\n            console.log('Width' + event.target.offsetWidth)\n            console.log(event)\n        },\n        // \n        dobet(num) {\n            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return\n            if (this.countDown < 10) return // 10\n            if (Object.prototype.toString.call(num) === '[object Number]') {\n                this.userBet.type = 'NUMBER'\n                this.userBet.betnum = num\n            } else if (Object.prototype.toString.call(num) === '[object String]') {\n                switch (num) {\n                    case 'single':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'double':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'big':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    case 'small':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    default:\n                        break\n                }\n            }\n            this.bets.push(Object.assign({}, this.userBet))\n        }\n    },\n    events: {\n        cancelBet(event) {\n            this.bets = []\n        }\n    }\n}\n</script>\n<style>\n.playpanel {\n    /*background: url(../assets///.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(../assets///-.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABJCAYAAACesWDiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4NzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4ODNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTg1M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTg2M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Uv2HIAAABDxJREFUeNrsnLGOFDEMhuPM6BDFFbRX8wR0xyvwKDwPj8JrUCNETUd1BTppJyGZtXP/eDPL5ITAIEfKJuzMLcmX3453FQ99+JxDKeuLl215f/+WYnm5cRS75SaWl1vnsFtuK6AXzmG3vJh77/549zpMRGudS43cj9Cncl/klri1VKpTzTmvbeJ2KW3iKv0T92t9+fHrxed0AQmYKcY+JIHDfYFkClCFUsaUuF9h1DELnMhwysVAKe1+zi6gCmdmKFgRFKonGgMkqmmgRDW8oAvft466zDXvQOoCQjBzT0UMZmIo0aKJMZQy0LNieJyiHuIaCpg1xinX8lFAUUwM/BCqBxWEcKyYWVUNQkLTaqoBkNIuIyYWFZyeiUVlXmRIPWJmAofApBZ1b+Y5LyMKmjo7l/gmkWsEcyNLgLjWsYnPEX+5sK+ReyYGlHbUvwsodkxK4CC4CKZlAVKG700Z4ZxtrznkSZw57MpDu1hU7UW/Y2JWdrLEviZpQAxJNpfM/QTvHQJEoCJCtfSqChQtKEjMhhiSVpdUwpgu5zETk0lj1NyDYzGaxvgn8FavASVQj4hgTEHgW5opyfvS11u9AUirMiA4jAxJnHZmVUlMtMKBXe4YINiVNhDA5Mjo9zGSbR63eFZ7hsUVeMRwaFRBBE44dPwLQiFDwWIWNTAkUv6FOr6WrvigeGhVQFEXgaGxSJp2xhbVHI6OdX6OhLutkWhadidRkphVfubYYvDigByQA3JADsgBOSAH5MUBOSAH5IAckANyQA7IiwNyQA7IATkgB+SAHJADcgQOyAE5IAfkgP7ZMnw+KHfa9fwNn+aykNvZUhF2xvzbFSR5V3hCtP2HfA0HZgYOjC2pORwd67ynEsmxynBULXfuwaO2ZAUSLipA6s1hnaO659eAeOLtA+RIbXg6RiunSTdHbY0cAw4q07AtNtekr19Z2F0FSaZewJSi8HQIMvFA8KgtXVmJv6WgxEl0Mqek3QRcPwyo0ZYENEgp2uQ9dI7amlAQugmBpKrksKLCxhQkeZ7c3xyhVfeKp49GdrGWzIIq6kFSwA4DEtVgexYMO+SwzcnCncJUOpRSkOSsLqov7ZCJJfWHa6ZeTUaLsTnBHDo5WVZ8UM/EeA4JUsFRUUOAFlaDJHpIuuKajMam1BJDxCUZAtQzsUW1GtSYidU/DGGTw7DmYik/JQ68maCxSBohLQrSSf17SEEnmbQCFOBrxQR+qqU8GlKRLNwiDjmE7hMXTqMKak8kWGmlc9DIQBKkZ2L8Y/rBAqAgVNKiIE0jJkbskLNyfJtcK0hGM/loCgh4EzjsCxWVuS6jgMQhB6We9nATMK1r+VZWoukjDzc5bGL4FJTMO9jyn/7eM8HG4z+Y+S+KDuiPFwqv7u9K+6bUO8exKd9K/VSd9GOp353HRalMHiugh1K/BH/Ymy5VOA8/BRgA3V2MtlWnR+sAAAAASUVORK5CYII="

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],
	    data: function data() {
	        return {
	            tablePanelImg: __webpack_require__(82),
	            chipImg: __webpack_require__(83),
	            imgSize: {
	                width: 640,
	                height: 528
	            }
	        };
	    },
	
	    computed: {
	        bonusNum: function bonusNum() {
	            var nums = this.lotterynum.lotterynums.split(',');
	            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1]);
	            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')';
	        },
	        single: function single() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'
	            };
	        },
	        double: function double() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        zero: function zero() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        one: function one() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        two: function two() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        three: function three() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        four: function four() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        five: function five() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        six: function six() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        seven: function seven() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        eight: function eight() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        nine: function nine() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        big: function big() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'
	            };
	        },
	        small: function small() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        formula: function formula() {
	            return {
	                width: 210 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	
	                fontSize: 42 * this.zoomRate.x + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'
	            };
	        },
	        bonudnum: function bonudnum() {
	            return {
	                width: 68 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	                fontSize: 40 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        bet: function bet(event) {
	            console.log('Height' + event.target.offsetHeight);
	            console.log('Width' + event.target.offsetWidth);
	            console.log(event);
	        },
	        dobet: function dobet(num) {
	            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return;
	            if (this.countDown < 10) return;
	            if (Object.prototype.toString.call(num) === '[object Number]') {
	                this.userBet.type = 'NUMBER';
	                this.userBet.betnum = num;
	            } else if (Object.prototype.toString.call(num) === '[object String]') {
	                switch (num) {
	                    case 'single':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'double':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'big':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'small':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    default:
	                        break;
	                }
	            }
	            this.bets.push((0, _assign2.default)({}, this.userBet));
	        }
	    },
	    events: {
	        cancelBet: function cancelBet(event) {
	            this.bets = [];
	        }
	    }
	};

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAIQCAYAAAARq99gAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4MzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4NDNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTgxM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTgyM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+vclhJQAAXSNJREFU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"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAlCAYAAAAqXEs9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5NzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDk5ODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQkE2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTk2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EVwcGQAADetJREFU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"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "<div class=\"playpanel\"><div class=\"table-panel\" v-el:panel=\"v-el:panel\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"><div class=\"num single\" v-bind:style=\"single\" @touchend=\"dobet('single')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'single' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num double\" v-bind:style=\"double\" @touchend=\"dobet('double')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'double' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num zero\" v-bind:style=\"zero\" @touchend=\"dobet(0)\"><img class=\"chip\" v-for=\"item in bets|filterBy 0 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num one\" v-bind:style=\"one\" @touchend=\"dobet(1)\"><img class=\"chip\" v-for=\"item in bets|filterBy 1 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num two\" v-bind:style=\"two\" @touchend=\"dobet(2)\"><img class=\"chip\" v-for=\"item in bets|filterBy 2 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num three\" v-bind:style=\"three\" @touchend=\"dobet(3)\"><img class=\"chip\" v-for=\"item in bets|filterBy 3 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num four\" v-bind:style=\"four\" @touchend=\"dobet(4)\"><img class=\"chip\" v-for=\"item in bets|filterBy 4 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num five\" v-bind:style=\"five\" @touchend=\"dobet(5)\"><img class=\"chip\" v-for=\"item in bets|filterBy 5 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num six\" v-bind:style=\"six\" @touchend=\"dobet(6)\"><img class=\"chip\" v-for=\"item in bets|filterBy 6 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num seven\" v-bind:style=\"seven\" @touchend=\"dobet(7)\"><img class=\"chip\" v-for=\"item in bets|filterBy 7 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num eight\" v-bind:style=\"eight\" @touchend=\"dobet(8)\"><img class=\"chip\" v-for=\"item in bets|filterBy 8 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num nine\" v-bind:style=\"nine\" @touchend=\"dobet(9)\"><img class=\"chip\" v-for=\"item in bets|filterBy 9 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num big\" v-bind:style=\"big\" @touchend=\"dobet('big')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'big' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num small\" v-bind:style=\"small\" @touchend=\"dobet('small')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'small' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num formula\" v-bind:style=\"formula\" v-html=\"bonusNum\"> </div><div class=\"num bonudnum\" v-bind:style=\"bonudnum\"><table><tr><td v-html=\"userBet.betnum\"></td></tr></table></div></div><img v-bind:src=\"tablePanelImg\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"/></div>";

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(86)
	__vue_script__ = __webpack_require__(91)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\State.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(93)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0ce74191/State.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(87);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(" + __webpack_require__(88) + ") 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets///1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(" + __webpack_require__(89) + ") 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(" + __webpack_require__(90) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets///.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n", "", {"version":3,"sources":["/./src/components/State.vue?46a91f68"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;IACA,gBAAA;IACA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,4DAAA;IACA,yBAAA;CACA;;AAEA;IACA,2EAAA;IACA,YAAA;IACA,aAAA;IACA;+BACA;IACA,aAAA;CACA;;AAEA;IACA,kDAAA;IACA,6BAAA;IACA,yBAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;IACA,YAAA;CACA;;AAEA;IACA,sBAAA;CACA;;;AAGA;;GAEA;;AAEA;IACA,oDAAA;IACA,6BAAA;IACA,iCAAA;CACA;;AAEA;IACA,YAAA;IACA,iBAAA;CACA;;AAEA;IACA,aAAA;IACA,+CAAA;IACA,iBAAA;CACA","file":"State.vue","sourcesContent":["<template lang=\"pug\">\n    //-  \n    div.state\n        div.state-item.money.table\n            div.money-state.table-cell\n                div.button\n                    table\n                        tr\n                            td\n                                span.money-num(contenteditable=\"true\",@keyup=\"checkData\",@blur=\"changeData\",v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\",v-html=\"userBet.betmoney\")\n        div.state-item.portrait\n            div.polygon(@touchend=\"showMessage\",v-bind:style=\"headstyle\")\n                svg(xmlns=\"http://www.w3.org/2000/svg\",version=\"1.1\",v-bind:width=\"headsize.width+'px'\",v-bind:height=\"headsize.height+'px'\")\n                    defs\n                        pattern(id=\"image\",x=\"0\",y=\"0\",patternUnits=\"userSpaceOnUse\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                            image(v-el:image,x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                    polygon(v-bind:points=\"headborder\",fill=\"url(#image)\")\n                    image(x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\",v-bind:xlink:href=\"headborderimg\")\n        div.state-item.stars.table\n            div.money-state.table-cell\n                div.button.undo(@click=\"cancelbet\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userBet', 'userinfo'],\n    ready() {\n        console.log(this.zoomRate)\n        console.log(this.$els.image)\n    },\n    data() {\n        return {\n            headzoom: 1.2,\n            headborderimg: require('../assets///1.png')\n        }\n    },\n    watch: {\n        'userinfo.headimgurl': function(newval) {\n            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval)\n        }\n    },\n    computed: {\n        headsize() {\n            return {\n                width: 142 * this.headzoom * this.zoomRate.x,\n                height: 165 * this.headzoom * this.zoomRate.y\n            }\n        },\n        headborder() {\n            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y\n        },\n        headstyle() {\n            return {\n                // width: 640 / 3 * this.zoomRate.x + 'px',\n                // height: 640 / 3 * this.zoomRate.y + 'px',\n                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' //\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ')'\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ',' + this.headsize.height / (1008 * 0.17) + ')'\n            }\n        }\n    },\n    methods: {\n        showMessage() {\n            this.$dispatch('showMessage', 5) // 5\n        },\n        cancelbet() {\n            this.$dispatch('cancelbet')\n        },\n        checkData(event) {\n            // console.log(/\\d+/.test(event.target.innerHTML))\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 // 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        },\n        changeData(event) {\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 // 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        }\n    }\n}\n</script>\n<style>\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(../assets/th.jpg) 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets///1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(./../assets///.png) 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(./../assets///.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets///.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGMjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkI2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkI3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0Y1lLQAAHf9JREFU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"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCNDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNkNBNkJCNTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkIyM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkIzM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++LpzqQAAEvFJREFU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"

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userBet', 'userinfo'],
	    ready: function ready() {
	        console.log(this.zoomRate);
	        console.log(this.$els.image);
	    },
	    data: function data() {
	        return {
	            headzoom: 1.2,
	            headborderimg: __webpack_require__(92)
	        };
	    },
	
	    watch: {
	        'userinfo.headimgurl': function userinfoHeadimgurl(newval) {
	            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval);
	        }
	    },
	    computed: {
	        headsize: function headsize() {
	            return {
	                width: 142 * this.headzoom * this.zoomRate.x,
	                height: 165 * this.headzoom * this.zoomRate.y
	            };
	        },
	        headborder: function headborder() {
	            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y;
	        },
	        headstyle: function headstyle() {
	            return {
	                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' };
	        }
	    },
	    methods: {
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        cancelbet: function cancelbet() {
	            this.$dispatch('cancelbet');
	        },
	        checkData: function checkData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        },
	        changeData: function changeData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        }
	    }
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "<div class=\"state\"><div class=\"state-item money table\"><div class=\"money-state table-cell\"><div class=\"button\"><table><tr><td><span class=\"money-num\" contenteditable=\"true\" @keyup=\"checkData\" @blur=\"changeData\" v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\" v-html=\"userBet.betmoney\"></span></td></tr></table></div></div></div><div class=\"state-item portrait\"><div class=\"polygon\" @touchend=\"showMessage\" v-bind:style=\"headstyle\"><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" v-bind:width=\"headsize.width+'px'\" v-bind:height=\"headsize.height+'px'\"><defs><pattern id=\"image\" x=\"0\" y=\"0\" patternUnits=\"userSpaceOnUse\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"><image v-el:image=\"v-el:image\" x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"></image></pattern></defs><polygon v-bind:points=\"headborder\" fill=\"url(#image)\"></polygon><image x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\" v-bind:xlink:href=\"headborderimg\"></image></svg></div></div><div class=\"state-item stars table\"><div class=\"money-state table-cell\"><div class=\"button undo\" @click=\"cancelbet\"></div></div></div></div>";

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(95)
	__vue_script__ = __webpack_require__(97)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetMultiple.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(98)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-8ff4067e/BetMultiple.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(96);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n", "", {"version":3,"sources":["/./src/components/BetMultiple.vue?3803979b"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA;IACA,iCAAA;IACA,YAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,aAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,gBAAA;IACA,gBAAA;IACA,eAAA;IACA,qBAAA;IACA,oEAAA;IACA,kBAAA;IACA,mBAAA;CACA","file":"BetMultiple.vue","sourcesContent":["<template lang=\"pug\">\n    //- \n    div.multiple\n        div.bet-button-area.one\n            div.table-cell\n                a.button 1X\n        div.bet-button-area.five\n            div.table-cell\n                a.button 5X\n        div.bet-button-area.ten\n            div.table-cell\n                a.button 10X\n</template>\n<script>\nexport default {\n    data() {\n        return {}\n    }\n}\n</script>\n<style>\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 97 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multiple\"><div class=\"bet-button-area one\"><div class=\"table-cell\"><a class=\"button\">1X</a></div></div><div class=\"bet-button-area five\"><div class=\"table-cell\"><a class=\"button\">5X</a></div></div><div class=\"bet-button-area ten\"><div class=\"table-cell\"><a class=\"button\">10X</a></div></div></div>";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(100)
	__vue_script__ = __webpack_require__(103)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\Message.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(160)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-33fdb807/Message.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(101);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(" + __webpack_require__(102) + ");\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n", "", {"version":3,"sources":["/./src/components/Message.vue?5d23d056"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,aAAA;IACA,mCAAA;IACA,0CAAA;IACA,OAAA;IACA,sBAAA;CACA;;AAEA;IACA,iCAAA;IAAA,yBAAA;CACA;;AAEA;;IAEA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,sBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA","file":"Message.vue","sourcesContent":["<template lang=\"pug\">\n    div.model(v-show='dialogShow',transition=\"message\")\n        div.dialog(v-bind:style=\"dialog\")\n            div.close(v-bind:style=\"close\",@touchend=\"dialogShow = false\")\n            div.content(v-bind:style=\"content\")\n            div(v-bind:is=\"dialogImg[currentIndex].type\",v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\")\n            img(v-bind:src=\"dialogImg[currentIndex].background\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo'],\n    data() {\n        return {\n            dialogShow: false,\n            currentIndex: 0,\n            dialogImg: [{\n                type: 'betInfo',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'bonusRecord',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'ruleIntroduce',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }, {\n                type: 'recharge',\n                background: require('../assets///.png'),\n                close: require('../assets///.png')\n            }]\n        }\n    },\n    computed: {\n        dialog() {\n            return {\n                width: 550 * this.zoomRate.x + 'px',\n                height: 760 * this.zoomRate.y + 'px',\n                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'\n            }\n        },\n        content() {\n            return {\n                width: 478 * this.zoomRate.x + 'px',\n                height: 618 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\n            }\n        },\n        close() {\n            return {\n                width: 42 * this.zoomRate.x + 'px',\n                height: 42 * this.zoomRate.y + 'px',\n                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',\n                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'\n            }\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.dialogShow = true\n            this.currentIndex = event\n        }\n    },\n    components: {\n        betInfo: require('./messageComponent/betInfo.vue'),\n        bonusRecord: require('./messageComponent/bonusRecord.vue'),\n        exchange: require('./messageComponent/Exchange.vue'),\n        Recharge: require('./messageComponent/Recharge.vue'),\n        ruleIntroduce: require('./messageComponent/ruleIntroduce.vue')\n    }\n}\n</script>\n<style>\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(../assets//.png);\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZEQzMwRDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZEQzMwRTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkRDMzBCM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkRDMzBDM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+X2ymawAAAA9JREFUeNpiYGBgmAkQYAAAngCaoMXLCwAAAABJRU5ErkJggg=="

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    data: function data() {
	        return {
	            dialogShow: false,
	            currentIndex: 0,
	            dialogImg: [{
	                type: 'betInfo',
	                background: __webpack_require__(104),
	                close: __webpack_require__(105)
	            }, {
	                type: 'bonusRecord',
	                background: __webpack_require__(106),
	                close: __webpack_require__(107)
	            }, {
	                type: 'ruleIntroduce',
	                background: __webpack_require__(108),
	                close: __webpack_require__(109)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(110),
	                close: __webpack_require__(111)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(112),
	                close: __webpack_require__(113)
	            }, {
	                type: 'recharge',
	                background: __webpack_require__(114),
	                close: __webpack_require__(115)
	            }]
	        };
	    },
	
	    computed: {
	        dialog: function dialog() {
	            return {
	                width: 550 * this.zoomRate.x + 'px',
	                height: 760 * this.zoomRate.y + 'px',
	                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        close: function close() {
	            return {
	                width: 42 * this.zoomRate.x + 'px',
	                height: 42 * this.zoomRate.y + 'px',
	                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',
	                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'
	            };
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.dialogShow = true;
	            this.currentIndex = event;
	        }
	    },
	    components: {
	        betInfo: __webpack_require__(116),
	        bonusRecord: __webpack_require__(122),
	        exchange: __webpack_require__(128),
	        Recharge: __webpack_require__(140),
	        ruleIntroduce: __webpack_require__(154)
	    }
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMDVDNDY0MjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMDVDNDY0MzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAwNUM0NjQxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Ii2N+QAAGLNJREFUeNrs3QtsXfV9wPG/n3HsBFgSVlh4dUBR2MLQIBVUiBZaJlJVtBsqKxq066oKWB9ap02aqgl164Q2TYNJBQn2VEc7ujKmlTHoylZaVA1UYCphDQXKKI8MKCRQHDv2tX2987vY2fG55z78uOYGfz7SX5Bzr6+dY0fn63P+5397ZnfdmZagNxs7snFeNs7MxtuysTUbI9lYlwCAtWIyG2PZ2JONx7PxYDbuycYD2ag2/KjtO0s39y/ykx+TjU9k49eycazvBQCseevmxqbIjWxcPLf92Wx8ORs3ZOO5dl+st83nbZ574Sez8XuiBABo4di5ZnhyriE2r1SYXJKNH2TjN7MxaD8DAIswONcQ0RK/2urJ/S0e+0I2rix7sPqT11Jl9xNpes/zaeblfak6uj+lqek0Oz3tWwAAa0RPf5YLA/2pd+OG1LdlU+rfenQaPPXk1Hv4YcWnbsnGV7Lxrmx8KhulwdDTYPLrcDb+IRvvKz4wveeFVNm1O0088D3fDQCg1NCO09PgaadmoXJU2cN3pDh7sn3neDthEmdKbsvGRcUHxu++N03c96C9DQC0Fyhnn5mGLzi37KHbU0yU3b5zuhghRdcXo2T6mT1p7Ov3pJkXfmwPAwBtixMaU089nUYuPD/1H7c1/9BFc82xYMpIcfJrTEq5Ir9h6skfpdFb/lmUAABLMvPCS7WWiKYouCI9cteljcJk81y5HDT99HNp/213ptnJSXsVAFiyaIloimiLguuzODmyLEz+KL0+Y/agsX+7J81OTNibAMDy4yRripgaUhALs32+GCbHZeNj+WfFRNc49QIAsFJmXnwpjX/j28XNv5Eeueu4fJhclY2B+UdjbRJ33wAAnTBx/0O11sgZmGuRWpjEuCz/6OTDu+01AKBjSlrjsvTIXb3z7xJ8zPzW6quvpckHH7bHAIDOhUnWGtEcOdEiOyJMzs9vrTz6hL0FAHRcSXOcF2FyRn5L4ZoPAEBHlDTHmREmp+S3xBvyAQB0WklznBJhcnR+S3X/mD0FAHRcSXMcHWGyMb9ldrJiTwEAHVfSHBsjTAYXbJqZsacAgM6rb47BXnsFAOgWwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAndZvF0CH/5FtPyOtv/SjB/8888xTafzGP6v9f88Rm1P/qact+bVn9jybqk//sO7z9Ww87OCfZ0dfS9OPPNT+byvHn5T6th67YNv07l1p9tW9i/67ljlwy9/Wvp51v3JZGjzzrGXv3/nXm7dSr9vW/s99LwFhAoeEiISBk08p/weYRcnGz3x2ya89fvttaeLmhWESYZD/fLMHDqRXPnxRy/iYN3jWuWnd2efUfZ6ZJx8rfX4+Wpr9XedNzEVTz8iGls9tx0QuwlbydQFhAm8K8Rt7HBzn9R35lgWP923ekoYuvzILihs78vmnHv3vBQfmnvXrayGSP7MyeO570vBFF7f9ms2eO3rdNWnqP+/xjQeECXSjuIzQ7Df23k2bawf6ToVJ9cXn6/+hn/JzqVK45PNmFWd24gxPJwyd867a9w8QJrBmTO95Ns2Oj5f/gz3muNoZkKYf/9j36z/uZ09KldWIguxrbxUF8ZylBkQ7YRBnbzp1Bmdg288LExAmsLYc+OrNDQ+sG6+5vuX8ibhkE/NK8gEz9O4LU8/whtS75cjanyfuuK1hFMTBt/g5Ju/7Tpp56cWmoTH/uYtzXlYyINoJg4F3nJf6TuzMHJO4DAcIEzikxJ0aeT3Dw6m/MNG0U5ca5k0/90xdXOQntI42i4LLr6z72Mr99x4y80giShYzfwYQJvCmVrx9NH6DL95506n5JfOKE2ABhAnQUNyVU7n33zv2+pP/cmvpJZlOa7YuS9maK50Q+7XRrc3Ltf6Sy+vOfgHCBA55calhJQ6e/ce/te5W4BDriox+9pPLXsBt0V9Pk3VZytZcWazZ8bGWz4l90akAGnqfS0QgTOAQ13vU1oYHubIzGrFSa7sGf+EX0/TT7zl4wI9IGbnitxY8Jy7rdPrS0VIsJZp6hkda7+8mi8ct+2seHq77c6x2u5iVdQFhAm+ogVO3L+r5zQ5yrc4YxJmC4i3FcfDsxjBZ7qq3DWNtkYvHLevvkAVQrLQ7Kkxg5X6Zswugg//Ast/e46xGUVzWqL78Ut32qSeaX96Z+NpXU3Vf8/esmXr80bqDZ3wdqyHO9sTfYTp3C3Gnzazi5wJWIfjtAuic+O29NDBuvrF2t05+bZDZsf2p8s27mr5enE159YoPLXijvuKBefrpp+piKL6O/PyOZm+2V7ZWR0z6bDS/Iv8mevHfOHtQdidSJ0SkVdfIirYgTIDlh8kZb2/4WNl6GyOXfmTRnyPeqyZ/cJ7+3gMpFV53/QXvrd2lczCM7rhtUXfsNLsTpfgmessRC8PFGixtPXd8rHYGqSz6FnPpatOtdy/4c5zxiYnDgDCBN5W4fPJG3FoaZy2KK7/G/+dDZKJL91lEyXKjICbVbvzcn9bt+/1/eX2qfONry3rteIPGeC+kvMqD96fJf/qSH3gQJtDdGl3GWQ0xz6RsbstaELdK77/umnT4569dEGcbPp4Fz8f/P3pavStyWYQUzzLFXJpWl98AYQJdId5wblUOxCW3F8cljoG3bWv4hn/Tu3fVDsylQXXWuQuWrw8xWbfRuivxWt0mLm3tv/G6Zc1z6RnZ0PJy1/hf31ALIUCYQFeLyZ+t3mwu5kHEKqVla27EwT5/wIvf3svmn4zd8sXS24tj2ysfvqj2dTQ6q9DobEHZG+BFlBwq75UzL77esaO2puEPXNLyHZmXImLN+iUgTKDrtfMOwAcD4SevpPXZb/XF+RBxiWD0c79bC4hmUdJqbkMcnOPrKdu+FsT+iVG26FqrMz3NlraPs1SiBIQJHJLiLo9GoVJbOj4LkOJkzfj/2FZ56Luli4XFb+vtTLiM24LL5kWsNRElxTNBcZv1Yi/DFM9kAcIEDr3f2r91d9MzKM3ipOyunsn7vtP27bD9p++oP7j+4Ptrav/HXTobrvzMgss5EYut9mHETHGOyuvv93OjH2roICu/wgqLBcdiYmmMV3/nqrZuUZ2Pk1ZnMyJKxq79g7a/lvzaJQfD5H/W1oJk6z/063VzTMZu+vOWHxeXu4or8cZ6MBE6gDCBQ0bMPagd1LKxmFVJW8VJ5eH/WlSUxAG07EzN1He/s2a+F3Epa+jdFy7YVns7gDa/L7EQ3YJ9mgVOhA4gTGBN6Dv2hNS3aUvpY3H7bxxo2zXw9nPqo2kJ8ypWU9n7By0lRuJupMFfen8a/tgnFr7+vr11l2JiMbpGIi7jLFVehE6ju52AFfiFwi6AlTd0+ZUtnxN328RaGXm1SwUNbm2N7Ydd/ce1A2X+PXaKt/LGXTixXHuETF2YzM0vKS7D3kptrkWDNUHaXcI9vyx+o+fH+imDf3f7om7vLS6UFu8B1GhOz9gXb3o92rKwmJ8M2+pzHbjty3XrusT+qH7kitot4fs+eIEfeBAm0N3K7qQpilVFW91WXHZHT9niZ/kDc7PXnPnxi2/YPikui9/seZ0QQTe/n8rep2heRF1eXPaJjy3u91br1ABL41IOrLLihMpGIjjizEK8x0uzyw3titdYreXTy1ajrYukVbxtOS7hxJmPtr4/ux+p2xYfuxLfA6A1Z0xgFcUE1rJ3xM2LeSCT937z4DolcVdP9fnn0tD7L0k9wyP1ETC2v+XnjdfML5/ebhy1Y+aZp+o/3yMPlZ5lKJ6JmPiPr6d173jnip4laeeyUlz+ivAr2162+Fx8ra9++qOp/9TT/BBDh/XM7rpzNr9h3x9ea68AAKti09W/veDPLuUAAF1DmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAArJD+bv8CZ7OxrzJVG6NTM6lSrda2AQCt9fX0pMHenjTS35c2DQ7URo8wWZqIkafHJ9LETNVPFgAswczsbDowE6OaXp6cSkN9ven44aFaoHSjrryUE2dEIkgeGx0XJQCwguK4GsfXOM524xWIrgyTZ7Kd9b8HJv30AECHxHE2jrfCpIW9lSlRAgCrFCdx3BUmDcQppR+NTfhJAYBVEsfdbrqk01VhsndyqnbXDQCwOuK4G5NihUmJfV12OgkA1oJXKsKk1P7pGT8dALCGj79dFSZTsy7jAMBq66ZpFF0VJlVLugLAqjP5FQBAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhYhcAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCpAv09fT4jgDAKuumo29XhclArzABgNU22Ns9OdBVYTLS1+enAwBW2Yb+7jn+dlWYbBoc8NMBAKvsp7ro+NtVYbJ53UBXnU4CgDe7OO5uFiblYobJCSNDfkoAYJXEcbebpnh23emJqLafWb/OTwoAdFgcbzd32TSKrrxuctzwUDpqaNBPDAB0SBxn43jbbfq7cWfFGaW3jqxPhw30p2fGJ9LETNVPEACsgKG+3lqQbO7SG076u3nnxU6LO3X2Tk6lfZWptH96JlWq1TTr5woA2v5lPya4xi3BcUyNG026edWw/kNhh27JdmIMAODNzb25AIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAoD5MKgu29PXZKwBA59U3RyXCZDS/pWfdoB0FAHRcSXOMRpg8n9/Su2HEngIAOq6kOZ6PMHksv6VvyyZ7CgDouJLmeCzC5KH8lv6tR9lTAEDH9W89urjpwQiTe/JbBre9zZ4CADpucNvJxU33RJh8NxvPzW/pPeKwNLTjdHsLAOiYaI1ojpxokQciTKrZ+NKCgjntVHsMAOiYktb4Utq+szq/wNoNKbeeScwzGTr7THsNAFhx0RiFOa2VuRY5uPJrnD75q/wzhi84N/W95Uh7DwBYMX0/vaXWGAV/k7bvfC4fJuHqbOzNP2vkwvNSz9CQvQgALFs0xcjO84uboz1+f/4PvYUHPpl/Zv/xx6QNF7839QwO2JsAwNKjZN1grSmiLQo+nbbv3FsWJuEr2bgpv2HgxBPSxkt/2WUdAGBJoiE2fugDtaYo+IssSv5+QcDM7rqz+KRYuP7WbFxUfGD87m+nifsesocBgLYMnX1GGr7gnWUP3Z6ND2ZhUmkVJmE4G/+YjZ3FB6b3vJAqu3aniQe+Z28DAOVBsuP02i3BDVaU/9dsXJJFyXjxgUZhEmJiyReycUXZg9VXf5Iqj/4wC5Xn08zL+1J1dH+ancyip1r13QCAtaK3tzZ/pHfjhtp738Qy84PbTkq9Rxze6CNiysinsiiZKnuwv8mnig+4MhvfmguULQu+juwTxukZAIA2vJxiomtKtzTtnDZeKCbEbsvGjSm3CBsAQBsqcw2xrVWUtBsm85VzVTZOzMafZGOP/QwANLFnrhlOnGuIl9v5oGZzTFoFzY5sxCopcT0n3pI4bkzekF6fmwIArA0x9WN/en0V+cezEbfvfjMbD6TX34+v3PadpZv/T4ABAMFnY+3Ft1qIAAAAAElFTkSuQmCC"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMxRDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMxRTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQ0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzFDM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MfthnAAABlJJREFU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"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyNjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzIzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzI0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+M8ZK3gAAF+xJREFU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TAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMLnwv0xbm38RAJhjLS0twqRI27wOnw4AmOvjb3vzHH+bKkzmL1jo0wEAc6xzYbcwKdK1ZKlPBwBcwsffpgqT7t5laV67yzkAMFfiuNvd2ydMisTkm2Vr1/uUAMAcieNuS0vz5EDT3S4c1da78jKfFABosDjeNtPZkqYMk9C35orUs3y1TwwANEjP8lWl422zmdeUe6ulJS2/fH1asGhxOrB7Zxo9OewTBAB10D6/M/Vdti51L+lryt9vXjPvvNhpXT1L09FDA+nY4YPp5PGj6dToSBobG/PJAoCa/q/fUprgOn9hd+num7jRpJkWVLuowqS8QxctXV4aAMBHm2flAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAgIlhMlK5oa21xV4BABquoDlGIkyGKrd0tDmJAgA0XkFzDMWW/sotXfPb7SkAoOEKmqM/wuStyi1LuzrsKQCg4Qqa460Ik5cqt6zqWWBPAQANt7pnYX7TixEm2yq3bFjRY08BAA13zYrF+U3bIkyez8au8pbFC9rTTZcvtbcAgIaJ1ojmqBAt8kKEyZlsPF75yg2rl9hjAEDDFLTG45vXpzPl+3S+kSrWM4l5JhvXLbPXAIC6i8bIzWkdOdci51d+jdMnf1v5jk9vWJmWL+q09wCAulnW3VlqjJy/37z+7LSSypVN/iwbByrftena1amzvc1eBABmLZrijutW5TdHe/xJ+YvW3At/UPnOtb0L069+cm1qtxosADALHfNaS02xtrcr/9JXN6//8MRIyxPvjOXf8M1s3Fe5Ydeh42nbW/1p/9CwPQsATMvy7s606brVpRMeOY9lUTKuOYrCJJZh++ds3J1/4btv700v7TxgDwMANbllXV/6pQ2ril56Ohu/mYXJyFRhEiJpnsrGnfkX9g6eSK/3H06vvH/Q3gYACsU6JXFLcJUV5Z/Jxj1ZlBzPv1AtTEKsevJIyl3WKRs8MZJ+8sFQ6h88ng4eG0lHT46mkVNn0pmxMf8aAHCJaG1pKc0f6Z7fXnr2TSwz/7EVi1LPgqrP3ns0Gw9kUTJa9OJkYVK2+VygWNgEAJipgWx8NRtPlOJifZXQqeEHbcnG9enspNgR+xUAmIaRcw1xfTlKJlPrfcBROfdn4+psfD0bu+1nAGASu881w9XnGmKglm+q5VJOtaC5NRt3ZOOWbGzIxtpsdKezc1MAgEtDzBU5ms6uIv92Nl7Kxn9l44V09nl8hapdyvl/AQYAVOAKyrWfc2EAAAAASUVORK5CYII="

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyQ0I2ODYzNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyQ0I2ODYzNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJDQjY4NjMyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJDQjY4NjMzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IMkNPQAABoZJREFU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"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNkE4MjEwNjNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozQzNFNkNCQTNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM2QTgyMTA0M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM2QTgyMTA1M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jGVjpAAAGdJJREFU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TAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTGwCAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwsQmAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABg1YZJ1/Sk3wgArLTpaWFSaeqINwcArLCuDtr/dlSYdB/9qXcHAKz4/veQMKnSM/6idwcArOL9b0eFSe/4gdQ1NeEdAgArJPa7sf8VJlWmp1PfyG7vEgBYITP7XYNfG+sZfyGtGXvWOwUA2iz2t7Hf7SQdOY/JmtHh1PvT57xjAKBNYj8b+9uO+746c3PFKZ2nUs/ESJpYtyVN9/R7BwHAMuiaHE99o3s67khJh4fJrNhoL5t4MR3tH0yT/aelqd6BLFL6YrN6ZwFAi3/sd01OpO6jYzNX38wMdO2gMSUnVJjMbs/p1Ht4/8wCAJzc3CsHABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAA1IfJRHFNj60CAKxAhdQ1x0SEyUjxSf02FACwAmFS1xwjESbPFFb1rbOhAID2q2+OZyJMHiusWrvRhgIA2q++OR6LMHmgsGrduTYUANB+6zaX1+yMMPlmYdXgpTYUANB+g5eU13wzwuS+bNkzv6p/Q0pnb7exAID2idaI5jgmWuT+CJOpbPls4clnDNlgAED71LfGZ9PQjqnaBGufSPn5TGKcyaarbTQAYPlFYxTHtE7Mtcj8zK9x+ORThU/a+rqUBs628QCA5TNw1mxjFH0mDe3Ykw+T8MFs2V942vlvSKl3rY0IABy/aIqfe2N5bbTHX9Q+6C498MeFp67fmtJFv5VST5+NCQAsXU//bFOcurX8yK1paMf+qjAJn8+WTxbWbLggpW1vcVoHAFiaOH2z7cbZpii6LYuSz+VXVN1d+NZs+XJhTRw5GXpnSpuusnEBgNZFOwz9wWxLFEVr3FJe2TX98B2VbZMtX8yWHXWPjD6d0r5dKe3daWMDANVinpK4JLh6RvmvZMuNaWjHWKthEtZky8ey5V2Vj46/mNKBx7JQGU7p8P6UJkZSmhxPaXrKLwMAVouu7tnxI33rZ+99E9PMD25Lqf+0Rp8RQ0ZuyaLkSNWDvU2+VHzCu7Pl7rlAOaPwaHxBp3YAgNbsS7PDRf6l2ZO6W3ihGBAbN9D5+5SfhA0AYGETcw1x6UJR0mqY1CrnPdlyYbb8VbYM284AQBPDc81w4VxD7Gvlk5qNMVkoaK7MltdmyxXZcnG2bMmWdWl2bAoAsDrE0I/RNDuL/A+y5YFs+Ua23J9m78dXbWhH5er/F2AAstWqWoT5nd4AAAAASUVORK5CYII="

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyMTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyMjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzFGM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzIwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++YKmbwAABkhJREFU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"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5ODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5OTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjk2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjk3M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MTGWBAAAFjdJREFU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CQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAEAEyWh+w6K2drMCALRMSWuMRpAMTLpRe7eZAgBaFyS1rTEQQXIov6Wte7mZAgBapqQ1DkWQPJPfsrj3EjMFALRMSWs8E0Hy0/yWjos2mykAoGVKWmNPBMkj+S1dl15tpgCAlilpjUciSP4zGweqWxb39KUlm28yWwBA00VjRGvkRIPsjiAZz8Z9+T3dG95kxgCApitpjPvSmu3j1QujfSHlrkfScdHrUs/W7WYNAGiaaItojJzRiQZ57Uqtcbjky/lb9L7+3al9xXqzBwDMWfvySyttUfDVtGb7gXyQhD/PxtH8rZZddXta1NFjFgGAWYuWWHbVjuLmaI4/q37TVtjxR/lbdvRtTSuu+1Ba1N5lNgGAmcdIe3elJTr6Lyvu+mRas/1oWZCEB7LxpfyGzouvTCt/6+PevgEAZqR9+bqsIe6qtETBvVmMfH1SuJw+9FDxRp3Z+EY23lHcMfjkt9PQc7vMMAAwpVjAWrJmJDyYjduyIBmdLkgq95ONb2bjbcUdJ1/+RRre/5N0Yt+jZhsAmCSuMxKn9hbOpqn6XjZuz8ZQFiSpkSAJHdn4XDY+Urbz1NDRNPLC41mg7EunBl9M48PH0/jYcErjp/w2AOB817Y4tbV3p7buFZXPponLwccVWAsXPcuLJSGfyMbJynczCJKq90yESb/ZBwBm6EiKBawp3T9payFI2hq4o1joekU2vphyF08DAJjC6EQ7XFETIyXaGrzTqJuPZWNLNv4mGwfNMwBQ4uBEK2yZaIcjjfyhRt6yqRcy12fjlmxcm41t2YjzgnvTmbUnAMD5LdaCDKYzV3t/Nhs/zcb3s7E7nfmcvKkV3rL5fwEGAEDIMmUyEQC5AAAAAElFTkSuQmCC"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5QzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5RDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlBM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjlCM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+uB+DYwAABmJJREFU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"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwNzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTA1M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTA2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+E7Z1owAAIPNJREFU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qHeP1TF2xxi+OYKk2cyvxtoqrlr3MSsxAgDrKEpm13TmY3Y2dscYXryeyYYNkrhr7/S1qfal4GdnRoQIAKy/MJmZKWmP2zGGx1i+4YPk6vjZ2eNT9Zp1IwCwnmOkYszOx/IVtuIXRpu8+F5rkUz7vjSte9PUdAgArMMuaXbuI5c6QVLPx/KVtuIzJNcvX25fAK7zxCqKDABY+xqZ+XP3uJ2P5Rs9SKavTZZCpFZ6CwCskyrpftsOk3ws3+hB0pxuzD65TpiYGQGAddokxbG6VhrLN3KQdO4oqEEAYIPFSStM8rF8owdJ9bMDANZ3iayuup0OAKy1VQwSMyMAsLGs3ththgQAWHOCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAB4PwVJ094GgA1l9cZuMyQAwJpbgyAxUwIA69vqj9UrHiS1WvYjmk0dAgAbsUuyMTwfyzd8kAzUZ59VJ0ya6gQA1meEFMfqZmks38BBMjA0UpohaZbeAgDrpEa637bDJB/LN3qQDG7bNlta5UM3ZkoAYJ20SLO7Swrjdj6Wb/QgGRndmT2fRrY1U+d/4glqEQBYh01SGK/zsTsbw2Ms3/BBsmX32GxlNZqF4mrOLTIAYI1KJHWP0YUxOx/LN3qQjNy0Kw0MDWdPqNHaGmIEANZ1lORjdWvcjjE8xvINHySpVkvbbz2QPadGtnWmf1pPtClMAGBdhEhxbM63GLOzsTvG8BjLN36QZEYPHkr5U2k0CltnLYkoAYC1j5H2zEhhrK61x/DVsCpBMrhla9q+77astKbbWyNfJGM9CQCsbYwUx+L8JJT8iEZrvN5+6235GL5pgiTs/sCRVKsPzFRXs73NHLoRJQCw6jEyc6imMy53ZkeyMXv34SOr9iutWpDUh4bT2D33p+b0dL6l2EpR0izXGgCwvCFSOExTjJE8RNpjdGxj99yXj92bLkjC9n0H0o44dDN9vRAm2Y6YbnTNnCRhAgArEiL5rEhhJiQfg/OxuBMj1/OxOpZarKbB1d4nNx95IE1PTqYr42c7eynbBvK3+c176rXsT+0b8tVqrYW9+U6s+Q8KABZfIzNNMhslrZNLOmtGZmZGrk+nrbv35GP1alv1IKnV6+mWBz+U3nn+B+nq+XP5fqpFuNWz/1PP/5BFSCtGYmvOnGrUXJXTjgBg87RIs/vPzcIZroU1I52ZkbgAWozRMVZv+iDJo2RgIO394GPp3Ms/TpdOn2jFRjNmRQZmZkZipiSfIYmZkbxDaoVJEmECAPOUSOFNs/2/s6f2zgbJ9EyQxGGam+99oHW0Yg0MrtWuiic8dvShtGXXWDr36oupcf16a4ak3jpskxrtt6k2OzNihgQAFtElhXUjafYKrM3GbJDU6wP5eLzaa0bWTZB0xELXLWN70vnXX0kTb59o1VpESRRa+7BNa0upe5ak/T4A0CmQ0h+bM3funbnERnvdSIygO269Le06fKR1i5c1Nrgedl/siLGjD6addx5OF4+/kS69fSo1rk21Q6Te6g6zJACwiDYpnrGaZi5IGqfyju4/mEYP3rlqFz3bMEEy88tkO2b33fel3YePpskL59PV8bNp8uJ76fqVy/mZOfmim+Q0YABYSL4Kc2AgDYxsSYNbt6WR0Z35otX8Rnnr8MX94Prci7U0snN3vgEAm1/dLgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBgPQTJVPGBoXrTXgEAVkxFa0xFkFwsPrJ9QJAAACunojUuRpCcKj4yNtKwpwCAFVPRGqciSF4uPnLHtuv2FACwYipa4+UIkh8UH3lg5zV7CgBYMQ/ObY2/iCD5VvGRT++9ak8BACvmU3Nb41sRJM9k2/HOI/u3Tqcnb79sbwEAyy4aI1qjIBrk+xEksbLkd4of+dz+K/YYALDsKhrjd9K+xxudC6P9dipcj+T+m66lLx6asNcAgGUTbRGNUTDVbpCZK7XGdMl/KX7Gl+65mO4edcYNAHDjDu+4nrdFyX9N+x4/XgyS8K+y7Wzxs379yIU0OuS6JADA0kVL/Pq9F8oPR3P8i8479dIHvlT8zEd2T6V//eB7aaurtwIAS7B9sJm3xId2T5U/9E/TvsfPVgVJ+Fq2/afiAx8bm0z/7pFxh28AgEW5e8f19G8/OJ63RMl/zmLkd4sP1Jqnvln+pOFs+x/Z9kT5A195dTR99dh2exgAmNevHJpIX567ZiR8Pdv+RhYkUwsFSdiWbf8z2z5X/sCLF4bSH53amp56a5u9DQB0ieuMxKm9pbNpOv4w276QbZezIEn9BEkYyravZNs/rPrgySsD6dvvbEkvvDeU3rw8mN6drKfL1+vpuuUmALDpDdZS2jbYSLeMNPJ708Tl4D+592o60H3Rs6JYEvLlbGuVyiKCpONvtcNkj90PACzSmRQLWFP6atejpSCp9/GNYqHrfdn2H1Ph4mkAAPOYarfDfXNipEK9z28adfNr2XY4234z207YzwBAhRPtVjjcbocz/XxRP4dseoXMR7LtM9n2aLYdybaD2bYjtdaeAACbW6wFuZRaV3t/Jdt+kG1/km3fT6375M2vdMjm/wswAOFHcKYGBK+BAAAAAElFTkSuQmCC"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwMzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTAxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTAyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/IKTpgAABoJJREFU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"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFGNzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGODNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU1REU2MUY1M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUY2M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xBVG6wAADz5JREFUeNrs3U9sVVUewPHD62tLrXVaCppaamRqJCXOwiBuR91NYnRhojHjyiHB/2tjjBvduFYTHYkrZ3SSWU0y28GZpUjGhYKYICbQaYZ/VaCUvrYPz6+84u3lSl+lLyb4+SS/Bee+9iXnbb65vZy34f2Dl9LPUMuzK8+Dee7Lc3ee0Tz9eXoTAHCjm8szk2cyz9d5PsuzL8/+PM3Vfnj3xMp/19f45lvzPJ/nj3nGfBYA8KvV25pNeX6X57HW+rE8f8nzTp7j7f6yWpuvG2794iN5XhYjAMBPGGu1wpFWOwyvV5A8nuerPM/l6bHPAEAbelrtEA3xxGovrq9y7a08z1RdnJ1rpP+dmk7T52bSzOxcujg3nxaazdRsNn0EAHCDq9VqqZ5nY2936u/rTUMD/en2zUOpr/eqexeb83yc54E8L+ZZWEuQ3JTnb3keLl/4LgfIsRNn0rdTJ30aAPArFTcgGjELC+nszGyaOvVdOnh0Mt05siWN3bopDQ70l38kbnDEs6hxt+RCO0ESax9VxUi80ZHJ//sUAIBKccMiZnz0trRj22j58sOtxogHYFfcKal6huTtPI8UF86cPZ/+8/lXYgQAaEs0w7//e2ipIUoeabVGulaQxG2UPcWFk9Nn06cHj6Tvz1+wuwBA2+JPOdEQ0RIle/YeSk/+VJAMl4vl9Pfn04HDR9P8wqJdBQDWLBoiWiKaouTtHCVbqoLkjXT5SdgrvvjmmBgBAK47SqIpSuJAtdfLQXJHnj8VXxUPsMatFgCA6xVN8eXRqw5ufXrvoaUGuRIkz+bpXr4aZ4t4gBUAWE/fTJ5YaoyC7laDLAVJzFPFq8dPnLFrAMC6q2iMp/YeSrXlb+3durx64WLDoWcAQEdEY0RrFESD7Iogeai4OnV62m4BAB1T0RoPRpDsLK6U/rYDALCuKlrjvgiS7cWV+KI8AIBOqWiN7REkI8WVi415OwUAdExFa4xEkAwUVxYWHYQGAHRORWsMRJD0FFeazUt2CgDomIrW6KnZFgDglyZIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAEEHSWLFQ22BXAIDOxcfVrdGIIDlXXKl3ddkpAKBjKlrjXATJVHFlY0+3nQIAOqaiNaYiSA4XV/r7eu0UANAxFa1xOILkQHFlaKDfTgEAHVPRGp9FkOwrrowMD9kpAKBjKlpjXwTJp3mOL6/ctLEn3TmyxW4BAOsuGiNaoyAaZH8ESTPPh8UrY7dusmMAwLqraIwPd0+k5vLBaO+kwnkkgwP9aXz0NrsGAKybaIvBlc+PNFoNcuWk1rhdsrf4ih3bRtMt/X12DwC4btEU0RYlH+yeuPzYSPHo+NfynC6+6p7fjqXuuoPSAICfL1oimqIkmuPV5X/UShdeKL5y+Dc3p53bt6V6l6+8AQDWLk5ljZaIpih5affEjzdCyqXxcZ73igtbhm5J9++4y59vAIA1iXa4f8f4UkuU/DnHyF+LC1W3Pl7K84/iQlTN7++d8KArANCWaIZoh4o7I9EYL5YX6xW/I554fTLP3/P8oXghHka5ffNgOnbiTPp26qTdBgBWiHNG4r/2Dlaf/P7PVmM02gmScCHPo3neyrOneCHeYPm/BU+dnk7T52bSzOxcmp2bT4uLi6l56ZJPAwBucLUNG1JXV1fq6+1e+m6aOA4+TmAtHXpWFI+ExJ2R+aqL9Wu8V/zAM3k+aYXJ5uLFeEN/wgEAVnEqXX4c5KNrBk4bvygedJ3I826quMUCAFCh0WqHidVipN0gWa6bZ/OM53kzz6R9BgAqTLZaYbzVDqfa+aH6Gt8kTlN7Oc8reXbleSjPzjx359maJx6l7fZZAMANLx7tON9qg6/zHMjzrzz70+XvyVuTHwQYANsFYMWa99MrAAAAAElFTkSuQmCC"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4MDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4MTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjdFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjdGM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+o5CrmQAABp1JREFU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"

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(117)
	__vue_script__ = __webpack_require__(119)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\betInfo.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(121)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-e2a4ac6e/betInfo.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(118);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/betInfo.vue?7661e2a1"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;CACA","file":"betInfo.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.bet-info(v-bind:style=\"content\")\r\n\t\tdiv.record(v-for=\"item in betRecord\")\r\n\t\t\tp.created-time(v-html=\"item.createdAt\")\r\n\t\t\tp.detail\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.playlaw\")\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.betmoney\")\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.multiple\")\r\n\t\t\tp.bonus-num\r\n\t\t\t\tspan \r\n\t\t\t\tspan(v-html=\"item.num\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {},\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                betRecord: require('../../data/betRecord')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            betRecord: __webpack_require__(120)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in betRecord\"><p class=\"created-time\" v-html=\"item.createdAt\"></p><p class=\"detail\"><span></span><span v-html=\"item.playlaw\"></span><span></span><span v-html=\"item.betmoney\"></span><span></span><span v-html=\"item.multiple\"></span></p><p class=\"bonus-num\"><span></span><span v-html=\"item.num\"></span></p></div></div>";

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(123)
	__vue_script__ = __webpack_require__(125)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\bonusRecord.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(127)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-692cd0ba/bonusRecord.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(124);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/bonusRecord.vue?c765f018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,oBAAA;IACA,iBAAA;CACA","file":"bonusRecord.vue","sourcesContent":["<template lang=\"pug\">\r\n    div.bet-info(v-bind:style=\"content\")\r\n        div.record(v-for=\"item in bonusRecord\")\r\n            p.created-time(v-html=\"item.createdAt | datetime\")\r\n            p.bonus-num\r\n                span \r\n                span(v-html=\"lotterynum(item.lotterynums)\")\r\n</template>\r\n<script>\r\nimport RequestList from '../../js/request-list'\r\nexport default {\r\n    props: ['zoomRate'],\r\n    ready() {\r\n        RequestList.getBonusRecord().then(res => this.bonusRecord = res.data)\r\n    },\r\n    data() {\r\n        return {\r\n            bonusRecord: require('../../data/bounsRecord')\r\n        }\r\n    },\r\n    methods: {\r\n        lotterynum(nums) {\r\n            if (Object.prototype.toString.call(nums) !== '[object String]') {\r\n                throw new Error('')\r\n            }\r\n            // \r\n            nums = nums.split(',')\r\n            return (nums[0] + nums[nums.length - 1]) % 10\r\n        }\r\n    },\r\n    computed: {\r\n        content() {\r\n            return {\r\n                width: 458 * this.zoomRate.x + 'px',\r\n                height: 580 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate'],
	    ready: function ready() {
	        var _this = this;
	
	        _requestList2.default.getBonusRecord().then(function (res) {
	            return _this.bonusRecord = res.data;
	        });
	    },
	    data: function data() {
	        return {
	            bonusRecord: __webpack_require__(126)
	        };
	    },
	
	    methods: {
	        lotterynum: function lotterynum(nums) {
	            if (Object.prototype.toString.call(nums) !== '[object String]') {
	                throw new Error('');
	            }
	
	            nums = nums.split(',');
	            return (nums[0] + nums[nums.length - 1]) % 10;
	        }
	    },
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in bonusRecord\"><p class=\"created-time\" v-html=\"item.createdAt | datetime\"></p><p class=\"bonus-num\"><span></span><span v-html=\"lotterynum(item.lotterynums)\"></span></p></div></div>";

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(129)
	__vue_script__ = __webpack_require__(131)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Exchange.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(139)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-f367a86e/Exchange.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(130);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Exchange.vue?4d705018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Exchange.vue","sourcesContent":["<template lang=\"pug\">\r\n    //-   \r\n    div.exchange(v-bind:style=\"content\")\r\n        //- img.background-img(v-bind:src=\"backgroundImg\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"bonusMoney\",v-html=\"item.goodname\")\r\n                    img.exchange(v-bind:src=\"doexchange\",v-bind:style=\"exchangeBtn\")\r\n            div.change-button(v-bind:style=\"buttonBar\")\r\n                div.bonus-button\r\n                    img.bonus-button(v-bind:src=\"bonusButton\")\r\n                div.prize-button\r\n                    img.prize-button(v-bind:src=\"prizeButton\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                moneyData: require('../../data/money-data.js'),\r\n                backgroundImg: require('../../assets///.png'),\r\n                moneyBack: require('../../assets///.png'),\r\n                bonusButton: require('../../assets///.png'),\r\n                prizeButton: require('../../assets///.png'),\r\n                doexchange: require('../../assets///.png'),\r\n                moneyImg: require('../../assets///.png')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 618 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyblock() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n                }\r\n            },\r\n            buttonBar() {\r\n                return {\r\n                    width: 260 * this.zoomRate.x + 'px',\r\n                    height: 68 * this.zoomRate.y + 'px',\r\n                    margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            barcontent() {\r\n                return {\r\n                    margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n                }\r\n            },\r\n            bonusMoney() {\r\n                return {\r\n                    width: 150 * this.zoomRate.x + 'px',\r\n                    height: 20 * this.zoomRate.y + 'px',\r\n                    margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyImg() {\r\n                return {\r\n                    width: 116 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: 0 * this.zoomRate.y + 'px 0 0 0px'\r\n                }\r\n            },\r\n            exchangeBtn() {\r\n                return {\r\n                    width: 90 * this.zoomRate.x + 'px',\r\n                    height: 50 * this.zoomRate.y + 'px',\r\n                    margin: 30 * this.zoomRate.y + 'px 0 0 ' + (364) * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(132),
	            backgroundImg: __webpack_require__(134),
	            moneyBack: __webpack_require__(135),
	            bonusButton: __webpack_require__(136),
	            prizeButton: __webpack_require__(137),
	            doexchange: __webpack_require__(138),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: 0 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        exchangeBtn: function exchangeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '10000',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50000',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '10W',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50W',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEMzREOUUxMjQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEMzREOUUxMzQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzNEQ5RTEwNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzNEQ5RTExNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MrPF1wAAIN9JREFU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"

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAIICAYAAACYbhx1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg4MTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg4MjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjYzODRGODdGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODgwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6e7g8wAAD2RJREFU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AwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwD/f4Je/Y8BAI+Uug26kAPAIx/2chL4etyuSg8A16zb9TiY19MhvUwpndd6usf95AcAgOswhD8wcLet1vDW8hJbv1yeqO2JkykdALiGYV8iPrd7eVx/Waaafj4/UXvM+7heVR0ArlfML2n11AbyaHkEvf5wOjyxlP6yY+oAwNVO5euqLYduLw3/YZvQ/2dc6t6f7CN8dWIcAFyfqPc239fs3vDvl3Gq355iqz0x9trPE/uac1M6AFz5dD5P5ak3um663RoeLS/x4Lv7qd4dlyfmF9YRfjulizoAXEHMT6bzvqu9N7stc8Nr/V4ZxzrFg3/ZL0+mfT2d1i+71g0A+P3E/DCdb/rcWn3odjT8L++8PpX9NKX9OL0ay3nbjsDPyzKpx4dMfUoXdQC4gpjXucXzrvapHjrd+33eGt7eWi7ixVjuXoz1a7Gki3Fqj+fqr7vfpyrqAHAVMZ82u9n3S7OXVs/Nrv/8F3devzsHfR7X44XzcXo5RvQ3zvsb9+2Nrf51M62LOgD8fmPeD4fPTe6Dd2v13Oxx+vL6I+0Yeq/8/MJL8YYW93Sv17/98CHqUz/7fb2gXdgB4HcS8sPZ7POdW3tze8z3vdX3lgE89VZ/4dk7r7+xfsbwZ08+lnJOseS2/kFJ+YmU01PxaPnmlry8sT2uef2xfPJ8ysf/qOz/FwB469P4ZiI/3Jt9PvktzWext8l8Hrz3S8j/d1n/00f+7cdf3X7Ebj7lPd5Y8hRL+/q1/IWo8hOx+UyL83J/95LqMKVdFL3Em4b5F4D5vbFeRvWcj/+BWdYB4CEx33zBSj2up3552rg5Zr7vk/nFHPMx3dtP/xnL5+//zF37DSDHD+R4c14m7PP447nY/Ea89OfrLvaziPrUYh41n6LeZV7qMtlvhvblkR3xAPBmUd/eNGa9A9zh8rTxeALcfCh8Py//Fctz9/bj+QNBn0+BT2uM57q3538Tmx+J5ZX4zBfWg/LTUNIQU/ouL5P6Iepp2WW/lL2azwHgoTE/bqzfmHZyNvsa9OMJcG35xzaZR8wv2sT+YNDr4X5y/Y8yX3weT13Eny/GbwnfGaf6yrgrj7e/YDeVtGuT+rzrPS+73ueY1+WYe5/WAYCHF3392vL1Dq3zZH64Ycxy7DxC/ot2Alwsr/Wwz89fEvT+a0E5Rr0us/p6uvyd+PBvxvKV/ZA/uRvqjW3QSw/64cS67acLOwBcMpofd7NvvgL1NOjjdN6uM4+Q/21M6hH19frz5fK1B4K+XOeWT6K+/CVTH/1L+/BfxPKZizH/QwT9pQj687G8s2yivsY8Zx0HgDfrer3v2PnmRLifzrdkH6fb+/nGb/0s934d+r7fw/2BoM/77/Mm6nn7F+QUPU/7WLcD82cl392N9YvDkL8UIf9ATOkfipi/Pyb098b6VtT87fH2M9M5ADx8So/5+SJi+6vI690YoH80f535VL/Vvmhl+Z6V451b11u9zl/I0s9ru9//CTAAwcI8aGUDpYoAAAAASUVORK5CYII="

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OTRCNTVEQzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OTRCNTVERDNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY5NEI1NURBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY5NEI1NURCM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FIWMwgAAJ/FJREFU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"

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI2RTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI2RjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjczMzVBODg5M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjczMzVBODhBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Nzdc8AAAB/ZJREFU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"

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI3MjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI3MzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4NzE2MjcwM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NzE2MjcxM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+QQjJUwAACBpJREFU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"

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDg5RkQxOTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDg5RkQxQTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlFM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY0ODlGRDE4M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CgsFFAAAC2RJREFU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"

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = "<div class=\"exchange\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"bonusMoney\" v-html=\"item.goodname\"></div><img class=\"exchange\" v-bind:src=\"doexchange\" v-bind:style=\"exchangeBtn\"/></div></div><div class=\"change-button\" v-bind:style=\"buttonBar\"><div class=\"bonus-button\"><img class=\"bonus-button\" v-bind:src=\"bonusButton\"/></div><div class=\"prize-button\"><img class=\"prize-button\" v-bind:src=\"prizeButton\"/></div></div></div></div>";

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(141)
	__vue_script__ = __webpack_require__(143)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Recharge.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(153)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-9e1d8b66/Recharge.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Recharge.vue?4d573667"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Recharge.vue","sourcesContent":["<template lang=\"pug\">\r\n    //-   \r\n    img.recharge-record(v-bind:src=\"recordImg\",v-bind:style=\"recordImgStyle\")\r\n    div.recharge(v-bind:style=\"content\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\",v-html=\"item.goodname\")\r\n                        //- \r\n                    div.bonus-money.bonus-sub(v-if=\"item.sub\",v-bind:style=\"bonusSub\",v-html=\"item.sub\")\r\n                    img.recharge(v-bind:src=\"dorecharge\",v-bind:style=\"rechargeBtn\")\r\n    div.my-money(v-bind:style=\"footer\") : {{userinfo.money}}\r\n</template>\r\n<script>\r\nexport default {\r\n    props: ['zoomRate', 'userinfo'],\r\n    ready() {\r\n\r\n    },\r\n    data() {\r\n        return {\r\n            moneyData: require('../../data/exchange-data'),\r\n            recordImg: require('../../assets///.png'),\r\n            moneyBack: require('../../assets///.png'),\r\n            dorecharge: require('../../assets///.png'),\r\n            moneyImg: require('../../assets///.png')\r\n        }\r\n    },\r\n    computed: {\r\n        recordImgStyle() {\r\n            return {\r\n                width: 136 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        content() {\r\n            return {\r\n                width: 495 * this.zoomRate.x + 'px',\r\n                height: 618 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyblock() {\r\n            return {\r\n                width: '100%',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n            }\r\n        },\r\n        buttonBar() {\r\n            return {\r\n                width: 260 * this.zoomRate.x + 'px',\r\n                height: 68 * this.zoomRate.y + 'px',\r\n                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        barcontent() {\r\n            return {\r\n                margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n            }\r\n        },\r\n        bonusMoney() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusMoneyHasSub() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusSub() {\r\n            return {\r\n                fontSize: 14 * this.zoomRate.x + 'px',\r\n                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',\r\n                borderRadius: 10 * this.zoomRate.x + 'px',\r\n                // width: 150 * this.zoomRate.x + 'px',\r\n                // height: 20 * this.zoomRate.y + 'px',\r\n                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyImg() {\r\n            return {\r\n                width: 116 * this.zoomRate.x + 'px',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: -2 * this.zoomRate.y + 'px 0 0 0px'\r\n            }\r\n        },\r\n        rechargeBtn() {\r\n            return {\r\n                width: 90 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        footer() {\r\n            return {\r\n                // width: 136 * this.zoomRate.x + 'px',\r\n                fontSize: 34 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    ready: function ready() {},
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(144),
	            recordImg: __webpack_require__(150),
	            moneyBack: __webpack_require__(151),
	            dorecharge: __webpack_require__(152),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        recordImgStyle: function recordImgStyle() {
	            return {
	                width: 136 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 495 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: '100%',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusMoneyHasSub: function bonusMoneyHasSub() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusSub: function bonusSub() {
	            return {
	                fontSize: 14 * this.zoomRate.x + 'px',
	                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',
	                borderRadius: 10 * this.zoomRate.x + 'px',
	
	                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: -2 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        rechargeBtn: function rechargeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        },
	        footer: function footer() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '500',
	        price: 500,
	        sub: '',
	        goodsimg: __webpack_require__(145),
	        goodsnum: 200
	    }, {
	        goodname: '1000',
	        price: 1000,
	        sub: '',
	        goodsimg: __webpack_require__(146),
	        goodsnum: 200
	    }, {
	        goodname: '2000',
	        price: 2000,
	        sub: '+188',
	        goodsimg: __webpack_require__(147),
	        goodsnum: 200
	    }, {
	        goodname: '5000',
	        price: 5000,
	        sub: '+888',
	        goodsimg: __webpack_require__(148),
	        goodsnum: 200
	    }, {
	        goodname: '10000',
	        price: 10000,
	        sub: '+2888',
	        goodsimg: __webpack_require__(149),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg3OTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg3QTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjQwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODc4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+3Q/9KQAAEj9JREFU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"

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzRjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjNDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjNENDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Z4g2cwAAGIhJREFU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"

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzQTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzQjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjM4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjM5NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YbZkgAAJTdJREFU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"

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQjUwMkFGRDQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQjUwMkFGRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZCNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQUZDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+L33IaQAAMdZJREFU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"

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzNjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzNzQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQjAwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+56FGOgAAQAZJREFU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"

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAAxCAYAAAABf+HvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNDBFMThBMjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNDBFMThBMzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEEwM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE0MEUxOEExM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gmaSkAAACUhJREFU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"

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4NDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4NTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjgyM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjgzM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+aqH0aAAAKFxJREFU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"

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFFRjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGMDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEE0M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUVFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CibruAAACphJREFUeNrsnX9sE/cVwN+dz78dx0mgYxDaUEYqTZQW1mijqKhTSas1o6WqyqqVQdWoBTZatX+0ULWjQtXaP1qtGi2MdoK1hWlAkRBaQaitNqkI+IMfARpECL9FgJCQ2E5sxzn/uL139/VhJ7ZzNsn5XO4pT2fHd+ev3+f73vd933195q4/+SQUKTxqA+qvUR9ArUedhOpGtYMpWmQQNYx6BbUd9TDq/1APoSa1nGDKBU/Gc6GIRtSi/gn1OdTJJpNbEjvTatR7UZ9m/7+M+i/UdagdhXqZVqlhb3AOdZUJc0xlMrPxOWbzmtEGuhC1DfWPqDbT3rqJjdmcbP+70QAqYCDfgNttqONM+5ZMyPZbGYu8w6Qg5X7Nha9t5wCaJNOghhBksRSh1nJKxIwU4qFCAr2SYJpmNBzUpoQSMQXNQPGA9RaA35rmM6YQG2KkCeigBL/HA140zWZ4qC8iq0XDPLjziSfUJ90JbnyNRWrjlXmRKQYXzG38V+L8z+d2uDuzeqiXl943YZbVeFo13pL8S0bIlRTScDHGT7VysCT13NTyUGS2+L+TwlMzPHTqxQoOQ+0KrrhSoCml9VKB2CkPGdBfOhJ2Jyc9a5qnPIXYEUMV6Orq6BwLBxNM05RpxovsiKEMFMMt7+OlRkM2dMoU8K1ZA3ds3QoVK1aM6XtVrlwpq/W++/LuR69Te2rWrQPXM88YxlbIcB7xJA+12nmYZcQBP37hAnAuF/BOJ7gbG0FAY47F+/DYcZwPPiirUF+fd1+uokJuj7W2FpKhkGFshQx/QSwJqM2GeZFRw0lw/c2CSOVLL43NGPTww/I2OTAA0e++y++h06apj8W2NsPYiTG0CTJQTjLslZQEemnkwAFwofeQV1CYi3z11ai+h2vuXHkbbWkBx7x5YJ8+PTfQO++8OW9//vn8be/uhr5PPtEHqMJQBmrlOXAZedDv/+wzcMycCbHLl0HCMDeqMLGDWKqVWkpk715wPvQQOO6/X9OxI+0X6+jQzUaMoVWQkyRJEvS6RFbz4Ydgr68v+DgKh3QcqW/ZMk3HRI8dg97Vq/Pu43n8cXk72N4OIu5vmTgR8tnC09io7h+7dCl/m8NhkCR9LMtqCBYhNSHVrSe5igsGlIiMtnheeEH1ztCuXfJ2YM8eGMixv4DJUwoo7T+4b5/h6gy6Aw19/TVYJuSe8vJut2o0ef9vv5V7ejESO3Mm9/tUVYHnscfU0KgFjqW29ua5W1sNWTjSvdRHHjBSSE6H2ffxxzm9hfN6IXb8eFHt8C5dqnr9wOHDw19/+eXhCdFdd6nh37NoUd7z52r3WIsM1ChLTCowBKbGV/KaYA6juBcuBO/TyorHXswiCw19dkx8KGtOFynHWJkr/Od7XZ5ulRKoEYSM7F2wQPWA3g8+yB1KT59WDTvu9dehFyf7I3l+eqj1NTdrblcYp0yJri5N+1rr6sCpMUP+UQOl8FmdVtrree89uUqUS0QMs92rVkHNO++AgElNNWa9AY8Hwtu3j/he1W+9JR+jVQZPnNDcWSjClBoobwSYBCY1nt1AzxQ1jIsEvGfNGoj39srPfTimUSjOJ5U4LqZC+gBOUX6MUtIxVPZMDJkpj/Fv2QLRPOMhhUv1sc8nt7sfvaeKJSgElf6Xy1M5t1vpDNgJ/B99BM4vvlDHz1w28C1ZIkcArXPlXGOyviFX0v/tXTih96JHCTXKKv94Tw84pk+Xleaqqfkqh56b2keLENzE1atZO0ZwwwZwYzLUizCTzLPVzz/aNpCkEgItgThnz84ARY8LAZdPxr3xBnT198uVnwwP8vvh6uLF8larBD7/HCIFjKGVTz11eyZFAwcPqgkEhSoaQ1O1TyubwJPXDhw5ohYWEp2dUDF/vnLpCo/pWrkSkoGACsuBmTLBlJOfV1+FzizF80JgmmNoARLGXp8gL2ptzTAyjZOTvvxSyTDb2iAwZD5Hnk1A5Q4wJBMewDAbnDYNnA0N4P/004I+V6597TNm5K1spYsNcwJjjKElkmzjnC3t0lVc4/wvo0KzaZOsoyXuOXPKz0ONJLb0C8h5arG6RZL9+zV3LPJQs7CQJ2yJBiiAR0+c0JwUec3CwvB5pv2eexSYmCDdSgJDCdLtKMYqzuMcMlUxihw6lLVdkoZEhmQ8ZrvRBQsgsHnzsOlLtnPmOlcVZso1y5ebhYWCQy2GKu+jj6qGCe3cOXK7crzOs8qTo74ebKhiS4v+hYDbrbCQ0Yi774Zxr712czK/Y0dmJafQ0O3z3cyUr127pbb1UmFh925tY2hzM/iMUFhI4ufmSwTX1dQE1RjW1FCL4TG0bdutfai0lQVxHRdqlVKIoQo0JkHUxoFHzwa4EaTnkUfksJgSgtn99tv5G562HMX3yitZl6e4GhrU0B07f15zYaEKzzfsXLNng22qtmXLtrq6jLal2hvcuHHM7UkMU0ClqMT5bZykC9CaN98E16xZGYu+yPB9e/dq+uA0jfCwyX5qzM0loQJXMmQ7n6vIaUjqXJSt6wGUGBJLGWgwyV3x8pIuN5JKB0IgI0ePQhBDbFyjJ4VxPBMmTJC90JYWWtOFasDRtjbwr11bUNsiY3CNtJhqVzFCDFNAE50Jvn2ykPyVLpUXBoS+FxKmFX1FJD/U40ej1/d9843iRawiNVK4N7JcRYbEkoDGDg8Khx+wxxfr9eYBHUKQpgy2QA82shwdFOiGjzGqFIn/6LMfiSgx2JQyFGKHDI8SSxkoDqiBk6Jlv2ma8hRiRwyJpRxyaTjZ2GffOWtc7DcW+RY4ppSLJPCP2BFDOeSerPXTjXb790Wtp1tFYZ9ponLzTmE/sSOGNHHgWcWRqspd7/pdW9B1w+btYspDidUav2szsWMM1ctnFHZ7TsUsZ3aEbf82+315CLLa1haz0HSlhzFUgLbW+gk4fZO24/2Aa88xUThgmsvYchwZISu6atDB2EnpHkpQRZpbo15afsOz8VzMctI0mzGF2CxDRsSKMRNTrw1dsUA31b3cn+TONt/wrL8Yt7SZ5jOWnI9ZThEbYgTKjw1k3Ag5Ayh6aYIKOdQJbiT40wuvV/ytRRQOmmY0hhCLZ7sq1hIbUH5gwK/MXNKADs2cfqj1x5gbt0ck7uwfuio2bep3mNlvibPZfyIDYoFMqPBMiVA3Y5UhWS9q447ivR1V19n5xL8GneKuiO3Un32R+TPt8QbeLD7oIkn0vpZB4dC7Add/cNyk5Oci80yCKWY7hjvH7gKSTRCqFTe0noMurdH30e+YYYtPXO6NzkWwM92cVGmaffQlLHFBBNny9z7H9ydE4SqbZ15iY2Yg3TORkXag7ADyRvoq2HhQflXppwRZ4MDV5BKnzHXEflYnJGpreGm8h5cqrZxkMz1YuwfGJE4MJblgT5LrxiS04/uo9ezuiO1CXJKTHcpnrrGpCQ2DkR+UPAeKBpp2IP0oDK1qoK+I/YRtvagOUH4wRmDKgc53ViljUW9ryJTCKC0l6WPFgutsG8oVYocBdc14rpAGECgKw7R+pIIB9TLQTgbWAgZbwG1sJ5WzVJGV7kIMJmk/+18MCljmKxTRo0Sm/SwM2JhaGUzTQwv30AQDl7JtDDT+OuFQ+b8AAwBwkbCx9iIYtQAAAABJRU5ErkJggg=="

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<img class=\"recharge-record\" v-bind:src=\"recordImg\" v-bind:style=\"recordImgStyle\"/><div class=\"recharge\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\" v-html=\"item.goodname\"></div><div class=\"bonus-money bonus-sub\" v-if=\"item.sub\" v-bind:style=\"bonusSub\" v-html=\"item.sub\"></div><img class=\"recharge\" v-bind:src=\"dorecharge\" v-bind:style=\"rechargeBtn\"/></div></div></div></div><div class=\"my-money\" v-bind:style=\"footer\">: {{userinfo.money}}</div>";

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(155)
	__vue_script__ = __webpack_require__(157)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\ruleIntroduce.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(159)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-41af1aed/ruleIntroduce.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(156);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/ruleIntroduce.vue?482cbdbb"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA","file":"ruleIntroduce.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.introduce(v-bind:style=\"content\",v-html=\"rule\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n            console.log(this.rule)\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                rule: require('./../../data/ruleIntro.html')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.rule);
	    },
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            rule: __webpack_require__(158)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n<p>1.PK</p>\r\n<p>PK10</p>\r\n";

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "<div class=\"introduce\" v-bind:style=\"content\" v-html=\"rule\"></div>";

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<div class=\"model\" v-show=\"dialogShow\" transition=\"message\"><div class=\"dialog\" v-bind:style=\"dialog\"><div class=\"close\" v-bind:style=\"close\" @touchend=\"dialogShow = false\"></div><div class=\"content\" v-bind:style=\"content\"></div><div v-bind:is=\"dialogImg[currentIndex].type\" v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\"></div><img v-bind:src=\"dialogImg[currentIndex].background\"/></div></div>";

/***/ },
/* 161 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    notice: {
	        'content': '?????',
	        'createdAt': 1469543980000,
	        'id': 6,
	        'title': 'title'
	    },
	    options: ['', '', '', '', '']
	};

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {};

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    'createdAt': 1469548675000,
	    'money': 10000,
	    'code': 0,
	    'nickname': '222',
	    'openid': 'xxxxxxxxxxxx'
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(165)
	__vue_script__ = __webpack_require__(167)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\tip-modal.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(168)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-691c031b/tip-modal.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /*  scale  */\r\n}\r\n\r\n.bounce-enter {\r\n    -webkit-animation: bounce-in .5s;\r\n            animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    -webkit-animation: bounce-out .5s;\r\n            animation: bounce-out .5s;\r\n}\r\n\r\n@-webkit-keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@-webkit-keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n", "", {"version":3,"sources":["/./src/components/tip-modal.vue?79187cbe"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;IACA,oBAAA;IACA,mBAAA;IACA,WAAA;IACA,aAAA;IACA,+BAAA;IACA,aAAA;IACA,mBAAA;IACA,mBAAA;IACA,mBAAA;CACA;;AAEA;IACA,sBAAA;IACA,qBAAA;CACA;;AAEA;IACA,iCAAA;YAAA,yBAAA;CACA;;AAEA;IACA,kCAAA;YAAA,0BAAA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA","file":"tip-modal.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.tip-content(transition=\"bounce\",v-show=\"isShow\",v-html=\"content\")\r\n</template>\r\n<script>\r\nexport default {\r\n    props: [],\r\n    data() {\r\n        return {\r\n            isShow: false,\r\n            content: ''\r\n        }\r\n    },\r\n    methods: {\r\n        showTip(content) {\r\n            this.content = content\r\n            this.isShow = true\r\n            setTimeout(() => this.isShow = false, 3000)\r\n        }\r\n    },\r\n    events: {\r\n        showTip(event) {\r\n            this.showTip(event)\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /*  scale  */\r\n}\r\n\r\n.bounce-enter {\r\n    animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    animation: bounce-out .5s;\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        transform: scale(0);\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        transform: scale(1);\r\n    }\r\n    100% {\r\n        transform: scale(0);\r\n    }\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: [],
	    data: function data() {
	        return {
	            isShow: false,
	            content: ''
	        };
	    },
	
	    methods: {
	        showTip: function showTip(content) {
	            var _this = this;
	
	            this.content = content;
	            this.isShow = true;
	            setTimeout(function () {
	                return _this.isShow = false;
	            }, 3000);
	        }
	    },
	    events: {
	        showTip: function showTip(event) {
	            this.showTip(event);
	        }
	    }
	};

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tip-content\" transition=\"bounce\" v-show=\"isShow\" v-html=\"content\"></div>";

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<background></background><menu-bar v-bind:game-data=\"gameData\" v-bind:notice=\"notice\" v-bind:zoom-rate=\"zoomRate\"></menu-bar><bet-and-bonus v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></bet-and-bonus><play-panel v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></play-panel><state v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></state><message v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></message><modal class=\"modal\" v-if=\"error\"></modal><tip-modal></tip-modal>";

/***/ },
/* 170 */
/***/ function(module, exports) {

	!function (a, b) {
	    module.exports = b(a)
	}(window, function (a, b) {
	    function c(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.invoke(b, e(c), function (a) {
	            g(b, a, d)
	        }) : j(b, d)
	    }
	
	    function d(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.on(b, function (a) {
	            d && d.trigger && d.trigger(a), g(b, a, c)
	        }) : d ? j(b, d) : j(b, c)
	    }
	
	    function e(a) {
	        return a = a || {}, a.appId = z.appId, a.verifyAppId = z.appId, a.verifySignType = "sha1", a.verifyTimestamp = z.timestamp + "", a.verifyNonceStr = z.nonceStr, a.verifySignature = z.signature, a
	    }
	
	    function f(a) {
	        return {
	            timeStamp: a.timestamp + "",
	            nonceStr: a.nonceStr,
	            "package": a.package,
	            paySign: a.paySign,
	            signType: a.signType || "SHA1"
	        }
	    }
	
	    function g(a, b, c) {
	        var d, e, f;
	        switch (delete b.err_code, delete b.err_desc, delete b.err_detail, d = b.errMsg, d || (d = b.err_msg, delete b.err_msg, d = h(a, d, c), b.errMsg = d), c = c || {}, c._complete && (c._complete(b), delete c._complete), d = b.errMsg || "", z.debug && !c.isInnerInvoke && alert(JSON.stringify(b)), e = d.indexOf(":"), f = d.substring(e + 1)) {
	            case"ok":
	                c.success && c.success(b);
	                break;
	            case"cancel":
	                c.cancel && c.cancel(b);
	                break;
	            default:
	                c.fail && c.fail(b)
	        }
	        c.complete && c.complete(b)
	    }
	
	    function h(a, b) {
	        var d, e, f, g;
	        if (b) {
	            switch (d = b.indexOf(":"), a) {
	                case o.config:
	                    e = "config";
	                    break;
	                case o.openProductSpecificView:
	                    e = "openProductSpecificView";
	                    break;
	                default:
	                    e = b.substring(0, d), e = e.replace(/_/g, " "), e = e.replace(/\b\w+\b/g, function (a) {
	                        return a.substring(0, 1).toUpperCase() + a.substring(1)
	                    }), e = e.substring(0, 1).toLowerCase() + e.substring(1), e = e.replace(/ /g, ""), -1 != e.indexOf("Wcpay") && (e = e.replace("Wcpay", "WCPay")), f = p[e], f && (e = f)
	            }
	            g = b.substring(d + 1), "confirm" == g && (g = "ok"), "failed" == g && (g = "fail"), -1 != g.indexOf("failed_") && (g = g.substring(7)), -1 != g.indexOf("fail_") && (g = g.substring(5)), g = g.replace(/_/g, " "), g = g.toLowerCase(), ("access denied" == g || "no permission to execute" == g) && (g = "permission denied"), "config" == e && "function not exist" == g && (g = "ok"), b = e + ":" + g
	        }
	        return b
	    }
	
	    function i(a) {
	        var b, c, d, e;
	        if (a) {
	            for (b = 0, c = a.length; c > b; ++b)d = a[b], e = o[d], e && (a[b] = e);
	            return a
	        }
	    }
	
	    function j(a, b) {
	        if (!(!z.debug || b && b.isInnerInvoke)) {
	            var c = p[a];
	            c && (a = c), b && b._complete && delete b._complete, console.log('"' + a + '",', b || "")
	        }
	    }
	
	    function k() {
	        if (!("6.0.2" > w || y.systemType < 0)) {
	            var b = new Image;
	            y.appId = z.appId, y.initTime = x.initEndTime - x.initStartTime, y.preVerifyTime = x.preVerifyEndTime - x.preVerifyStartTime, C.getNetworkType({
	                isInnerInvoke: !0,
	                success: function (a) {
	                    y.networkType = a.networkType;
	                    var c = "https://open.weixin.qq.com/sdk/report?v=" + y.version + "&o=" + y.isPreVerifyOk + "&s=" + y.systemType + "&c=" + y.clientVersion + "&a=" + y.appId + "&n=" + y.networkType + "&i=" + y.initTime + "&p=" + y.preVerifyTime + "&u=" + y.url;
	                    b.src = c
	                }
	            })
	        }
	    }
	
	    function l() {
	        return (new Date).getTime()
	    }
	
	    function m(b) {
	        t && (a.WeixinJSBridge ? b() : q.addEventListener && q.addEventListener("WeixinJSBridgeReady", b, !1))
	    }
	
	    function n() {
	        C.invoke || (C.invoke = function (b, c, d) {
	            a.WeixinJSBridge && WeixinJSBridge.invoke(b, e(c), d)
	        }, C.on = function (b, c) {
	            a.WeixinJSBridge && WeixinJSBridge.on(b, c)
	        })
	    }
	
	    var o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
	    if (!a.jWeixin)return o = {
	        config: "preVerifyJSAPI",
	        onMenuShareTimeline: "menu:share:timeline",
	        onMenuShareAppMessage: "menu:share:appmessage",
	        onMenuShareQQ: "menu:share:qq",
	        onMenuShareWeibo: "menu:share:weiboApp",
	        onMenuShareQZone: "menu:share:QZone",
	        previewImage: "imagePreview",
	        getLocation: "geoLocation",
	        openProductSpecificView: "openProductViewWithPid",
	        addCard: "batchAddCard",
	        openCard: "batchViewCard",
	        chooseWXPay: "getBrandWCPayRequest"
	    }, p = function () {
	        var b, a = {};
	        for (b in o)a[o[b]] = b;
	        return a
	    }(), q = a.document,
	        r = q.title,
	        s = navigator.userAgent.toLowerCase(), t = -1 != s.indexOf("micromessenger"), u = -1 != s.indexOf("android"), v = -1 != s.indexOf("iphone") || -1 != s.indexOf("ipad"), w = function () {
	        var a = s.match(/micromessenger\/(\d+\.\d+\.\d+)/) || s.match(/micromessenger\/(\d+\.\d+)/);
	        return a ? a[1] : ""
	    }(), x = {initStartTime: l(), initEndTime: 0, preVerifyStartTime: 0, preVerifyEndTime: 0}, y = {
	        version: 1,
	        appId: "",
	        initTime: 0,
	        preVerifyTime: 0,
	        networkType: "",
	        isPreVerifyOk: 1,
	        systemType: v ? 1 : u ? 2 : -1,
	        clientVersion: w,
	        url: encodeURIComponent(location.href)
	    }, z = {}, A = {_completes: []}, B = {state: 0, res: {}}, m(function () {
	        x.initEndTime = l()
	    }), C = {
	        config: function (a) {
	            z = a, j("config", a);
	            var b = z.check === !1 ? !1 : !0;
	            m(function () {
	                var a, d, e;
	                if (b)c(o.config, {verifyJsApiList: i(z.jsApiList)}, function () {
	                    A._complete = function (a) {
	                        x.preVerifyEndTime = l(), B.state = 1, B.res = a
	                    }, A.success = function () {
	                        y.isPreVerifyOk = 0
	                    }, A.fail = function (a) {
	                        A._fail ? A._fail(a) : B.state = -1
	                    };
	                    var a = A._completes;
	                    return a.push(function () {
	                        z.debug || k()
	                    }), A.complete = function () {
	                        for (var c = 0, d = a.length; d > c; ++c)a[c]();
	                        A._completes = []
	                    }, A
	                }()), x.preVerifyStartTime = l(); else {
	                    for (B.state = 1, a = A._completes, d = 0, e = a.length; e > d; ++d)a[d]();
	                    A._completes = []
	                }
	            }), z.beta && n()
	        }, ready: function (a) {
	            0 != B.state ? a() : (A._completes.push(a), !t && z.debug && a())
	        }, error: function (a) {
	            "6.0.2" > w || (-1 == B.state ? a(B.res) : A._fail = a)
	        }, checkJsApi: function (a) {
	            var b = function (a) {
	                var c, d, b = a.checkResult;
	                for (c in b)d = p[c], d && (b[d] = b[c], delete b[c]);
	                return a
	            };
	            c("checkJsApi", {jsApiList: i(a.jsApiList)}, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var c = a.checkResult;
	                        c && (a.checkResult = JSON.parse(c))
	                    }
	                    a = b(a)
	                }, a
	            }())
	        }, onMenuShareTimeline: function (a) {
	            d(o.onMenuShareTimeline, {
	                complete: function () {
	                    c("shareTimeline", {
	                        title: a.title || r,
	                        desc: a.title || r,
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareAppMessage: function (a) {
	            d(o.onMenuShareAppMessage, {
	                complete: function () {
	                    c("sendAppMessage", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        link: a.link || location.href,
	                        img_url: a.imgUrl || "",
	                        type: a.type || "link",
	                        data_url: a.dataUrl || ""
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQQ: function (a) {
	            d(o.onMenuShareQQ, {
	                complete: function () {
	                    c("shareQQ", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareWeibo: function (a) {
	            d(o.onMenuShareWeibo, {
	                complete: function () {
	                    c("shareWeiboApp", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQZone: function (a) {
	            d(o.onMenuShareQZone, {
	                complete: function () {
	                    c("shareQZone", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, startRecord: function (a) {
	            c("startRecord", {}, a)
	        }, stopRecord: function (a) {
	            c("stopRecord", {}, a)
	        }, onVoiceRecordEnd: function (a) {
	            d("onVoiceRecordEnd", a)
	        }, playVoice: function (a) {
	            c("playVoice", {localId: a.localId}, a)
	        }, pauseVoice: function (a) {
	            c("pauseVoice", {localId: a.localId}, a)
	        }, stopVoice: function (a) {
	            c("stopVoice", {localId: a.localId}, a)
	        }, onVoicePlayEnd: function (a) {
	            d("onVoicePlayEnd", a)
	        }, uploadVoice: function (a) {
	            c("uploadVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadVoice: function (a) {
	            c("downloadVoice", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, translateVoice: function (a) {
	            c("translateVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, chooseImage: function (a) {
	            c("chooseImage", {
	                scene: "1|2",
	                count: a.count || 9,
	                sizeType: a.sizeType || ["original", "compressed"],
	                sourceType: a.sourceType || ["album", "camera"]
	            }, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var b = a.localIds;
	                        b && (a.localIds = JSON.parse(b))
	                    }
	                }, a
	            }())
	        }, previewImage: function (a) {
	            c(o.previewImage, {current: a.current, urls: a.urls}, a)
	        }, uploadImage: function (a) {
	            c("uploadImage", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadImage: function (a) {
	            c("downloadImage", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, getNetworkType: function (a) {
	            var b = function (a) {
	                var c, d, e, b = a.errMsg;
	                if (a.errMsg = "getNetworkType:ok", c = a.subtype, delete a.subtype, c)a.networkType = c; else switch (d = b.indexOf(":"), e = b.substring(d + 1)) {
	                    case"wifi":
	                    case"edge":
	                    case"wwan":
	                        a.networkType = e;
	                        break;
	                    default:
	                        a.errMsg = "getNetworkType:fail"
	                }
	                return a
	            };
	            c("getNetworkType", {}, function () {
	                return a._complete = function (a) {
	                    a = b(a)
	                }, a
	            }())
	        }, openLocation: function (a) {
	            c("openLocation", {
	                latitude: a.latitude,
	                longitude: a.longitude,
	                name: a.name || "",
	                address: a.address || "",
	                scale: a.scale || 28,
	                infoUrl: a.infoUrl || ""
	            }, a)
	        }, getLocation: function (a) {
	            a = a || {}, c(o.getLocation, {type: a.type || "wgs84"}, function () {
	                return a._complete = function (a) {
	                    delete a.type
	                }, a
	            }())
	        }, hideOptionMenu: function (a) {
	            c("hideOptionMenu", {}, a)
	        }, showOptionMenu: function (a) {
	            c("showOptionMenu", {}, a)
	        }, closeWindow: function (a) {
	            a = a || {}, c("closeWindow", {immediate_close: a.immediateClose || 0}, a)
	        }, hideMenuItems: function (a) {
	            c("hideMenuItems", {menuList: a.menuList}, a)
	        }, showMenuItems: function (a) {
	            c("showMenuItems", {menuList: a.menuList}, a)
	        }, hideAllNonBaseMenuItem: function (a) {
	            c("hideAllNonBaseMenuItem", {}, a)
	        }, showAllNonBaseMenuItem: function (a) {
	            c("showAllNonBaseMenuItem", {}, a)
	        }, scanQRCode: function (a) {
	            a = a || {}, c("scanQRCode", {
	                needResult: a.needResult || 0,
	                scanType: a.scanType || ["qrCode", "barCode"]
	            }, function () {
	                return a._complete = function (a) {
	                    var b, c;
	                    v && (b = a.resultStr, b && (c = JSON.parse(b), a.resultStr = c && c.scan_code && c.scan_code.scan_result))
	                }, a
	            }())
	        }, openProductSpecificView: function (a) {
	            c(o.openProductSpecificView, {pid: a.productId, view_type: a.viewType || 0}, a)
	        }, addCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, card_ext: g.cardExt}, d.push(h);
	            c(o.addCard, {card_list: d}, function () {
	                return a._complete = function (a) {
	                    var c, d, e, b = a.card_list;
	                    if (b) {
	                        for (b = JSON.parse(b), c = 0, d = b.length; d > c; ++c)e = b[c], e.cardId = e.card_id, e.cardExt = e.card_ext, e.isSuccess = e.is_succ ? !0 : !1, delete e.card_id, delete e.card_ext, delete e.is_succ;
	                        a.cardList = b, delete a.card_list
	                    }
	                }, a
	            }())
	        }, chooseCard: function (a) {
	            c("chooseCard", {
	                app_id: z.appId,
	                location_id: a.shopId || "",
	                sign_type: a.signType || "SHA1",
	                card_id: a.cardId || "",
	                card_type: a.cardType || "",
	                card_sign: a.cardSign,
	                time_stamp: a.timestamp + "",
	                nonce_str: a.nonceStr
	            }, function () {
	                return a._complete = function (a) {
	                    a.cardList = a.choose_card_info, delete a.choose_card_info
	                }, a
	            }())
	        }, openCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, code: g.code}, d.push(h);
	            c(o.openCard, {card_list: d}, a)
	        }, chooseWXPay: function (a) {
	            c(o.chooseWXPay, f(a), a)
	        }
	    }, b && (a.wx = a.jWeixin = C), C
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZGYxYmQwYTVjNDE0MjhiMDdiZDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC92dWUvMS4wLjI2L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2U2MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/N2YwMSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvYmFiZWwtcnVudGltZS82LjkuMi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT81ZDVmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlPzM4MTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL0JHLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWU/Mzk3ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lNzQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlPzhhZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmciLCJ3ZWJwYWNrOi8vL01lbnVCYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzgyMTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/NmI3NyIsIndlYnBhY2s6Ly8vT3B0aW9uc0RpYWxvZy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/MGVkZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lZDM4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/NmIzNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MzBlMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmciLCJ3ZWJwYWNrOi8vL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlPzU1NjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzM5MWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9jYmRlIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZyIsIndlYnBhY2s6Ly8vUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzhjMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9iMjdjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9lNWUxIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvdGguanBnIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nIiwid2VicGFjazovLy9TdGF0ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT81MzhjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/YTFhMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/NWZmYyIsIndlYnBhY2s6Ly8vQmV0TXVsdGlwbGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT84MDgxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlP2RmYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/ZjRiYiIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mmpfoibLmjKHmnb8ucG5nIiwid2VicGFjazovLy9NZXNzYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWU/ZWRkMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlP2M5MGQiLCJ3ZWJwYWNrOi8vL2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2JldFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/YjU4MSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9hZDBlIiwid2VicGFjazovLy9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/ZGUyYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZT81NjMyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlP2QzM2UiLCJ3ZWJwYWNrOi8vL0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzkwZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NzM3OSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT9jOTEzIiwid2VicGFjazovLy9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlP2Q0ZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2Q4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT9mYzVkIiwid2VicGFjazovLy9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2E5ZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/OGJiNCIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL25vdGljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT9kZmFhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWU/YzkzOCIsIndlYnBhY2s6Ly8vdGlwLW1vZGFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlP2NiZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/ZDExZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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LFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLO0FBQ2hCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGdEQUErQztBQUMvQyxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLG9DQUFtQztBQUNuQztBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHNDQUFxQyxPQUFP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsS0FBSztBQUNsQixjQUFhLElBQUk7QUFDakIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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LGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsSUFBSTtBQUNqQixjQUFhLFFBQVE7QUFDckIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixFQUFFOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN0SHRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRSx1Q0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFD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QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxXQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakIsMkJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsMkNBQTBDO0FBQzFDLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0Msc0NBQXNDO0FBQzlFLHFDQUFvQyx1Q0FBdUM7QUFDM0UscUNBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLFFBQU87QUFDUDtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDLHNDQUFxQztBQUNyQyxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixhQUFhO0FBQ3BDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixrREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FB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QTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7O0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCLDJCQUEyQixRQUFRLGlCQUFpQjtBQUM5RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxLQUFLLEVBQUUsS0FBSyxNQUFNLEVBQUU7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCw0QkFBMkI7QUFDM0I7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CO0FBQ25COztBQUVBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVB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QVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUMsRSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJidWlsZC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGRmMWJkMGE1YzQxNDI4YjA3YmQ5XG4gKiovIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJ1xuaW1wb3J0IHd4IGZyb20gJ3dlaXhpbi1qcy1zZGsnXG5pbXBvcnQgVnVlUmVzb3VyY2UgZnJvbSAndnVlLXJlc291cmNlJ1xuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4vanMvcmVxdWVzdC1saXN0J1xuVnVlLnVzZShWdWVSZXNvdXJjZSlcblZ1ZS5maWx0ZXIoJ3RpbWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGxldCBob3VyID0gTWF0aC5mbG9vcih2YWx1ZSAvIDM2MDApXG4gICAgbGV0IG1pbiA9IE1hdGguZmxvb3IoKHZhbHVlICUgMzYwMCkgLyA2MClcbiAgICBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgIGhvdXIgPSAnMCcgKyBob3VyXG4gICAgfVxuICAgIGlmIChtaW4gPCAxMCkge1xuICAgICAgICBtaW4gPSAnMCcgKyBtaW5cbiAgICB9XG4gICAgbGV0IHNlYyA9IHZhbHVlICUgNjBcbiAgICBpZiAoc2VjIDwgMTApIHtcbiAgICAgICAgc2VjID0gJzAnICsgc2VjXG4gICAgfVxuICAgIHJldHVybiAoaG91ciA+IDAgPyBob3VyICsgJzonIDogJycpICsgbWluICsgJzonICsgc2VjXG59KVxuVnVlLmZpbHRlcignZGF0ZXRpbWUnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0xvY2FsZVN0cmluZygpXG59KVxubGV0IGNvbmZpZyA9IHt9XG5SZXF1ZXN0TGlzdC5nZXRNYWluQ29uZmlnKCkudGhlbigocmVzKSA9PiB7IC8v5LuO5ZCO5Y+w6I635Y+W6YWN572u5paH5Lu2XG4gICAgY29uZmlnID0gcmVzLmRhdGFcbiAgICBjb25zb2xlLmxvZyhjb25maWcpXG4gICAgICAgIC8vIHd4LmNvbmZpZyh7XG4gICAgICAgIC8vICAgICBkZWJ1ZzogdHJ1ZSxcbiAgICAgICAgLy8gICAgIGFwcElkOiAnPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJhcHBJZFwiXTs/PicsXG4gICAgICAgIC8vICAgICB0aW1lc3RhbXA6IDw/cGhwIGVjaG8gJHNpZ25QYWNrYWdlW1widGltZXN0YW1wXCJdOz8+LFxuICAgICAgICAvLyAgICAgbm9uY2VTdHI6ICc8P3BocCBlY2hvICRzaWduUGFja2FnZVtcIm5vbmNlU3RyXCJdOz8+JyxcbiAgICAgICAgLy8gICAgIHNpZ25hdHVyZTogJzw/cGhwIGVjaG8gJHNpZ25QYWNrYWdlW1wic2lnbmF0dXJlXCJdOz8+JyxcbiAgICAgICAgLy8gICAgIGpzQXBpTGlzdDogW1xuICAgICAgICAvLyAgICAgICAgIC8vIOaJgOacieimgeiwg+eUqOeahCBBUEkg6YO96KaB5Yqg5Yiw6L+Z5Liq5YiX6KGo5LitXG4gICAgICAgIC8vICAgICAgICAgJ29uTWVudVNoYXJlVGltZWxpbmUnLFxuICAgICAgICAvLyAgICAgICAgICdvbk1lbnVTaGFyZUFwcE1lc3NhZ2UnLFxuICAgICAgICAvLyAgICAgICAgICdjaG9vc2VJbWFnZSdcbiAgICAgICAgLy8gICAgIF1cbiAgICAgICAgLy8gfSk7XG59LCAocmVzKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihyZXMpXG59KVxuXG4vL2h0dHBzOi8vb3Blbi53ZWl4aW4ucXEuY29tL2Nvbm5lY3Qvb2F1dGgyL2F1dGhvcml6ZT9hcHBpZD13eGZmZTE5MGRlYzMyNzFhMWMmcmVkaXJlY3RfdXJpPWh0dHA6Ly9sc3dlaXhpbnRlc3QuYXBwbGluemkuY29tL3BocC91cmxvcGVuaWQucGhwJnJlc3BvbnNlX3R5cGU9Y29kZSZzY29wZT1zbnNhcGlfdXNlcmluZm8mc3RhdGU9MTIzXG52YXIgbWFpbiA9IG5ldyBWdWUoe1xuICAgIGVsOiAnYm9keScsXG4gICAgY29tcG9uZW50czogeyBhcHA6IEFwcCB9XG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWFpbi5qc1xuICoqLyIsIi8qIVxuICogVnVlLmpzIHYxLjAuMjZcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9iai5faXNWdWUpIHtcbiAgICBzZXQob2JqLl9kYXRhLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgaWYgKG9iLnZtcykge1xuICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICB2bS5fcHJveHkoa2V5KTtcbiAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBkZWwob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlbGV0ZSBvYmpba2V5XTtcbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKCFvYikge1xuICAgIGlmIChvYmouX2lzVnVlKSB7XG4gICAgICBkZWxldGUgb2JqLl9kYXRhW2tleV07XG4gICAgICBvYmouX2RpZ2VzdCgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl91bnByb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfC0/W1xcZFxcLl0rfCdbXiddKid8XCJbXlwiXSpcIilcXHM/JC87XG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGO1xufVxuXG4vKipcbiAqIEd1YXJkIHRleHQgb3V0cHV0LCBtYWtlIHN1cmUgdW5kZWZpbmVkIG91dHB1dHNcbiAqIGVtcHR5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBfdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZWQgPSBOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiBpc05hTihwYXJzZWQpID8gdmFsdWUgOiBwYXJzZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyBib29sZWFuIGxpdGVyYWxzIGludG8gcmVhbCBib29sZWFucy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfEJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTdHJpcCBxdW90ZXMgZnJvbSBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZyB8IGZhbHNlfVxuICovXG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHN0cikge1xuICB2YXIgYSA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGEgPT09IGIgJiYgKGEgPT09IDB4MjIgfHwgYSA9PT0gMHgyNykgPyBzdHIuc2xpY2UoMSwgLTEpIDogc3RyO1xufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcik7XG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBoeXBoZW4vdW5kZXJzY29yZS9zbGFzaCBkZWxpbWl0ZXJlZCBuYW1lcyBpbnRvXG4gKiBjYW1lbGl6ZWQgY2xhc3NOYW1lcy5cbiAqXG4gKiBlLmcuIG15LWNvbXBvbmVudCA9PiBNeUNvbXBvbmVudFxuICogICAgICBzb21lX2Vsc2UgICAgPT4gU29tZUVsc2VcbiAqICAgICAgc29tZS9jb21wICAgID0+IFNvbWVDb21wXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXFwvXSkoXFx3KS9nO1xuXG5mdW5jdGlvbiBjbGFzc2lmeShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBmcm9tKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG59XG5cbi8qKlxuICogQXJyYXkgdHlwZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudW1lcmFibGVdXG4gKi9cblxuZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gc28gaXQgb25seSBnZXRzIGNhbGxlZCBhZnRlciB0aGVcbiAqIGlucHV0IHN0b3BzIGFycml2aW5nIGFmdGVyIHRoZSBnaXZlbiB3YWl0IHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge051bWJlcn0gd2FpdFxuICogQHJldHVybiB7RnVuY3Rpb259IC0gdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIF9kZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyLCBvYmopIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogTWFrZSBhIGNhbmNlbGxhYmxlIHZlcnNpb24gb2YgYW4gYXN5bmMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNhbmNlbGxhYmxlKGZuKSB7XG4gIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gY2I7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICByZXR1cm4gYSA9PSBiIHx8IChpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSA6IGZhbHNlKTtcbiAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbn1cblxudmFyIGhhc1Byb3RvID0gKCdfX3Byb3RvX18nIGluIHt9KTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8vIFVBIHNuaWZmaW5nIGZvciB3b3JraW5nIGFyb3VuZCBicm93c2VyLXNwZWNpZmljIHF1aXJrc1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIFVBLmluZGV4T2YoJ3RyaWRlbnQnKSA+IDA7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSW9zID0gVUEgJiYgLyhpcGhvbmV8aXBhZHxpcG9kfGlvcykvaS50ZXN0KFVBKTtcbnZhciBpb3NWZXJzaW9uTWF0Y2ggPSBpc0lvcyAmJiBVQS5tYXRjaCgvb3MgKFtcXGRfXSspLyk7XG52YXIgaW9zVmVyc2lvbiA9IGlvc1ZlcnNpb25NYXRjaCAmJiBpb3NWZXJzaW9uTWF0Y2hbMV0uc3BsaXQoJ18nKTtcblxuLy8gZGV0ZWN0aW5nIGlPUyBVSVdlYlZpZXcgYnkgaW5kZXhlZERCXG52YXIgaGFzTXV0YXRpb25PYnNlcnZlckJ1ZyA9IGlvc1ZlcnNpb24gJiYgTnVtYmVyKGlvc1ZlcnNpb25bMF0pID49IDkgJiYgTnVtYmVyKGlvc1ZlcnNpb25bMV0pID49IDMgJiYgIXdpbmRvdy5pbmRleGVkREI7XG5cbnZhciB0cmFuc2l0aW9uUHJvcCA9IHVuZGVmaW5lZDtcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uUHJvcCA9IHVuZGVmaW5lZDtcbnZhciBhbmltYXRpb25FbmRFdmVudCA9IHVuZGVmaW5lZDtcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xuaWYgKGluQnJvd3NlciAmJiAhaXNJRTkpIHtcbiAgdmFyIGlzV2Via2l0VHJhbnMgPSB3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXNXZWJraXRBbmltID0gd2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gIHRyYW5zaXRpb25Qcm9wID0gaXNXZWJraXRUcmFucyA/ICdXZWJraXRUcmFuc2l0aW9uJyA6ICd0cmFuc2l0aW9uJztcbiAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gaXNXZWJraXRUcmFucyA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcbiAgYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbSA/ICdXZWJraXRBbmltYXRpb24nIDogJ2FuaW1hdGlvbic7XG4gIGFuaW1hdGlvbkVuZEV2ZW50ID0gaXNXZWJraXRBbmltID8gJ3dlYmtpdEFuaW1hdGlvbkVuZCcgOiAnYW5pbWF0aW9uZW5kJztcbn1cblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS4gSWRlYWxseSB0aGlzXG4gKiBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSBtaWNyb3Rhc2ssIHNvIHdlIGxldmVyYWdlXG4gKiBNdXRhdGlvbk9ic2VydmVyIGlmIGl0J3MgYXZhaWxhYmxlLCBhbmQgZmFsbGJhY2sgdG9cbiAqIHNldFRpbWVvdXQoMCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqL1xuXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlcigpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIWhhc011dGF0aW9uT2JzZXJ2ZXJCdWcpIHtcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb3VudGVyKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IGNvdW50ZXI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZWJwYWNrIGF0dGVtcHRzIHRvIGluamVjdCBhIHNoaW0gZm9yIHNldEltbWVkaWF0ZVxuICAgIC8vIGlmIGl0IGlzIHVzZWQgYXMgYSBnbG9iYWwsIHNvIHdlIGhhdmUgdG8gd29yayBhcm91bmQgdGhhdCB0b1xuICAgIC8vIGF2b2lkIGJ1bmRsaW5nIHVubmVjZXNzYXJ5IGNvZGUuXG4gICAgdmFyIGNvbnRleHQgPSBpbkJyb3dzZXIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xuICAgIHRpbWVyRnVuYyA9IGNvbnRleHQuc2V0SW1tZWRpYXRlIHx8IHNldFRpbWVvdXQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHggPyBmdW5jdGlvbiAoKSB7XG4gICAgICBjYi5jYWxsKGN0eCk7XG4gICAgfSA6IGNiO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICAgIGlmIChwZW5kaW5nKSByZXR1cm47XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMCk7XG4gIH07XG59KSgpO1xuXG52YXIgX1NldCA9IHVuZGVmaW5lZDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIFNldC50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzLnNldFtrZXldID0gMTtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBDYWNoZShsaW1pdCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fa2V5bWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxudmFyIHAgPSBDYWNoZS5wcm90b3R5cGU7XG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgcmVtb3ZlZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgcmVtb3ZlZCA9IHRoaXMuc2hpZnQoKTtcbiAgICB9XG4gICAgZW50cnkgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeTtcbiAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTtcbiAgICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB9XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5zaXplKys7XG4gIH1cbiAgZW50cnkudmFsdWUgPSB2YWx1ZTtcblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gIGlmIChlbnRyeSkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXdlcjtcbiAgICB0aGlzLmhlYWQub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9rZXltYXBbZW50cnkua2V5XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNpemUtLTtcbiAgfVxuICByZXR1cm4gZW50cnk7XG59O1xuXG4vKipcbiAqIEdldCBhbmQgcmVnaXN0ZXIgcmVjZW50IHVzZSBvZiA8a2V5Pi4gUmV0dXJucyB0aGUgdmFsdWVcbiAqIGFzc29jaWF0ZWQgd2l0aCA8a2V5PiBvciB1bmRlZmluZWQgaWYgbm90IGluIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRW50cnlcbiAqIEByZXR1cm4ge0VudHJ5fCp9XG4gKi9cblxucC5nZXQgPSBmdW5jdGlvbiAoa2V5LCByZXR1cm5FbnRyeSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9rZXltYXBba2V5XTtcbiAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xuICB9XG4gIC8vIEhFQUQtLS0tLS0tLS0tLS0tLVRBSUxcbiAgLy8gICA8Lm9sZGVyICAgLm5ld2VyPlxuICAvLyAgPC0tLSBhZGQgZGlyZWN0aW9uIC0tXG4gIC8vICAgQSAgQiAgQyAgPEQ+ICBFXG4gIGlmIChlbnRyeS5uZXdlcikge1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjsgLy8gQyA8LS0gRS5cbiAgfVxuICBpZiAoZW50cnkub2xkZXIpIHtcbiAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyOyAvLyBDLiAtLT4gRVxuICB9XG4gIGVudHJ5Lm5ld2VyID0gdW5kZWZpbmVkOyAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDsgLy8gRC4gLS0+IEVcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5OyAvLyBFLiA8LS0gRFxuICB9XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xufTtcblxudmFyIGNhY2hlJDEgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nO1xudmFyIHJlc2VydmVkQXJnUkUgPSAvXmluJHxeLT9cXGQrLztcblxuLyoqXG4gKiBQYXJzZXIgc3RhdGVcbiAqL1xuXG52YXIgc3RyO1xudmFyIGRpcjtcbnZhciBjO1xudmFyIHByZXY7XG52YXIgaTtcbnZhciBsO1xudmFyIGxhc3RGaWx0ZXJJbmRleDtcbnZhciBpblNpbmdsZTtcbnZhciBpbkRvdWJsZTtcbnZhciBjdXJseTtcbnZhciBzcXVhcmU7XG52YXIgcGFyZW47XG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gIHZhciBleHAgPSBzdHIuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCk7XG4gIHZhciBmaWx0ZXI7XG4gIGlmIChleHApIHtcbiAgICBmaWx0ZXIgPSB7fTtcbiAgICB2YXIgdG9rZW5zID0gZXhwLm1hdGNoKGZpbHRlclRva2VuUkUpO1xuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgZmlsdGVyLmFyZ3MgPSB0b2tlbnMuc2xpY2UoMSkubWFwKHByb2Nlc3NGaWx0ZXJBcmcpO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyKSB7XG4gICAgKGRpci5maWx0ZXJzID0gZGlyLmZpbHRlcnMgfHwgW10pLnB1c2goZmlsdGVyKTtcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhcmd1bWVudCBpcyBkeW5hbWljIGFuZCBzdHJpcCBxdW90ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NGaWx0ZXJBcmcoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdG9OdW1iZXIoYXJnKSxcbiAgICAgIGR5bmFtaWM6IGZhbHNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhhcmcpO1xuICAgIHZhciBkeW5hbWljID0gc3RyaXBwZWQgPT09IGFyZztcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGR5bmFtaWMgPyBhcmcgOiBzdHJpcHBlZCxcbiAgICAgIGR5bmFtaWM6IGR5bmFtaWNcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKHMpIHtcbiAgdmFyIGhpdCA9IGNhY2hlJDEuZ2V0KHMpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIC8vIHJlc2V0IHBhcnNlciBzdGF0ZVxuICBzdHIgPSBzO1xuICBpblNpbmdsZSA9IGluRG91YmxlID0gZmFsc2U7XG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwO1xuICBsYXN0RmlsdGVySW5kZXggPSAwO1xuICBkaXIgPSB7fTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIC8vIGNoZWNrIHNpbmdsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgaW5TaW5nbGUgPSAhaW5TaW5nbGU7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgLy8gY2hlY2sgZG91YmxlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSBpbkRvdWJsZSA9ICFpbkRvdWJsZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJiBzdHIuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MpIHtcbiAgICAgIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFscmVhZHkgaGFzIGZpbHRlclxuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6XG4gICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO2JyZWFrOyAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6XG4gICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO2JyZWFrOyAvLyAnXG4gICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICBwYXJlbisrO2JyZWFrOyAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICBwYXJlbi0tO2JyZWFrOyAvLyApXG4gICAgICAgIGNhc2UgMHg1QjpcbiAgICAgICAgICBzcXVhcmUrKzticmVhazsgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6XG4gICAgICAgICAgc3F1YXJlLS07YnJlYWs7IC8vIF1cbiAgICAgICAgY2FzZSAweDdCOlxuICAgICAgICAgIGN1cmx5Kys7YnJlYWs7IC8vIHtcbiAgICAgICAgY2FzZSAweDdEOlxuICAgICAgICAgIGN1cmx5LS07YnJlYWs7IC8vIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBjYWNoZSQxLnB1dChzLCBkaXIpO1xuICByZXR1cm4gZGlyO1xufVxuXG52YXIgZGlyZWN0aXZlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRGlyZWN0aXZlOiBwYXJzZURpcmVjdGl2ZVxufSk7XG5cbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbnZhciBjYWNoZSA9IHVuZGVmaW5lZDtcbnZhciB0YWdSRSA9IHVuZGVmaW5lZDtcbnZhciBodG1sUkUgPSB1bmRlZmluZWQ7XG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBzbyBpdCBjYW4gYmUgdXNlZCBpbiBhIFJlZ0V4cFxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlUmVnZXgoKSB7XG4gIHZhciBvcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMF0pO1xuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSk7XG4gIHZhciB1bnNhZmVPcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMF0pO1xuICB2YXIgdW5zYWZlQ2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1sxXSk7XG4gIHRhZ1JFID0gbmV3IFJlZ0V4cCh1bnNhZmVPcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyB1bnNhZmVDbG9zZSArICd8JyArIG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpO1xuICBodG1sUkUgPSBuZXcgUmVnRXhwKCdeJyArIHVuc2FmZU9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIHVuc2FmZUNsb3NlICsgJyQnKTtcbiAgLy8gcmVzZXQgY2FjaGVcbiAgY2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRleHQodGV4dCkge1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY29tcGlsZVJlZ2V4KCk7XG4gIH1cbiAgdmFyIGhpdCA9IGNhY2hlLmdldCh0ZXh0KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgaHRtbCwgdmFsdWUsIGZpcnN0LCBvbmVUaW1lO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKTtcbiAgICB2YWx1ZSA9IGh0bWwgPyBtYXRjaFsxXSA6IG1hdGNoWzJdO1xuICAgIGZpcnN0ID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyOyAvLyAqXG4gICAgdmFsdWUgPSBvbmVUaW1lID8gdmFsdWUuc2xpY2UoMSkgOiB2YWx1ZTtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgpXG4gICAgfSk7XG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2Vucyk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbGlzdCBvZiB0b2tlbnMgaW50byBhbiBleHByZXNzaW9uLlxuICogZS5nLiB0b2tlbnMgcGFyc2VkIGZyb20gJ2Ege3tifX0gYycgY2FuIGJlIHNlcmlhbGl6ZWRcbiAqIGludG8gb25lIHNpbmdsZSBleHByZXNzaW9uIGFzICdcImEgXCIgKyBiICsgXCIgY1wiJy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5zVG9FeHAodG9rZW5zLCB2bSkge1xuICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbiwgdm0pO1xuICAgIH0pLmpvaW4oJysnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW5zWzBdLCB2bSwgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzaW5nbGUgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2luZ2xlXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFRva2VuKHRva2VuLCB2bSwgc2luZ2xlKSB7XG4gIHJldHVybiB0b2tlbi50YWcgPyB0b2tlbi5vbmVUaW1lICYmIHZtID8gJ1wiJyArIHZtLiRldmFsKHRva2VuLnZhbHVlKSArICdcIicgOiBpbmxpbmVGaWx0ZXJzKHRva2VuLnZhbHVlLCBzaW5nbGUpIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJztcbn1cblxuLyoqXG4gKiBGb3IgYW4gYXR0cmlidXRlIHdpdGggbXVsdGlwbGUgaW50ZXJwb2xhdGlvbiB0YWdzLFxuICogZS5nLiBhdHRyPVwic29tZS17e3RoaW5nIHwgZmlsdGVyfX1cIiwgaW4gb3JkZXIgdG8gY29tYmluZVxuICogdGhlIHdob2xlIHRoaW5nIGludG8gYSBzaW5nbGUgd2F0Y2hhYmxlIGV4cHJlc3Npb24sIHdlXG4gKiBoYXZlIHRvIGlubGluZSB0aG9zZSBmaWx0ZXJzLiBUaGlzIGZ1bmN0aW9uIGRvZXMgZXhhY3RseVxuICogdGhhdC4gVGhpcyBpcyBhIGJpdCBoYWNreSBidXQgaXQgYXZvaWRzIGhlYXZ5IGNoYW5nZXNcbiAqIHRvIGRpcmVjdGl2ZSBwYXJzZXIgYW5kIHdhdGNoZXIgbWVjaGFuaXNtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGZpbHRlclJFID0gL1tefF1cXHxbXnxdLztcbmZ1bmN0aW9uIGlubGluZUZpbHRlcnMoZXhwLCBzaW5nbGUpIHtcbiAgaWYgKCFmaWx0ZXJSRS50ZXN0KGV4cCkpIHtcbiAgICByZXR1cm4gc2luZ2xlID8gZXhwIDogJygnICsgZXhwICsgJyknO1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZShleHApO1xuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndGhpcy5fYXBwbHlGaWx0ZXJzKCcgKyBkaXIuZXhwcmVzc2lvbiArIC8vIHZhbHVlXG4gICAgICAnLG51bGwsJyArIC8vIG9sZFZhbHVlIChudWxsIGZvciByZWFkKVxuICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAnLGZhbHNlKSc7IC8vIHdyaXRlP1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICBjb21waWxlUmVnZXg6IGNvbXBpbGVSZWdleCxcbiAgcGFyc2VUZXh0OiBwYXJzZVRleHQsXG4gIHRva2Vuc1RvRXhwOiB0b2tlbnNUb0V4cFxufSk7XG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddO1xudmFyIHVuc2FmZURlbGltaXRlcnMgPSBbJ3t7eycsICd9fX0nXTtcblxudmFyIGNvbmZpZyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBkZXZ0b29scyBpbnNwZWN0aW9uLlxuICAgKiBEaXNhYmxlZCBieSBkZWZhdWx0IGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgKi9cblxuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdlbGVtZW50RGlyZWN0aXZlJywgJ2ZpbHRlcicsICd0cmFuc2l0aW9uJywgJ3BhcnRpYWwnXSxcblxuICAvKipcbiAgICogcHJvcCBiaW5kaW5nIG1vZGVzXG4gICAqL1xuXG4gIF9wcm9wQmluZGluZ01vZGVzOiB7XG4gICAgT05FX1dBWTogMCxcbiAgICBUV09fV0FZOiAxLFxuICAgIE9ORV9USU1FOiAyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBiYXRjaGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cblxuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxuXG59LCB7XG4gIGRlbGltaXRlcnM6IHsgLyoqXG4gICAgICAgICAgICAgICAgICogSW50ZXJwb2xhdGlvbiBkZWxpbWl0ZXJzLiBDaGFuZ2luZyB0aGVzZSB3b3VsZCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQgcGFyc2VyIHRvIHJlLWNvbXBpbGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAgICAgICAgICAgICAgICAgKi9cblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIGRlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIHVuc2FmZURlbGltaXRlcnM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB1bnNhZmVEZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICB1bnNhZmVEZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHdhcm4gPSB1bmRlZmluZWQ7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IHVuZGVmaW5lZDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxuICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1Z1ZSB3YXJuXTogJyArIG1zZyArICh2bSA/IGZvcm1hdENvbXBvbmVudE5hbWUodm0pIDogJycpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5faXNWdWUgPyB2bS4kb3B0aW9ucy5uYW1lIDogdm0ubmFtZTtcbiAgICAgIHJldHVybiBuYW1lID8gJyAoZm91bmQgaW4gY29tcG9uZW50OiA8JyArIGh5cGhlbmF0ZShuYW1lKSArICc+KScgOiAnJztcbiAgICB9O1xuICB9KSgpO1xufVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZFdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZVdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVXaXRoVHJhbnNpdGlvbihlbCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgLTEsIGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmUoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEFwcGx5IHRyYW5zaXRpb25zIHdpdGggYW4gb3BlcmF0aW9uIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgMTogZW50ZXJcbiAqICAgICAgICAgICAgICAgICAtMTogbGVhdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gdGhlIGFjdHVhbCBET00gb3BlcmF0aW9uXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zaXRpb24oZWwsIGRpcmVjdGlvbiwgb3AsIHZtLCBjYikge1xuICB2YXIgdHJhbnNpdGlvbiA9IGVsLl9fdl90cmFucztcbiAgaWYgKCF0cmFuc2l0aW9uIHx8XG4gIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAvLyBub3Qgc3VwcG9ydGVkXG4gICF0cmFuc2l0aW9uLmhvb2tzICYmICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCB0cmFuc2l0aW9ucyBmb3IgaW5pdGlhbCBjb21waWxlXG4gICF2bS5faXNDb21waWxlZCB8fFxuICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgbWFuaXB1bGF0ZWQgYnkgYSBwYXJlbnQgZGlyZWN0aXZlXG4gIC8vIGR1cmluZyB0aGUgcGFyZW50J3MgY29tcGlsYXRpb24gcGhhc2UsIHNraXAgdGhlXG4gIC8vIGFuaW1hdGlvbi5cbiAgdm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZCkge1xuICAgIG9wKCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYWN0aW9uID0gZGlyZWN0aW9uID4gMCA/ICdlbnRlcicgOiAnbGVhdmUnO1xuICB0cmFuc2l0aW9uW2FjdGlvbl0ob3AsIGNiKTtcbn1cblxudmFyIHRyYW5zaXRpb24gPSBPYmplY3QuZnJlZXplKHtcbiAgYXBwZW5kV2l0aFRyYW5zaXRpb246IGFwcGVuZFdpdGhUcmFuc2l0aW9uLFxuICBiZWZvcmVXaXRoVHJhbnNpdGlvbjogYmVmb3JlV2l0aFRyYW5zaXRpb24sXG4gIHJlbW92ZVdpdGhUcmFuc2l0aW9uOiByZW1vdmVXaXRoVHJhbnNpdGlvbixcbiAgYXBwbHlUcmFuc2l0aW9uOiBhcHBseVRyYW5zaXRpb25cbn0pO1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWw7XG4gICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBzZWxlY3Rvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICogTm90ZTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zIHNob3VsZCB3b3JrIGhlcmVcbiAqIGJ1dCBhbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgY29tbWVudCBub2RlcyBpbiBwaGFudG9tanMsXG4gKiBtYWtpbmcgdW5pdCB0ZXN0cyBkaWZmaWN1bHQuIFRoaXMgaXMgZml4ZWQgYnkgZG9pbmcgdGhlXG4gKiBjb250YWlucygpIGNoZWNrIG9uIHRoZSBub2RlJ3MgcGFyZW50Tm9kZSBpbnN0ZWFkIG9mXG4gKiB0aGUgbm9kZSBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGluRG9jKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gZG9jID09PSBub2RlIHx8IGRvYyA9PT0gcGFyZW50IHx8ICEhKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEgJiYgZG9jLmNvbnRhaW5zKHBhcmVudCkpO1xufVxuXG4vKipcbiAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBfYXR0clxuICovXG5cbmZ1bmN0aW9uIGdldEF0dHIobm9kZSwgX2F0dHIpIHtcbiAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKF9hdHRyKTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEdldCBhbiBhdHRyaWJ1dGUgd2l0aCBjb2xvbiBvciB2LWJpbmQ6IHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRCaW5kQXR0cihub2RlLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBnZXRBdHRyKG5vZGUsICc6JyArIG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdmFsID0gZ2V0QXR0cihub2RlLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIENoZWNrIHRoZSBwcmVzZW5jZSBvZiBhIGJpbmQgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzQmluZEF0dHIobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJzonICsgbmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtYmluZDonICsgbmFtZSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGJlZm9yZSB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZShlbCwgdGFyZ2V0KSB7XG4gIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYWZ0ZXIgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBhZnRlcihlbCwgdGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5uZXh0U2libGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGVsIGZyb20gRE9NXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuLyoqXG4gKiBQcmVwZW5kIGVsIHRvIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gcHJlcGVuZChlbCwgdGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQuZmlyc3RDaGlsZCkge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIHRhcmdldCB3aXRoIGVsXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlKHRhcmdldCwgZWwpIHtcbiAgdmFyIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAqL1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGNiLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiLCB1c2VDYXB0dXJlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBjYikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYik7XG59XG5cbi8qKlxuICogRm9yIElFOSBjb21wYXQ6IHdoZW4gYm90aCBjbGFzcyBhbmQgOmNsYXNzIGFyZSBwcmVzZW50XG4gKiBnZXRBdHRyaWJ1dGUoJ2NsYXNzJykgcmV0dXJucyB3cm9uZyB2YWx1ZS4uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xuICB2YXIgY2xhc3NuYW1lID0gZWwuY2xhc3NOYW1lO1xuICBpZiAodHlwZW9mIGNsYXNzbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjbGFzc25hbWUgPSBjbGFzc25hbWUuYmFzZVZhbCB8fCAnJztcbiAgfVxuICByZXR1cm4gY2xhc3NuYW1lO1xufVxuXG4vKipcbiAqIEluIElFOSwgc2V0QXR0cmlidXRlKCdjbGFzcycpIHdpbGwgcmVzdWx0IGluIGVtcHR5IGNsYXNzXG4gKiBpZiB0aGUgZWxlbWVudCBhbHNvIGhhcyB0aGUgOmNsYXNzIGF0dHJpYnV0ZTsgSG93ZXZlciBpblxuICogUGhhbnRvbUpTLCBzZXR0aW5nIGBjbGFzc05hbWVgIGRvZXMgbm90IHdvcmsgb24gU1ZHIGVsZW1lbnRzLi4uXG4gKiBTbyB3ZSBoYXZlIHRvIGRvIGEgY29uZGl0aW9uYWwgY2hlY2sgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmICEvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xzO1xuICB9IGVsc2Uge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBnZXRDbGFzcyhlbCkgKyAnICc7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBzZXRDbGFzcyhlbCwgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGdldENsYXNzKGVsKSArICcgJztcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgc2V0Q2xhc3MoZWwsIGN1ci50cmltKCkpO1xuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCByYXcgY29udGVudCBpbnNpZGUgYW4gZWxlbWVudCBpbnRvIGEgdGVtcG9yYXJ5XG4gKiBjb250YWluZXIgZGl2XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBhc0ZyYWdtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnQoZWwsIGFzRnJhZ21lbnQpIHtcbiAgdmFyIGNoaWxkO1xuICB2YXIgcmF3Q29udGVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1RlbXBsYXRlKGVsKSAmJiBpc0ZyYWdtZW50KGVsLmNvbnRlbnQpKSB7XG4gICAgZWwgPSBlbC5jb250ZW50O1xuICB9XG4gIGlmIChlbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB0cmltTm9kZShlbCk7XG4gICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnQgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIHJhd0NvbnRlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3Q29udGVudDtcbn1cblxuLyoqXG4gKiBUcmltIHBvc3NpYmxlIGVtcHR5IGhlYWQvdGFpbCB0ZXh0IGFuZCBjb21tZW50XG4gKiBub2RlcyBpbnNpZGUgYSBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cblxuZnVuY3Rpb24gdHJpbU5vZGUobm9kZSkge1xuICB2YXIgY2hpbGQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlcXVlbmNlcyAqL1xuICB3aGlsZSAoKGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUubGFzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZXF1ZW5jZXMgKi9cbn1cblxuZnVuY3Rpb24gaXNUcmltbWFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZS5kYXRhLnRyaW0oKSB8fCBub2RlLm5vZGVUeXBlID09PSA4KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgdGVtcGxhdGUgdGFnLlxuICogTm90ZSBpZiB0aGUgdGVtcGxhdGUgYXBwZWFycyBpbnNpZGUgYW4gU1ZHIGl0cyB0YWdOYW1lXG4gKiB3aWxsIGJlIGluIGxvd2VyY2FzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZSc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIFwiYW5jaG9yXCIgZm9yIHBlcmZvcm1pbmcgZG9tIGluc2VydGlvbi9yZW1vdmFscy5cbiAqIFRoaXMgaXMgdXNlZCBpbiBhIG51bWJlciBvZiBzY2VuYXJpb3M6XG4gKiAtIGZyYWdtZW50IGluc3RhbmNlXG4gKiAtIHYtaHRtbFxuICogLSB2LWlmXG4gKiAtIHYtZm9yXG4gKiAtIGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBlcnNpc3QgLSBJRSB0cmFzaGVzIGVtcHR5IHRleHROb2RlcyBvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVOb2RlKHRydWUpLCBzbyBpbiBjZXJ0YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlcyB0aGUgYW5jaG9yIG5lZWRzIHRvIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub24tZW1wdHkgdG8gYmUgcGVyc2lzdGVkIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuXG4gKiBAcmV0dXJuIHtDb21tZW50fFRleHR9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQW5jaG9yKGNvbnRlbnQsIHBlcnNpc3QpIHtcbiAgdmFyIGFuY2hvciA9IGNvbmZpZy5kZWJ1ZyA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCkgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwZXJzaXN0ID8gJyAnIDogJycpO1xuICBhbmNob3IuX192X2FuY2hvciA9IHRydWU7XG4gIHJldHVybiBhbmNob3I7XG59XG5cbi8qKlxuICogRmluZCBhIGNvbXBvbmVudCByZWYgYXR0cmlidXRlIHRoYXQgc3RhcnRzIHdpdGggJC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxudmFyIHJlZlJFID0gL152LXJlZjovO1xuXG5mdW5jdGlvbiBmaW5kUmVmKG5vZGUpIHtcbiAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgdmFyIGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAocmVmUkUudGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gY2FtZWxpemUobmFtZS5yZXBsYWNlKHJlZlJFLCAnJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZnVuY3Rpb24gbWFwTm9kZVJhbmdlKG5vZGUsIGVuZCwgb3ApIHtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlIChub2RlICE9PSBlbmQpIHtcbiAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBvcChub2RlKTtcbiAgICBub2RlID0gbmV4dDtcbiAgfVxuICBvcChlbmQpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIHZtLCBmcmFnLCBjYikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVtb3ZlZCA9IDA7XG4gIHZhciBub2RlcyA9IFtdO1xuICBtYXBOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZW5kKSBkb25lID0gdHJ1ZTtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIHJlbW92ZVdpdGhUcmFuc2l0aW9uKG5vZGUsIHZtLCBvblJlbW92ZWQpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25SZW1vdmVkKCkge1xuICAgIHJlbW92ZWQrKztcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNGcmFnbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgfVxufVxuXG52YXIgY29tbW9uVGFnUkUgPSAvXihkaXZ8cHxzcGFufGltZ3xhfGJ8aXxicnx1bHxvbHxsaXxoMXxoMnxoM3xoNHxoNXxoNnxjb2RlfHByZXx0YWJsZXx0aHx0ZHx0cnxmb3JtfGxhYmVsfGlucHV0fHNlbGVjdHxvcHRpb258bmF2fGFydGljbGV8c2VjdGlvbnxoZWFkZXJ8Zm9vdGVyKSQvaTtcbnZhciByZXNlcnZlZFRhZ1JFID0gL14oc2xvdHxwYXJ0aWFsfGNvbXBvbmVudCkkL2k7XG5cbnZhciBpc1Vua25vd25FbGVtZW50ID0gdW5kZWZpbmVkO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaXNVbmtub3duRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgdGFnKSB7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgcmV0dXJuIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8IGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSAmJlxuICAgICAgICAvLyBDaHJvbWUgcmV0dXJucyB1bmtub3duIGZvciBzZXZlcmFsIEhUTUw1IGVsZW1lbnRzLlxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTQwNTI2XG4gICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyB1bmtub3duIGZvciBzb21lIFwiSW50ZXJhY3RpdmUgZWxlbWVudHMuXCJcbiAgICAgICAgIS9eKGRhdGF8dGltZXxydGN8cmJ8ZGV0YWlsc3xkaWFsb2d8c3VtbWFyeSkkLy50ZXN0KHRhZylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgaWYgKCFjb21tb25UYWdSRS50ZXN0KHRhZykgJiYgIXJlc2VydmVkVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpIHtcbiAgICAgIHJldHVybiB7IGlkOiB0YWcgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzID0gaGFzQXR0cnMgJiYgZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXM7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkVGFnID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCAmJiBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwW3RhZ107XG4gICAgICAgIGlmIChleHBlY3RlZFRhZykge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSAnICsgJ2RpZCB5b3UgbWVhbiA8JyArIGV4cGVjdGVkVGFnICsgJz4/ICcgKyAnSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2Uga2ViYWItY2FzZSBpbiB0ZW1wbGF0ZXMuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmtub3duRWxlbWVudChlbCwgdGFnKSkge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgKyAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc0F0dHJzKSB7XG4gICAgcmV0dXJuIGdldElzQmluZGluZyhlbCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgXCJpc1wiIGJpbmRpbmcgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldElzQmluZGluZyhlbCwgb3B0aW9ucykge1xuICAvLyBkeW5hbWljIHN5bnRheFxuICB2YXIgZXhwID0gZWwuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgZXhwKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgcmV0dXJuIHsgaWQ6IGV4cCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHAgPSBnZXRCaW5kQXR0cihlbCwgJ2lzJyk7XG4gICAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyBpZDogZXhwLCBkeW5hbWljOiB0cnVlIH07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICpcbiAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0geyp9IHBhcmVudFZhbFxuICogQHBhcmFtIHsqfSBjaGlsZFZhbFxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqL1xuXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tKSB7XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICBmb3IgKGtleSBpbiBmcm9tKSB7XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRvVmFsKSAmJiBpc09iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKGNoaWxkVmFsLmNhbGwodGhpcyksIHBhcmVudFZhbC5jYWxsKHRoaXMpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh2bSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbFxuICovXG5cbnN0cmF0cy5lbCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtICYmIGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZWxcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmV0ID0gY2hpbGRWYWwgfHwgcGFyZW50VmFsO1xuICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gIHJldHVybiB2bSAmJiB0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nID8gcmV0LmNhbGwodm0pIDogcmV0O1xufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcGFyYW0gYXR0cmlidXRlcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuXG5zdHJhdHMuaW5pdCA9IHN0cmF0cy5jcmVhdGVkID0gc3RyYXRzLnJlYWR5ID0gc3RyYXRzLmF0dGFjaGVkID0gc3RyYXRzLmRldGFjaGVkID0gc3RyYXRzLmJlZm9yZUNvbXBpbGUgPSBzdHJhdHMuY29tcGlsZWQgPSBzdHJhdHMuYmVmb3JlRGVzdHJveSA9IHN0cmF0cy5kZXN0cm95ZWQgPSBzdHJhdHMuYWN0aXZhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKSA6IGlzQXJyYXkoY2hpbGRWYWwpID8gY2hpbGRWYWwgOiBbY2hpbGRWYWxdIDogcGFyZW50VmFsO1xufTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyhwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsID8gZXh0ZW5kKHJlcywgZ3VhcmRBcnJheUFzc2V0cyhjaGlsZFZhbCkpIDogcmVzO1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIEV2ZW50cyAmIFdhdGNoZXJzLlxuICpcbiAqIEV2ZW50cyAmIHdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy53YXRjaCA9IHN0cmF0cy5ldmVudHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIWlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50ID8gcGFyZW50LmNvbmNhdChjaGlsZCkgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cblxuc3RyYXRzLnByb3BzID0gc3RyYXRzLm1ldGhvZHMgPSBzdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgY29tcG9uZW50IG9wdGlvbnMgZ2V0IGNvbnZlcnRlZCB0byBhY3R1YWxcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cyA9IGd1YXJkQXJyYXlBc3NldHMob3B0aW9ucy5jb21wb25lbnRzKTtcbiAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgdmFyIGRlZjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hcCA9IG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXAgPSB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgICAgaWYgKGNvbW1vblRhZ1JFLnRlc3Qoa2V5KSB8fCByZXNlcnZlZFRhZ1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gcmVjb3JkIGEgYWxsIGxvd2VyY2FzZSA8LT4ga2ViYWItY2FzZSBtYXBwaW5nIGZvclxuICAgICAgLy8gcG9zc2libGUgY3VzdG9tIGVsZW1lbnQgY2FzZSBlcnJvciB3YXJuaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtYXBba2V5LnJlcGxhY2UoLy0vZywgJycpLnRvTG93ZXJDYXNlKCldID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICB9XG4gICAgICBkZWYgPSBjb21wb25lbnRzW2tleV07XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChkZWYpKSB7XG4gICAgICAgIGNvbXBvbmVudHNba2V5XSA9IFZ1ZS5leHRlbmQoZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBndWFyZFByb3BzKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgdmFyIGksIHZhbDtcbiAgaWYgKGlzQXJyYXkocHJvcHMpKSB7XG4gICAgb3B0aW9ucy5wcm9wcyA9IHt9O1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9wc1t2YWxdID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodmFsLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9wc1t2YWwubmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleXNbaV1dO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHNba2V5c1tpXV0gPSB7IHR5cGU6IHZhbCB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEd1YXJkIGFuIEFycmF5LWZvcm1hdCBhc3NldHMgb3B0aW9uIGFuZCBjb252ZXJ0ZWQgaXRcbiAqIGludG8gdGhlIGtleS12YWx1ZSBPYmplY3QgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhc3NldHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBndWFyZEFycmF5QXNzZXRzKGFzc2V0cykge1xuICBpZiAoaXNBcnJheShhc3NldHMpKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpID0gYXNzZXRzLmxlbmd0aDtcbiAgICB2YXIgYXNzZXQ7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXNzZXQgPSBhc3NldHNbaV07XG4gICAgICB2YXIgaWQgPSB0eXBlb2YgYXNzZXQgPT09ICdmdW5jdGlvbicgPyBhc3NldC5vcHRpb25zICYmIGFzc2V0Lm9wdGlvbnMubmFtZSB8fCBhc3NldC5pZCA6IGFzc2V0Lm5hbWUgfHwgYXNzZXQuaWQ7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXJyYXktc3ludGF4IGFzc2V0cyBtdXN0IHByb3ZpZGUgYSBcIm5hbWVcIiBvciBcImlkXCIgZmllbGQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNbaWRdID0gYXNzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIGFzc2V0cztcbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtIHtWdWV9IFt2bV0gLSBpZiB2bSBpcyBwcmVzZW50LCBpbmRpY2F0ZXMgdGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICBhbiBpbnN0YW50aWF0aW9uIG1lcmdlLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBndWFyZENvbXBvbmVudHMoY2hpbGQpO1xuICBndWFyZFByb3BzKGNoaWxkKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY2hpbGQucHJvcHNEYXRhICYmICF2bSkge1xuICAgICAgd2FybigncHJvcHNEYXRhIGNhbiBvbmx5IGJlIHVzZWQgYXMgYW4gaW5zdGFudGlhdGlvbiBvcHRpb24uJyk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGlmIChjaGlsZFsnZXh0ZW5kcyddKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGNoaWxkWydleHRlbmRzJ10gPT09ICdmdW5jdGlvbicgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZFsnZXh0ZW5kcyddLm9wdGlvbnMsIHZtKSA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkWydleHRlbmRzJ10sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICB2YXIgbWl4aW5PcHRpb25zID0gbWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlID8gbWl4aW4ub3B0aW9ucyA6IG1peGluO1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW5PcHRpb25zLCB2bSk7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdhcm5NaXNzaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R8RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkLCB3YXJuTWlzc2luZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIHZhciBjYW1lbGl6ZWRJZDtcbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHxcbiAgLy8gY2FtZWxDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKV0gfHxcbiAgLy8gUGFzY2FsIENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGVwKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG5cbi8qKlxuICogQWRkIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yik7XG59O1xuXG4vKipcbiAqIEFkZCBzZWxmIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGFyZ2V0IHdhdGNoZXIuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xufTtcblxuLyoqXG4gKiBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIG9mIGEgbmV3IHZhbHVlLlxuICovXG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFibGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdG9BcnJheSh0aGlzLnN1YnMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJywgJ3NvcnQnLCAncmV2ZXJzZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IoKSB7XG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIGEgbmV3IHZhbHVlXG4gKiBhbmQgZW1pdHMgY29ycmVzcG9uZGluZyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHsqfSAtIHJlcGxhY2VkIGVsZW1lbnRcbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRzZXQnLCBmdW5jdGlvbiAkc2V0KGluZGV4LCB2YWwpIHtcbiAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhpcy5sZW5ndGggPSBOdW1iZXIoaW5kZXgpICsgMTtcbiAgfVxuICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEsIHZhbClbMF07XG59KTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGF0IGdpdmVuIGluZGV4IG9yIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0geyp9IGl0ZW1cbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRyZW1vdmUnLCBmdW5jdGlvbiAkcmVtb3ZlKGl0ZW0pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdGhpcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLCBpdGVtKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59KTtcblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIGluIGNlcnRhaW4gY2FzZXMsIGUuZy5cbiAqIHYtZm9yIHNjb3BlIGFsaWFzIGFuZCBwcm9wcywgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uXG4gKiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWUgdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogU28gd2hlbmV2ZXIgd2Ugd2FudCB0byBzZXQgYSByZWFjdGl2ZSBwcm9wZXJ0eSB3aXRob3V0IGZvcmNpbmdcbiAqIGNvbnZlcnNpb24gb24gdGhlIG5ldyB2YWx1ZSwgd2Ugd3JhcCB0aGF0IGNhbGwgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gKi9cblxudmFyIHNob3VsZENvbnZlcnQgPSB0cnVlO1xuXG5mdW5jdGlvbiB3aXRob3V0Q29udmVyc2lvbihmbikge1xuICBzaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gIGZuKCk7XG4gIHNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90byA/IHByb3RvQXVnbWVudCA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jb252ZXJ0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICogdGhlIGV2ZW50cyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC9jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgZGVmaW5lUmVhY3RpdmUodGhpcy52YWx1ZSwga2V5LCB2YWwpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gb3duZXIgdm0sIHNvIHRoYXQgd2hlbiAkc2V0LyRkZWxldGUgbXV0YXRpb25zXG4gKiBoYXBwZW4gd2UgY2FuIG5vdGlmeSBvd25lciB2bXMgdG8gcHJveHkgdGhlIGtleXMgYW5kXG4gKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICogaXMgb2JzZXJ2ZWQgYXMgYW4gaW5zdGFuY2UncyByb290ICRkYXRhLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uICh2bSkge1xuICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKTtcbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqL1xuXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvXG4gKi9cblxuZnVuY3Rpb24gY29weUF1Z21lbnQodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAqIEBzdGF0aWNcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCB2bSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChzaG91bGRDb252ZXJ0ICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiYgIXZhbHVlLl9pc1Z1ZSkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAob2IgJiYgdm0pIHtcbiAgICBvYi5hZGRWbSh2bSk7XG4gIH1cbiAgcmV0dXJuIG9iO1xufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5cbnZhciB1dGlsID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSxcblx0c2V0OiBzZXQsXG5cdGRlbDogZGVsLFxuXHRoYXNPd246IGhhc093bixcblx0aXNMaXRlcmFsOiBpc0xpdGVyYWwsXG5cdGlzUmVzZXJ2ZWQ6IGlzUmVzZXJ2ZWQsXG5cdF90b1N0cmluZzogX3RvU3RyaW5nLFxuXHR0b051bWJlcjogdG9OdW1iZXIsXG5cdHRvQm9vbGVhbjogdG9Cb29sZWFuLFxuXHRzdHJpcFF1b3Rlczogc3RyaXBRdW90ZXMsXG5cdGNhbWVsaXplOiBjYW1lbGl6ZSxcblx0aHlwaGVuYXRlOiBoeXBoZW5hdGUsXG5cdGNsYXNzaWZ5OiBjbGFzc2lmeSxcblx0YmluZDogYmluZCxcblx0dG9BcnJheTogdG9BcnJheSxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0aXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcblx0ZGVmOiBkZWYsXG5cdGRlYm91bmNlOiBfZGVib3VuY2UsXG5cdGluZGV4T2Y6IGluZGV4T2YsXG5cdGNhbmNlbGxhYmxlOiBjYW5jZWxsYWJsZSxcblx0bG9vc2VFcXVhbDogbG9vc2VFcXVhbCxcblx0aXNBcnJheTogaXNBcnJheSxcblx0aGFzUHJvdG86IGhhc1Byb3RvLFxuXHRpbkJyb3dzZXI6IGluQnJvd3Nlcixcblx0ZGV2dG9vbHM6IGRldnRvb2xzLFxuXHRpc0lFOiBpc0lFLFxuXHRpc0lFOTogaXNJRTksXG5cdGlzQW5kcm9pZDogaXNBbmRyb2lkLFxuXHRpc0lvczogaXNJb3MsXG5cdGlvc1ZlcnNpb25NYXRjaDogaW9zVmVyc2lvbk1hdGNoLFxuXHRpb3NWZXJzaW9uOiBpb3NWZXJzaW9uLFxuXHRoYXNNdXRhdGlvbk9ic2VydmVyQnVnOiBoYXNNdXRhdGlvbk9ic2VydmVyQnVnLFxuXHRnZXQgdHJhbnNpdGlvblByb3AgKCkgeyByZXR1cm4gdHJhbnNpdGlvblByb3A7IH0sXG5cdGdldCB0cmFuc2l0aW9uRW5kRXZlbnQgKCkgeyByZXR1cm4gdHJhbnNpdGlvbkVuZEV2ZW50OyB9LFxuXHRnZXQgYW5pbWF0aW9uUHJvcCAoKSB7IHJldHVybiBhbmltYXRpb25Qcm9wOyB9LFxuXHRnZXQgYW5pbWF0aW9uRW5kRXZlbnQgKCkgeyByZXR1cm4gYW5pbWF0aW9uRW5kRXZlbnQ7IH0sXG5cdG5leHRUaWNrOiBuZXh0VGljayxcblx0Z2V0IF9TZXQgKCkgeyByZXR1cm4gX1NldDsgfSxcblx0cXVlcnk6IHF1ZXJ5LFxuXHRpbkRvYzogaW5Eb2MsXG5cdGdldEF0dHI6IGdldEF0dHIsXG5cdGdldEJpbmRBdHRyOiBnZXRCaW5kQXR0cixcblx0aGFzQmluZEF0dHI6IGhhc0JpbmRBdHRyLFxuXHRiZWZvcmU6IGJlZm9yZSxcblx0YWZ0ZXI6IGFmdGVyLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0cHJlcGVuZDogcHJlcGVuZCxcblx0cmVwbGFjZTogcmVwbGFjZSxcblx0b246IG9uLFxuXHRvZmY6IG9mZixcblx0c2V0Q2xhc3M6IHNldENsYXNzLFxuXHRhZGRDbGFzczogYWRkQ2xhc3MsXG5cdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcblx0ZXh0cmFjdENvbnRlbnQ6IGV4dHJhY3RDb250ZW50LFxuXHR0cmltTm9kZTogdHJpbU5vZGUsXG5cdGlzVGVtcGxhdGU6IGlzVGVtcGxhdGUsXG5cdGNyZWF0ZUFuY2hvcjogY3JlYXRlQW5jaG9yLFxuXHRmaW5kUmVmOiBmaW5kUmVmLFxuXHRtYXBOb2RlUmFuZ2U6IG1hcE5vZGVSYW5nZSxcblx0cmVtb3ZlTm9kZVJhbmdlOiByZW1vdmVOb2RlUmFuZ2UsXG5cdGlzRnJhZ21lbnQ6IGlzRnJhZ21lbnQsXG5cdGdldE91dGVySFRNTDogZ2V0T3V0ZXJIVE1MLFxuXHRtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcblx0cmVzb2x2ZUFzc2V0OiByZXNvbHZlQXNzZXQsXG5cdGNoZWNrQ29tcG9uZW50QXR0cjogY2hlY2tDb21wb25lbnRBdHRyLFxuXHRjb21tb25UYWdSRTogY29tbW9uVGFnUkUsXG5cdHJlc2VydmVkVGFnUkU6IHJlc2VydmVkVGFnUkUsXG5cdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm47IH1cbn0pO1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFRoZSBtYWluIGluaXQgc2VxdWVuY2UuIFRoaXMgaXMgY2FsbGVkIGZvciBldmVyeVxuICAgKiBpbnN0YW5jZSwgaW5jbHVkaW5nIG9uZXMgdGhhdCBhcmUgY3JlYXRlZCBmcm9tIGV4dGVuZGVkXG4gICAqIGNvbnN0cnVjdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGlzIG9wdGlvbnMgb2JqZWN0IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYW5kIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgdGhpcy4kcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy4kcm9vdCA9IHRoaXMuJHBhcmVudCA/IHRoaXMuJHBhcmVudC4kcm9vdCA6IHRoaXM7XG4gICAgdGhpcy4kY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLiRyZWZzID0ge307IC8vIGNoaWxkIHZtIHJlZmVyZW5jZXNcbiAgICB0aGlzLiRlbHMgPSB7fTsgLy8gZWxlbWVudCByZWZlcmVuY2VzXG4gICAgdGhpcy5fd2F0Y2hlcnMgPSBbXTsgLy8gYWxsIHdhdGNoZXJzIGFzIGFuIGFycmF5XG4gICAgdGhpcy5fZGlyZWN0aXZlcyA9IFtdOyAvLyBhbGwgZGlyZWN0aXZlc1xuXG4gICAgLy8gYSB1aWRcbiAgICB0aGlzLl91aWQgPSB1aWQrKztcblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdGhpcy5faXNWdWUgPSB0cnVlO1xuXG4gICAgLy8gZXZlbnRzIGJvb2trZWVwaW5nXG4gICAgdGhpcy5fZXZlbnRzID0ge307IC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzXG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSB7fTsgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBmcmFnbWVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5faXNGcmFnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZyYWdtZW50ID0gLy8gQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgdGhpcy5fZnJhZ21lbnRTdGFydCA9IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG4gICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBudWxsOyAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuXG4gICAgLy8gbGlmZWN5Y2xlIHN0YXRlXG4gICAgdGhpcy5faXNDb21waWxlZCA9IHRoaXMuX2lzRGVzdHJveWVkID0gdGhpcy5faXNSZWFkeSA9IHRoaXMuX2lzQXR0YWNoZWQgPSB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdGhpcy5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fdW5saW5rRm4gPSBudWxsO1xuXG4gICAgLy8gY29udGV4dDpcbiAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgLy8gYW5kIGl0cyBob3N0LlxuICAgIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLl9jb250ZXh0IHx8IHRoaXMuJHBhcmVudDtcblxuICAgIC8vIHNjb3BlOlxuICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICB0aGlzLl9zY29wZSA9IG9wdGlvbnMuX3Njb3BlO1xuXG4gICAgLy8gZnJhZ21lbnQ6XG4gICAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgICAvLyBuZWVkcyB0byByZWlnc3RlciBpdHNlbGYgYXMgYSBjaGlsZCBvZiB0aGF0IGZyYWdtZW50XG4gICAgLy8gZm9yIGF0dGFjaC9kZXRhY2ggdG8gd29yayBwcm9wZXJseS5cbiAgICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZztcbiAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgdGhpcy5fZnJhZy5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIHB1c2ggc2VsZiBpbnRvIHBhcmVudCAvIHRyYW5zY2x1c2lvbiBob3N0XG4gICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50LiRjaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIG1lcmdlIG9wdGlvbnMuXG4gICAgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLCBvcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIHNldCByZWZcbiAgICB0aGlzLl91cGRhdGVSZWYoKTtcblxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBhcyBlbXB0eSBvYmplY3QuXG4gICAgLy8gaXQgd2lsbCBiZSBmaWxsZWQgdXAgaW4gX2luaXREYXRhKCkuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgLy8gY2FsbCBpbml0IGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnaW5pdCcpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9ic2VydmF0aW9uIGFuZCBzY29wZSBpbmhlcml0YW5jZS5cbiAgICB0aGlzLl9pbml0U3RhdGUoKTtcblxuICAgIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdjcmVhdGVkJyk7XG5cbiAgICAvLyBpZiBgZWxgIG9wdGlvbiBpcyBwYXNzZWQsIHN0YXJ0IGNvbXBpbGF0aW9uLlxuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLiRtb3VudChvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYXRoQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbi8vIGFjdGlvbnNcbnZhciBBUFBFTkQgPSAwO1xudmFyIFBVU0ggPSAxO1xudmFyIElOQ19TVUJfUEFUSF9ERVBUSCA9IDI7XG52YXIgUFVTSF9TVUJfUEFUSCA9IDM7XG5cbi8vIHN0YXRlc1xudmFyIEJFRk9SRV9QQVRIID0gMDtcbnZhciBJTl9QQVRIID0gMTtcbnZhciBCRUZPUkVfSURFTlQgPSAyO1xudmFyIElOX0lERU5UID0gMztcbnZhciBJTl9TVUJfUEFUSCA9IDQ7XG52YXIgSU5fU0lOR0xFX1FVT1RFID0gNTtcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA2O1xudmFyIEFGVEVSX1BBVEggPSA3O1xudmFyIEVSUk9SID0gODtcblxudmFyIHBhdGhTdGF0ZU1hY2hpbmUgPSBbXTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfUEFUSF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfUEFUSF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfSURFTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0lERU5UXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0lERU5UXSA9IHtcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnMCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ3dzJzogW0lOX1BBVEgsIFBVU0hdLFxuICAnLic6IFtCRUZPUkVfSURFTlQsIFBVU0hdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgUFVTSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSCwgUFVTSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU1VCX1BBVEhdID0ge1xuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1wiJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIElOQ19TVUJfUEFUSF9ERVBUSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hfU1VCX1BBVEhdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0RPVUJMRV9RVU9URV0gPSB7XG4gICdcIic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUoY2gpIHtcbiAgaWYgKGNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2VvZic7XG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDVCOiAvLyBbXG4gICAgY2FzZSAweDVEOiAvLyBdXG4gICAgY2FzZSAweDJFOiAvLyAuXG4gICAgY2FzZSAweDIyOiAvLyBcIlxuICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgIGNhc2UgMHgzMDpcbiAgICAgIC8vIDBcbiAgICAgIHJldHVybiBjaDtcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDpcbiAgICAgIC8vICRcbiAgICAgIHJldHVybiAnaWRlbnQnO1xuXG4gICAgY2FzZSAweDIwOiAvLyBTcGFjZVxuICAgIGNhc2UgMHgwOTogLy8gVGFiXG4gICAgY2FzZSAweDBBOiAvLyBOZXdsaW5lXG4gICAgY2FzZSAweDBEOiAvLyBSZXR1cm5cbiAgICBjYXNlIDB4QTA6IC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgY2FzZSAweEZFRkY6IC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAvLyBMaW5lIFNlcGFyYXRvclxuICAgIGNhc2UgMHgyMDI5OlxuICAgICAgLy8gUGFyYWdyYXBoIFNlcGFyYXRvclxuICAgICAgcmV0dXJuICd3cyc7XG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3QSB8fCBjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVBKSB7XG4gICAgcmV0dXJuICdpZGVudCc7XG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICByZXR1cm4gJ2Vsc2UnO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIHN1YlBhdGgsIHJldHVybiBpdHMgcGxhaW4gZm9ybSBpZiBpdCBpc1xuICogYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuIE90aGVyd2lzZSBwcmVwZW5kIHRoZVxuICogZHluYW1pYyBpbmRpY2F0b3IgKCopLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0U3ViUGF0aChwYXRoKSB7XG4gIHZhciB0cmltbWVkID0gcGF0aC50cmltKCk7XG4gIC8vIGludmFsaWQgbGVhZGluZyAwXG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJzAnICYmIGlzTmFOKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0xpdGVyYWwodHJpbW1lZCkgPyBzdHJpcFF1b3Rlcyh0cmltbWVkKSA6ICcqJyArIHRyaW1tZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbW9kZSA9IEJFRk9SRV9QQVRIO1xuICB2YXIgc3ViUGF0aERlcHRoID0gMDtcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwO1xuXG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgYWN0aW9uc1tQVVNIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0FQUEVORF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSBuZXdDaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhcjtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tJTkNfU1VCX1BBVEhfREVQVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIHN1YlBhdGhEZXB0aCsrO1xuICB9O1xuXG4gIGFjdGlvbnNbUFVTSF9TVUJfUEFUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN1YlBhdGhEZXB0aCA+IDApIHtcbiAgICAgIHN1YlBhdGhEZXB0aC0tO1xuICAgICAgbW9kZSA9IElOX1NVQl9QQVRIO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgICBrZXkgPSBmb3JtYXRTdWJQYXRoKGtleSk7XG4gICAgICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25zW1BVU0hdKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSgpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBwYXRoW2luZGV4ICsgMV07XG4gICAgaWYgKG1vZGUgPT09IElOX1NJTkdMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gXCInXCIgfHwgbW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgbmV3Q2hhciA9ICdcXFxcJyArIG5leHRDaGFyO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gcGF0aFtpbmRleF07XG5cbiAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpO1xuICAgIHR5cGVNYXAgPSBwYXRoU3RhdGVNYWNoaW5lW21vZGVdO1xuICAgIHRyYW5zaXRpb24gPSB0eXBlTWFwW3R5cGVdIHx8IHR5cGVNYXBbJ2Vsc2UnXSB8fCBFUlJPUjtcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuOyAvLyBwYXJzZSBlcnJvclxuICAgIH1cblxuICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgIGFjdGlvbiA9IGFjdGlvbnNbdHJhbnNpdGlvblsxXV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl07XG4gICAgICBuZXdDaGFyID0gbmV3Q2hhciA9PT0gdW5kZWZpbmVkID8gYyA6IG5ld0NoYXI7XG4gICAgICBpZiAoYWN0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBoaXQgPSBwYXRoQ2FjaGUuZ2V0KHBhdGgpO1xuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgIGlmIChoaXQpIHtcbiAgICAgIHBhdGhDYWNoZS5wdXQocGF0aCwgaGl0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhpdDtcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoKG9iaiwgcGF0aCkge1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKHBhdGgpLmdldChvYmopO1xufVxuXG4vKipcbiAqIFdhcm4gYWdhaW5zdCBzZXR0aW5nIG5vbi1leGlzdGVudCByb290IHBhdGggb24gYSB2bS5cbiAqL1xuXG52YXIgd2Fybk5vbkV4aXN0ZW50O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2Fybk5vbkV4aXN0ZW50ID0gZnVuY3Rpb24gKHBhdGgsIHZtKSB7XG4gICAgd2FybignWW91IGFyZSBzZXR0aW5nIGEgbm9uLWV4aXN0ZW50IHBhdGggXCInICsgcGF0aC5yYXcgKyAnXCIgJyArICdvbiBhIHZtIGluc3RhbmNlLiBDb25zaWRlciBwcmUtaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSAnICsgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgKyAnYW5kIGJldHRlciBwZXJmb3JtYW5jZS4nLCB2bSk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0IG9uIGFuIG9iamVjdCBmcm9tIGEgcGF0aFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gc2V0UGF0aChvYmosIHBhdGgsIHZhbCkge1xuICB2YXIgb3JpZ2luYWwgPSBvYmo7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gcGFyc2UocGF0aCk7XG4gIH1cbiAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0LCBrZXk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsYXN0ID0gb2JqO1xuICAgIGtleSA9IHBhdGhbaV07XG4gICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgICAga2V5ID0gcGFyc2VFeHByZXNzaW9uKGtleS5zbGljZSgxKSkuZ2V0LmNhbGwob3JpZ2luYWwsIG9yaWdpbmFsKTtcbiAgICB9XG4gICAgaWYgKGkgPCBsIC0gMSkge1xuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGxhc3QuX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgsIGxhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHNldChsYXN0LCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqLiRzZXQoa2V5LCB2YWwpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb2JqLl9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHNldChvYmosIGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBwYXRoID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlUGF0aDogcGFyc2VQYXRoLFxuICBnZXRQYXRoOiBnZXRQYXRoLFxuICBzZXRQYXRoOiBzZXRQYXRoXG59KTtcblxudmFyIGV4cHJlc3Npb25DYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxudmFyIGFsbG93ZWRLZXl3b3JkcyA9ICdNYXRoLERhdGUsdGhpcyx0cnVlLGZhbHNlLG51bGwsdW5kZWZpbmVkLEluZmluaXR5LE5hTiwnICsgJ2lzTmFOLGlzRmluaXRlLGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLCcgKyAnZW5jb2RlVVJJQ29tcG9uZW50LHBhcnNlSW50LHBhcnNlRmxvYXQnO1xudmFyIGFsbG93ZWRLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG4vLyBrZXl3b3JkcyB0aGF0IGRvbid0IG1ha2Ugc2Vuc2UgaW5zaWRlIGV4cHJlc3Npb25zXG52YXIgaW1wcm9wZXJLZXl3b3JkcyA9ICdicmVhayxjYXNlLGNsYXNzLGNhdGNoLGNvbnN0LGNvbnRpbnVlLGRlYnVnZ2VyLGRlZmF1bHQsJyArICdkZWxldGUsZG8sZWxzZSxleHBvcnQsZXh0ZW5kcyxmaW5hbGx5LGZvcixmdW5jdGlvbixpZiwnICsgJ2ltcG9ydCxpbixpbnN0YW5jZW9mLGxldCxyZXR1cm4sc3VwZXIsc3dpdGNoLHRocm93LHRyeSwnICsgJ3Zhcix3aGlsZSx3aXRoLHlpZWxkLGVudW0sYXdhaXQsaW1wbGVtZW50cyxwYWNrYWdlLCcgKyAncHJvdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnO1xudmFyIGltcHJvcGVyS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGltcHJvcGVyS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbnZhciB3c1JFID0gL1xccy9nO1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZztcbnZhciBzYXZlUkUgPSAvW1xceyxdXFxzKltcXHdcXCRfXStcXHMqOnwoJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmApfG5ldyB8dHlwZW9mIHx2b2lkIC9nO1xudmFyIHJlc3RvcmVSRSA9IC9cIihcXGQrKVwiL2c7XG52YXIgcGF0aFRlc3RSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J1xcXXxcXFtcIi4qP1wiXFxdfFxcW1xcZCtcXF18XFxbW0EtWmEtel8kXVtcXHckXSpcXF0pKiQvO1xudmFyIGlkZW50UkUgPSAvW15cXHckXFwuXSg/OltBLVphLXpfJF1bXFx3JF0qKS9nO1xudmFyIGxpdGVyYWxWYWx1ZVJFJDEgPSAvXig/OnRydWV8ZmFsc2V8bnVsbHx1bmRlZmluZWR8SW5maW5pdHl8TmFOKSQvO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXTtcblxuLyoqXG4gKiBTYXZlIHJlcGxhY2VyXG4gKlxuICogVGhlIHNhdmUgcmVnZXggY2FuIG1hdGNoIHR3byBwb3NzaWJsZSBjYXNlczpcbiAqIDEuIEFuIG9wZW5pbmcgb2JqZWN0IGxpdGVyYWxcbiAqIDIuIEEgc3RyaW5nXG4gKiBJZiBtYXRjaGVkIGFzIGEgcGxhaW4gc3RyaW5nLCB3ZSBuZWVkIHRvIGVzY2FwZSBpdHNcbiAqIG5ld2xpbmVzLCBzaW5jZSB0aGUgc3RyaW5nIG5lZWRzIHRvIGJlIHByZXNlcnZlZCB3aGVuXG4gKiBnZW5lcmF0aW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpc1N0cmluZyAtIHN0ciBpZiBtYXRjaGVkIGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gcGxhY2Vob2xkZXIgd2l0aCBpbmRleFxuICovXG5cbmZ1bmN0aW9uIHNhdmUoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aDtcbiAgc2F2ZWRbaV0gPSBpc1N0cmluZyA/IHN0ci5yZXBsYWNlKG5ld2xpbmVSRSwgJ1xcXFxuJykgOiBzdHI7XG4gIHJldHVybiAnXCInICsgaSArICdcIic7XG59XG5cbi8qKlxuICogUGF0aCByZXdyaXRlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJld3JpdGUocmF3KSB7XG4gIHZhciBjID0gcmF3LmNoYXJBdCgwKTtcbiAgdmFyIHBhdGggPSByYXcuc2xpY2UoMSk7XG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gcGF0aC5pbmRleE9mKCdcIicpID4gLTEgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKSA6IHBhdGg7XG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN0b3JlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGkgLSBtYXRjaGVkIHNhdmUgaW5kZXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV07XG59XG5cbi8qKlxuICogUmV3cml0ZSBhbiBleHByZXNzaW9uLCBwcmVmaXhpbmcgYWxsIHBhdGggYWNjZXNzb3JzIHdpdGhcbiAqIGBzY29wZS5gIGFuZCBnZW5lcmF0ZSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlR2V0dGVyKGV4cCkge1xuICBpZiAoaW1wcm9wZXJLZXl3b3Jkc1JFLnRlc3QoZXhwKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbiAgLy8gcmVzZXQgc3RhdGVcbiAgc2F2ZWQubGVuZ3RoID0gMDtcbiAgLy8gc2F2ZSBzdHJpbmdzIGFuZCBvYmplY3QgbGl0ZXJhbCBrZXlzXG4gIHZhciBib2R5ID0gZXhwLnJlcGxhY2Uoc2F2ZVJFLCBzYXZlKS5yZXBsYWNlKHdzUkUsICcnKTtcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdXNlIHRoZSByZWdleCBtYXRjaGVzIDEgZXh0cmEgY2hhclxuICBib2R5ID0gKCcgJyArIGJvZHkpLnJlcGxhY2UoaWRlbnRSRSwgcmV3cml0ZSkucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpO1xuICByZXR1cm4gbWFrZUdldHRlckZuKGJvZHkpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZ2V0dGVyIGZ1bmN0aW9uLiBSZXF1aXJlcyBldmFsLlxuICpcbiAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAqIG9wdGltaXphdGlvbiBvZiB0aGUgcGFyc2UgZnVuY3Rpb24gd2hlbiBpdCBpcyBub3QgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gbWFrZUdldHRlckZuKGJvZHkpIHtcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7Jyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgZGVmYXVsdCBidWlsZCBvZiBWdWUuanMgaW4gYW4gZW52aXJvbm1lbnQgJyArICd3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICsgJ1VzZSB0aGUgQ1NQLWNvbXBsaWFudCBidWlsZCBpbnN0ZWFkOiAnICsgJ2h0dHA6Ly92dWVqcy5vcmcvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWwjQ1NQLWNvbXBsaWFudC1idWlsZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybignSW52YWxpZCBleHByZXNzaW9uLiAnICsgJ0dlbmVyYXRlZCBmdW5jdGlvbiBib2R5OiAnICsgYm9keSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub29wO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVTZXR0ZXIoZXhwKSB7XG4gIHZhciBwYXRoID0gcGFyc2VQYXRoKGV4cCk7XG4gIGlmIChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgdmFsKSB7XG4gICAgICBzZXRQYXRoKHNjb3BlLCBwYXRoLCB2YWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHNldHRlciBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gaW50byByZS13cml0dGVuIGdldHRlci9zZXR0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpO1xuICAvLyB0cnkgY2FjaGVcbiAgdmFyIGhpdCA9IGV4cHJlc3Npb25DYWNoZS5nZXQoZXhwKTtcbiAgaWYgKGhpdCkge1xuICAgIGlmIChuZWVkU2V0ICYmICFoaXQuc2V0KSB7XG4gICAgICBoaXQuc2V0ID0gY29tcGlsZVNldHRlcihoaXQuZXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICB2YXIgcmVzID0geyBleHA6IGV4cCB9O1xuICByZXMuZ2V0ID0gaXNTaW1wbGVQYXRoKGV4cCkgJiYgZXhwLmluZGV4T2YoJ1snKSA8IDBcbiAgLy8gb3B0aW1pemVkIHN1cGVyIHNpbXBsZSBnZXR0ZXJcbiAgPyBtYWtlR2V0dGVyRm4oJ3Njb3BlLicgKyBleHApXG4gIC8vIGR5bmFtaWMgZ2V0dGVyXG4gIDogY29tcGlsZUdldHRlcihleHApO1xuICBpZiAobmVlZFNldCkge1xuICAgIHJlcy5zZXQgPSBjb21waWxlU2V0dGVyKGV4cCk7XG4gIH1cbiAgZXhwcmVzc2lvbkNhY2hlLnB1dChleHAsIHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIHNpbXBsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKGV4cCkge1xuICByZXR1cm4gcGF0aFRlc3RSRS50ZXN0KGV4cCkgJiZcbiAgLy8gZG9uJ3QgdHJlYXQgbGl0ZXJhbCB2YWx1ZXMgYXMgcGF0aHNcbiAgIWxpdGVyYWxWYWx1ZVJFJDEudGVzdChleHApICYmXG4gIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgZXhwLnNsaWNlKDAsIDUpICE9PSAnTWF0aC4nO1xufVxuXG52YXIgZXhwcmVzc2lvbiA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZUV4cHJlc3Npb246IHBhcnNlRXhwcmVzc2lvbixcbiAgaXNTaW1wbGVQYXRoOiBpc1NpbXBsZVBhdGhcbn0pO1xuXG4vLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbi8vIGFuZCBvbmUgZm9yIHVzZXIgd2F0Y2hlciByZWdpc3RlcmVkIHZpYSAkd2F0Y2goKS5cbi8vIHdlIHdhbnQgdG8gZ3VhcmFudGVlIGRpcmVjdGl2ZSB1cGRhdGVzIHRvIGJlIGNhbGxlZFxuLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4vLyB0cmlnZ2VyZWQsIHRoZSBET00gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gaW4gdXBkYXRlZFxuLy8gc3RhdGUuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIHVzZXJRdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBiYXRjaGVyJ3Mgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRCYXRjaGVyU3RhdGUoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIHVzZXJRdWV1ZS5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgY2lyY3VsYXIgPSB7fTtcbiAgd2FpdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlKCkge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSk7XG4gICAgcnVuQmF0Y2hlclF1ZXVlKHVzZXJRdWV1ZSk7XG4gICAgLy8gdXNlciB3YXRjaGVycyB0cmlnZ2VyZWQgbW9yZSB3YXRjaGVycyxcbiAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRlcGxldGVzXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICB9XG4gICAgLy8gZGV2IHRvb2wgaG9va1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgfVxuICAgIHJlc2V0QmF0Y2hlclN0YXRlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cblxuZnVuY3Rpb24gcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKSB7XG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybignWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wIGZvciB3YXRjaGVyICcgKyAnd2l0aCBleHByZXNzaW9uIFwiJyArIHdhdGNoZXIuZXhwcmVzc2lvbiArICdcIicsIHdhdGNoZXIudm0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqXG4gKiBAcGFyYW0ge1dhdGNoZXJ9IHdhdGNoZXJcbiAqICAgcHJvcGVydGllczpcbiAqICAgLSB7TnVtYmVyfSBpZFxuICogICAtIHtGdW5jdGlvbn0gcnVuXG4gKi9cblxuZnVuY3Rpb24gcHVzaFdhdGNoZXIod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgLy8gcHVzaCB3YXRjaGVyIGludG8gYXBwcm9wcmlhdGUgcXVldWVcbiAgICB2YXIgcSA9IHdhdGNoZXIudXNlciA/IHVzZXJRdWV1ZSA6IHF1ZXVlO1xuICAgIGhhc1tpZF0gPSBxLmxlbmd0aDtcbiAgICBxLnB1c2god2F0Y2hlcik7XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoQmF0Y2hlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHR3b1dheVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gc3luY1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxhenlcbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3ByZVByb2Nlc3NdXG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwb3N0UHJvY2Vzc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAvLyBtaXggaW4gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgaXNGbiA9IHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nO1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuO1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5wcmV2RXJyb3IgPSBudWxsOyAvLyBmb3IgYXN5bmMgZXJyb3Igc3RhY2tzXG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlci9zZXR0ZXJcbiAgaWYgKGlzRm4pIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgdGhpcy5zZXR0ZXIgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHBPckZuLCB0aGlzLnR3b1dheSk7XG4gICAgdGhpcy5nZXR0ZXIgPSByZXMuZ2V0O1xuICAgIHRoaXMuc2V0dGVyID0gcmVzLnNldDtcbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5ID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoKTtcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKTtcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZSB8fCB0aGlzLnZtO1xuICB2YXIgdmFsdWU7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHNjb3BlLCBzY29wZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBleHByZXNzaW9uICcgKyAnXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiOiAnICsgZS50b1N0cmluZygpLCB0aGlzLnZtKTtcbiAgICB9XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLnByZVByb2Nlc3MpIHtcbiAgICB2YWx1ZSA9IHRoaXMucHJlUHJvY2Vzcyh2YWx1ZSk7XG4gIH1cbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHRoaXMucG9zdFByb2Nlc3MpIHtcbiAgICB2YWx1ZSA9IHRoaXMucG9zdFByb2Nlc3ModmFsdWUpO1xuICB9XG4gIHRoaXMuYWZ0ZXJHZXQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZSB8fCB0aGlzLnZtO1xuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKHZhbHVlLCB0aGlzLnZhbHVlLCB0aGlzLmZpbHRlcnMsIHRydWUpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhpcy5zZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUsIHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgd2FybignRXJyb3Igd2hlbiBldmFsdWF0aW5nIHNldHRlciAnICsgJ1wiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIjogJyArIGUudG9TdHJpbmcoKSwgdGhpcy52bSk7XG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dDtcbiAgaWYgKGZvckNvbnRleHQgJiYgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uKSB7XG4gICAgaWYgKGZvckNvbnRleHQuZmlsdGVycykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHR3by13YXkgYmluZGluZyBvbiAnICsgJ2Egdi1mb3IgYWxpYXMgKCcgKyB0aGlzLmV4cHJlc3Npb24gKyAnKSwgYW5kIHRoZSAnICsgJ3YtZm9yIGhhcyBmaWx0ZXJzLiBUaGlzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkuICcgKyAnRWl0aGVyIHJlbW92ZSB0aGUgZmlsdGVycyBvciB1c2UgYW4gYXJyYXkgb2YgJyArICdvYmplY3RzIGFuZCBiaW5kIHRvIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvckNvbnRleHQuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAgIC8vIG9yaWdpbmFsIGlzIGFuIG9iamVjdFxuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlW3Njb3BlLiRrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJlcGFyZSBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtEZXB9IGRlcFxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFmdGVyR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvd1xuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgcXVldWVkLCBvbmx5IG92ZXJ3cml0ZSBzaGFsbG93IHdpdGggbm9uLXNoYWxsb3csXG4gICAgLy8gYnV0IG5vdCB0aGUgb3RoZXIgd2F5IGFyb3VuZC5cbiAgICB0aGlzLnNoYWxsb3cgPSB0aGlzLnF1ZXVlZCA/IHNoYWxsb3cgPyB0aGlzLnNoYWxsb3cgOiBmYWxzZSA6ICEhc2hhbGxvdztcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWU7XG4gICAgLy8gcmVjb3JkIGJlZm9yZS1wdXNoIGVycm9yIHN0YWNrIGluIGRlYnVnIG1vZGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcpIHtcbiAgICAgIHRoaXMucHJldkVycm9yID0gbmV3IEVycm9yKCdbdnVlXSBhc3luYyBzdGFjayB0cmFjZScpO1xuICAgIH1cbiAgICBwdXNoV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgLy8gbm9uLXNoYWxsb3cgdXBkYXRlIChjYXVzZWQgYnkgYSB2bSBkaWdlc3QpLlxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gaW4gZGVidWcgKyBhc3luYyBtb2RlLCB3aGVuIGEgd2F0Y2hlciBjYWxsYmFja3NcbiAgICAgIC8vIHRocm93cywgd2UgYWxzbyB0aHJvdyB0aGUgc2F2ZWQgYmVmb3JlLXB1c2ggZXJyb3JcbiAgICAgIC8vIHNvIHRoZSBmdWxsIGNyb3NzLXRpY2sgc3RhY2sgdHJhY2UgaXMgYXZhaWxhYmxlLlxuICAgICAgdmFyIHByZXZFcnJvciA9IHRoaXMucHJldkVycm9yO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcgJiYgcHJldkVycm9yKSB7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHByZXZFcnJvcjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGF2b2lkIG92ZXJ3cml0aW5nIGFub3RoZXIgd2F0Y2hlciB0aGF0IGlzIGJlaW5nXG4gIC8vIGNvbGxlY3RlZC5cbiAgdmFyIGN1cnJlbnQgPSBEZXAudGFyZ2V0O1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBEZXAudGFyZ2V0ID0gY3VycmVudDtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJjcmliZXIgbGlzdC5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkIG9yIGlzIHBlcmZvcm1pbmcgYSB2LWZvclxuICAgIC8vIHJlLXJlbmRlciAodGhlIHdhdGNoZXIgbGlzdCBpcyB0aGVuIGZpbHRlcmVkIGJ5IHYtZm9yKS5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXRoaXMudm0uX3ZGb3JSZW1vdmluZykge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy52bSA9IHRoaXMuY2IgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UodmFsLCBzZWVuKSB7XG4gIHZhciBpID0gdW5kZWZpbmVkLFxuICAgICAga2V5cyA9IHVuZGVmaW5lZDtcbiAgaWYgKCFzZWVuKSB7XG4gICAgc2VlbiA9IHNlZW5PYmplY3RzO1xuICAgIHNlZW4uY2xlYXIoKTtcbiAgfVxuICB2YXIgaXNBID0gaXNBcnJheSh2YWwpO1xuICB2YXIgaXNPID0gaXNPYmplY3QodmFsKTtcbiAgaWYgKChpc0EgfHwgaXNPKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQSkge1xuICAgICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICAgIH0gZWxzZSBpZiAoaXNPKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0JDEgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmF0dHIgPSB0aGlzLmVsLm5vZGVUeXBlID09PSAzID8gJ2RhdGEnIDogJ3RleHRDb250ZW50JztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWxbdGhpcy5hdHRyXSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gIH1cbn07XG5cbnZhciB0ZW1wbGF0ZUNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxudmFyIG1hcCA9IHtcbiAgZWZhdWx0OiBbMCwgJycsICcnXSxcbiAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgdHI6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuICBjb2w6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddXG59O1xuXG5tYXAudGQgPSBtYXAudGggPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxubWFwLm9wdGlvbiA9IG1hcC5vcHRncm91cCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cIm11bHRpcGxlXCI+JywgJzwvc2VsZWN0PiddO1xuXG5tYXAudGhlYWQgPSBtYXAudGJvZHkgPSBtYXAuY29sZ3JvdXAgPSBtYXAuY2FwdGlvbiA9IG1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAuZyA9IG1hcC5kZWZzID0gbWFwLnN5bWJvbCA9IG1hcC51c2UgPSBtYXAuaW1hZ2UgPSBtYXAudGV4dCA9IG1hcC5jaXJjbGUgPSBtYXAuZWxsaXBzZSA9IG1hcC5saW5lID0gbWFwLnBhdGggPSBtYXAucG9seWdvbiA9IG1hcC5wb2x5bGluZSA9IG1hcC5yZWN0ID0gWzEsICc8c3ZnICcgKyAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcgKyAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyArICd4bWxuczpldj1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50c1wiJyArICd2ZXJzaW9uPVwiMS4xXCI+JywgJzwvc3ZnPiddO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICogRG9jdW1lbnRGcmFnbWVudCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZShub2RlKSB7XG4gIHJldHVybiBpc1RlbXBsYXRlKG5vZGUpICYmIGlzRnJhZ21lbnQobm9kZS5jb250ZW50KTtcbn1cblxudmFyIHRhZ1JFJDEgPSAvPChbXFx3Oi1dKykvO1xudmFyIGVudGl0eVJFID0gLyYjP1xcdys/Oy87XG52YXIgY29tbWVudFJFID0gLzwhLS0vO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlU3RyaW5nLCByYXcpIHtcbiAgLy8gdHJ5IGEgY2FjaGUgaGl0IGZpcnN0XG4gIHZhciBjYWNoZUtleSA9IHJhdyA/IHRlbXBsYXRlU3RyaW5nIDogdGVtcGxhdGVTdHJpbmcudHJpbSgpO1xuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSQxKTtcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG4gIHZhciBjb21tZW50TWF0Y2ggPSBjb21tZW50UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG5cbiAgaWYgKCF0YWdNYXRjaCAmJiAhZW50aXR5TWF0Y2ggJiYgIWNvbW1lbnRNYXRjaCkge1xuICAgIC8vIHRleHQgb25seSwgcmV0dXJuIGEgc2luZ2xlIHRleHQgbm9kZS5cbiAgICBmcmFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRlbXBsYXRlU3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdO1xuICAgIHZhciB3cmFwID0gbWFwW3RhZ10gfHwgbWFwLmVmYXVsdDtcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICAgIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICAgIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBub2RlLmlubmVySFRNTCA9IHByZWZpeCArIHRlbXBsYXRlU3RyaW5nICsgc3VmZml4O1xuICAgIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcpIHtcbiAgICB0cmltTm9kZShmcmFnKTtcbiAgfVxuICB0ZW1wbGF0ZUNhY2hlLnB1dChjYWNoZUtleSwgZnJhZyk7XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSB0ZW1wbGF0ZSBub2RlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gbm9kZVRvRnJhZ21lbnQobm9kZSkge1xuICAvLyBpZiBpdHMgYSB0ZW1wbGF0ZSB0YWcgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0LFxuICAvLyBpdHMgY29udGVudCBpcyBhbHJlYWR5IGEgZG9jdW1lbnQgZnJhZ21lbnQuIEhvd2V2ZXIsIGlPUyBTYWZhcmkgaGFzXG4gIC8vIGJ1ZyB3aGVuIHVzaW5nIGRpcmVjdGx5IGNsb25lZCB0ZW1wbGF0ZSBjb250ZW50IHdpdGggdG91Y2hcbiAgLy8gZXZlbnRzIGFuZCBjYW4gY2F1c2UgY3Jhc2hlcyB3aGVuIHRoZSBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIERPTSwgc28gd2VcbiAgLy8gaGF2ZSB0byB0cmVhdCB0ZW1wbGF0ZSBlbGVtZW50cyBhcyBzdHJpbmcgdGVtcGxhdGVzLiAoIzI4MDUpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLmlubmVySFRNTCk7XG4gIH1cbiAgLy8gc2NyaXB0IHRlbXBsYXRlXG4gIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmVkTm9kZSA9IGNsb25lTm9kZShub2RlKTtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKGNoaWxkID0gY2xvbmVkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRyaW1Ob2RlKGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3d1Zy5jZ2k/aWQ9MTM3NzU1XG52YXIgaGFzQnJva2VuVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+JztcbiAgICByZXR1cm4gIWEuY2xvbmVOb2RlKHRydWUpLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gVGVzdCBmb3IgSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBjbG9uZSBidWdcbnZhciBoYXNUZXh0YXJlYUNsb25lQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnO1xuICAgIHJldHVybiB0LmNsb25lTm9kZSh0cnVlKS52YWx1ZSA9PT0gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiAxLiBEZWFsIHdpdGggU2FmYXJpIGNsb25pbmcgbmVzdGVkIDx0ZW1wbGF0ZT4gYnVnIGJ5XG4gKiAgICBtYW51YWxseSBjbG9uaW5nIGFsbCB0ZW1wbGF0ZSBpbnN0YW5jZXMuXG4gKiAyLiBEZWFsIHdpdGggSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWcgYnkgc2V0dGluZ1xuICogICAgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgY2xvbmluZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIW5vZGUucXVlcnlTZWxlY3RvckFsbCkge1xuICAgIHJldHVybiBub2RlLmNsb25lTm9kZSgpO1xuICB9XG4gIHZhciByZXMgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzQnJva2VuVGVtcGxhdGUpIHtcbiAgICB2YXIgdGVtcENsb25lID0gcmVzO1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgIHRlbXBDbG9uZSA9IHJlcy5jb250ZW50O1xuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICBjbG9uZWQgPSB0ZW1wQ2xvbmUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjbG9uZWRbaV0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVOb2RlKG9yaWdpbmFsW2ldKSwgY2xvbmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNUZXh0YXJlYUNsb25lQnVnKSB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgcmVzLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNsb25lZFtpXS52YWx1ZSA9IG9yaWdpbmFsW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgb3B0aW9uIGFuZCBub3JtYWxpemVzIGl0IGludG8gYVxuICogYSBEb2N1bWVudEZyYWdtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwYXJ0aWFsIG9yIGFcbiAqIGluc3RhbmNlIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGVtcGxhdGVcbiAqICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZTpcbiAqICAgICAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAgICAgLSBOb2RlIG9iamVjdCBvZiB0eXBlIFRlbXBsYXRlXG4gKiAgICAgICAgLSBpZCBzZWxlY3RvcjogJyNzb21lLXRlbXBsYXRlLWlkJ1xuICogICAgICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkQ2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiAgICAgICAgaW5saW5lIEhUTUwgaW50ZXJwb2xhdGlvbi4gRG8gbm90IGNoZWNrIGZvciBpZFxuICogICAgICAgIHNlbGVjdG9yIGFuZCBrZWVwIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHNob3VsZENsb25lLCByYXcpIHtcbiAgdmFyIG5vZGUsIGZyYWc7XG5cbiAgLy8gaWYgdGhlIHRlbXBsYXRlIGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudCxcbiAgLy8gZG8gbm90aGluZ1xuICBpZiAoaXNGcmFnbWVudCh0ZW1wbGF0ZSkpIHtcbiAgICB0cmltTm9kZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHNob3VsZENsb25lID8gY2xvbmVOb2RlKHRlbXBsYXRlKSA6IHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghcmF3ICYmIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAvLyBpZCBzZWxlY3RvciBjYW4gYmUgY2FjaGVkIHRvb1xuICAgICAgZnJhZyA9IGlkU2VsZWN0b3JDYWNoZS5nZXQodGVtcGxhdGUpO1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KG5vZGUpO1xuICAgICAgICAgIC8vIHNhdmUgc2VsZWN0b3IgdG8gY2FjaGVcbiAgICAgICAgICBpZFNlbGVjdG9yQ2FjaGUucHV0KHRlbXBsYXRlLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSwgcmF3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnICYmIHNob3VsZENsb25lID8gY2xvbmVOb2RlKGZyYWcpIDogZnJhZztcbn1cblxudmFyIHRlbXBsYXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNsb25lTm9kZTogY2xvbmVOb2RlLFxuICBwYXJzZVRlbXBsYXRlOiBwYXJzZVRlbXBsYXRlXG59KTtcblxudmFyIGh0bWwgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBhIGNvbW1lbnQgbm9kZSBtZWFucyB0aGlzIGlzIGEgYmluZGluZyBmb3JcbiAgICAvLyB7e3sgaW5saW5lIHVuZXNjYXBlZCBodG1sIH19fVxuICAgIGlmICh0aGlzLmVsLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAvLyBob2xkIG5vZGVzXG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWh0bWwnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5zd2FwKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gc3dhcCh2YWx1ZSkge1xuICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICB2YXIgaSA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlbW92ZSh0aGlzLm5vZGVzW2ldKTtcbiAgICB9XG4gICAgLy8gY29udmVydCBuZXcgdmFsdWUgdG8gYSBmcmFnbWVudFxuICAgIC8vIGRvIG5vdCBhdHRlbXB0IHRvIHJldHJpZXZlIGZyb20gaWQgc2VsZWN0b3JcbiAgICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIC8vIHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlc2Ugbm9kZXMgc28gd2UgY2FuIHJlbW92ZSBsYXRlclxuICAgIHRoaXMubm9kZXMgPSB0b0FycmF5KGZyYWcuY2hpbGROb2Rlcyk7XG4gICAgYmVmb3JlKGZyYWcsIHRoaXMuYW5jaG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbcGFyZW50RnJhZ11cbiAqL1xuZnVuY3Rpb24gRnJhZ21lbnQobGlua2VyLCB2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLmNoaWxkRnJhZ3MgPSBbXTtcbiAgdGhpcy52bSA9IHZtO1xuICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXJlbnRGcmFnID0gcGFyZW50RnJhZztcbiAgaWYgKHBhcmVudEZyYWcpIHtcbiAgICBwYXJlbnRGcmFnLmNoaWxkRnJhZ3MucHVzaCh0aGlzKTtcbiAgfVxuICB0aGlzLnVubGluayA9IGxpbmtlcih2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHRoaXMpO1xuICB2YXIgc2luZ2xlID0gdGhpcy5zaW5nbGUgPSBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gIC8vIGRvIG5vdCBnbyBzaW5nbGUgbW9kZSBpZiB0aGUgb25seSBub2RlIGlzIGFuIGFuY2hvclxuICAhZnJhZy5jaGlsZE5vZGVzWzBdLl9fdl9hbmNob3I7XG4gIGlmIChzaW5nbGUpIHtcbiAgICB0aGlzLm5vZGUgPSBmcmFnLmNoaWxkTm9kZXNbMF07XG4gICAgdGhpcy5iZWZvcmUgPSBzaW5nbGVCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2RlID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1lbmQnKTtcbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHByZXBlbmQodGhpcy5ub2RlLCBmcmFnKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gbXVsdGlSZW1vdmU7XG4gIH1cbiAgdGhpcy5ub2RlLl9fdl9mcmFnID0gdGhpcztcbn1cblxuLyoqXG4gKiBDYWxsIGF0dGFjaC9kZXRhY2ggZm9yIGFsbCBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW5cbiAqIHRoaXMgZnJhZ21lbnQuIEFsc28gZG8gc28gcmVjdXJzaXZlbHkgZm9yIGFsbCBjaGlsZFxuICogZnJhZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uY2FsbEhvb2soaG9vayk7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaG9vayh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnNlcnQgZnJhZ21lbnQgYmVmb3JlIHRhcmdldCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWV0aG9kKHRoaXMubm9kZSwgdGFyZ2V0LCB0aGlzLnZtKTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBzaW5nbGVSZW1vdmUoKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBpbkRvYyh0aGlzLm5vZGUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIHJlbW92ZVdpdGhUcmFuc2l0aW9uKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZnJhZ21lbnQgYmVmb3JlIHRhcmdldCwgbXVsdGktbm9kZXMgdmVyc2lvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICBtYXBOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBtZXRob2Qobm9kZSwgdGFyZ2V0LCB2bSk7XG4gIH0pO1xuICBpZiAoaW5Eb2ModGhpcy5ub2RlKSkge1xuICAgIHRoaXMuY2FsbEhvb2soYXR0YWNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBmcmFnbWVudCwgbXVsdGktbm9kZXMgdmVyc2lvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBpbkRvYyh0aGlzLm5vZGUpO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgdGhpcy52bSwgdGhpcy5mcmFnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICB9XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFByZXBhcmUgdGhlIGZyYWdtZW50IGZvciByZW1vdmFsLlxuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5iZWZvcmVSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpLCBsO1xuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHJlY3Vyc2l2ZWx5IG9uIGNoaWxkXG4gICAgLy8gZnJhZ21lbnRzLCBkZXB0aC1maXJzdFxuICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5iZWZvcmVSZW1vdmUoZmFsc2UpO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIENhbGwgZGVzdHJveSBmb3IgYWxsIGNvbnRhaW5lZCBpbnN0YW5jZXMsXG4gICAgLy8gd2l0aCByZW1vdmU6ZmFsc2UgYW5kIGRlZmVyOnRydWUuXG4gICAgLy8gRGVmZXIgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgIC8vIGtlZXAgdGhlIGNoaWxkcmVuIHRvIGNhbGwgZGV0YWNoIGhvb2tzXG4gICAgLy8gb24gdGhlbS5cbiAgICB0aGlzLmNoaWxkcmVuW2ldLiRkZXN0cm95KGZhbHNlLCB0cnVlKTtcbiAgfVxuICB2YXIgZGlycyA9IHRoaXMudW5saW5rLmRpcnM7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIGRpc2FibGUgdGhlIHdhdGNoZXJzIG9uIGFsbCB0aGUgZGlyZWN0aXZlc1xuICAgIC8vIHNvIHRoYXQgdGhlIHJlbmRlcmVkIGNvbnRlbnQgc3RheXMgdGhlIHNhbWVcbiAgICAvLyBkdXJpbmcgcmVtb3ZhbC5cbiAgICBkaXJzW2ldLl93YXRjaGVyICYmIGRpcnNbaV0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBmcmFnbWVudC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFyZW50RnJhZykge1xuICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcyk7XG4gIH1cbiAgdGhpcy5ub2RlLl9fdl9mcmFnID0gbnVsbDtcbiAgdGhpcy51bmxpbmsoKTtcbn07XG5cbi8qKlxuICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoKGNoaWxkKSB7XG4gIGlmICghY2hpbGQuX2lzQXR0YWNoZWQgJiYgaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgZGV0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGRldGFjaChjaGlsZCkge1xuICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gIH1cbn1cblxudmFyIGxpbmtlckNhY2hlID0gbmV3IENhY2hlKDUwMDApO1xuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYVxuICogZnJhZ21lbnQuIENhY2hlcyB0aGUgY29tcGlsZWQgbGlua2VyIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqL1xuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5KHZtLCBlbCkge1xuICB0aGlzLnZtID0gdm07XG4gIHZhciB0ZW1wbGF0ZTtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJztcbiAgaWYgKGlzU3RyaW5nIHx8IGlzVGVtcGxhdGUoZWwpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgIHRlbXBsYXRlID0gcGFyc2VUZW1wbGF0ZShlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQsIGJ1dCBvbmx5IGZvciBjb21wb25lbnRzXG4gIHZhciBsaW5rZXI7XG4gIHZhciBjaWQgPSB2bS5jb25zdHJ1Y3Rvci5jaWQ7XG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGdldE91dGVySFRNTChlbCkpO1xuICAgIGxpbmtlciA9IGxpbmtlckNhY2hlLmdldChjYWNoZUlkKTtcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICAgICAgbGlua2VyQ2FjaGUucHV0KGNhY2hlSWQsIGxpbmtlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmcmFnbWVudCBpbnN0YW5jZSB3aXRoIGdpdmVuIGhvc3QgYW5kIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBob3N0XG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IHBhcmVudEZyYWdcbiAqL1xuXG5GcmFnbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB2YXIgZnJhZyA9IGNsb25lTm9kZSh0aGlzLnRlbXBsYXRlKTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpO1xufTtcblxudmFyIE9OID0gNzAwO1xudmFyIE1PREVMID0gODAwO1xudmFyIEJJTkQgPSA4NTA7XG52YXIgVFJBTlNJVElPTiA9IDExMDA7XG52YXIgRUwgPSAxNTAwO1xudmFyIENPTVBPTkVOVCA9IDE1MDA7XG52YXIgUEFSVElBTCA9IDE3NTA7XG52YXIgSUYgPSAyMTAwO1xudmFyIEZPUiA9IDIyMDA7XG52YXIgU0xPVCA9IDIzMDA7XG5cbnZhciB1aWQkMyA9IDA7XG5cbnZhciB2Rm9yID0ge1xuXG4gIHByaW9yaXR5OiBGT1IsXG4gIHRlcm1pbmFsOiB0cnVlLFxuXG4gIHBhcmFtczogWyd0cmFjay1ieScsICdzdGFnZ2VyJywgJ2VudGVyLXN0YWdnZXInLCAnbGVhdmUtc3RhZ2dlciddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gc3VwcG9ydCBcIml0ZW0gaW4vb2YgaXRlbXNcIiBzeW50YXhcbiAgICB2YXIgaW5NYXRjaCA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaCgvKC4qKSAoPzppbnxvZikgKC4qKS8pO1xuICAgIGlmIChpbk1hdGNoKSB7XG4gICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pO1xuICAgICAgaWYgKGl0TWF0Y2gpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0TWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB0aGlzLmFsaWFzID0gaXRNYXRjaFsyXS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBpbk1hdGNoWzJdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hbGlhcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb24gXCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArICdhbGlhcyBpcyByZXF1aXJlZC4nLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1aWQgYXMgYSBjYWNoZSBpZGVudGlmaWVyXG4gICAgdGhpcy5pZCA9ICdfX3YtZm9yX18nICsgKyt1aWQkMztcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW9uIGxpc3QsXG4gICAgLy8gc28gdGhhdCB3ZSBrbm93IGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PidzXG4gICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBiZWNhdXNlIHYtbW9kZWwgaGFzIGEgbG93ZXIgcHJpb3JpdHkgdGhhbiB2LWZvcixcbiAgICAvLyB0aGUgdi1tb2RlbCBpcyBub3QgYm91bmQgaGVyZSB5ZXQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lO1xuICAgIHRoaXMuaXNPcHRpb24gPSAodGFnID09PSAnT1BUSU9OJyB8fCB0YWcgPT09ICdPUFRHUk9VUCcpICYmIHRoaXMuZWwucGFyZW50Tm9kZS50YWdOYW1lID09PSAnU0VMRUNUJztcblxuICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgIHRoaXMuc3RhcnQgPSBjcmVhdGVBbmNob3IoJ3YtZm9yLXN0YXJ0Jyk7XG4gICAgdGhpcy5lbmQgPSBjcmVhdGVBbmNob3IoJ3YtZm9yLWVuZCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5lbmQpO1xuICAgIGJlZm9yZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG5cbiAgICAvLyBjYWNoZVxuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gZnJhZ21lbnQgZmFjdG9yeVxuICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICAgIHRoaXMuZGlmZihkYXRhKTtcbiAgICB0aGlzLnVwZGF0ZVJlZigpO1xuICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlmZiwgYmFzZWQgb24gbmV3IGRhdGEgYW5kIG9sZCBkYXRhLCBkZXRlcm1pbmUgdGhlXG4gICAqIG1pbmltdW0gYW1vdW50IG9mIERPTSBtYW5pcHVsYXRpb25zIG5lZWRlZCB0byBtYWtlIHRoZVxuICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZGlmZnMgdGhlIG5ldyBkYXRhIEFycmF5IGJ5IHN0b3JpbmcgYVxuICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICogc2VlbiBkYXRhLiBUaGlzIGFsbG93cyB1cyB0byBhY2hpZXZlIE8obikgd2hpY2ggaXNcbiAgICogYmV0dGVyIHRoYW4gYSBsZXZlbnNodGVpbiBkaXN0YW5jZSBiYXNlZCBhbGdvcml0aG0sXG4gICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqL1xuXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYoZGF0YSkge1xuICAgIC8vIGNoZWNrIGlmIHRoZSBBcnJheSB3YXMgY29udmVydGVkIGZyb20gYW4gT2JqZWN0XG4gICAgdmFyIGl0ZW0gPSBkYXRhWzBdO1xuICAgIHZhciBjb252ZXJ0ZWRGcm9tT2JqZWN0ID0gdGhpcy5mcm9tT2JqZWN0ID0gaXNPYmplY3QoaXRlbSkgJiYgaGFzT3duKGl0ZW0sICcka2V5JykgJiYgaGFzT3duKGl0ZW0sICckdmFsdWUnKTtcblxuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgb2xkRnJhZ3MgPSB0aGlzLmZyYWdzO1xuICAgIHZhciBmcmFncyA9IHRoaXMuZnJhZ3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHZhciBhbGlhcyA9IHRoaXMuYWxpYXM7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICB2YXIgaW5Eb2N1bWVudCA9IGluRG9jKHN0YXJ0KTtcbiAgICB2YXIgaW5pdCA9ICFvbGRGcmFncztcbiAgICB2YXIgaSwgbCwgZnJhZywga2V5LCB2YWx1ZSwgcHJpbWl0aXZlO1xuXG4gICAgLy8gRmlyc3QgcGFzcywgZ28gdGhyb3VnaCB0aGUgbmV3IEFycmF5IGFuZCBmaWxsIHVwXG4gICAgLy8gdGhlIG5ldyBmcmFncyBhcnJheS4gSWYgYSBwaWVjZSBvZiBkYXRhIGhhcyBhIGNhY2hlZFxuICAgIC8vIGluc3RhbmNlIGZvciBpdCwgd2UgcmV1c2UgaXQuIE90aGVyd2lzZSBidWlsZCBhIG5ld1xuICAgIC8vIGluc3RhbmNlLlxuICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaXRlbSA9IGRhdGFbaV07XG4gICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbDtcbiAgICAgIHZhbHVlID0gY29udmVydGVkRnJvbU9iamVjdCA/IGl0ZW0uJHZhbHVlIDogaXRlbTtcbiAgICAgIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgLy8gcmV1c2FibGUgZnJhZ21lbnRcbiAgICAgICAgZnJhZy5yZXVzZWQgPSB0cnVlO1xuICAgICAgICAvLyB1cGRhdGUgJGluZGV4XG4gICAgICAgIGZyYWcuc2NvcGUuJGluZGV4ID0gaTtcbiAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGZyYWcuc2NvcGUuJGtleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgaXRlcmF0b3JcbiAgICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgZnJhZy5zY29wZVtpdGVyYXRvcl0gPSBrZXkgIT09IG51bGwgPyBrZXkgOiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBkYXRhIGZvciB0cmFjay1ieSwgb2JqZWN0IHJlcGVhdCAmXG4gICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgIGlmICh0cmFja0J5S2V5IHx8IGNvbnZlcnRlZEZyb21PYmplY3QgfHwgcHJpbWl0aXZlKSB7XG4gICAgICAgICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnJhZy5zY29wZVthbGlhc10gPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGlzbnRhbmNlXG4gICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSk7XG4gICAgICAgIGZyYWcuZnJlc2ggPSAhaW5pdDtcbiAgICAgIH1cbiAgICAgIGZyYWdzW2ldID0gZnJhZztcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIGZyYWcuYmVmb3JlKGVuZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UncmUgZG9uZSBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgIGlmIChpbml0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2Vjb25kIHBhc3MsIGdvIHRocm91Z2ggdGhlIG9sZCBmcmFnbWVudHMgYW5kXG4gICAgLy8gZGVzdHJveSB0aG9zZSB3aG8gYXJlIG5vdCByZXVzZWQgKGFuZCByZW1vdmUgdGhlbVxuICAgIC8vIGZyb20gY2FjaGUpXG4gICAgdmFyIHJlbW92YWxJbmRleCA9IDA7XG4gICAgdmFyIHRvdGFsUmVtb3ZlZCA9IG9sZEZyYWdzLmxlbmd0aCAtIGZyYWdzLmxlbmd0aDtcbiAgICAvLyB3aGVuIHJlbW92aW5nIGEgbGFyZ2UgbnVtYmVyIG9mIGZyYWdtZW50cywgd2F0Y2hlciByZW1vdmFsXG4gICAgLy8gdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBib3R0bGVuZWNrLCBzbyB3ZSBiYXRjaCB0aGUgd2F0Y2hlclxuICAgIC8vIHJlbW92YWxzIGludG8gYSBzaW5nbGUgZmlsdGVyIGNhbGwhXG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gb2xkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gb2xkRnJhZ3NbaV07XG4gICAgICBpZiAoIWZyYWcucmV1c2VkKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoZnJhZywgcmVtb3ZhbEluZGV4KyssIHRvdGFsUmVtb3ZlZCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IGZhbHNlO1xuICAgIGlmIChyZW1vdmFsSW5kZXgpIHtcbiAgICAgIHRoaXMudm0uX3dhdGNoZXJzID0gdGhpcy52bS5fd2F0Y2hlcnMuZmlsdGVyKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHJldHVybiB3LmFjdGl2ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIHBhc3MsIG1vdmUvaW5zZXJ0IG5ldyBmcmFnbWVudHMgaW50byB0aGVcbiAgICAvLyByaWdodCBwbGFjZS5cbiAgICB2YXIgdGFyZ2V0UHJldiwgcHJldkVsLCBjdXJyZW50UHJldjtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBmcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBmcmFnc1tpXTtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGZyYWcgdGhhdCB3ZSBzaG91bGQgYmUgYWZ0ZXJcbiAgICAgIHRhcmdldFByZXYgPSBmcmFnc1tpIC0gMV07XG4gICAgICBwcmV2RWwgPSB0YXJnZXRQcmV2ID8gdGFyZ2V0UHJldi5zdGFnZ2VyQ2IgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3IgOiB0YXJnZXRQcmV2LmVuZCB8fCB0YXJnZXRQcmV2Lm5vZGUgOiBzdGFydDtcbiAgICAgIGlmIChmcmFnLnJldXNlZCAmJiAhZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgICAgY3VycmVudFByZXYgPSBmaW5kUHJldkZyYWcoZnJhZywgc3RhcnQsIHRoaXMuaWQpO1xuICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYgJiYgKCFjdXJyZW50UHJldiB8fFxuICAgICAgICAvLyBvcHRpbWl6YXRpb24gZm9yIG1vdmluZyBhIHNpbmdsZSBpdGVtLlxuICAgICAgICAvLyB0aGFua3MgdG8gc3VnZ2VzdGlvbnMgYnkgQGxpdm9yYXMgaW4gIzE4MDdcbiAgICAgICAgZmluZFByZXZGcmFnKGN1cnJlbnRQcmV2LCBzdGFydCwgdGhpcy5pZCkgIT09IHRhcmdldFByZXYpKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlKGZyYWcsIHByZXZFbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5ldyBpbnN0YW5jZSwgb3Igc3RpbGwgaW4gc3RhZ2dlci5cbiAgICAgICAgLy8gaW5zZXJ0IHdpdGggdXBkYXRlZCBzdGFnZ2VyIGluZGV4LlxuICAgICAgICB0aGlzLmluc2VydChmcmFnLCBpbnNlcnRpb25JbmRleCsrLCBwcmV2RWwsIGluRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgZnJhZy5yZXVzZWQgPSBmcmFnLmZyZXNoID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBhbGlhcywgaW5kZXgsIGtleSkge1xuICAgIHZhciBob3N0ID0gdGhpcy5faG9zdDtcbiAgICAvLyBjcmVhdGUgaXRlcmF0aW9uIHNjb3BlXG4gICAgdmFyIHBhcmVudFNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgc2NvcGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlKTtcbiAgICAvLyByZWYgaG9sZGVyIGZvciB0aGUgc2NvcGVcbiAgICBzY29wZS4kcmVmcyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJHJlZnMpO1xuICAgIHNjb3BlLiRlbHMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRlbHMpO1xuICAgIC8vIG1ha2Ugc3VyZSBwb2ludCAkcGFyZW50IHRvIHBhcmVudCBzY29wZVxuICAgIHNjb3BlLiRwYXJlbnQgPSBwYXJlbnRTY29wZTtcbiAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgc2NvcGUuJGZvckNvbnRleHQgPSB0aGlzO1xuICAgIC8vIGRlZmluZSBzY29wZSBwcm9wZXJ0aWVzXG4gICAgLy8gaW1wb3J0YW50OiBkZWZpbmUgdGhlIHNjb3BlIGFsaWFzIHdpdGhvdXQgZm9yY2VkIGNvbnZlcnNpb25cbiAgICAvLyBzbyB0aGF0IGZyb3plbiBkYXRhIHN0cnVjdHVyZXMgcmVtYWluIG5vbi1yZWFjdGl2ZS5cbiAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgYWxpYXMsIHZhbHVlKTtcbiAgICB9KTtcbiAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRrZXknLCBrZXkpO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgZGVmKHNjb3BlLCAnJGtleScsIG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVyYXRvcikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KTtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICBmcmFnLmZvcklkID0gdGhpcy5pZDtcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSk7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdi1yZWYgb24gb3duZXIgdm0uXG4gICAqL1xuXG4gIHVwZGF0ZVJlZjogZnVuY3Rpb24gdXBkYXRlUmVmKCkge1xuICAgIHZhciByZWYgPSB0aGlzLmRlc2NyaXB0b3IucmVmO1xuICAgIGlmICghcmVmKSByZXR1cm47XG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnM7XG4gICAgdmFyIHJlZnM7XG4gICAgaWYgKCF0aGlzLmZyb21PYmplY3QpIHtcbiAgICAgIHJlZnMgPSB0aGlzLmZyYWdzLm1hcChmaW5kVm1Gcm9tRnJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fTtcbiAgICAgIHRoaXMuZnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICByZWZzW2ZyYWcuc2NvcGUuJGtleV0gPSBmaW5kVm1Gcm9tRnJhZyhmcmFnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNoW3JlZl0gPSByZWZzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3Igb3B0aW9uIGxpc3RzLCB1cGRhdGUgdGhlIGNvbnRhaW5pbmcgdi1tb2RlbCBvblxuICAgKiBwYXJlbnQgPHNlbGVjdD4uXG4gICAqL1xuXG4gIHVwZGF0ZU1vZGVsOiBmdW5jdGlvbiB1cGRhdGVNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgIHZhciBtb2RlbCA9IHBhcmVudCAmJiBwYXJlbnQuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICovXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoZnJhZywgaW5kZXgsIHByZXZFbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yO1xuICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yID0gY3JlYXRlQW5jaG9yKCdzdGFnZ2VyLWFuY2hvcicpO1xuICAgICAgICBhbmNob3IuX192X2ZyYWcgPSBmcmFnO1xuICAgICAgfVxuICAgICAgYWZ0ZXIoYW5jaG9yLCBwcmV2RWwpO1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5iZWZvcmUoYW5jaG9yKTtcbiAgICAgICAgcmVtb3ZlKGFuY2hvcik7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcHJldkVsLm5leHRTaWJsaW5nO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAvLyByZXNldCBlbmQgYW5jaG9yIHBvc2l0aW9uIGluIGNhc2UgdGhlIHBvc2l0aW9uIHdhcyBtZXNzZWQgdXBcbiAgICAgICAgLy8gYnkgYW4gZXh0ZXJuYWwgZHJhZy1uLWRyb3AgbGlicmFyeS5cbiAgICAgICAgYWZ0ZXIodGhpcy5lbmQsIHByZXZFbCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZW5kO1xuICAgICAgfVxuICAgICAgZnJhZy5iZWZvcmUodGFyZ2V0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZnJhZywgaW5kZXgsIHRvdGFsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgIC8vIGl0J3Mgbm90IHBvc3NpYmxlIGZvciB0aGUgc2FtZSBmcmFnIHRvIGJlIHJlbW92ZWRcbiAgICAgIC8vIHR3aWNlLCBzbyBpZiB3ZSBoYXZlIGEgcGVuZGluZyBzdGFnZ2VyIGNhbGxiYWNrLFxuICAgICAgLy8gaXQgbWVhbnMgdGhpcyBmcmFnIGlzIHF1ZXVlZCBmb3IgZW50ZXIgYnV0IHJlbW92ZWRcbiAgICAgIC8vIGJlZm9yZSBpdHMgdHJhbnNpdGlvbiBzdGFydGVkLiBTaW5jZSBpdCBpcyBhbHJlYWR5XG4gICAgICAvLyBkZXN0cm95ZWQsIHdlIGNhbiBqdXN0IGxlYXZlIGl0IGluIGRldGFjaGVkIHN0YXRlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsICdsZWF2ZScpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLnJlbW92ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZSBhIGZyYWdtZW50IHRvIGEgbmV3IHBvc2l0aW9uLlxuICAgKiBGb3JjZSBubyB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqL1xuXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoZnJhZywgcHJldkVsKSB7XG4gICAgLy8gZml4IGEgY29tbW9uIGlzc3VlIHdpdGggU29ydGFibGU6XG4gICAgLy8gaWYgcHJldkVsIGRvZXNuJ3QgaGF2ZSBuZXh0U2libGluZywgdGhpcyBtZWFucyBpdCdzXG4gICAgLy8gYmVlbiBkcmFnZ2VkIGFmdGVyIHRoZSBlbmQgYW5jaG9yLiBKdXN0IHJlLXBvc2l0aW9uXG4gICAgLy8gdGhlIGVuZCBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgY29udGFpbmVyLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghcHJldkVsLm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLmVuZC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICB9XG4gICAgZnJhZy5iZWZvcmUocHJldkVsLm5leHRTaWJsaW5nLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGEgZnJhZ21lbnQgdXNpbmcgdHJhY2stYnkgb3IgdGhlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqL1xuXG4gIGNhY2hlRnJhZzogZnVuY3Rpb24gY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgdmFyIGlkO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICBjYWNoZVtpZF0gPSBmcmFnO1xuICAgICAgfSBlbHNlIGlmICh0cmFja0J5S2V5ICE9PSAnJGluZGV4Jykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgIGlmIChoYXNPd24odmFsdWUsIGlkKSkge1xuICAgICAgICBpZiAodmFsdWVbaWRdID09PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVbaWRdID0gZnJhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZGVmKHZhbHVlLCBpZCwgZnJhZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybignRnJvemVuIHYtZm9yIG9iamVjdHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgdHJhY2tlZCwgbWFrZSBzdXJlIHRvICcgKyAncHJvdmlkZSBhIHRyYWNrLWJ5IGtleS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZy5yYXcgPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiBnZXRDYWNoZWRGcmFnKHZhbHVlLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBmcmFnO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgZnJhZyA9IHRoaXMuY2FjaGVbaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnID0gdmFsdWVbdGhpcy5pZF07XG4gICAgfVxuICAgIGlmIChmcmFnICYmIChmcmFnLnJldXNlZCB8fCBmcmFnLmZyZXNoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgZnJhZ21lbnQgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKi9cblxuICBkZWxldGVDYWNoZWRGcmFnOiBmdW5jdGlvbiBkZWxldGVDYWNoZWRGcmFnKGZyYWcpIHtcbiAgICB2YXIgdmFsdWUgPSBmcmFnLnJhdztcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIHNjb3BlID0gZnJhZy5zY29wZTtcbiAgICB2YXIgaW5kZXggPSBzY29wZS4kaW5kZXg7XG4gICAgLy8gZml4ICM5NDg6IGF2b2lkIGFjY2lkZW50YWxseSBmYWxsIHRocm91Z2ggdG9cbiAgICAvLyBhIHBhcmVudCByZXBlYXRlciB3aGljaCBoYXBwZW5zIHRvIGhhdmUgJGtleS5cbiAgICB2YXIga2V5ID0gaGFzT3duKHNjb3BlLCAnJGtleScpICYmIHNjb3BlLiRrZXk7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgaWYgKHRyYWNrQnlLZXkgfHwga2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlW3RoaXMuaWRdID0gbnVsbDtcbiAgICAgIGZyYWcucmF3ID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhZ2dlciBhbW91bnQgZm9yIGFuIGluc2VydGlvbi9yZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICovXG5cbiAgZ2V0U3RhZ2dlcjogZnVuY3Rpb24gZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSArICdTdGFnZ2VyJztcbiAgICB2YXIgdHJhbnMgPSBmcmFnLm5vZGUuX192X3RyYW5zO1xuICAgIHZhciBob29rcyA9IHRyYW5zICYmIHRyYW5zLmhvb2tzO1xuICAgIHZhciBob29rID0gaG9va3MgJiYgKGhvb2tzW3R5cGVdIHx8IGhvb2tzLnN0YWdnZXIpO1xuICAgIHJldHVybiBob29rID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbCkgOiBpbmRleCAqIHBhcnNlSW50KHRoaXMucGFyYW1zW3R5cGVdIHx8IHRoaXMucGFyYW1zLnN0YWdnZXIsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICogZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICovXG5cbiAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uIF9wcmVQcm9jZXNzKHZhbHVlKSB7XG4gICAgLy8gcmVnYXJkbGVzcyBvZiB0eXBlLCBzdG9yZSB0aGUgdW4tZmlsdGVyZWQgcmF3IHZhbHVlLlxuICAgIHRoaXMucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvc3QtcHJvY2VzcyB0aGUgdmFsdWUgYWZ0ZXIgaXQgaGFzIGJlZW4gcGlwZWQgdGhyb3VnaFxuICAgKiB0aGUgZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICpcbiAgICogSXQgaXMgbmVjZXNzYXJ5IGZvciB0aGlzIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlXG4gICAqIHdhdGNoZXIncyBkZXBlbmRlbmN5IGNvbGxlY3Rpb24gcGhhc2UgYmVjYXVzZSB3ZSB3YW50XG4gICAqIHRoZSB2LWZvciB0byB1cGRhdGUgd2hlbiB0aGUgc291cmNlIE9iamVjdCBpcyBtdXRhdGVkLlxuICAgKi9cblxuICBfcG9zdFByb2Nlc3M6IGZ1bmN0aW9uIF9wb3N0UHJvY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGNvbnZlcnQgcGxhaW4gb2JqZWN0IHRvIGFycmF5LlxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAka2V5OiBrZXksXG4gICAgICAgICAgJHZhbHVlOiB2YWx1ZVtrZXldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gcmFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzW3RoaXMuZGVzY3JpcHRvci5yZWZdID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ3MpIHtcbiAgICAgIHZhciBpID0gdGhpcy5mcmFncy5sZW5ndGg7XG4gICAgICB2YXIgZnJhZztcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZnJhZ3NbaV07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKTtcbiAgICAgICAgZnJhZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciB0byBmaW5kIHRoZSBwcmV2aW91cyBlbGVtZW50IHRoYXQgaXMgYSBmcmFnbWVudFxuICogYW5jaG9yLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgZGVzdHJveWVkIGZyYWcnc1xuICogZWxlbWVudCBjb3VsZCBzdGlsbCBiZSBsaW5nZXJpbmcgaW4gdGhlIERPTSBiZWZvcmUgaXRzXG4gKiBsZWF2aW5nIHRyYW5zaXRpb24gZmluaXNoZXMsIGJ1dCBpdHMgaW5zZXJ0ZWQgZmxhZ1xuICogc2hvdWxkIGhhdmUgYmVlbiBzZXQgdG8gZmFsc2Ugc28gd2UgY2FuIHNraXAgdGhlbS5cbiAqXG4gKiBJZiB0aGlzIGlzIGEgYmxvY2sgcmVwZWF0LCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBvbmx5XG4gKiByZXR1cm4gZnJhZyB0aGF0IGlzIGJvdW5kIHRvIHRoaXMgdi1mb3IuIChzZWUgIzkyOSlcbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0NvbW1lbnR8VGV4dH0gYW5jaG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGZpbmRQcmV2RnJhZyhmcmFnLCBhbmNob3IsIGlkKSB7XG4gIHZhciBlbCA9IGZyYWcubm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgd2hpbGUgKCghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiYgZWwgIT09IGFuY2hvcikge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIH1cbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGZpbmRWbUZyb21GcmFnKGZyYWcpIHtcbiAgdmFyIG5vZGUgPSBmcmFnLm5vZGU7XG4gIC8vIGhhbmRsZSBtdWx0aS1ub2RlIGZyYWdcbiAgaWYgKGZyYWcuZW5kKSB7XG4gICAgd2hpbGUgKCFub2RlLl9fdnVlX18gJiYgbm9kZSAhPT0gZnJhZy5lbmQgJiYgbm9kZS5uZXh0U2libGluZykge1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlLl9fdnVlX187XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmFuZ2UgYXJyYXkgZnJvbSBnaXZlbiBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShNYXRoLmZsb29yKG4pKTtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByZXRbaV0gPSBpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0cmFjayBieSBrZXkgZm9yIGFuIGl0ZW0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3RyYWNrQnlLZXldXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSkge1xuICByZXR1cm4gdHJhY2tCeUtleSA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnID8gaW5kZXggOiB0cmFja0J5S2V5LmNoYXJBdCgwKS5tYXRjaCgvXFx3LykgPyBnZXRQYXRoKHZhbHVlLCB0cmFja0J5S2V5KSA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2Rm9yLndhcm5EdXBsaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB3YXJuKCdEdXBsaWNhdGUgdmFsdWUgZm91bmQgaW4gdi1mb3I9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgKyAneW91IGFyZSBleHBlY3RpbmcgZHVwbGljYXRlIHZhbHVlcy4nLCB0aGlzLnZtKTtcbiAgfTtcbn1cblxudmFyIHZJZiA9IHtcblxuICBwcmlvcml0eTogSUYsXG4gIHRlcm1pbmFsOiB0cnVlLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoIWVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICAgIHZhciBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICB0aGlzLmVsc2VFbCA9IG5leHQ7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBtYWluIGJsb2NrXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1pZicpO1xuICAgICAgcmVwbGFjZShlbCwgdGhpcy5hbmNob3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtaWY9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGNhbm5vdCBiZSAnICsgJ3VzZWQgb24gYW4gaW5zdGFuY2Ugcm9vdCBlbGVtZW50LicsIHRoaXMudm0pO1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSByZXR1cm47XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmluc2VydCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICBpZiAodGhpcy5lbHNlRnJhZykge1xuICAgICAgdGhpcy5lbHNlRnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZWxzZUZyYWcgPSBudWxsO1xuICAgIH1cbiAgICAvLyBsYXp5IGluaXQgZmFjdG9yeVxuICAgIGlmICghdGhpcy5mYWN0b3J5KSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKTtcbiAgICB0aGlzLmZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmZyYWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRWwgJiYgIXRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIGlmICghdGhpcy5lbHNlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLmVsc2VFbC5fY29udGV4dCB8fCB0aGlzLnZtLCB0aGlzLmVsc2VFbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsc2VGcmFnID0gdGhpcy5lbHNlRmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgICAgdGhpcy5lbHNlRnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRnJhZykge1xuICAgICAgdGhpcy5lbHNlRnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICB2YXIgbmV4dCA9IHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmVsc2VFbCA9IG5leHQ7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBseSh0aGlzLmVsLCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuZWxzZUVsKSB7XG4gICAgICB0aGlzLmFwcGx5KHRoaXMuZWxzZUVsLCAhdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoZWwsIHZhbHVlKSB7XG4gICAgaWYgKGluRG9jKGVsKSkge1xuICAgICAgYXBwbHlUcmFuc2l0aW9uKGVsLCB2YWx1ZSA/IDEgOiAtMSwgdG9nZ2xlLCB0aGlzLnZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9nZ2xlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRleHQkMiA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpc1JhbmdlID0gZWwudHlwZSA9PT0gJ3JhbmdlJztcbiAgICB2YXIgbGF6eSA9IHRoaXMucGFyYW1zLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlcjtcbiAgICB2YXIgZGVib3VuY2UgPSB0aGlzLnBhcmFtcy5kZWJvdW5jZTtcblxuICAgIC8vIGhhbmRsZSBjb21wb3NpdGlvbiBldmVudHMuXG4gICAgLy8gICBodHRwOi8vYmxvZy5ldmFueW91Lm1lLzIwMTQvMDEvMDMvY29tcG9zaXRpb24tZXZlbnQvXG4gICAgLy8gc2tpcCB0aGlzIGZvciBBbmRyb2lkIGJlY2F1c2UgaXQgaGFuZGxlcyBjb21wb3NpdGlvblxuICAgIC8vIGV2ZW50cyBxdWl0ZSBkaWZmZXJlbnRseS4gQW5kcm9pZCBkb2Vzbid0IHRyaWdnZXJcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgZm9yIGxhbmd1YWdlIGlucHV0IG1ldGhvZHMgZS5nLlxuICAgIC8vIENoaW5lc2UsIGJ1dCBpbnN0ZWFkIHRyaWdnZXJzIHRoZW0gZm9yIHNwZWxsaW5nXG4gICAgLy8gc3VnZ2VzdGlvbnMuLi4gKHNlZSBEaXNjdXNzaW9uLyMxNjIpXG4gICAgdmFyIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgIGlmICghaXNBbmRyb2lkICYmICFpc1JhbmdlKSB7XG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGluIElFMTEgdGhlIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCBmaXJlcyBBRlRFUlxuICAgICAgICAvLyB0aGUgXCJpbnB1dFwiIGV2ZW50LCBzbyB0aGUgaW5wdXQgaGFuZGxlciBpcyBibG9ja2VkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuLi4gaGF2ZSB0byBjYWxsIGl0IGhlcmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICMxMzI3OiBpbiBsYXp5IG1vZGUgdGhpcyBpcyB1bmVjZXNzYXJ5LlxuICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgbWVzc2luZyB3aXRoIHRoZSBpbnB1dCB3aGVuIHVzZXIgaXMgdHlwaW5nLFxuICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICBpZiAoIWlzUmFuZ2UgJiYgIWxhenkpIHtcbiAgICAgIHRoaXMub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gZG8gbm90IHN5bmMgdmFsdWUgYWZ0ZXIgZnJhZ21lbnQgcmVtb3ZhbCAoIzIwMTcpXG4gICAgICAgIGlmICghc2VsZi5fZnJhZyB8fCBzZWxmLl9mcmFnLmluc2VydGVkKSB7XG4gICAgICAgICAgc2VsZi5yYXdMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgYXR0YWNoIHRoZSBtYWluIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IHRoaXMucmF3TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29tcG9zaW5nIHx8ICFzZWxmLl9ib3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gbnVtYmVyIHx8IGlzUmFuZ2UgPyB0b051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICAgIHNlbGYuc2V0KHZhbCk7XG4gICAgICAvLyBmb3JjZSB1cGRhdGUgb24gbmV4dCB0aWNrIHRvIGF2b2lkIGxvY2sgJiBzYW1lIHZhbHVlXG4gICAgICAvLyBhbHNvIG9ubHkgdXBkYXRlIHdoZW4gdXNlciBpcyBub3QgdHlwaW5nXG4gICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLl9ib3VuZCAmJiAhc2VsZi5mb2N1c2VkKSB7XG4gICAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBhcHBseSBkZWJvdW5jZVxuICAgIGlmIChkZWJvdW5jZSkge1xuICAgICAgdGhpcy5saXN0ZW5lciA9IF9kZWJvdW5jZSh0aGlzLmxpc3RlbmVyLCBkZWJvdW5jZSk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBqUXVlcnkgZXZlbnRzLCBzaW5jZSBqUXVlcnkudHJpZ2dlcigpIGRvZXNuJ3RcbiAgICAvLyB0cmlnZ2VyIG5hdGl2ZSBldmVudHMgaW4gc29tZSBjYXNlcyBhbmQgc29tZSBwbHVnaW5zXG4gICAgLy8gcmVseSBvbiAkLnRyaWdnZXIoKVxuICAgIC8vXG4gICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgaWYgYSBsaXN0ZW5lciBpcyBhdHRhY2hlZCB1c2luZ1xuICAgIC8vIGpRdWVyeSwgaXQgaXMgYWxzbyByZW1vdmVkIHdpdGggalF1ZXJ5LCB0aGF0J3Mgd2h5XG4gICAgLy8gd2UgZG8gdGhlIGNoZWNrIGZvciBlYWNoIGRpcmVjdGl2ZSBpbnN0YW5jZSBhbmRcbiAgICAvLyBzdG9yZSB0aGF0IGNoZWNrIHJlc3VsdCBvbiBpdHNlbGYuIFRoaXMgYWxzbyBhbGxvd3NcbiAgICAvLyBlYXNpZXIgdGVzdCBjb3ZlcmFnZSBjb250cm9sIGJ5IHVuc2V0dGluZyB0aGUgZ2xvYmFsXG4gICAgLy8galF1ZXJ5IHZhcmlhYmxlIGluIHRlc3RzLlxuICAgIHRoaXMuaGFzalF1ZXJ5ID0gdHlwZW9mIGpRdWVyeSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub24gPyAnb24nIDogJ2JpbmQnO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLnJhd0xpc3RlbmVyKTtcbiAgICAgIGlmICghbGF6eSkge1xuICAgICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU5IGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudCBvbiBiYWNrc3BhY2UvZGVsL2N1dFxuICAgIGlmICghbGF6eSAmJiBpc0lFOSkge1xuICAgICAgdGhpcy5vbignY3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljayhzZWxmLmxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA0NiB8fCBlLmtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpbml0aWFsIHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpIHx8IGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgZWwudmFsdWUudHJpbSgpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgLy8gIzMwMjkgb25seSB1cGRhdGUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gVGhpcyBwcmV2ZW50XG4gICAgLy8gYnJvd3NlcnMgZnJvbSBvdmVyd3JpdGluZyB2YWx1ZXMgbGlrZSBzZWxlY3Rpb25TdGFydFxuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuZWwudmFsdWUpIHRoaXMuZWwudmFsdWUgPSB2YWx1ZTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByYWRpbyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHZhbHVlIG92ZXJ3cml0ZSB2aWEgdi1iaW5kOnZhbHVlXG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWU7XG4gICAgICBpZiAoc2VsZi5wYXJhbXMubnVtYmVyKSB7XG4gICAgICAgIHZhbCA9IHRvTnVtYmVyKHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxufTtcblxudmFyIHNlbGVjdCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIC8vIG1ldGhvZCB0byBmb3JjZSB1cGRhdGUgRE9NIHVzaW5nIGxhdGVzdCB2YWx1ZS5cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci5nZXQoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBtdWx0aXBsZSBzZWxlY3RcbiAgICB2YXIgbXVsdGlwbGUgPSB0aGlzLm11bHRpcGxlID0gZWwuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpO1xuXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSk7XG4gICAgICB2YWx1ZSA9IHNlbGYucGFyYW1zLm51bWJlciA/IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHRvTnVtYmVyKSA6IHRvTnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsdWUpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICAvLyBpZiBoYXMgaW5pdGlhbCB2YWx1ZSwgc2V0IGFmdGVyQmluZFxuICAgIHZhciBpbml0VmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUsIHRydWUpO1xuICAgIGlmIChtdWx0aXBsZSAmJiBpbml0VmFsdWUubGVuZ3RoIHx8ICFtdWx0aXBsZSAmJiBpbml0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG5cbiAgICAvLyBBbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IEZpcmVmb3ggcmVzZXRzXG4gICAgLy8gc2VsZWN0ZWRJbmRleCB3aXRoIHZhbHVlIC0xIHRvIDAgd2hlbiB0aGUgZWxlbWVudFxuICAgIC8vIGlzIGFwcGVuZGVkIHRvIGEgbmV3IHBhcmVudCwgdGhlcmVmb3JlIHdlIGhhdmUgdG9cbiAgICAvLyBmb3JjZSBhIERPTSB1cGRhdGUgd2hlbmV2ZXIgdGhhdCBoYXBwZW5zLi4uXG4gICAgdGhpcy52bS4kb24oJ2hvb2s6YXR0YWNoZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBuZXh0VGljayhfdGhpcy5mb3JjZVVwZGF0ZSk7XG4gICAgfSk7XG4gICAgaWYgKCFpbkRvYyhlbCkpIHtcbiAgICAgIG5leHRUaWNrKHRoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIHZhciBtdWx0aSA9IHRoaXMubXVsdGlwbGUgJiYgaXNBcnJheSh2YWx1ZSk7XG4gICAgdmFyIG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICAgIHZhciBpID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgdmFyIG9wLCB2YWw7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgb3AgPSBvcHRpb25zW2ldO1xuICAgICAgdmFsID0gb3AuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gb3AuX3ZhbHVlIDogb3AudmFsdWU7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgIG9wLnNlbGVjdGVkID0gbXVsdGkgPyBpbmRleE9mJDEodmFsdWUsIHZhbCkgPiAtMSA6IGxvb3NlRXF1YWwodmFsdWUsIHZhbCk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRoaXMudm0uJG9mZignaG9vazphdHRhY2hlZCcsIHRoaXMuZm9yY2VVcGRhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBzZWxlY3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NlbGVjdEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FycmF5fCp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwsIG11bHRpLCBpbml0KSB7XG4gIHZhciByZXMgPSBtdWx0aSA/IFtdIDogbnVsbDtcbiAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3AgPSBlbC5vcHRpb25zW2ldO1xuICAgIHNlbGVjdGVkID0gaW5pdCA/IG9wLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA6IG9wLnNlbGVjdGVkO1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdmFsID0gb3AuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gb3AuX3ZhbHVlIDogb3AudmFsdWU7XG4gICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogTmF0aXZlIEFycmF5LmluZGV4T2YgdXNlcyBzdHJpY3QgZXF1YWwsIGJ1dCBpbiB0aGlzXG4gKiBjYXNlIHdlIG5lZWQgdG8gbWF0Y2ggc3RyaW5nL251bWJlcnMgd2l0aCBjdXN0b20gZXF1YWwuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIGluZGV4T2YkMShhcnIsIHZhbCkge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBjaGVja2JveCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBlbC5fdmFsdWUgOiBzZWxmLnBhcmFtcy5udW1iZXIgPyB0b051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm9vbGVhblZhbHVlKCkge1xuICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWQ7XG4gICAgICBpZiAodmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfdHJ1ZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl90cnVlVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX2ZhbHNlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX2ZhbHNlVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbW9kZWwgPSBzZWxmLl93YXRjaGVyLnZhbHVlO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobW9kZWwsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICBtb2RlbC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZXQoZ2V0Qm9vbGVhblZhbHVlKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZWwuY2hlY2tlZCA9IGluZGV4T2YodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSkgPiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdHJ1ZVZhbHVlJykpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGVsLl90cnVlVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gIHRleHQ6IHRleHQkMixcbiAgcmFkaW86IHJhZGlvLFxuICBzZWxlY3Q6IHNlbGVjdCxcbiAgY2hlY2tib3g6IGNoZWNrYm94XG59O1xuXG52YXIgbW9kZWwgPSB7XG5cbiAgcHJpb3JpdHk6IE1PREVMLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGZyaWVuZGx5IHdhcm5pbmcuLi5cbiAgICB0aGlzLmNoZWNrRmlsdGVycygpO1xuICAgIGlmICh0aGlzLmhhc1JlYWQgJiYgIXRoaXMuaGFzV3JpdGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyBhIHJlYWQtb25seSBmaWx0ZXIgd2l0aCAnICsgJ3YtbW9kZWw9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIi4gJyArICdZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci4nLCB0aGlzLnZtKTtcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZTtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy5zZWxlY3Q7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWcsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzO1xuICAgIGhhbmRsZXIuYmluZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlID0gaGFuZGxlci51cGRhdGU7XG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHJlYWQvd3JpdGUgZmlsdGVyIHN0YXRzLlxuICAgKi9cblxuICBjaGVja0ZpbHRlcnM6IGZ1bmN0aW9uIGNoZWNrRmlsdGVycygpIHtcbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAoIWZpbHRlcnMpIHJldHVybjtcbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBmaWx0ZXIgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXJzW2ldLm5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIud3JpdGUpIHtcbiAgICAgICAgdGhpcy5oYXNXcml0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuZWwuX192X21vZGVsID0gbnVsbDtcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKCk7XG4gIH1cbn07XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICAnZGVsZXRlJzogWzgsIDQ2XSxcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufTtcblxuZnVuY3Rpb24ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGtleS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyQ29kZSA+IDQ3ICYmIGNoYXJDb2RlIDwgNTgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNoYXJDb2RlID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5Q29kZXNba2V5XTtcbiAgfSk7XG4gIGNvZGVzID0gW10uY29uY2F0LmFwcGx5KFtdLCBjb2Rlcyk7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICBpZiAoY29kZXMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdG9wRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEhhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxmRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGZIYW5kbGVyKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBPTixcbiAgYWNjZXB0U3RhdGVtZW50OiB0cnVlLFxuICBrZXlDb2Rlczoga2V5Q29kZXMsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBkZWFsIHdpdGggaWZyYW1lc1xuICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdJRlJBTUUnICYmIHRoaXMuYXJnICE9PSAnbG9hZCcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuaWZyYW1lQmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyLCBzZWxmLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdsb2FkJywgdGhpcy5pZnJhbWVCaW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1vbjonICsgdGhpcy5hcmcgKyAnPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBleHBlY3RzIGEgZnVuY3Rpb24gdmFsdWUsICcgKyAnZ290ICcgKyBoYW5kbGVyLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBtb2RpZmllcnNcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc3RvcCkge1xuICAgICAgaGFuZGxlciA9IHN0b3BGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5wcmV2ZW50KSB7XG4gICAgICBoYW5kbGVyID0gcHJldmVudEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnNlbGYpIHtcbiAgICAgIGhhbmRsZXIgPSBzZWxmRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBrZXkgZmlsdGVyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT09ICdzdG9wJyAmJiBrZXkgIT09ICdwcmV2ZW50JyAmJiBrZXkgIT09ICdzZWxmJyAmJiBrZXkgIT09ICdjYXB0dXJlJztcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5pZnJhbWVCaW5kKSB7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb24odGhpcy5lbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlciwgdGhpcy5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmlmcmFtZUJpbmQgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3cgOiB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIG9mZihlbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ107XG52YXIgY2FtZWxQcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xudmFyIGltcG9ydGFudFJFID0gLyFpbXBvcnRhbnQ7PyQvO1xudmFyIHByb3BDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciB0ZXN0RWwgPSBudWxsO1xuXG52YXIgc3R5bGUgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoZXh0ZW5kLCB7fSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gaGFuZGxlT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSk7XG4gICAgdmFyIG5hbWUsIHZhbDtcbiAgICBmb3IgKG5hbWUgaW4gY2FjaGUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIG51bGwpO1xuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgdmFsID0gdmFsdWVbbmFtZV07XG4gICAgICBpZiAodmFsICE9PSBjYWNoZVtuYW1lXSkge1xuICAgICAgICBjYWNoZVtuYW1lXSA9IHZhbDtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUocHJvcCwgdmFsdWUpIHtcbiAgICBwcm9wID0gbm9ybWFsaXplKHByb3ApO1xuICAgIGlmICghcHJvcCkgcmV0dXJuOyAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBpc0ltcG9ydGFudCA9IGltcG9ydGFudFJFLnRlc3QodmFsdWUpID8gJ2ltcG9ydGFudCcgOiAnJztcbiAgICAgIGlmIChpc0ltcG9ydGFudCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdJdFxcJ3MgcHJvYmFibHkgYSBiYWQgaWRlYSB0byB1c2UgIWltcG9ydGFudCB3aXRoIGlubGluZSBydWxlcy4gJyArICdUaGlzIGZlYXR1cmUgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgVnVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLmtlYmFiLCB2YWx1ZSwgaXNJbXBvcnRhbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wLmNhbWVsXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnN0eWxlW3Byb3AuY2FtZWxdID0gJyc7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUocHJvcCkge1xuICBpZiAocHJvcENhY2hlW3Byb3BdKSB7XG4gICAgcmV0dXJuIHByb3BDYWNoZVtwcm9wXTtcbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApO1xuICBwcm9wQ2FjaGVbcHJvcF0gPSBwcm9wQ2FjaGVbcmVzXSA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeChwcm9wKSB7XG4gIHByb3AgPSBoeXBoZW5hdGUocHJvcCk7XG4gIHZhciBjYW1lbCA9IGNhbWVsaXplKHByb3ApO1xuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpO1xuICBpZiAoIXRlc3RFbCkge1xuICAgIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG4gIHZhciBpID0gcHJlZml4ZXMubGVuZ3RoO1xuICB2YXIgcHJlZml4ZWQ7XG4gIGlmIChjYW1lbCAhPT0gJ2ZpbHRlcicgJiYgY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlYmFiOiBwcm9wLFxuICAgICAgY2FtZWw6IGNhbWVsXG4gICAgfTtcbiAgfVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcHJlZml4ZWQgPSBjYW1lbFByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2ViYWI6IHByZWZpeGVzW2ldICsgcHJvcCxcbiAgICAgICAgY2FtZWw6IHByZWZpeGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyB4bGlua1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgeGxpbmtSRSA9IC9eeGxpbms6LztcblxuLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xudmFyIGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUgPSAvXnYtfF46fF5AfF4oPzppc3x0cmFuc2l0aW9ufHRyYW5zaXRpb24tbW9kZXxkZWJvdW5jZXx0cmFjay1ieXxzdGFnZ2VyfGVudGVyLXN0YWdnZXJ8bGVhdmUtc3RhZ2dlcikkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIGFsc28gc2V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuLy8gYmVjYXVzZSB0aGV5IG9ubHkgYWZmZWN0IHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBlbGVtZW50XG52YXIgYXR0cldpdGhQcm9wc1JFID0gL14oPzp2YWx1ZXxjaGVja2VkfHNlbGVjdGVkfG11dGVkKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBleHBlY3QgZW51bXJhdGVkIHZhbHVlcyBvZiBcInRydWVcIiBvciBcImZhbHNlXCJcbi8vIGJ1dCBhcmUgbm90IGJvb2xlYW4gYXR0cmlidXRlc1xudmFyIGVudW1lcmF0ZWRBdHRyUkUgPSAvXig/OmRyYWdnYWJsZXxjb250ZW50ZWRpdGFibGV8c3BlbGxjaGVjaykkLztcblxuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgc2V0IGEgaGlkZGVuIHByb3BlcnR5IGZvclxuLy8gYmluZGluZyB2LW1vZGVsIHRvIG9iamVjdCB2YWx1ZXNcbnZhciBtb2RlbFByb3BzID0ge1xuICB2YWx1ZTogJ192YWx1ZScsXG4gICd0cnVlLXZhbHVlJzogJ190cnVlVmFsdWUnLFxuICAnZmFsc2UtdmFsdWUnOiAnX2ZhbHNlVmFsdWUnXG59O1xuXG52YXIgYmluZCQxID0ge1xuXG4gIHByaW9yaXR5OiBCSU5ELFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZztcbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lO1xuICAgIC8vIHNob3VsZCBiZSBkZWVwIHdhdGNoIG9uIG9iamVjdCBtb2RlXG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICB0aGlzLmRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuICAgIHZhciB0b2tlbnMgPSBkZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbnMgd2l0aCBvbmUtdGltZSB0b2tlbnNcbiAgICAgIGlmIChkZXNjcmlwdG9yLmhhc09uZVRpbWUpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9rZW5zVG9FeHAodG9rZW5zLCB0aGlzLl9zY29wZSB8fCB0aGlzLnZtKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBhbGxvdyBiaW5kaW5nIG9uIG5hdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8IGF0dHIgPT09ICduYW1lJyAmJiAodGFnID09PSAnUEFSVElBTCcgfHwgdGFnID09PSAnU0xPVCcpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihhdHRyICsgJz1cIicgKyBkZXNjcmlwdG9yLnJhdyArICdcIjogJyArICdhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvbiBpcyBub3QgYWxsb3dlZCBpbiBWdWUuanMgJyArICdkaXJlY3RpdmVzIGFuZCBzcGVjaWFsIGF0dHJpYnV0ZXMuJywgdGhpcy52bSk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByYXcgPSBhdHRyICsgJz1cIicgKyBkZXNjcmlwdG9yLnJhdyArICdcIjogJztcbiAgICAgICAgLy8gd2FybiBzcmNcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzcmMnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAnYSA0MDQgcmVxdWVzdC4gVXNlIHYtYmluZDpzcmMgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gc3R5bGVcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3R5bGVcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ3RoZSBhdHRyaWJ1dGUgdG8gYmUgZGlzY2FyZGVkIGluIEludGVybmV0IEV4cGxvcmVyLiAnICsgJ1VzZSB2LWJpbmQ6c3R5bGUgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZztcbiAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICAvLyBzaGFyZSBvYmplY3QgaGFuZGxlciB3aXRoIHYtYmluZDpjbGFzc1xuICBoYW5kbGVPYmplY3Q6IHN0eWxlLmhhbmRsZU9iamVjdCxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIGhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGludGVycCA9IHRoaXMuZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICBhdHRyID0gY2FtZWxpemUoYXR0cik7XG4gICAgfVxuICAgIGlmICghaW50ZXJwICYmIGF0dHJXaXRoUHJvcHNSRS50ZXN0KGF0dHIpICYmIGF0dHIgaW4gZWwpIHtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyID09PSAndmFsdWUnID8gdmFsdWUgPT0gbnVsbCAvLyBJRTkgd2lsbCBzZXQgaW5wdXQudmFsdWUgdG8gXCJudWxsXCIgZm9yIG51bGwuLi5cbiAgICAgID8gJycgOiB2YWx1ZSA6IHZhbHVlO1xuXG4gICAgICBpZiAoZWxbYXR0cl0gIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICBlbFthdHRyXSA9IGF0dHJWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IG1vZGVsIHByb3BzXG4gICAgdmFyIG1vZGVsUHJvcCA9IG1vZGVsUHJvcHNbYXR0cl07XG4gICAgaWYgKCFpbnRlcnAgJiYgbW9kZWxQcm9wKSB7XG4gICAgICBlbFttb2RlbFByb3BdID0gdmFsdWU7XG4gICAgICAvLyB1cGRhdGUgdi1tb2RlbCBpZiBwcmVzZW50XG4gICAgICB2YXIgbW9kZWwgPSBlbC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwubGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gbm90IHNldCB2YWx1ZSBhdHRyaWJ1dGUgZm9yIHRleHRhcmVhXG4gICAgaWYgKGF0dHIgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgYXR0cmlidXRlXG4gICAgaWYgKGVudW1lcmF0ZWRBdHRyUkUudGVzdChhdHRyKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVkZ2UgY2FzZSAjMTk2MDpcbiAgICAgICAgLy8gY2xhc3MgaW50ZXJwb2xhdGlvbiBzaG91bGQgbm90IG92ZXJ3cml0ZSBWdWUgdHJhbnNpdGlvbiBjbGFzc1xuICAgICAgICBpZiAoZWwuX192X3RyYW5zKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJyAnICsgZWwuX192X3RyYW5zLmlkICsgJy10cmFuc2l0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBzZXRDbGFzcyhlbCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh4bGlua1JFLnRlc3QoYXR0cikpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywgYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWwgPSB7XG5cbiAgcHJpb3JpdHk6IEVMLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gY2FtZWxpemUodGhpcy5hcmcpO1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKGhhc093bihyZWZzLCBpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocmVmcywgaWQsIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChyZWZzW3RoaXMuaWRdID09PSB0aGlzLmVsKSB7XG4gICAgICByZWZzW3RoaXMuaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZWYgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgKyAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJywgdGhpcy52bSk7XG4gIH1cbn07XG5cbnZhciBjbG9hayA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudm0uJG9uY2UoJ3ByZS1ob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIG11c3QgZXhwb3J0IHBsYWluIG9iamVjdFxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIHRleHQ6IHRleHQkMSxcbiAgaHRtbDogaHRtbCxcbiAgJ2Zvcic6IHZGb3IsXG4gICdpZic6IHZJZixcbiAgc2hvdzogc2hvdyxcbiAgbW9kZWw6IG1vZGVsLFxuICBvbjogb24kMSxcbiAgYmluZDogYmluZCQxLFxuICBlbDogZWwsXG4gIHJlZjogcmVmLFxuICBjbG9hazogY2xvYWtcbn07XG5cbnZhciB2Q2xhc3MgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zZXRDbGFzcyh2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3Mobm9ybWFsaXplJDEodmFsdWUpKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q2xhc3M6IGZ1bmN0aW9uIHNldENsYXNzKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IHZhbHVlW2ldO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICBhcHBseSh0aGlzLmVsLCB2YWwsIGFkZENsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmV2S2V5cyA9IHZhbHVlO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAodmFsdWUpIHtcbiAgICB2YXIgcHJldktleXMgPSB0aGlzLnByZXZLZXlzO1xuICAgIGlmICghcHJldktleXMpIHJldHVybjtcbiAgICB2YXIgaSA9IHByZXZLZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJldktleXNbaV07XG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgYXBwbHkodGhpcy5lbCwga2V5LCByZW1vdmVDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMgKHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgb2JqZWN0cylcbiAqIGludG8gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplJDEodmFsdWUpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIF9rZXkgPSB2YWx1ZVtpXTtcbiAgICAgIGlmIChfa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2tleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXMucHVzaChfa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIF9rZXkpIHtcbiAgICAgICAgICAgIGlmIChfa2V5W2tdKSByZXMucHVzaChrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgcmVzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGEgY2xhc3MvY2xhc3NlcyBvbiBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgY2xhc3MgbmFtZS4gVGhpcyBtYXkgb3IgbWF5IG5vdFxuICogICAgICAgICAgICAgICAgICAgICBjb250YWluIGEgc3BhY2UgY2hhcmFjdGVyLCBpbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZSdsbCBkZWFsIHdpdGggbXVsdGlwbGUgY2xhc3NcbiAqICAgICAgICAgICAgICAgICAgICAgbmFtZXMgYXQgb25jZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHkoZWwsIGtleSwgZm4pIHtcbiAga2V5ID0ga2V5LnRyaW0oKTtcbiAgaWYgKGtleS5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgZm4oZWwsIGtleSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSBrZXkgY29udGFpbnMgb25lIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVycy5cbiAgLy8gU2luY2UgYSBjbGFzcyBuYW1lIGRvZXNuJ3QgYWNjZXB0IHN1Y2ggY2hhcmFjdGVycywgd2VcbiAgLy8gdHJlYXQgaXQgYXMgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgdmFyIGtleXMgPSBrZXkuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZuKGVsLCBrZXlzW2ldKTtcbiAgfVxufVxuXG52YXIgY29tcG9uZW50ID0ge1xuXG4gIHByaW9yaXR5OiBDT01QT05FTlQsXG5cbiAgcGFyYW1zOiBbJ2tlZXAtYWxpdmUnLCAndHJhbnNpdGlvbi1tb2RlJywgJ2lubGluZS10ZW1wbGF0ZSddLFxuXG4gIC8qKlxuICAgKiBTZXR1cC4gVHdvIHBvc3NpYmxlIHVzYWdlczpcbiAgICpcbiAgICogLSBzdGF0aWM6XG4gICAqICAgPGNvbXA+IG9yIDxkaXYgdi1jb21wb25lbnQ9XCJjb21wXCI+XG4gICAqXG4gICAqIC0gZHluYW1pYzpcbiAgICogICA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBpZiAoIXRoaXMuZWwuX192dWVfXykge1xuICAgICAgLy8ga2VlcC1hbGl2ZSBjYWNoZVxuICAgICAgdGhpcy5rZWVwQWxpdmUgPSB0aGlzLnBhcmFtcy5rZWVwQWxpdmU7XG4gICAgICBpZiAodGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBvbmVudCByZXNvbHV0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gdGhpcy5Db21wb25lbnQgPSBudWxsO1xuICAgICAgLy8gdHJhbnNpdGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscyA9IDA7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtY29tcG9uZW50Jyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICAgIC8vIHJlbW92ZSBpcyBhdHRyaWJ1dGUuXG4gICAgICAvLyB0aGlzIGlzIHJlbW92ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLCBidXQgYmVjYXVzZSBjb21waWxhdGlvbiBpc1xuICAgICAgLy8gY2FjaGVkLCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdXNlZCBlbHNld2hlcmUgdGhpcyBhdHRyaWJ1dGVcbiAgICAgIC8vIHdpbGwgcmVtYWluIGF0IGxpbmsgdGltZS5cbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJzppcycpO1xuICAgICAgLy8gcmVtb3ZlIHJlZiwgc2FtZSBhcyBhYm92ZVxuICAgICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtcmVmOicgKyBoeXBoZW5hdGUodGhpcy5kZXNjcmlwdG9yLnJlZikpO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignY2Fubm90IG1vdW50IGNvbXBvbmVudCBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgJyArICdvbiBhbHJlYWR5IG1vdW50ZWQgZWxlbWVudDogJyArIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN3aXRjaCBkeW5hbWljIGNvbXBvbmVudHMuIE1heSByZXNvbHZlIHRoZSBjb21wb25lbnRcbiAgICogYXN5bmNocm9ub3VzbHksIGFuZCBwZXJmb3JtIHRyYW5zaXRpb24gYmFzZWQgb25cbiAgICogc3BlY2lmaWVkIHRyYW5zaXRpb24gbW9kZS4gQWNjZXB0cyBhIGZldyBhZGRpdGlvbmFsXG4gICAqIGFyZ3VtZW50cyBzcGVjaWZpY2FsbHkgZm9yIHZ1ZS1yb3V0ZXIuXG4gICAqXG4gICAqIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgZnVsbCB0cmFuc2l0aW9uIGlzXG4gICAqIGZpbmlzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uIHNldENvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgLy8ganVzdCByZW1vdmUgY3VycmVudFxuICAgICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYik7XG4gICAgICB0aGlzLmNoaWxkVk0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciB0byB1c2Ugd2hlbiBjcmVhdGluZ1xuICAgKiB0aGUgY2hpbGQgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IG51bGwpO1xuICAgICAgc2VsZi5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICBjYigpO1xuICAgIH0pO1xuICAgIHRoaXMudm0uX3Jlc29sdmVDb21wb25lbnQodmFsdWUsIHRoaXMucGVuZGluZ0NvbXBvbmVudENiKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoY2IpIHtcbiAgICAvLyBhY3R1YWwgbW91bnRcbiAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3RpdmF0ZUhvb2tzID0gdGhpcy5Db21wb25lbnQub3B0aW9ucy5hY3RpdmF0ZTtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKTtcbiAgICB2YXIgbmV3Q29tcG9uZW50ID0gdGhpcy5idWlsZCgpO1xuICAgIGlmIChhY3RpdmF0ZUhvb2tzICYmICFjYWNoZWQpIHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG5ld0NvbXBvbmVudDtcbiAgICAgIGNhbGxBY3RpdmF0ZUhvb2tzKGFjdGl2YXRlSG9va3MsIG5ld0NvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi53YWl0aW5nRm9yICE9PSBuZXdDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi53YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgc2VsZi50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSByZWYgZm9yIGtlcHQtYWxpdmUgY29tcG9uZW50XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIG5ld0NvbXBvbmVudC5fdXBkYXRlUmVmKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb21wb25lbnQgY2hhbmdlcyBvciB1bmJpbmRzIGJlZm9yZSBhbiBhc3luY1xuICAgKiBjb25zdHJ1Y3RvciBpcyByZXNvbHZlZCwgd2UgbmVlZCB0byBpbnZhbGlkYXRlIGl0c1xuICAgKiBwZW5kaW5nIGNhbGxiYWNrLlxuICAgKi9cblxuICBpbnZhbGlkYXRlUGVuZGluZzogZnVuY3Rpb24gaW52YWxpZGF0ZVBlbmRpbmcoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYi5jYW5jZWwoKTtcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlL2luc2VydCBhIG5ldyBjaGlsZCB2bS5cbiAgICogSWYga2VlcCBhbGl2ZSBhbmQgaGFzIGNhY2hlZCBpbnN0YW5jZSwgaW5zZXJ0IHRoYXRcbiAgICogaW5zdGFuY2U7IG90aGVyd2lzZSBidWlsZCBhIG5ldyBvbmUgYW5kIGNhY2hlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhT3B0aW9uc11cbiAgICogQHJldHVybiB7VnVlfSAtIHRoZSBjcmVhdGVkIGluc3RhbmNlXG4gICAqL1xuXG4gIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChleHRyYU9wdGlvbnMpIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgZWw6IGNsb25lTm9kZSh0aGlzLmVsKSxcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBhZGQgdGhlIGNoaWxkIHdpdGggY29ycmVjdCBwYXJlbnRcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgaXRzIHBhcmVudFxuICAgICAgICAvLyBzaG91bGQgYmUgdGhlIHRyYW5zY2x1c2lvbiBob3N0LlxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2hvc3QgfHwgdGhpcy52bSxcbiAgICAgICAgLy8gaWYgbm8gaW5saW5lLXRlbXBsYXRlLCB0aGVuIHRoZSBjb21waWxlZFxuICAgICAgICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICBfbGlua2VyQ2FjaGFibGU6ICF0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICBfcmVmOiB0aGlzLmRlc2NyaXB0b3IucmVmLFxuICAgICAgICBfYXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICBfY29udGV4dDogdGhpcy52bSxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAvLyBwYXNzIGluIHRoZSBvd25lciBmcmFnbWVudCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB0aGUgZnJhZ21lbnQgY2FuIGtlZXBcbiAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGNhbGwgYXR0YWNoL2RldGFjaCBob29rcyBmb3IgdGhlbS5cbiAgICAgICAgX2ZyYWc6IHRoaXMuX2ZyYWdcbiAgICAgIH07XG4gICAgICAvLyBleHRyYSBvcHRpb25zXG4gICAgICAvLyBpbiAxLjAuMCB0aGlzIGlzIHVzZWQgYnkgdnVlLXJvdXRlciBvbmx5XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5Db21wb25lbnQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwuaGFzQXR0cmlidXRlKCd0cmFuc2l0aW9uJykgJiYgY2hpbGQuX2lzRnJhZ21lbnQpIHtcbiAgICAgICAgd2FybignVHJhbnNpdGlvbnMgd2lsbCBub3Qgd29yayBvbiBhIGZyYWdtZW50IGluc3RhbmNlLiAnICsgJ1RlbXBsYXRlOiAnICsgY2hpbGQuJG9wdGlvbnMudGVtcGxhdGUsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyeSB0byBnZXQgYSBjYWNoZWQgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICAgKi9cblxuICBnZXRDYWNoZWQ6IGZ1bmN0aW9uIGdldENhY2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZWVwQWxpdmUgJiYgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIHVuYnVpbGQoZGVmZXIpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yKSB7XG4gICAgICBpZiAoIXRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMud2FpdGluZ0Zvci4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy53YWl0aW5nRm9yID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZFZNO1xuICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAvLyByZW1vdmUgcmVmXG4gICAgICAgIGNoaWxkLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGNoaWxkLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYGRlZmVyQ2xlYW51cGAgaXMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBcImRlYWN0aXZhdGVcIiB0aGUgdm0gcmlnaHQgbm93IGFuZCBwZXJmb3JtIERPTSByZW1vdmFsXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuJGRlc3Ryb3koZmFsc2UsIGRlZmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGN1cnJlbnQgZGVzdHJveWVkIGNoaWxkIGFuZCBtYW51YWxseSBkb1xuICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCwgY2IpIHtcbiAgICB2YXIga2VlcEFsaXZlID0gdGhpcy5rZWVwQWxpdmU7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICAvLyB3ZSBtYXkgaGF2ZSBhIGNvbXBvbmVudCBzd2l0Y2ggd2hlbiBhIHByZXZpb3VzXG4gICAgICAvLyBjb21wb25lbnQgaXMgc3RpbGwgYmVpbmcgdHJhbnNpdGlvbmVkIG91dC5cbiAgICAgIC8vIHdlIHdhbnQgdG8gdHJpZ2dlciBvbmx5IG9uZSBsYXN0ZXN0IGluc2VydGlvbiBjYlxuICAgICAgLy8gd2hlbiB0aGUgZXhpc3RpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcy4gKCMxMTE5KVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMrKztcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IGNiO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2hpbGQuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxzLS07XG4gICAgICAgIGlmICgha2VlcEFsaXZlKSBjaGlsZC5fY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ1JlbW92YWxzICYmIHNlbGYucGVuZGluZ1JlbW92YWxDYikge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpO1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBY3R1YWxseSBzd2FwIHRoZSBjb21wb25lbnRzLCBkZXBlbmRpbmcgb24gdGhlXG4gICAqIHRyYW5zaXRpb24gbW9kZS4gRGVmYXVsdHMgdG8gc2ltdWx0YW5lb3VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbih0YXJnZXQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGlsZFZNO1xuICAgIC8vIGZvciBkZXZ0b29sIGluc3BlY3Rpb25cbiAgICBpZiAoY3VycmVudCkgY3VycmVudC5faW5hY3RpdmUgPSB0cnVlO1xuICAgIHRhcmdldC5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkVk0gPSB0YXJnZXQ7XG4gICAgc3dpdGNoIChzZWxmLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnaW4tb3V0JzpcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ291dC1pbic6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50KTtcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZC5cbiAgICovXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgIC8vIERvIG5vdCBkZWZlciBjbGVhbnVwIHdoZW4gdW5iaW5kaW5nXG4gICAgdGhpcy51bmJ1aWxkKCk7XG4gICAgLy8gZGVzdHJveSBhbGwga2VlcC1hbGl2ZSBjYWNoZWQgaW5zdGFuY2VzXG4gICAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XS4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWN0aXZhdGUgaG9va3MgaW4gb3JkZXIgKGFzeW5jaHJvbm91cylcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZUhvb2tzKGhvb2tzLCB2bSwgY2IpIHtcbiAgdmFyIHRvdGFsID0gaG9va3MubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gMDtcbiAgaG9va3NbMF0uY2FsbCh2bSwgbmV4dCk7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKCsrY2FsbGVkID49IHRvdGFsKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rc1tjYWxsZWRdLmNhbGwodm0sIG5leHQpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcEJpbmRpbmdNb2RlcyA9IGNvbmZpZy5fcHJvcEJpbmRpbmdNb2RlcztcbnZhciBlbXB0eSA9IHt9O1xuXG4vLyByZWdleGVzXG52YXIgaWRlbnRSRSQxID0gL15bJF9hLXpBLVpdK1tcXHckXSokLztcbnZhciBzZXR0YWJsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbW15cXFtcXF1dK1xcXSkqJC87XG5cbi8qKlxuICogQ29tcGlsZSBwcm9wcyBvbiBhIHJvb3QgZWxlbWVudCBhbmQgcmV0dXJuXG4gKiBhIHByb3BzIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wT3B0aW9uc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUHJvcHMoZWwsIHByb3BPcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpO1xuICB2YXIgaSA9IG5hbWVzLmxlbmd0aDtcbiAgdmFyIG9wdGlvbnMsIG5hbWUsIGF0dHIsIHZhbHVlLCBwYXRoLCBwYXJzZWQsIHByb3A7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgb3B0aW9ucyA9IHByb3BPcHRpb25zW25hbWVdIHx8IGVtcHR5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJyRkYXRhJykge1xuICAgICAgd2FybignRG8gbm90IHVzZSAkZGF0YSBhcyBwcm9wLicsIHZtKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHByb3BzIGNvdWxkIGNvbnRhaW4gZGFzaGVzLCB3aGljaCB3aWxsIGJlXG4gICAgLy8gaW50ZXJwcmV0ZWQgYXMgbWludXMgY2FsY3VsYXRpb25zIGJ5IHRoZSBwYXJzZXJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBwYXRoIGhlcmVcbiAgICBwYXRoID0gY2FtZWxpemUobmFtZSk7XG4gICAgaWYgKCFpZGVudFJFJDEudGVzdChwYXRoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3Aga2V5OiBcIicgKyBuYW1lICsgJ1wiLiBQcm9wIGtleXMgJyArICdtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzLicsIHZtKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtb2RlOiBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVksXG4gICAgICByYXc6IG51bGxcbiAgICB9O1xuXG4gICAgYXR0ciA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAvLyBmaXJzdCBjaGVjayBkeW5hbWljIHZlcnNpb25cbiAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIpKSA9PT0gbnVsbCkge1xuICAgICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWTtcbiAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLm9uY2UnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgZHluYW1pYyBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVycztcbiAgICAgIC8vIGNoZWNrIGJpbmRpbmcgdHlwZVxuICAgICAgaWYgKGlzTGl0ZXJhbCh2YWx1ZSkgJiYgIXBhcnNlZC5maWx0ZXJzKSB7XG4gICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgLy8gYm9vbGVhbnMsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZXR1cCBhIHByb3AgYmluZGluZyxcbiAgICAgICAgLy8gc28gd2UgY2FuIG9wdGltaXplIHRoZW0gYXMgYSBvbmUtdGltZSBzZXQuXG4gICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAvLyBjaGVjayBub24tc2V0dGFibGUgcGF0aCBmb3IgdHdvLXdheSBiaW5kaW5nc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJiAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVk7XG4gICAgICAgICAgd2FybignQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgKyAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLnBhcmVudFBhdGggPSB2YWx1ZTtcblxuICAgICAgLy8gd2FybiByZXF1aXJlZCB0d28td2F5XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLnR3b1dheSAmJiBwcm9wLm1vZGUgIT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSkge1xuICAgICAgICB3YXJuKCdQcm9wIFwiJyArIG5hbWUgKyAnXCIgZXhwZWN0cyBhIHR3by13YXkgYmluZGluZyB0eXBlLicsIHZtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEF0dHIoZWwsIGF0dHIpKSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGFzIGxpdGVyYWwgYmluZGluZyFcbiAgICAgIHByb3AucmF3ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBjaGVjayBwb3NzaWJsZSBjYW1lbENhc2UgcHJvcCB1c2FnZVxuICAgICAgdmFyIGxvd2VyQ2FzZU5hbWUgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IC9bQS1aXFwtXS8udGVzdChuYW1lKSAmJiAoZWwuZ2V0QXR0cmlidXRlKGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybignUG9zc2libGUgdXNhZ2UgZXJyb3IgZm9yIHByb3AgYCcgKyBsb3dlckNhc2VOYW1lICsgJ2AgLSAnICsgJ2RpZCB5b3UgbWVhbiBgJyArIGF0dHIgKyAnYD8gSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2UgJyArICdrZWJhYi1jYXNlIGZvciBwcm9wcyBpbiB0ZW1wbGF0ZXMuJywgdm0pO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVkKSB7XG4gICAgICAgIC8vIHdhcm4gbWlzc2luZyByZXF1aXJlZFxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHB1c2ggcHJvcFxuICAgIHByb3BzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VQcm9wc0xpbmtGbihwcm9wcyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgcHJvcHMgdG8gYSB2bS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wc1xuICogQHJldHVybiB7RnVuY3Rpb259IHByb3BzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVByb3BzTGlua0ZuKHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9wc0xpbmtGbih2bSwgc2NvcGUpIHtcbiAgICAvLyBzdG9yZSByZXNvbHZlZCBwcm9wcyBpbmZvXG4gICAgdm0uX3Byb3BzID0ge307XG4gICAgdmFyIGlubGluZVByb3BzID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhO1xuICAgIHZhciBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHZhciBwcm9wLCBwYXRoLCBvcHRpb25zLCB2YWx1ZSwgcmF3O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHJhdyA9IHByb3AucmF3O1xuICAgICAgcGF0aCA9IHByb3AucGF0aDtcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gICAgICB2bS5fcHJvcHNbcGF0aF0gPSBwcm9wO1xuICAgICAgaWYgKGlubGluZVByb3BzICYmIGhhc093bihpbmxpbmVQcm9wcywgcGF0aCkpIHtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIGlubGluZVByb3BzW3BhdGhdKTtcbiAgICAgIH1pZiAocmF3ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgYWJzZW50IHByb3BcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICAvLyBkeW5hbWljIHByb3BcbiAgICAgICAgaWYgKHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRSkge1xuICAgICAgICAgIC8vIG9uZSB0aW1lIGJpbmRpbmdcbiAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bS5fY29udGV4dCB8fCB2bSkuJGdldChwcm9wLnBhcmVudFBhdGgpO1xuICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZtLl9jb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkeW5hbWljIGJpbmRpbmdcbiAgICAgICAgICAgIHZtLl9iaW5kRGlyKHtcbiAgICAgICAgICAgICAgbmFtZTogJ3Byb3AnLFxuICAgICAgICAgICAgICBkZWY6IHByb3BEZWYsXG4gICAgICAgICAgICAgIHByb3A6IHByb3BcbiAgICAgICAgICAgIH0sIG51bGwsIG51bGwsIHNjb3BlKTsgLy8gZWwsIGhvc3QsIHNjb3BlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZVxuICAgICAgICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdm0uJGdldChwcm9wLnBhcmVudFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wLm9wdGltaXplZExpdGVyYWwpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxpdGVyYWwsIGNhc3QgaXQgYW5kIGp1c3Qgc2V0IG9uY2VcbiAgICAgICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMocmF3KTtcbiAgICAgICAgdmFsdWUgPSBzdHJpcHBlZCA9PT0gcmF3ID8gdG9Cb29sZWFuKHRvTnVtYmVyKHJhdykpIDogc3RyaXBwZWQ7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCwgYnV0IHdlIG5lZWQgdG8gY2F0ZXIgZm9yXG4gICAgICAgIC8vIEJvb2xlYW4gcHJvcHMgd2l0aCBubyB2YWx1ZSwgb3Igd2l0aCBzYW1lXG4gICAgICAgIC8vIGxpdGVyYWwgdmFsdWUgKGUuZy4gZGlzYWJsZWQ9XCJkaXNhYmxlZFwiKVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1sb2FkZXIvaXNzdWVzLzE4MlxuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiAmJiAocmF3ID09PSAnJyB8fCByYXcgPT09IGh5cGhlbmF0ZShwcm9wLm5hbWUpKSA/IHRydWUgOiByYXc7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBwcm9wIHdpdGggYSByYXdWYWx1ZSwgYXBwbHlpbmcgbmVjZXNzYXJ5IGNvZXJzaW9ucyxcbiAqIGRlZmF1bHQgdmFsdWVzICYgYXNzZXJ0aW9ucyBhbmQgY2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgd2l0aFxuICogcHJvY2Vzc2VkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gcmF3VmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgcmF3VmFsdWUsIGZuKSB7XG4gIHZhciBpc1NpbXBsZSA9IHByb3AuZHluYW1pYyAmJiBpc1NpbXBsZVBhdGgocHJvcC5wYXJlbnRQYXRoKTtcbiAgdmFyIHZhbHVlID0gcmF3VmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wKTtcbiAgfVxuICB2YWx1ZSA9IGNvZXJjZVByb3AocHJvcCwgdmFsdWUsIHZtKTtcbiAgdmFyIGNvZXJjZWQgPSB2YWx1ZSAhPT0gcmF3VmFsdWU7XG4gIGlmICghYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSwgdm0pKSB7XG4gICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzU2ltcGxlICYmICFjb2VyY2VkKSB7XG4gICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZm4odmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZuKHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgcHJvcC5wYXRoLCB2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhIHByb3AncyB2YWx1ZSBvbiBhIHZtLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdm1bcHJvcC5wYXRoXSA9IHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIHZhciBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICBpZiAoIWhhc093bihvcHRpb25zLCAnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRlZiA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIjogJyArICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICsgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy50eXBlICE9PSBGdW5jdGlvbiA/IGRlZi5jYWxsKHZtKSA6IGRlZjtcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFByb3AocHJvcCwgdmFsdWUsIHZtKSB7XG4gIGlmICghcHJvcC5vcHRpb25zLnJlcXVpcmVkICYmICggLy8gbm9uLXJlcXVpcmVkXG4gIHByb3AucmF3ID09PSBudWxsIHx8IC8vIGFic2NlbnRcbiAgdmFsdWUgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIHZhciBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIi4nICsgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoZm9ybWF0VHlwZSkuam9pbignLCAnKSArICcsIGdvdCAnICsgZm9ybWF0VmFsdWUodmFsdWUpICsgJy4nLCB2bSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCIuJywgdm0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGb3JjZSBwYXJzaW5nIHZhbHVlIHdpdGggY29lcmNlIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2VQcm9wKHByb3AsIHZhbHVlLCB2bSkge1xuICB2YXIgY29lcmNlID0gcHJvcC5vcHRpb25zLmNvZXJjZTtcbiAgaWYgKCFjb2VyY2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgY29lcmNlIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIjogZXhwZWN0ZWQgZnVuY3Rpb24sIGdvdCAnICsgdHlwZW9mIGNvZXJjZSArICcuJywgdm0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlO1xuICBpZiAodHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZyc7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnbnVtYmVyJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnYm9vbGVhbic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBPYmplY3QpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnb2JqZWN0JztcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEFycmF5KSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2FycmF5JztcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5cbi8qKlxuICogRm9ybWF0IHR5cGUgZm9yIG91dHB1dFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID8gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkgOiAnY3VzdG9tIHR5cGUnO1xufVxuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbn1cblxudmFyIGJpbmRpbmdNb2RlcyA9IGNvbmZpZy5fcHJvcEJpbmRpbmdNb2RlcztcblxudmFyIHByb3BEZWYgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtO1xuICAgIHZhciBwYXJlbnQgPSBjaGlsZC5fY29udGV4dDtcbiAgICAvLyBwYXNzZWQgaW4gZnJvbSBjb21waWxlciBkaXJlY3RseVxuICAgIHZhciBwcm9wID0gdGhpcy5kZXNjcmlwdG9yLnByb3A7XG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoO1xuICAgIHZhciBwYXJlbnRLZXkgPSBwcm9wLnBhcmVudFBhdGg7XG4gICAgdmFyIHR3b1dheSA9IHByb3AubW9kZSA9PT0gYmluZGluZ01vZGVzLlRXT19XQVk7XG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHBhcmVudCwgcGFyZW50S2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB1cGRhdGVQcm9wKGNoaWxkLCBwcm9wLCB2YWwpO1xuICAgIH0sIHtcbiAgICAgIHR3b1dheTogdHdvV2F5LFxuICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgLy8gaW1wb3J0YW50OiBwcm9wcyBuZWVkIHRvIGJlIG9ic2VydmVkIG9uIHRoZVxuICAgICAgLy8gdi1mb3Igc2NvcGUgaWYgcHJlc2VudFxuICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdGhlIGNoaWxkIGluaXRpYWwgdmFsdWUuXG4gICAgaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpO1xuXG4gICAgLy8gc2V0dXAgdHdvLXdheSBiaW5kaW5nXG4gICAgaWYgKHR3b1dheSkge1xuICAgICAgLy8gaW1wb3J0YW50OiBkZWZlciB0aGUgY2hpbGQgd2F0Y2hlciBjcmVhdGlvbiB1bnRpbFxuICAgICAgLy8gdGhlIGNyZWF0ZWQgaG9vayAoYWZ0ZXIgZGF0YSBvYnNlcnZhdGlvbilcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRvbmNlKCdwcmUtaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNoaWxkV2F0Y2hlciA9IG5ldyBXYXRjaGVyKGNoaWxkLCBjaGlsZEtleSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHBhcmVudFdhdGNoZXIuc2V0KHZhbCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAvLyBlbnN1cmUgc3luYyB1cHdhcmQgYmVmb3JlIHBhcmVudCBzeW5jIGRvd24uXG4gICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgaW4gY2FzZXMgZS5nLiB0aGUgY2hpbGRcbiAgICAgICAgICAvLyBtdXRhdGVzIGEgcHJvcCBhcnJheSwgdGhlbiByZXBsYWNlcyBpdC4gKCMxNjgzKVxuICAgICAgICAgIHN5bmM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5wYXJlbnRXYXRjaGVyLnRlYXJkb3duKCk7XG4gICAgaWYgKHRoaXMuY2hpbGRXYXRjaGVyKSB7XG4gICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlJDEgPSBbXTtcbnZhciBxdWV1ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBQdXNoIGEgam9iIGludG8gdGhlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYlxuICovXG5cbmZ1bmN0aW9uIHB1c2hKb2Ioam9iKSB7XG4gIHF1ZXVlJDEucHVzaChqb2IpO1xuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgbmV4dFRpY2soZmx1c2gpO1xuICB9XG59XG5cbi8qKlxuICogRmx1c2ggdGhlIHF1ZXVlLCBhbmQgZG8gb25lIGZvcmNlZCByZWZsb3cgYmVmb3JlXG4gKiB0cmlnZ2VyaW5nIHRyYW5zaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAvLyBGb3JjZSBsYXlvdXRcbiAgdmFyIGYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlJDEubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZSQxW2ldKCk7XG4gIH1cbiAgcXVldWUkMSA9IFtdO1xuICBxdWV1ZWQgPSBmYWxzZTtcbiAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gIC8vIHVudXNlZCB2YXJpYWJsZSBmXG4gIHJldHVybiBmO1xufVxuXG52YXIgVFlQRV9UUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIFRZUEVfQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG52YXIgdHJhbnNEdXJhdGlvblByb3AgPSB0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbic7XG52YXIgYW5pbUR1cmF0aW9uUHJvcCA9IGFuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nO1xuXG4vKipcbiAqIElmIGEganVzdC1lbnRlcmVkIGVsZW1lbnQgaXMgYXBwbGllZCB0aGVcbiAqIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBlbnRlciB0cmFuc2l0aW9uIGhhc24ndCBzdGFydGVkIHlldCxcbiAqIGFuZCB0aGUgdHJhbnNpdGlvbmVkIHByb3BlcnR5IGhhcyB0aGUgc2FtZSB2YWx1ZSBmb3IgYm90aFxuICogZW50ZXIvbGVhdmUsIHRoZW4gdGhlIGxlYXZlIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkIGFuZFxuICogdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIFRoaXMgZnVuY3Rpb24gZW5zdXJlc1xuICogaXRzIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhZnRlciBhIHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWRcbiAqIGJ5IHdhaXRpbmcgZm9yIGRvdWJsZSByYWYuXG4gKlxuICogSXQgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0IG9uIGRldmljZXMgdGhhdCBzdXBwb3J0IENTU1xuICogdHJhbnNpdGlvbnMgYnV0IG5vdCByYWYgKGUuZy4gQW5kcm9pZCA0LjIgYnJvd3NlcikgLSBzaW5jZVxuICogdGhlc2UgZW52aXJvbm1lbnRzIGFyZSB1c3VhbGx5IHNsb3csIHdlIGFyZSBnaXZpbmcgaXQgYVxuICogcmVsYXRpdmVseSBsYXJnZSB0aW1lb3V0LlxuICovXG5cbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbnZhciB3YWl0Rm9yVHJhbnNpdGlvblN0YXJ0ID0gcmFmXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgc2V0VGltZW91dChmbiwgNTApO1xufTtcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5lbnRlckNsYXNzID0gaG9va3MgJiYgaG9va3MuZW50ZXJDbGFzcyB8fCBpZCArICctZW50ZXInO1xuICB0aGlzLmxlYXZlQ2xhc3MgPSBob29rcyAmJiBob29rcy5sZWF2ZUNsYXNzIHx8IGlkICsgJy1sZWF2ZSc7XG4gIHRoaXMuaG9va3MgPSBob29rcztcbiAgdGhpcy52bSA9IHZtO1xuICAvLyBhc3luYyBzdGF0ZVxuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB0aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xuICAvLyBjaGVjayBjc3MgdHJhbnNpdGlvbiB0eXBlXG4gIHRoaXMudHlwZSA9IGhvb2tzICYmIGhvb2tzLnR5cGU7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSBUWVBFX1RSQU5TSVRJT04gJiYgdGhpcy50eXBlICE9PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgd2FybignaW52YWxpZCBDU1MgdHJhbnNpdGlvbiB0eXBlIGZvciB0cmFuc2l0aW9uPVwiJyArIHRoaXMuaWQgKyAnXCI6ICcgKyB0aGlzLnR5cGUsIHZtKTtcbiAgICB9XG4gIH1cbiAgLy8gYmluZFxuICB2YXIgc2VsZiA9IHRoaXM7WydlbnRlck5leHRUaWNrJywgJ2VudGVyRG9uZScsICdsZWF2ZU5leHRUaWNrJywgJ2xlYXZlRG9uZSddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICBzZWxmW21dID0gYmluZChzZWxmW21dLCBzZWxmKTtcbiAgfSk7XG59XG5cbnZhciBwJDEgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGVudGVyIHRyYW5zaXRpb24gdHJpZ2dlcmVkXG4gKiAyLiBjYWxsIGJlZm9yZUVudGVyIGhvb2tcbiAqIDMuIGFkZCBlbnRlciBjbGFzc1xuICogNC4gaW5zZXJ0L3Nob3cgZWxlbWVudFxuICogNS4gY2FsbCBlbnRlciBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNi4gcmVmbG93XG4gKiA3LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb246XG4gKiAgICAgICAgcmVtb3ZlIGNsYXNzIG5vdywgd2FpdCBmb3IgdHJhbnNpdGlvbmVuZCxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGFuaW1hdGlvbmVuZCwgcmVtb3ZlIGNsYXNzLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIG5vdyBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogOC4gd2FpdCBmb3IgZWl0aGVyIGRvbmUgb3IganMgY2FsbGJhY2ssIHRoZW4gY2FsbFxuICogICAgYWZ0ZXJFbnRlciBob29rLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gaW5zZXJ0L3Nob3cgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5wJDEuZW50ZXIgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICB0aGlzLmNhbGxIb29rKCdiZWZvcmVFbnRlcicpO1xuICB0aGlzLmNiID0gY2I7XG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIG9wKCk7XG4gIHRoaXMuZW50ZXJlZCA9IGZhbHNlO1xuICB0aGlzLmNhbGxIb29rV2l0aENiKCdlbnRlcicpO1xuICBpZiAodGhpcy5lbnRlcmVkKSB7XG4gICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gIH1cbiAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuZW50ZXJDYW5jZWxsZWQ7XG4gIHB1c2hKb2IodGhpcy5lbnRlck5leHRUaWNrKTtcbn07XG5cbi8qKlxuICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLCB3aGljaCBpc1xuICogdG8gYmUgcHVzaGVkIGludG8gYSBxdWV1ZSBhbmQgZXhlY3V0ZWQgYWZ0ZXIgYSByZWZsb3cgc29cbiAqIHRoYXQgcmVtb3ZpbmcgdGhlIGNsYXNzIGNhbiB0cmlnZ2VyIGEgQ1NTIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgLy8gcHJldmVudCB0cmFuc2l0aW9uIHNraXBwaW5nXG4gIHRoaXMuanVzdEVudGVyZWQgPSB0cnVlO1xuICB3YWl0Rm9yVHJhbnNpdGlvblN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB9KTtcbiAgdmFyIGVudGVyRG9uZSA9IHRoaXMuZW50ZXJEb25lO1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIGJ5IHJlbW92aW5nIGVudGVyIGNsYXNzIG5vd1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYih0cmFuc2l0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlckRvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmxlYXZlID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKTtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLmNiID0gY2I7XG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLmNhbGxIb29rV2l0aENiKCdsZWF2ZScpO1xuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gIH1cbiAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MubGVhdmVDYW5jZWxsZWQ7XG4gIC8vIG9ubHkgbmVlZCB0byBoYW5kbGUgbGVhdmVEb25lIGlmXG4gIC8vIDEuIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgZG9uZSAoc3luY2hyb25vdXNseSBjYWxsZWRcbiAgLy8gICAgYnkgdGhlIHVzZXIsIHdoaWNoIGNhdXNlcyB0aGlzLm9wIHNldCB0byBudWxsKVxuICAvLyAyLiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrXG4gIGlmICh0aGlzLm9wICYmICF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgLy8gaWYgYSBDU1MgdHJhbnNpdGlvbiBsZWF2ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgZW50ZXIsXG4gICAgLy8gdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIHRoZXJlZm9yZSB3ZVxuICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBlbmQgdGhlIGxlYXZlIGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLmp1c3RFbnRlcmVkKSB7XG4gICAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoSm9iKHRoaXMubGVhdmVOZXh0VGljayk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmxlYXZlQ2xhc3MpO1xuICBpZiAodHlwZSkge1xuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHRoaXMuc2V0dXBDc3NDYihldmVudCwgdGhpcy5sZWF2ZURvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGVhdmVEb25lKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHRoaXMub3AoKTtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJMZWF2ZScpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xuICB0aGlzLm9wID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FuY2VsIGFueSBwZW5kaW5nIGNhbGxiYWNrcyBmcm9tIGEgcHJldmlvdXNseSBydW5uaW5nXG4gKiBidXQgbm90IGZpbmlzaGVkIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmNhbmNlbFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdmFyIGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgb2ZmKHRoaXMuZWwsIHRoaXMucGVuZGluZ0Nzc0V2ZW50LCB0aGlzLnBlbmRpbmdDc3NDYik7XG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiLmNhbmNlbCgpO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB9XG4gIGlmIChoYXNQZW5kaW5nKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdKSB7XG4gICAgdGhpcy5ob29rc1t0eXBlXS5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkLCBwb3RlbnRpYWxseS1hc3luYyBob29rIGZ1bmN0aW9uLlxuICogV2UgY2hlY2sgZm9yIHRoZSBsZW5ndGggb2YgYXJndW1lbnRzIHRvIHNlZSBpZiB0aGUgaG9va1xuICogZXhwZWN0cyBhIGBkb25lYCBjYWxsYmFjay4gSWYgdHJ1ZSwgdGhlIHRyYW5zaXRpb24ncyBlbmRcbiAqIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB3aGVuIHRoZSB1c2VyIGNhbGxzIHRoYXQgY2FsbGJhY2s7XG4gKiBvdGhlcndpc2UsIHRoZSBlbmQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgQ1NTIHRyYW5zaXRpb24gb3JcbiAqIGFuaW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdO1xuICBpZiAoaG9vaykge1xuICAgIGlmIChob29rLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBjYW5jZWxsYWJsZSh0aGlzW3R5cGUgKyAnRG9uZSddKTtcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgdHJhbnNpdGlvbiB0eXBlIGJhc2VkIG9uIHRoZVxuICogY2FsY3VsYXRlZCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5cbnAkMS5nZXRDc3NUcmFuc2l0aW9uVHlwZSA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgQ1NTIHRyYW5zaXRpb25zIGlmIHBhZ2UgaXMgbm90IHZpc2libGUgLVxuICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gIC8vIGZpcmluZyB1bnRpbCB0aGUgcGFnZSBpcyB2aXNpYmxlIGFnYWluLlxuICAvLyBwYWdlVmlzaWJpbGl0eSBBUEkgaXMgc3VwcG9ydGVkIGluIElFMTArLCBzYW1lIGFzXG4gIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgZG9jdW1lbnQuaGlkZGVuIHx8XG4gIC8vIGV4cGxpY2l0IGpzLW9ubHkgdHJhbnNpdGlvblxuICB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuY3NzID09PSBmYWxzZSB8fFxuICAvLyBlbGVtZW50IGlzIGhpZGRlblxuICBpc0hpZGRlbih0aGlzLmVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZSB8fCB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdO1xuICBpZiAodHlwZSkgcmV0dXJuIHR5cGU7XG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlO1xuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcbiAgdmFyIHRyYW5zRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXTtcbiAgaWYgKHRyYW5zRHVyYXRpb24gJiYgdHJhbnNEdXJhdGlvbiAhPT0gJzBzJykge1xuICAgIHR5cGUgPSBUWVBFX1RSQU5TSVRJT047XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9IGlubGluZVN0eWxlc1thbmltRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1thbmltRHVyYXRpb25Qcm9wXTtcbiAgICBpZiAoYW5pbUR1cmF0aW9uICYmIGFuaW1EdXJhdGlvbiAhPT0gJzBzJykge1xuICAgICAgdHlwZSA9IFRZUEVfQU5JTUFUSU9OO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlO1xuICB9XG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucCQxLnNldHVwQ3NzQ2IgPSBmdW5jdGlvbiAoZXZlbnQsIGNiKSB7XG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gZXZlbnQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsID0gdGhpcy5lbDtcbiAgdmFyIG9uRW5kID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIG9mZihlbCwgZXZlbnQsIG9uRW5kKTtcbiAgICAgIHNlbGYucGVuZGluZ0Nzc0V2ZW50ID0gc2VsZi5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLnBlbmRpbmdKc0NiICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBvbihlbCwgZXZlbnQsIG9uRW5kKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBoaWRkZW4gLSBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3RcbiAqIHNraXAgdGhlIHRyYW5zaXRpb24gYWxsdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICBpZiAoL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaGF2ZSBvZmZzZXQoV2lkdGh8SGVpZ2h0KVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNsaWVudCByZWN0XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gIShyZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IFRSQU5TSVRJT04sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAvLyByZXNvbHZlIG9uIG93bmVyIHZtXG4gICAgdmFyIGhvb2tzID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICd0cmFuc2l0aW9ucycsIGlkKTtcbiAgICBpZCA9IGlkIHx8ICd2JztcbiAgICBvbGRJZCA9IG9sZElkIHx8ICd2JztcbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLnZtKTtcbiAgICByZW1vdmVDbGFzcyhlbCwgb2xkSWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgICBhZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgfVxufTtcblxudmFyIGludGVybmFsRGlyZWN0aXZlcyA9IHtcbiAgc3R5bGU6IHN0eWxlLFxuICAnY2xhc3MnOiB2Q2xhc3MsXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBwcm9wOiBwcm9wRGVmLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uJDFcbn07XG5cbi8vIHNwZWNpYWwgYmluZGluZyBwcmVmaXhlc1xudmFyIGJpbmRSRSA9IC9edi1iaW5kOnxeOi87XG52YXIgb25SRSA9IC9edi1vbjp8XkAvO1xudmFyIGRpckF0dHJSRSA9IC9edi0oW146XSspKD86JHw6KC4qKSQpLztcbnZhciBtb2RpZmllclJFID0gL1xcLlteXFwuXSsvZztcbnZhciB0cmFuc2l0aW9uUkUgPSAvXih2LWJpbmQ6fDopP3RyYW5zaXRpb24kLztcblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcbnZhciBERUZBVUxUX1RFUk1JTkFMX1BSSU9SSVRZID0gMjAwMDtcblxuLyoqXG4gKiBDb21waWxlIGEgdGVtcGxhdGUgYW5kIHJldHVybiBhIHJldXNhYmxlIGNvbXBvc2l0ZSBsaW5rXG4gKiBmdW5jdGlvbiwgd2hpY2ggcmVjdXJzaXZlbHkgY29udGFpbnMgbW9yZSBsaW5rIGZ1bmN0aW9uc1xuICogaW5zaWRlLiBUaGlzIHRvcCBsZXZlbCBjb21waWxlIGZ1bmN0aW9uIHdvdWxkIG5vcm1hbGx5XG4gKiBiZSBjYWxsZWQgb24gaW5zdGFuY2Ugcm9vdCBub2RlcywgYnV0IGNhbiBhbHNvIGJlIHVzZWRcbiAqIGZvciBwYXJ0aWFsIGNvbXBpbGF0aW9uIGlmIHRoZSBwYXJ0aWFsIGFyZ3VtZW50IGlzIHRydWUuXG4gKlxuICogVGhlIHJldHVybmVkIGNvbXBvc2l0ZSBsaW5rIGZ1bmN0aW9uLCB3aGVuIGNhbGxlZCwgd2lsbFxuICogcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBhbGwgZGlyZWN0aXZlc1xuICogY3JlYXRlZCBkdXJpbmcgdGhlIGxpbmtpbmcgcGhhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBwYXJ0aWFsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlKGVsLCBvcHRpb25zLCBwYXJ0aWFsKSB7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBub2RlIGl0c2VsZi5cbiAgdmFyIG5vZGVMaW5rRm4gPSBwYXJ0aWFsIHx8ICFvcHRpb25zLl9hc0NvbXBvbmVudCA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKSA6IG51bGw7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBjaGlsZE5vZGVzXG4gIHZhciBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiAhaXNTY3JpcHQoZWwpICYmIGVsLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChlbC5jaGlsZE5vZGVzLCBvcHRpb25zKSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgY29tcG9zaXRlIGxpbmtlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYSBhbHJlYWR5XG4gICAqIGNvbXBpbGVkIHBpZWNlIG9mIERPTSwgd2hpY2ggaW5zdGFudGlhdGVzIGFsbCBkaXJlY3RpdmVcbiAgICogaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSBob3N0IHZtIG9mIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cblxuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkoZWwuY2hpbGROb2Rlcyk7XG4gICAgLy8gbGlua1xuICAgIHZhciBkaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gY29tcG9zaXRlTGlua0NhcHR1cmVyKCkge1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICBpZiAoY2hpbGRMaW5rRm4pIGNoaWxkTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfSwgdm0pO1xuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIGRpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGx5IGEgbGlua2VyIHRvIGEgdm0vZWxlbWVudCBwYWlyIGFuZCBjYXB0dXJlIHRoZVxuICogZGlyZWN0aXZlcyBjcmVhdGVkIGR1cmluZyB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIGxpbmtBbmRDYXB0dXJlKGxpbmtlciwgdm0pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gcmVzZXQgZGlyZWN0aXZlcyBiZWZvcmUgZXZlcnkgY2FwdHVyZSBpbiBwcm9kdWN0aW9uXG4gICAgLy8gbW9kZSwgc28gdGhhdCB3aGVuIHVubGlua2luZyB3ZSBkb24ndCBuZWVkIHRvIHNwbGljZVxuICAgIC8vIHRoZW0gb3V0ICh3aGljaCB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGhpdCkuXG4gICAgLy8gdGhleSBhcmUga2VwdCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgdGhleSBhcmVcbiAgICAvLyB1c2VmdWwgZm9yIFZ1ZSdzIG93biB0ZXN0cy5cbiAgICB2bS5fZGlyZWN0aXZlcyA9IFtdO1xuICB9XG4gIHZhciBvcmlnaW5hbERpckNvdW50ID0gdm0uX2RpcmVjdGl2ZXMubGVuZ3RoO1xuICBsaW5rZXIoKTtcbiAgdmFyIGRpcnMgPSB2bS5fZGlyZWN0aXZlcy5zbGljZShvcmlnaW5hbERpckNvdW50KTtcbiAgZGlycy5zb3J0KGRpcmVjdGl2ZUNvbXBhcmF0b3IpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyc1tpXS5fYmluZCgpO1xuICB9XG4gIHJldHVybiBkaXJzO1xufVxuXG4vKipcbiAqIERpcmVjdGl2ZSBwcmlvcml0eSBzb3J0IGNvbXBhcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqL1xuXG5mdW5jdGlvbiBkaXJlY3RpdmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgYSA9IGEuZGVzY3JpcHRvci5kZWYucHJpb3JpdHkgfHwgREVGQVVMVF9QUklPUklUWTtcbiAgYiA9IGIuZGVzY3JpcHRvci5kZWYucHJpb3JpdHkgfHwgREVGQVVMVF9QUklPUklUWTtcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5cbi8qKlxuICogTGlua2VyIGZ1bmN0aW9ucyByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXRcbiAqIHRlYXJzZG93biBhbGwgZGlyZWN0aXZlcyBpbnN0YW5jZXMgZ2VuZXJhdGVkIGR1cmluZ1xuICogdGhlIHByb2Nlc3MuXG4gKlxuICogV2UgY3JlYXRlIHVubGluayBmdW5jdGlvbnMgd2l0aCBvbmx5IHRoZSBuZWNlc3NhcnlcbiAqIGluZm9ybWF0aW9uIHRvIGF2b2lkIHJldGFpbmluZyBhZGRpdGlvbmFsIGNsb3N1cmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICogQHBhcmFtIHtWdWV9IFtjb250ZXh0XVxuICogQHBhcmFtIHtBcnJheX0gW2NvbnRleHREaXJzXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gbWFrZVVubGlua0ZuKHZtLCBkaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycykge1xuICBmdW5jdGlvbiB1bmxpbmsoZGVzdHJveWluZykge1xuICAgIHRlYXJkb3duRGlycyh2bSwgZGlycywgZGVzdHJveWluZyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dERpcnMpIHtcbiAgICAgIHRlYXJkb3duRGlycyhjb250ZXh0LCBjb250ZXh0RGlycyk7XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBsaW5rZWQgZGlyZWN0aXZlc1xuICB1bmxpbmsuZGlycyA9IGRpcnM7XG4gIHJldHVybiB1bmxpbms7XG59XG5cbi8qKlxuICogVGVhcmRvd24gcGFydGlhbCBsaW5rZWQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveWluZ1xuICovXG5cbmZ1bmN0aW9uIHRlYXJkb3duRGlycyh2bSwgZGlycywgZGVzdHJveWluZykge1xuICB2YXIgaSA9IGRpcnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlyc1tpXS5fdGVhcmRvd24oKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZGVzdHJveWluZykge1xuICAgICAgdm0uX2RpcmVjdGl2ZXMuJHJlbW92ZShkaXJzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGxpbmsgcHJvcHMgb24gYW4gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlQW5kTGlua1Byb3BzKHZtLCBlbCwgcHJvcHMsIHNjb3BlKSB7XG4gIHZhciBwcm9wc0xpbmtGbiA9IGNvbXBpbGVQcm9wcyhlbCwgcHJvcHMsIHZtKTtcbiAgdmFyIHByb3BEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgIHByb3BzTGlua0ZuKHZtLCBzY29wZSk7XG4gIH0sIHZtKTtcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIHJvb3QgZWxlbWVudCBvZiBhbiBpbnN0YW5jZS5cbiAqXG4gKiAxLiBhdHRycyBvbiBjb250ZXh0IGNvbnRhaW5lciAoY29udGV4dCBzY29wZSlcbiAqIDIuIGF0dHJzIG9uIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgcm9vdCBub2RlLCBpZlxuICogICAgcmVwbGFjZTp0cnVlIChjaGlsZCBzY29wZSlcbiAqXG4gKiBJZiB0aGlzIGlzIGEgZnJhZ21lbnQgaW5zdGFuY2UsIHdlIG9ubHkgbmVlZCB0byBjb21waWxlIDEuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzO1xuICB2YXIgcmVwbGFjZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnM7XG4gIHZhciBjb250ZXh0TGlua0ZuLCByZXBsYWNlckxpbmtGbjtcblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxhY2VyQXR0cnMpIHtcbiAgICAgICAgLy8gMy4gcmVwbGFjZXIgYXR0cmlidXRlc1xuICAgICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKHJlcGxhY2VyQXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tY29tcG9uZW50LCBqdXN0IGNvbXBpbGUgYXMgYSBub3JtYWwgZWxlbWVudC5cbiAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIGFsbG93IHZ1ZS1sb2FkZXIvdnVlaWZ5IHNjb3BlZCBjc3MgYXR0cmlidXRlc1xuICAgICAgcmV0dXJuIGF0dHIubmFtZS5pbmRleE9mKCdfdi0nKSA8IDAgJiZcbiAgICAgIC8vIGFsbG93IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgIW9uUkUudGVzdChhdHRyLm5hbWUpICYmXG4gICAgICAvLyBhbGxvdyBzbG90c1xuICAgICAgYXR0ci5uYW1lICE9PSAnc2xvdCc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIGF0dHIubmFtZSArICdcIic7XG4gICAgfSk7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHBsdXJhbCA9IG5hbWVzLmxlbmd0aCA+IDE7XG4gICAgICB3YXJuKCdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMuam9pbignLCAnKSArIChwbHVyYWwgPyAnIGFyZScgOiAnIGlzJykgKyAnIGlnbm9yZWQgb24gY29tcG9uZW50ICcgKyAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArICd0aGUgY29tcG9uZW50IGlzIGEgZnJhZ21lbnQgaW5zdGFuY2U6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9jb21wb25lbnRzLmh0bWwjRnJhZ21lbnQtSW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbih2bSwgZWwsIHNjb3BlKSB7XG4gICAgLy8gbGluayBjb250ZXh0IHNjb3BlIGRpcnNcbiAgICB2YXIgY29udGV4dCA9IHZtLl9jb250ZXh0O1xuICAgIHZhciBjb250ZXh0RGlycztcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0TGlua0ZuKSB7XG4gICAgICBjb250ZXh0RGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dExpbmtGbihjb250ZXh0LCBlbCwgbnVsbCwgc2NvcGUpO1xuICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpO1xuICAgIH0sIHZtKTtcblxuICAgIC8vIHJldHVybiB0aGUgdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGNvbnRleHRcbiAgICAvLyBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBzZWxmRGlycywgY29udGV4dCwgY29udGV4dERpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuIGJhc2VkIG9uIHRoZVxuICogbm9kZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gIGlmICh0eXBlID09PSAxICYmICFpc1NjcmlwdChub2RlKSkge1xuICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAzICYmIG5vZGUuZGF0YS50cmltKCkpIHtcbiAgICByZXR1cm4gY29tcGlsZVRleHROb2RlKG5vZGUsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50KGVsLCBvcHRpb25zKSB7XG4gIC8vIHByZXByb2Nlc3MgdGV4dGFyZWFzLlxuICAvLyB0ZXh0YXJlYSB0cmVhdHMgaXRzIHRleHQgY29udGVudCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgLy8ganVzdCBiaW5kIGl0IGFzIGFuIGF0dHIgZGlyZWN0aXZlIGZvciB2YWx1ZS5cbiAgaWYgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KGVsLnZhbHVlKTtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJzp2YWx1ZScsIHRva2Vuc1RvRXhwKHRva2VucykpO1xuICAgICAgZWwudmFsdWUgPSAnJztcbiAgICB9XG4gIH1cbiAgdmFyIGxpbmtGbjtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICB2YXIgYXR0cnMgPSBoYXNBdHRycyAmJiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICAvLyBjaGVjayB0ZXJtaW5hbCBkaXJlY3RpdmVzIChmb3IgJiBpZilcbiAgaWYgKGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIGF0dHJzLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBjb21wb25lbnRcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4gJiYgaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhhdHRycywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGxpbmtGbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGV4dE5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtUZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9IHRleHROb2RlTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVRleHROb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgLy8gc2tpcCBtYXJrZWQgdGV4dCBub2Rlc1xuICBpZiAobm9kZS5fc2tpcCkge1xuICAgIHJldHVybiByZW1vdmVUZXh0O1xuICB9XG5cbiAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChub2RlLndob2xlVGV4dCk7XG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBtYXJrIGFkamFjZW50IHRleHQgbm9kZXMgYXMgc2tpcHBlZCxcbiAgLy8gYmVjYXVzZSB3ZSBhcmUgdXNpbmcgbm9kZS53aG9sZVRleHQgdG8gY29tcGlsZVxuICAvLyBhbGwgYWRqYWNlbnQgdGV4dCBub2RlcyB0b2dldGhlci4gVGhpcyBmaXhlc1xuICAvLyBpc3N1ZXMgaW4gSUUgd2hlcmUgc29tZXRpbWVzIGl0IHNwbGl0cyB1cCBhIHNpbmdsZVxuICAvLyB0ZXh0IG5vZGUgaW50byBtdWx0aXBsZSBvbmVzLlxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgPT09IDMpIHtcbiAgICBuZXh0Ll9za2lwID0gdHJ1ZTtcbiAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgZWwsIHRva2VuO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBlbCA9IHRva2VuLnRhZyA/IHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG4gIHJldHVybiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBMaW5rZXIgZm9yIGFuIHNraXBwZWQgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVGV4dCh2bSwgbm9kZSkge1xuICByZW1vdmUobm9kZSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHNpbmdsZSB0ZXh0IHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykge1xuICB2YXIgZWw7XG4gIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRva2VuLmh0bWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgndi1odG1sJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgd2lsbCBjbGVhbiB1cCBlbXB0eSB0ZXh0Tm9kZXMgZHVyaW5nXG4gICAgICAvLyBmcmFnLmNsb25lTm9kZSh0cnVlKSwgc28gd2UgaGF2ZSB0byBnaXZlIGl0XG4gICAgICAvLyBzb21ldGhpbmcgaGVyZS4uLlxuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpO1xuICAgICAgc2V0VG9rZW5UeXBlKCd0ZXh0Jyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFRva2VuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRva2VuLmRlc2NyaXB0b3IpIHJldHVybjtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodG9rZW4udmFsdWUpO1xuICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiB0eXBlLFxuICAgICAgZGVmOiBkaXJlY3RpdmVzW3R5cGVdLFxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVyc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSB0ZXh0Tm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHRva2Vuc1xuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZykge1xuICByZXR1cm4gZnVuY3Rpb24gdGV4dE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSkge1xuICAgIHZhciBmcmFnQ2xvbmUgPSBmcmFnLmNsb25lTm9kZSh0cnVlKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkoZnJhZ0Nsb25lLmNoaWxkTm9kZXMpO1xuICAgIHZhciB0b2tlbiwgdmFsdWUsIG5vZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICBpZiAodG9rZW4udGFnKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAodG9rZW4ub25lVGltZSkge1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtKS4kZXZhbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRva2VuLmh0bWwpIHtcbiAgICAgICAgICAgIHJlcGxhY2Uobm9kZSwgcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShlbCwgZnJhZ0Nsb25lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBsaXN0IGFuZCByZXR1cm4gYSBjaGlsZExpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZUxpc3Qobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXTtcbiAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucyk7XG4gICAgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBub2RlLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChub2RlLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgICBsaW5rRm5zLnB1c2gobm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4pO1xuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aCA/IG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSA6IG51bGw7XG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGlsZExpbmtGbih2bSwgbm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdmFyIG5vZGUsIG5vZGVMaW5rRm4sIGNoaWxkcmVuTGlua0ZuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbCA9IGxpbmtGbnMubGVuZ3RoOyBpIDwgbDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgY2hpbGRyZW5MaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcbiAgICAgICAgbm9kZUxpbmtGbih2bSwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuTGlua0ZuKSB7XG4gICAgICAgIGNoaWxkcmVuTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBlbGVtZW50IGRpcmVjdGl2ZXMgKGN1c3RvbSBlbGVtZW50cyB0aGF0IHNob3VsZFxuICogYmUgcmVzb3ZsZWQgYXMgdGVybWluYWwgZGlyZWN0aXZlcykuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb21tb25UYWdSRS50ZXN0KHRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpO1xuICBpZiAoZGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIHRhZywgJycsIG9wdGlvbnMsIGRlZik7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LiBJZiB5ZXMsIHJldHVyblxuICogYSBjb21wb25lbnQgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKSB7XG4gIHZhciBjb21wb25lbnQgPSBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpO1xuICBpZiAoY29tcG9uZW50KSB7XG4gICAgdmFyIHJlZiA9IGZpbmRSZWYoZWwpO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogJ2NvbXBvbmVudCcsXG4gICAgICByZWY6IHJlZixcbiAgICAgIGV4cHJlc3Npb246IGNvbXBvbmVudC5pZCxcbiAgICAgIGRlZjogaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudCxcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICBsaXRlcmFsOiAhY29tcG9uZW50LmR5bmFtaWNcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRMaW5rRm4gPSBmdW5jdGlvbiBjb21wb25lbnRMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCByZWYsIG51bGwpO1xuICAgICAgfVxuICAgICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9O1xuICAgIGNvbXBvbmVudExpbmtGbi50ZXJtaW5hbCA9IHRydWU7XG4gICAgcmV0dXJuIGNvbXBvbmVudExpbmtGbjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gYXR0cnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGVybWluYWxMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgYXR0cnMsIG9wdGlvbnMpIHtcbiAgLy8gc2tpcCB2LXByZVxuICBpZiAoZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2tpcDtcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKHByZXYgJiYgcHJldi5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgcmV0dXJuIHNraXA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHIsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIG1hdGNoZWQsIGRpck5hbWUsIHJhd05hbWUsIGFyZywgZGVmLCB0ZXJtRGVmO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IGF0dHJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBuYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICBkZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBtYXRjaGVkWzFdKTtcbiAgICAgIGlmIChkZWYgJiYgZGVmLnRlcm1pbmFsKSB7XG4gICAgICAgIGlmICghdGVybURlZiB8fCAoZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfVEVSTUlOQUxfUFJJT1JJVFkpID4gdGVybURlZi5wcmlvcml0eSkge1xuICAgICAgICAgIHRlcm1EZWYgPSBkZWY7XG4gICAgICAgICAgcmF3TmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhhdHRyLm5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICBkaXJOYW1lID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlcm1EZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIHRlcm1EZWYsIHJhd05hbWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBza2lwKCkge31cbnNraXAudGVybWluYWwgPSB0cnVlO1xuXG4vKipcbiAqIEJ1aWxkIGEgbm9kZSBsaW5rIGZ1bmN0aW9uIGZvciBhIHRlcm1pbmFsIGRpcmVjdGl2ZS5cbiAqIEEgdGVybWluYWwgbGluayBmdW5jdGlvbiB0ZXJtaW5hdGVzIHRoZSBjdXJyZW50XG4gKiBjb21waWxhdGlvbiByZWN1cnNpb24gYW5kIGhhbmRsZXMgY29tcGlsYXRpb24gb2YgdGhlXG4gKiBzdWJ0cmVlIGluIHRoZSBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcmF3TmFtZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbYXJnXVxuICogQHBhcmFtIHtPYmplY3R9IFttb2RpZmllcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGVybWluYWxMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmLCByYXdOYW1lLCBhcmcsIG1vZGlmaWVycykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBkaXJOYW1lLFxuICAgIGFyZzogYXJnLFxuICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgIHJhdzogdmFsdWUsXG4gICAgYXR0cjogcmF3TmFtZSxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICBkZWY6IGRlZlxuICB9O1xuICAvLyBjaGVjayByZWYgZm9yIHYtZm9yIGFuZCByb3V0ZXItdmlld1xuICBpZiAoZGlyTmFtZSA9PT0gJ2ZvcicgfHwgZGlyTmFtZSA9PT0gJ3JvdXRlci12aWV3Jykge1xuICAgIGRlc2NyaXB0b3IucmVmID0gZmluZFJlZihlbCk7XG4gIH1cbiAgdmFyIGZuID0gZnVuY3Rpb24gdGVybWluYWxOb2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIGRlc2NyaXB0b3IucmVmLCBudWxsKTtcbiAgICB9XG4gICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbiAgZm4udGVybWluYWwgPSB0cnVlO1xuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZGlyZWN0aXZlcyBvbiBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBsaW5rZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOYW1lZE5vZGVNYXB9IGF0dHJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZURpcmVjdGl2ZXMoYXR0cnMsIG9wdGlvbnMpIHtcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gIHZhciBkaXJzID0gW107XG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgcmF3TmFtZSwgcmF3VmFsdWUsIGRpck5hbWUsIGFyZywgbW9kaWZpZXJzLCBkaXJEZWYsIHRva2VucywgbWF0Y2hlZDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGF0dHIubmFtZTtcbiAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICB0b2tlbnMgPSBwYXJzZVRleHQodmFsdWUpO1xuICAgIC8vIHJlc2V0IGFyZ1xuICAgIGFyZyA9IG51bGw7XG4gICAgLy8gY2hlY2sgbW9kaWZpZXJzXG4gICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG5cbiAgICAvLyBhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvbnNcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICB2YWx1ZSA9IHRva2Vuc1RvRXhwKHRva2Vucyk7XG4gICAgICBhcmcgPSBuYW1lO1xuICAgICAgcHVzaERpcignYmluZCcsIGRpcmVjdGl2ZXMuYmluZCwgdG9rZW5zKTtcbiAgICAgIC8vIHdhcm4gYWdhaW5zdCBtaXhpbmcgbXVzdGFjaGVzIHdpdGggdi1iaW5kXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBhdHRyLm5hbWUgPT09ICc6Y2xhc3MnIHx8IGF0dHIubmFtZSA9PT0gJ3YtYmluZDpjbGFzcyc7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd2FybignY2xhc3M9XCInICsgcmF3VmFsdWUgKyAnXCI6IERvIG5vdCBtaXggbXVzdGFjaGUgaW50ZXJwb2xhdGlvbiAnICsgJ2FuZCB2LWJpbmQgZm9yIFwiY2xhc3NcIiBvbiB0aGUgc2FtZSBlbGVtZW50LiBVc2Ugb25lIG9yIHRoZSBvdGhlci4nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZVxuXG4gICAgICAvLyBzcGVjaWFsIGF0dHJpYnV0ZTogdHJhbnNpdGlvblxuICAgICAgaWYgKHRyYW5zaXRpb25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpO1xuICAgICAgICBwdXNoRGlyKCd0cmFuc2l0aW9uJywgaW50ZXJuYWxEaXJlY3RpdmVzLnRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlXG5cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIGFyZyA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgICAgcHVzaERpcignb24nLCBkaXJlY3RpdmVzLm9uKTtcbiAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgYmluZGluZ3NcbiAgICAgICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGRpck5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ3N0eWxlJyB8fCBkaXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgaW50ZXJuYWxEaXJlY3RpdmVzW2Rpck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFyZyA9IGRpck5hbWU7XG4gICAgICAgICAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQgPSBuYW1lLm1hdGNoKGRpckF0dHJSRSkpIHtcbiAgICAgICAgICAgICAgZGlyTmFtZSA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG5cbiAgICAgICAgICAgICAgLy8gc2tpcCB2LWVsc2UgKHdoZW4gdXNlZCB3aXRoIHYtc2hvdylcbiAgICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlyRGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmIChkaXJEZWYpIHtcbiAgICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGRpckRlZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbnRlcnBUb2tlbnNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHB1c2hEaXIoZGlyTmFtZSwgZGVmLCBpbnRlcnBUb2tlbnMpIHtcbiAgICB2YXIgaGFzT25lVGltZVRva2VuID0gaW50ZXJwVG9rZW5zICYmIGhhc09uZVRpbWUoaW50ZXJwVG9rZW5zKTtcbiAgICB2YXIgcGFyc2VkID0gIWhhc09uZVRpbWVUb2tlbiAmJiBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgZGlycy5wdXNoKHtcbiAgICAgIG5hbWU6IGRpck5hbWUsXG4gICAgICBhdHRyOiByYXdOYW1lLFxuICAgICAgcmF3OiByYXdWYWx1ZSxcbiAgICAgIGRlZjogZGVmLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgIC8vIGNvbnZlcnNpb24gZnJvbSBpbnRlcnBvbGF0aW9uIHN0cmluZ3Mgd2l0aCBvbmUtdGltZSB0b2tlblxuICAgICAgLy8gdG8gZXhwcmVzc2lvbiBpcyBkaWZmZXJlZCB1bnRpbCBkaXJlY3RpdmUgYmluZCB0aW1lIHNvIHRoYXQgd2VcbiAgICAgIC8vIGhhdmUgYWNjZXNzIHRvIHRoZSBhY3R1YWwgdm0gY29udGV4dCBmb3Igb25lLXRpbWUgYmluZGluZ3MuXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQgJiYgcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICBpbnRlcnA6IGludGVycFRva2VucyxcbiAgICAgIGhhc09uZVRpbWU6IGhhc09uZVRpbWVUb2tlblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgbW9kaWZpZXJzIGZyb20gZGlyZWN0aXZlIGF0dHJpYnV0ZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGkgPSBtYXRjaC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQnVpbGQgYSBsaW5rIGZ1bmN0aW9uIGZvciBhbGwgZGlyZWN0aXZlcyBvbiBhIHNpbmdsZSBub2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkaXJlY3RpdmVzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZU5vZGVMaW5rRm4oZGlyZWN0aXZlcykge1xuICByZXR1cm4gZnVuY3Rpb24gbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fYmluZERpcihkaXJlY3RpdmVzW2ldLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBpbnRlcnBvbGF0aW9uIHN0cmluZyBjb250YWlucyBvbmUtdGltZSB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc09uZVRpbWUodG9rZW5zKSB7XG4gIHZhciBpID0gdG9rZW5zLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICh0b2tlbnNbaV0ub25lVGltZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTY3JpcHQoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmICghZWwuaGFzQXR0cmlidXRlKCd0eXBlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICd0ZXh0L2phdmFzY3JpcHQnKTtcbn1cblxudmFyIHNwZWNpYWxDaGFyUkUgPSAvW15cXHdcXC06XFwuXS87XG5cbi8qKlxuICogUHJvY2VzcyBhbiBlbGVtZW50IG9yIGEgRG9jdW1lbnRGcmFnbWVudCBiYXNlZCBvbiBhXG4gKiBpbnN0YW5jZSBvcHRpb24gb2JqZWN0LiBUaGlzIGFsbG93cyB1cyB0byB0cmFuc2NsdWRlXG4gKiBhIHRlbXBsYXRlIG5vZGUvZnJhZ21lbnQgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLFxuICogc28gdGhlIHByb2Nlc3NlZCBmcmFnbWVudCBjYW4gdGhlbiBiZSBjbG9uZWQgYW5kIHJldXNlZFxuICogaW4gdi1mb3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbCk7XG4gIH1cbiAgLy8gZm9yIHRlbXBsYXRlIHRhZ3MsIHdoYXQgd2Ugd2FudCBpcyBpdHMgY29udGVudCBhc1xuICAvLyBhIGRvY3VtZW50RnJhZ21lbnQgKGZvciBmcmFnbWVudCBpbnN0YW5jZXMpXG4gIGlmIChpc1RlbXBsYXRlKGVsKSkge1xuICAgIGVsID0gcGFyc2VUZW1wbGF0ZShlbCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQgJiYgIW9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSAnPHNsb3Q+PC9zbG90Pic7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gZXh0cmFjdENvbnRlbnQoZWwpO1xuICAgICAgZWwgPSB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAvLyBhbmNob3JzIGZvciBmcmFnbWVudCBpbnN0YW5jZVxuICAgIC8vIHBhc3NpbmcgaW4gYHBlcnNpc3Q6IHRydWVgIHRvIGF2b2lkIHRoZW0gYmVpbmdcbiAgICAvLyBkaXNjYXJkZWQgYnkgSUUgZHVyaW5nIHRlbXBsYXRlIGNsb25pbmdcbiAgICBwcmVwZW5kKGNyZWF0ZUFuY2hvcigndi1zdGFydCcsIHRydWUpLCBlbCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgb3B0aW9uLlxuICogSWYgdGhlIHJlcGxhY2Ugb3B0aW9uIGlzIHRydWUgdGhpcyB3aWxsIHN3YXAgdGhlICRlbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucykge1xuICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpO1xuICBpZiAoZnJhZykge1xuICAgIHZhciByZXBsYWNlciA9IGZyYWcuZmlyc3RDaGlsZDtcbiAgICB2YXIgdGFnID0gcmVwbGFjZXIudGFnTmFtZSAmJiByZXBsYWNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdZb3UgYXJlIG1vdW50aW5nIGFuIGluc3RhbmNlIHdpdGggYSB0ZW1wbGF0ZSB0byAnICsgJzxib2R5Pi4gVGhpcyB3aWxsIHJlcGxhY2UgPGJvZHk+IGVudGlyZWx5LiBZb3UgJyArICdzaG91bGQgcHJvYmFibHkgdXNlIGByZXBsYWNlOiBmYWxzZWAgaGVyZS4nKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIHRoZSBpbnN0YW5jZSBtdXN0XG4gICAgICAvLyBiZWNvbWUgYSBmcmFnbWVudCBpbnN0YW5jZTogYmFzaWNhbGx5IGFueXRoaW5nIHRoYXRcbiAgICAgIC8vIGNhbiBjcmVhdGUgbW9yZSB0aGFuIDEgcm9vdCBub2Rlcy5cbiAgICAgIGlmIChcbiAgICAgIC8vIG11bHRpLWNoaWxkcmVuIHRlbXBsYXRlXG4gICAgICBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgLy8gbm9uLWVsZW1lbnQgdGVtcGxhdGVcbiAgICAgIHJlcGxhY2VyLm5vZGVUeXBlICE9PSAxIHx8XG4gICAgICAvLyBzaW5nbGUgbmVzdGVkIGNvbXBvbmVudFxuICAgICAgdGFnID09PSAnY29tcG9uZW50JyB8fCByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpIHx8IGhhc0JpbmRBdHRyKHJlcGxhY2VyLCAnaXMnKSB8fFxuICAgICAgLy8gZWxlbWVudCBkaXJlY3RpdmVcbiAgICAgIHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpIHx8XG4gICAgICAvLyBmb3IgYmxvY2tcbiAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1mb3InKSB8fFxuICAgICAgLy8gaWYgYmxvY2tcbiAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IGV4dHJhY3RBdHRycyhyZXBsYWNlcik7XG4gICAgICAgIG1lcmdlQXR0cnMoZWwsIHJlcGxhY2VyKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogJyArIHRlbXBsYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGEgY29tcG9uZW50IGNvbnRhaW5lcidzIGF0dHJpYnV0ZXNcbiAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJzKGVsKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICByZXR1cm4gdG9BcnJheShlbC5hdHRyaWJ1dGVzKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBhdHRyaWJ1dGVzIG9mIHR3byBlbGVtZW50cywgYW5kIG1ha2Ugc3VyZVxuICogdGhlIGNsYXNzIG5hbWVzIGFyZSBtZXJnZWQgcHJvcGVybHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBmcm9tXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRvXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBdHRycyhmcm9tLCB0bykge1xuICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXM7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgbmFtZSwgdmFsdWU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIGlmICghdG8uaGFzQXR0cmlidXRlKG5hbWUpICYmICFzcGVjaWFsQ2hhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIHRvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnICYmICFwYXJzZVRleHQodmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlLnRyaW0oKSkpIHtcbiAgICAgIHZhbHVlLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIGFkZENsYXNzKHRvLCBjbHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2NhbiBhbmQgZGV0ZXJtaW5lIHNsb3QgY29udGVudCBkaXN0cmlidXRpb24uXG4gKiBXZSBkbyB0aGlzIGR1cmluZyB0cmFuc2NsdXNpb24gaW5zdGVhZCBhdCBjb21waWxlIHRpbWUgc28gdGhhdFxuICogdGhlIGRpc3RyaWJ1dGlvbiBpcyBkZWNvdXBsZWQgZnJvbSB0aGUgY29tcGlsYXRpb24gb3JkZXIgb2ZcbiAqIHRoZSBzbG90cy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGVudFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKHZtLCBjb250ZW50KSB7XG4gIGlmICghY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29udGVudHMgPSB2bS5fc2xvdENvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGVsLCBuYW1lO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZWwgPSBjb250ZW50LmNoaWxkcmVuW2ldO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkge1xuICAgICAgKGNvbnRlbnRzW25hbWVdIHx8IChjb250ZW50c1tuYW1lXSA9IFtdKSkucHVzaChlbCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXRCaW5kQXR0cihlbCwgJ3Nsb3QnKSkge1xuICAgICAgd2FybignVGhlIFwic2xvdFwiIGF0dHJpYnV0ZSBtdXN0IGJlIHN0YXRpYy4nLCB2bS4kcGFyZW50KTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIGNvbnRlbnRzKSB7XG4gICAgY29udGVudHNbbmFtZV0gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudHNbbmFtZV0sIGNvbnRlbnQpO1xuICB9XG4gIGlmIChjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHZhciBub2RlcyA9IGNvbnRlbnQuY2hpbGROb2RlcztcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmIG5vZGVzWzBdLm5vZGVUeXBlID09PSAzICYmICFub2Rlc1swXS5kYXRhLnRyaW0oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZW50c1snZGVmYXVsdCddID0gZXh0cmFjdEZyYWdtZW50KGNvbnRlbnQuY2hpbGROb2RlcywgY29udGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHF1YWxpZmllZCBjb250ZW50IG5vZGVzIGZyb20gYSBub2RlIGxpc3QuXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZXNcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCBwYXJlbnQpIHtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIG5vZGVzID0gdG9BcnJheShub2Rlcyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoaXNUZW1wbGF0ZShub2RlKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBwYXJzZVRlbXBsYXRlKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG5cblxudmFyIGNvbXBpbGVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNvbXBpbGU6IGNvbXBpbGUsXG5cdGNvbXBpbGVBbmRMaW5rUHJvcHM6IGNvbXBpbGVBbmRMaW5rUHJvcHMsXG5cdGNvbXBpbGVSb290OiBjb21waWxlUm9vdCxcblx0dHJhbnNjbHVkZTogdHJhbnNjbHVkZSxcblx0cmVzb2x2ZVNsb3RzOiByZXNvbHZlU2xvdHNcbn0pO1xuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIEFjY2Vzc29yIGZvciBgJGRhdGFgIHByb3BlcnR5LCBzaW5jZSBzZXR0aW5nICRkYXRhXG4gICAqIHJlcXVpcmVzIG9ic2VydmluZyB0aGUgbmV3IG9iamVjdCBhbmQgdXBkYXRpbmdcbiAgICogcHJveGllZCBwcm9wZXJ0aWVzLlxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdEYXRhKSB7XG4gICAgICBpZiAobmV3RGF0YSAhPT0gdGhpcy5fZGF0YSkge1xuICAgICAgICB0aGlzLl9zZXREYXRhKG5ld0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBzY29wZSBvZiBhbiBpbnN0YW5jZSwgd2hpY2ggY29udGFpbnM6XG4gICAqIC0gb2JzZXJ2ZWQgZGF0YVxuICAgKiAtIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICogLSB1c2VyIG1ldGhvZHNcbiAgICogLSBtZXRhIHByb3BlcnRpZXNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXRQcm9wcygpO1xuICAgIHRoaXMuX2luaXRNZXRhKCk7XG4gICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICB0aGlzLl9pbml0RGF0YSgpO1xuICAgIHRoaXMuX2luaXRDb21wdXRlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHByb3BzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIHZhciBlbCA9IG9wdGlvbnMuZWw7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAocHJvcHMgJiYgIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Byb3BzIHdpbGwgbm90IGJlIGNvbXBpbGVkIGlmIG5vIGBlbGAgb3B0aW9uIGlzICcgKyAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRvIGNvbnZlcnQgc3RyaW5nIHNlbGVjdG9ycyBpbnRvIGVsZW1lbnQgbm93XG4gICAgZWwgPSBvcHRpb25zLmVsID0gcXVlcnkoZWwpO1xuICAgIHRoaXMuX3Byb3BzVW5saW5rRm4gPSBlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiBwcm9wc1xuICAgIC8vIHByb3BzIG11c3QgYmUgbGlua2VkIGluIHByb3BlciBzY29wZSBpZiBpbnNpZGUgdi1mb3JcbiAgICA/IGNvbXBpbGVBbmRMaW5rUHJvcHModGhpcywgZWwsIHByb3BzLCB0aGlzLl9zY29wZSkgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkYXRhLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YUZuID0gdGhpcy4kb3B0aW9ucy5kYXRhO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSA9IGRhdGFGbiA/IGRhdGFGbigpIDoge307XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICBkYXRhID0ge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LicsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgaSwga2V5O1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gdGhlcmUgYXJlIHR3byBzY2VuYXJpb3Mgd2hlcmUgd2UgY2FuIHByb3h5IGEgZGF0YSBrZXk6XG4gICAgICAvLyAxLiBpdCdzIG5vdCBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wXG4gICAgICAvLyAyLiBpdCdzIHByb3ZpZGVkIHZpYSBhIGluc3RhbnRpYXRpb24gb3B0aW9uIEFORCB0aGVyZSBhcmUgbm9cbiAgICAgIC8vICAgIHRlbXBsYXRlIHByb3AgcHJlc2VudFxuICAgICAgaWYgKCFwcm9wcyB8fCAhaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybignRGF0YSBmaWVsZCBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgKyAnYXMgYSBwcm9wLiBUbyBwcm92aWRlIGRlZmF1bHQgdmFsdWUgZm9yIGEgcHJvcCwgdXNlIHRoZSBcImRlZmF1bHRcIiAnICsgJ3Byb3Agb3B0aW9uOyBpZiB5b3Ugd2FudCB0byBwYXNzIHByb3AgdmFsdWVzIHRvIGFuIGluc3RhbnRpYXRpb24gJyArICdjYWxsLCB1c2UgdGhlIFwicHJvcHNEYXRhXCIgb3B0aW9uLicsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICBvYnNlcnZlKGRhdGEsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBpbnN0YW5jZSdzICRkYXRhLiBDYWxsZWQgaW4gJGRhdGEncyBzZXR0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdEYXRhXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9O1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gbmV3RGF0YTtcbiAgICB2YXIga2V5cywga2V5LCBpO1xuICAgIC8vIHVucHJveHkga2V5cyBub3QgcHJlc2VudCBpbiBuZXcgZGF0YVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghKGtleSBpbiBuZXdEYXRhKSkge1xuICAgICAgICB0aGlzLl91bnByb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByb3h5IGtleXMgbm90IGFscmVhZHkgcHJveGllZCxcbiAgICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG5ld0RhdGEpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xuICAgICAgICAvLyBuZXcgcHJvcGVydHlcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2xkRGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyk7XG4gICAgb2JzZXJ2ZShuZXdEYXRhLCB0aGlzKTtcbiAgICB0aGlzLl9kaWdlc3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJveHkgYSBwcm9wZXJ0eSwgc28gdGhhdFxuICAgKiB2bS5wcm9wID09PSB2bS5fZGF0YS5wcm9wXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIC8vIG5lZWQgdG8gc3RvcmUgcmVmIHRvIHNlbGYgaGVyZVxuICAgICAgLy8gYmVjYXVzZSB0aGVzZSBnZXR0ZXIvc2V0dGVycyBtaWdodFxuICAgICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAgIC8vIHByb3RvdHlwZSBpbmhlcml0YW5jZS5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9kYXRhW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XG4gICAgICAgICAgc2VsZi5fZGF0YVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVucHJveHkgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91bnByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2UgdXBkYXRlIG9uIGV2ZXJ5IHdhdGNoZXIgaW4gc2NvcGUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3dhdGNoZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpOyAvLyBzaGFsbG93IHVwZGF0ZXNcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGNvbXB1dGVkIHByb3BlcnRpZXMuIFRoZXkgYXJlIGVzc2VudGlhbGx5XG4gICAqIHNwZWNpYWwgZ2V0dGVyL3NldHRlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRDb21wdXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLiRvcHRpb25zLmNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgdmFyIGRlZiA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYsIHRoaXMpO1xuICAgICAgICAgIGRlZi5zZXQgPSBub29wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldCA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IGJpbmQodXNlckRlZi5nZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgICBkZWYuc2V0ID0gdXNlckRlZi5zZXQgPyBiaW5kKHVzZXJEZWYuc2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyKGdldHRlciwgb3duZXIpIHtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKG93bmVyLCBnZXR0ZXIsIG51bGwsIHtcbiAgICAgIGxhenk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBpbnN0YW5jZSBtZXRob2RzLiBNZXRob2RzIG11c3QgYmUgYm91bmQgdG8gdGhlXG4gICAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFzc2VkIGRvd24gYXMgYSBwcm9wIHRvXG4gICAqIGNoaWxkIGNvbXBvbmVudHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2RzID0gdGhpcy4kb3B0aW9ucy5tZXRob2RzO1xuICAgIGlmIChtZXRob2RzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICB0aGlzW2tleV0gPSBiaW5kKG1ldGhvZHNba2V5XSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG1ldGEgaW5mb3JtYXRpb24gbGlrZSAkaW5kZXgsICRrZXkgJiAkdmFsdWUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRNZXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRhcyA9IHRoaXMuJG9wdGlvbnMuX21ldGE7XG4gICAgaWYgKG1ldGFzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodGhpcywga2V5LCBtZXRhc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBldmVudFJFID0gL152LW9uOnxeQC87XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldHVwIHRoZSBpbnN0YW5jZSdzIG9wdGlvbiBldmVudHMgJiB3YXRjaGVycy5cbiAgICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gICAqIGluc3RhbmNlJ3MgbWV0aG9kcyBieSBuYW1lLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHRoaXMsIG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpO1xuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgdi1vbiBldmVudHMgb24gYSBjaGlsZCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHModm0sIGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcztcbiAgICB2YXIgbmFtZSwgdmFsdWUsIGhhbmRsZXI7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKGV2ZW50UkUudGVzdChuYW1lKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKTtcbiAgICAgICAgLy8gZm9yY2UgdGhlIGV4cHJlc3Npb24gaW50byBhIHN0YXRlbWVudCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGFsd2F5cyBkeW5hbWljYWxseSByZXNvbHZlcyB0aGUgbWV0aG9kIHRvIGNhbGwgKCMyNjcwKVxuICAgICAgICAvLyBraW5kYSB1Z2x5IGhhY2ssIGJ1dCBkb2VzIHRoZSBqb2IuXG4gICAgICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWU7XG4gICAgICAgIGlmIChpc1NpbXBsZVBhdGgodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJy5hcHBseSh0aGlzLCAkYXJndW1lbnRzKSc7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgaGFuZGxlci5fZnJvbVBhcmVudCA9IHRydWU7XG4gICAgICAgIHZtLiRvbihuYW1lLnJlcGxhY2UoZXZlbnRSRSksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjYWxsYmFja3MgZm9yIG9wdGlvbiBldmVudHMgYW5kIHdhdGNoZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaFxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyh2bSwgYWN0aW9uLCBoYXNoKSB7XG4gICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgdmFyIGhhbmRsZXJzLCBrZXksIGksIGo7XG4gICAgZm9yIChrZXkgaW4gaGFzaCkge1xuICAgICAgaGFuZGxlcnMgPSBoYXNoW2tleV07XG4gICAgICBpZiAoaXNBcnJheShoYW5kbGVycykpIHtcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIHJlZ2lzdGVyIGFuIGV2ZW50L3dhdGNoIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE9iamVjdH0gaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGhhbmRsZXI7XG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZtW2FjdGlvbl0oa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgICB2YXIgbWV0aG9kID0gbWV0aG9kcyAmJiBtZXRob2RzW2hhbmRsZXJdO1xuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICB2bVthY3Rpb25dKGtleSwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICsgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICsgJzogXCInICsga2V5ICsgJ1wiLicsIHZtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRET01Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpO1xuICAgIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgYXR0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkF0dGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxBdHRhY2goY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBkZXRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRGV0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbERldGFjaChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCBoYW5kbGVycyBmb3IgYSBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICB0aGlzLiRlbWl0KCdwcmUtaG9vazonICsgaG9vayk7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy4kb3B0aW9uc1tob29rXTtcbiAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIGxpbmtzIGEgRE9NIGVsZW1lbnQgd2l0aCBhIHBpZWNlIG9mIGRhdGEsXG4gKiB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbi5cbiAqIEl0IHJlZ2lzdGVycyBhIHdhdGNoZXIgd2l0aCB0aGUgZXhwcmVzc2lvbiBhbmQgY2FsbHNcbiAqIHRoZSBET00gdXBkYXRlIGZ1bmN0aW9uIHdoZW4gYSBjaGFuZ2UgaXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBkZWZcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbZmlsdGVyc11cbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IFttb2RpZmllcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGl0ZXJhbFxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXR0clxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXJnXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSByYXdcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IFtyZWZdXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ludGVycF1cbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaGFzT25lVGltZV1cbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuZWwgPSBlbDtcbiAgLy8gY29weSBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbiAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lO1xuICB0aGlzLmV4cHJlc3Npb24gPSBkZXNjcmlwdG9yLmV4cHJlc3Npb247XG4gIHRoaXMuYXJnID0gZGVzY3JpcHRvci5hcmc7XG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnM7XG4gIHRoaXMuZmlsdGVycyA9IGRlc2NyaXB0b3IuZmlsdGVycztcbiAgdGhpcy5saXRlcmFsID0gdGhpcy5tb2RpZmllcnMgJiYgdGhpcy5tb2RpZmllcnMubGl0ZXJhbDtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZTtcbiAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0O1xuICB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICB0aGlzLl9mcmFnID0gZnJhZztcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdO1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLnB1c2godGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkaXJlY3RpdmUsIG1peGluIGRlZmluaXRpb24gcHJvcGVydGllcyxcbiAqIHNldHVwIHRoZSB3YXRjaGVyLCBjYWxsIGRlZmluaXRpb24gYmluZCgpIGFuZCB1cGRhdGUoKVxuICogaWYgcHJlc2VudC5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9iaW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICd2LScgKyBuYW1lO1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWY7XG4gIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy51cGRhdGUgPSBkZWY7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKHRoaXMsIGRlZik7XG4gIH1cblxuICAvLyBzZXR1cCBkaXJlY3RpdmUgcGFyYW1zXG4gIHRoaXMuX3NldHVwUGFyYW1zKCk7XG5cbiAgLy8gaW5pdGlhbCBiaW5kXG4gIGlmICh0aGlzLmJpbmQpIHtcbiAgICB0aGlzLmJpbmQoKTtcbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWU7XG5cbiAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgIHRoaXMudXBkYXRlICYmIHRoaXMudXBkYXRlKGRlc2NyaXB0b3IucmF3KTtcbiAgfSBlbHNlIGlmICgodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJiAodGhpcy51cGRhdGUgfHwgdGhpcy50d29XYXkpICYmICF0aGlzLl9jaGVja1N0YXRlbWVudCgpKSB7XG4gICAgLy8gd3JhcHBlZCB1cGRhdGVyIGZvciBjb250ZXh0XG4gICAgdmFyIGRpciA9IHRoaXM7XG4gICAgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKCFkaXIuX2xvY2tlZCkge1xuICAgICAgICAgIGRpci51cGRhdGUodmFsLCBvbGRWYWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBub29wJDE7XG4gICAgfVxuICAgIHZhciBwcmVQcm9jZXNzID0gdGhpcy5fcHJlUHJvY2VzcyA/IGJpbmQodGhpcy5fcHJlUHJvY2VzcywgdGhpcykgOiBudWxsO1xuICAgIHZhciBwb3N0UHJvY2VzcyA9IHRoaXMuX3Bvc3RQcm9jZXNzID8gYmluZCh0aGlzLl9wb3N0UHJvY2VzcywgdGhpcykgOiBudWxsO1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMudm0sIHRoaXMuZXhwcmVzc2lvbiwgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgIHtcbiAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICBkZWVwOiB0aGlzLmRlZXAsXG4gICAgICBwcmVQcm9jZXNzOiBwcmVQcm9jZXNzLFxuICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgfSk7XG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUod2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGFsbCBwYXJhbSBhdHRyaWJ1dGVzLCBlLmcuIHRyYWNrLWJ5LFxuICogdHJhbnNpdGlvbi1tb2RlLCBldGMuLi5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9zZXR1cFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhcmFtcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gIC8vIHN3YXAgdGhlIHBhcmFtcyBhcnJheSB3aXRoIGEgZnJlc2ggb2JqZWN0LlxuICB0aGlzLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBpID0gcGFyYW1zLmxlbmd0aDtcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBoeXBoZW5hdGUocGFyYW1zW2ldKTtcbiAgICBtYXBwZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgIHZhbCA9IGdldEJpbmRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAvLyBkeW5hbWljXG4gICAgICB0aGlzLl9zZXR1cFBhcmFtV2F0Y2hlcihtYXBwZWRLZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXRpY1xuICAgICAgdmFsID0gZ2V0QXR0cih0aGlzLmVsLCBrZXkpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFyYW1zW21hcHBlZEtleV0gPSB2YWwgPT09ICcnID8gdHJ1ZSA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYSB3YXRjaGVyIGZvciBhIGR5bmFtaWMgcGFyYW0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9zZXR1cFBhcmFtV2F0Y2hlciA9IGZ1bmN0aW9uIChrZXksIGV4cHJlc3Npb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHZhciB1bndhdGNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsO1xuICAgIC8vIHNpbmNlIHdlIGFyZSBpbiBpbW1lZGlhdGUgbW9kZSxcbiAgICAvLyBvbmx5IGNhbGwgdGhlIHBhcmFtIGNoYW5nZSBjYWxsYmFja3MgaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLnBhcmFtV2F0Y2hlcnMgJiYgc2VsZi5wYXJhbVdhdGNoZXJzW2tleV07XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IuY2FsbChzZWxmLCB2YWwsIG9sZFZhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgIHVzZXI6IGZhbHNlXG4gIH0pOyh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgfHwgKHRoaXMuX3BhcmFtVW53YXRjaEZucyA9IFtdKSkucHVzaCh1bndhdGNoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRpcmVjdGl2ZSBpcyBhIGZ1bmN0aW9uIGNhbGxlclxuICogYW5kIGlmIHRoZSBleHByZXNzaW9uIGlzIGEgY2FsbGFibGUgb25lLiBJZiBib3RoIHRydWUsXG4gKiB3ZSB3cmFwIHVwIHRoZSBleHByZXNzaW9uIGFuZCB1c2UgaXQgYXMgdGhlIGV2ZW50XG4gKiBoYW5kbGVyLlxuICpcbiAqIGUuZy4gb24tY2xpY2s9XCJhKytcIlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fY2hlY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uO1xuICBpZiAoZXhwcmVzc2lvbiAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJiAhaXNTaW1wbGVQYXRoKGV4cHJlc3Npb24pKSB7XG4gICAgdmFyIGZuID0gcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pLmdldDtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICBzY29wZS4kZXZlbnQgPSBlO1xuICAgICAgZm4uY2FsbChzY29wZSwgc2NvcGUpO1xuICAgICAgc2NvcGUuJGV2ZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgIGhhbmRsZXIgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKGhhbmRsZXIsIG51bGwsIHRoaXMuZmlsdGVycyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdHdvLXdheSBkaXJlY3RpdmVzXG4gKiBlLmcuIHYtbW9kZWwuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLnR3b1dheSkge1xuICAgIHRoaXMuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIuc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybignRGlyZWN0aXZlLnNldCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHR3b1dheScgKyAnZGlyZWN0aXZlcy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hpbGUgcHJldmVudGluZyB0aGF0IGZ1bmN0aW9uIGZyb21cbiAqIHRyaWdnZXJpbmcgdXBkYXRlcyBvbiB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3dpdGhMb2NrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbG9ja2VkID0gdHJ1ZTtcbiAgZm4uY2FsbChzZWxmKTtcbiAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2xvY2tlZCA9IGZhbHNlO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXR0YWNoZXMgYSBET00gZXZlbnQgbGlzdGVuZXJcbiAqIHRvIHRoZSBkaXJlY3RpdmUgZWxlbWVudCBhbmQgYXV0b21ldGljYWxseSB0ZWFycyBpdCBkb3duXG4gKiBkdXJpbmcgdW5iaW5kLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIG9uKHRoaXMuZWwsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKTsodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpLnB1c2goW2V2ZW50LCBoYW5kbGVyXSk7XG59O1xuXG4vKipcbiAqIFRlYXJkb3duIHRoZSB3YXRjaGVyIGFuZCBjYWxsIHVuYmluZC5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl90ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2JvdW5kKSB7XG4gICAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy51bmJpbmQpIHtcbiAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl93YXRjaGVyKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgdmFyIGk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bndhdGNoRm5zID0gdGhpcy5fcGFyYW1VbndhdGNoRm5zO1xuICAgIGlmICh1bndhdGNoRm5zKSB7XG4gICAgICBpID0gdW53YXRjaEZucy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVud2F0Y2hGbnNbaV0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy52bSA9IHRoaXMuZWwgPSB0aGlzLl93YXRjaGVyID0gdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVXBkYXRlIHYtcmVmIGZvciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZiA9IGZ1bmN0aW9uIChyZW1vdmUpIHtcbiAgICB2YXIgcmVmID0gdGhpcy4kb3B0aW9ucy5fcmVmO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMuX2NvbnRleHQpLiRyZWZzO1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBpZiAocmVmc1tyZWZdID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1tyZWZdID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYW5zY2x1ZGUsIGNvbXBpbGUgYW5kIGxpbmsgZWxlbWVudC5cbiAgICpcbiAgICogSWYgYSBwcmUtY29tcGlsZWQgbGlua2VyIGlzIGF2YWlsYWJsZSwgdGhhdCBtZWFucyB0aGVcbiAgICogcGFzc2VkIGluIGVsZW1lbnQgd2lsbCBiZSBwcmUtdHJhbnNjbHVkZWQgYW5kIGNvbXBpbGVkXG4gICAqIGFzIHdlbGwgLSBhbGwgd2UgbmVlZCB0byBkbyBpcyB0byBjYWxsIHRoZSBsaW5rZXIuXG4gICAqXG4gICAqIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGNhbGwgdHJhbnNjbHVkZS9jb21waWxlL2xpbmsgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgLy8gdHJhbnNjbHVkZSBhbmQgaW5pdCBlbGVtZW50XG4gICAgLy8gdHJhbnNjbHVkZSBjYW4gcG90ZW50aWFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIC8vIHNvIHdlIG5lZWQgdG8ga2VlcCByZWZlcmVuY2U7IHRoaXMgc3RlcCBhbHNvIGluamVjdHNcbiAgICAvLyB0aGUgdGVtcGxhdGUgYW5kIGNhY2hlcyB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAgIC8vIG9uIHRoZSBjb250YWluZXIgbm9kZSBhbmQgcmVwbGFjZXIgbm9kZS5cbiAgICB2YXIgb3JpZ2luYWwgPSBlbDtcbiAgICBlbCA9IHRyYW5zY2x1ZGUoZWwsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2luaXRFbGVtZW50KGVsKTtcblxuICAgIC8vIGhhbmRsZSB2LXByZSBvbiByb290IG5vZGUgKCMyMDI2KVxuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSAmJiBnZXRBdHRyKGVsLCAndi1wcmUnKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJvb3QgaXMgYWx3YXlzIGNvbXBpbGVkIHBlci1pbnN0YW5jZSwgYmVjYXVzZVxuICAgIC8vIGNvbnRhaW5lciBhdHRycyBhbmQgcHJvcHMgY2FuIGJlIGRpZmZlcmVudCBldmVyeSB0aW1lLlxuICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHRoaXMuX2NvbnRleHQgJiYgdGhpcy5fY29udGV4dC4kb3B0aW9ucztcbiAgICB2YXIgcm9vdExpbmtlciA9IGNvbXBpbGVSb290KGVsLCBvcHRpb25zLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAvLyByZXNvbHZlIHNsb3QgZGlzdHJpYnV0aW9uXG4gICAgcmVzb2x2ZVNsb3RzKHRoaXMsIG9wdGlvbnMuX2NvbnRlbnQpO1xuXG4gICAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICAgIHZhciBjb250ZW50TGlua0ZuO1xuICAgIHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjb21wb25lbnQgY29tcGlsYXRpb24gY2FuIGJlIGNhY2hlZFxuICAgIC8vIGFzIGxvbmcgYXMgaXQncyBub3QgdXNpbmcgaW5saW5lLXRlbXBsYXRlXG4gICAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXI7XG4gICAgICBpZiAoIWNvbnRlbnRMaW5rRm4pIHtcbiAgICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyID0gY29tcGlsZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGluayBwaGFzZVxuICAgIC8vIG1ha2Ugc3VyZSB0byBsaW5rIHJvb3Qgd2l0aCBwcm9wIHNjb3BlIVxuICAgIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSk7XG4gICAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm4gPyBjb250ZW50TGlua0ZuKHRoaXMsIGVsKSA6IGNvbXBpbGUoZWwsIG9wdGlvbnMpKHRoaXMsIGVsKTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvc2l0ZSB1bmxpbmsgZnVuY3Rpb25cbiAgICAvLyB0byBiZSBjYWxsZWQgZHVyaW5nIGluc3RhbmNlIGRlc3RydWN0aW9uXG4gICAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByb290VW5saW5rRm4oKTtcbiAgICAgIC8vIHBhc3NpbmcgZGVzdHJveWluZzogdHJ1ZSB0byBhdm9pZCBzZWFyY2hpbmcgYW5kXG4gICAgICAvLyBzcGxpY2luZyB0aGUgZGlyZWN0aXZlc1xuICAgICAgY29udGVudFVubGlua0ZuKHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICByZXBsYWNlKG9yaWdpbmFsLCBlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNDb21waWxlZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2NvbXBpbGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgaW5zdGFuY2UgZWxlbWVudC4gQ2FsbGVkIGluIHRoZSBwdWJsaWNcbiAgICogJG1vdW50KCkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsID0gdGhpcy5fZnJhZ21lbnRTdGFydCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLl9mcmFnbWVudEVuZCA9IGVsLmxhc3RDaGlsZDtcbiAgICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRTdGFydC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0LmRhdGEgPSB0aGlzLl9mcmFnbWVudEVuZC5kYXRhID0gJyc7XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFnbWVudCA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbCA9IGVsO1xuICAgIH1cbiAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gdGhpcztcbiAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlQ29tcGlsZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgLSBwYXJzZWQgZGlyZWN0aXZlIGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICAgLSB0YXJnZXQgbm9kZVxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYmluZERpciA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHRoaXMuX2RpcmVjdGl2ZXMucHVzaChuZXcgRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHRoaXMsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICAgKiBkaXJlY3RpdmVzLCB0dXJuIG9mZiBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycywgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlckNsZWFudXAgLSBpZiB0cnVlLCBkZWZlciBjbGVhbnVwIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY2FsbGVkIGxhdGVyXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICBpZiAodGhpcy5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZXN0cm95UmVhZHk7XG4gICAgdmFyIHBlbmRpbmdSZW1vdmFsO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIENsZWFudXAgc2hvdWxkIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25veXNseSBhc1xuICAgIC8vIGNhbGxiYWNrIG9mIHRoaXMuJHJlbW92ZSgpLCBvciBpZiByZW1vdmUgYW5kIGRlZmVyQ2xlYW51cCBhcmUgZmFsc2UuXG4gICAgLy8gSW4gYW55IGNhc2UgaXQgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbGwgb3RoZXIgcmVtb3ZpbmcsIHVuYmluZGluZyBhbmRcbiAgICAvLyB0dXJuaW5nIG9mIGlzIGRvbmVcbiAgICB2YXIgY2xlYW51cElmUG9zc2libGUgPSBmdW5jdGlvbiBjbGVhbnVwSWZQb3NzaWJsZSgpIHtcbiAgICAgIGlmIChkZXN0cm95UmVhZHkgJiYgIXBlbmRpbmdSZW1vdmFsICYmICFkZWZlckNsZWFudXApIHtcbiAgICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZW1vdmUgRE9NIGVsZW1lbnRcbiAgICBpZiAocmVtb3ZlICYmIHRoaXMuJGVsKSB7XG4gICAgICBwZW5kaW5nUmVtb3ZhbCA9IHRydWU7XG4gICAgICB0aGlzLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBwZW5kaW5nUmVtb3ZhbCA9IGZhbHNlO1xuICAgICAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudC4gb25seSBuZWNlc3NhcnlcbiAgICAvLyBpZiBwYXJlbnQgaXMgbm90IGJlaW5nIGRlc3Ryb3llZCBhcyB3ZWxsLlxuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICBwYXJlbnQuJGNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgICAvLyB1bnJlZ2lzdGVyIHJlZiAocmVtb3ZlOiB0cnVlKVxuICAgICAgdGhpcy5fdXBkYXRlUmVmKHRydWUpO1xuICAgIH1cbiAgICAvLyBkZXN0cm95IGFsbCBjaGlsZHJlbi5cbiAgICBpID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHByb3BzXG4gICAgaWYgKHRoaXMuX3Byb3BzVW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3Byb3BzVW5saW5rRm4oKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gYWxsIGRpcmVjdGl2ZXMuIHRoaXMgYWxzbyB0ZWFyc2Rvd24gYWxsXG4gICAgLy8gZGlyZWN0aXZlLW93bmVkIHdhdGNoZXJzLlxuICAgIGlmICh0aGlzLl91bmxpbmtGbikge1xuICAgICAgdGhpcy5fdW5saW5rRm4oKTtcbiAgICB9XG4gICAgaSA9IHRoaXMuX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHNlbGYgb24gJGVsXG4gICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95UmVhZHkgPSB0cnVlO1xuICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRvIGVuc3VyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIGlmIHRoZXJlXG4gICAqIGlzIGFueS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBvd25lciBmcmFnbWVudFxuICAgIC8vIGRvIGl0IGluIGNsZWFudXAgc28gdGhhdCB3ZSBjYW4gY2FsbCAkZGVzdHJveSB3aXRoXG4gICAgLy8gZGVmZXIgcmlnaHQgd2hlbiBhIGZyYWdtZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYgKHRoaXMuX2ZyYWcpIHtcbiAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLl9fb2JfXykge1xuICAgICAgdGhpcy5fZGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyk7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHJlZmVyZW5jZXMgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBvdGhlclxuICAgIC8vIGluc3RhbmNlcy4gcHJlc2VydmUgcmVmZXJlbmNlIHRvIF9kYXRhIHNvIHRoYXQgcHJveHlcbiAgICAvLyBhY2Nlc3NvcnMgc3RpbGwgd29yay4gVGhlIG9ubHkgcG90ZW50aWFsIHNpZGUgZWZmZWN0XG4gICAgLy8gaGVyZSBpcyB0aGF0IG11dGF0aW5nIHRoZSBpbnN0YW5jZSBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICAgIC8vIG1heSBhZmZlY3QgdGhlIHN0YXRlIG9mIG90aGVyIGNvbXBvbmVudHMgdGhhdCBhcmUgc3RpbGxcbiAgICAvLyBvYnNlcnZpbmcgdGhlIHNhbWUgb2JqZWN0LCBidXQgdGhhdCBzZWVtcyB0byBiZSBhXG4gICAgLy8gcmVhc29uYWJsZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHVzZXIgcmF0aGVyIHRoYW5cbiAgICAvLyBhbHdheXMgdGhyb3dpbmcgYW4gZXJyb3Igb24gdGhlbS5cbiAgICB0aGlzLiRlbCA9IHRoaXMuJHBhcmVudCA9IHRoaXMuJHJvb3QgPSB0aGlzLiRjaGlsZHJlbiA9IHRoaXMuX3dhdGNoZXJzID0gdGhpcy5fY29udGV4dCA9IHRoaXMuX3Njb3BlID0gdGhpcy5fZGlyZWN0aXZlcyA9IG51bGw7XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHRoaXMuJG9mZigpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtaXNjTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQXBwbHkgYSBsaXN0IG9mIGZpbHRlciAoZGVzY3JpcHRvcnMpIHRvIGEgdmFsdWUuXG4gICAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICAgKiB0aGUgZ2V0dGVyIG9mIGFueSB3YXRjaGVyIHdpdGggZmlsdGVycyBzbyBpdCBpcyB2ZXJ5XG4gICAqIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IFtvbGRWYWx1ZV1cbiAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdyaXRlXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2FwcGx5RmlsdGVycyA9IGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsdWUsIGZpbHRlcnMsIHdyaXRlKSB7XG4gICAgdmFyIGZpbHRlciwgZm4sIGFyZ3MsIGFyZywgb2Zmc2V0LCBpLCBsLCBqLCBrO1xuICAgIGZvciAoaSA9IDAsIGwgPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZmlsdGVyID0gZmlsdGVyc1t3cml0ZSA/IGwgLSBpIC0gMSA6IGldO1xuICAgICAgZm4gPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWZuKSBjb250aW51ZTtcbiAgICAgIGZuID0gd3JpdGUgPyBmbi53cml0ZSA6IGZuLnJlYWQgfHwgZm47XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgIGFyZ3MgPSB3cml0ZSA/IFt2YWx1ZSwgb2xkVmFsdWVdIDogW3ZhbHVlXTtcbiAgICAgIG9mZnNldCA9IHdyaXRlID8gMiA6IDE7XG4gICAgICBpZiAoZmlsdGVyLmFyZ3MpIHtcbiAgICAgICAgZm9yIChqID0gMCwgayA9IGZpbHRlci5hcmdzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgIGFyZyA9IGZpbHRlci5hcmdzW2pdO1xuICAgICAgICAgIGFyZ3NbaiArIG9mZnNldF0gPSBhcmcuZHluYW1pYyA/IHRoaXMuJGdldChhcmcudmFsdWUpIDogYXJnLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYSBjb21wb25lbnQsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb21wb25lbnRcbiAgICogaXMgZGVmaW5lZCBub3JtYWxseSBvciB1c2luZyBhbiBhc3luYyBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBSZXNvbHZlcyBzeW5jaHJvbm91c2x5IGlmIGFscmVhZHkgcmVzb2x2ZWQsIG90aGVyd2lzZVxuICAgKiByZXNvbHZlcyBhc3luY2hyb25vdXNseSBhbmQgY2FjaGVzIHRoZSByZXNvbHZlZFxuICAgKiBjb25zdHJ1Y3RvciBvbiB0aGUgZmFjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Jlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGNiKSB7XG4gICAgdmFyIGZhY3Rvcnk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmFjdG9yeSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWN0b3J5ID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnlcbiAgICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgICAgaWYgKGZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpO1xuICAgICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgICAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgICAgICBmYWN0b3J5LmNhbGwodGhpcywgZnVuY3Rpb24gcmVzb2x2ZShyZXMpIHtcbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBWdWUuZXh0ZW5kKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCcgKyAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICc6ICcgKyB2YWx1ZSA6ICcnKSArICcuICcgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgICBjYihmYWN0b3J5KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBmaWx0ZXJSRSQxID0gL1tefF1cXHxbXnxdLztcblxuZnVuY3Rpb24gZGF0YUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBpZiAoYXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RhdGVtZW50SGFuZGxlcigpIHtcbiAgICAgICAgICBzZWxmLiRhcmd1bWVudHMgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcy5nZXQuY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgICBzZWxmLiRhcmd1bWVudHMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgKiBUaGUgZXhwcmVzc2lvbiBtdXN0IGJlIGEgdmFsaWQgbGVmdC1oYW5kXG4gICAqIGV4cHJlc3Npb24gaW4gYW4gYXNzaWdubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBmdW5jdGlvbiAoZXhwLCB2YWwpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCwgdHJ1ZSk7XG4gICAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgICByZXMuc2V0LmNhbGwodGhpcywgdGhpcywgdmFsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb3BlcnR5IG9uIHRoZSBWTVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWwodGhpcy5fZGF0YSwga2V5KTtcbiAgfTtcblxuICAvKipcbiAgICogV2F0Y2ggYW4gZXhwcmVzc2lvbiwgdHJpZ2dlciBjYWxsYmFjayB3aGVuIGl0c1xuICAgKiB2YWx1ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBpbW1lZGlhdGVcbiAgICogQHJldHVybiB7RnVuY3Rpb259IC0gdW53YXRjaEZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKGV4cE9yRm4pO1xuICAgICAgZXhwT3JGbiA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgIH1cbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwge1xuICAgICAgZGVlcDogb3B0aW9ucyAmJiBvcHRpb25zLmRlZXAsXG4gICAgICBzeW5jOiBvcHRpb25zICYmIG9wdGlvbnMuc3luYyxcbiAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgIHVzZXI6ICFvcHRpb25zIHx8IG9wdGlvbnMudXNlciAhPT0gZmFsc2VcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4oKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgYSB0ZXh0IGRpcmVjdGl2ZSwgaW5jbHVkaW5nIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGV2YWwgPSBmdW5jdGlvbiAodGV4dCwgYXNTdGF0ZW1lbnQpIHtcbiAgICAvLyBjaGVjayBmb3IgZmlsdGVycy5cbiAgICBpZiAoZmlsdGVyUkUkMS50ZXN0KHRleHQpKSB7XG4gICAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUodGV4dCk7XG4gICAgICAvLyB0aGUgZmlsdGVyIHJlZ2V4IGNoZWNrIG1pZ2h0IGdpdmUgZmFsc2UgcG9zaXRpdmVcbiAgICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55IGZpbHRlcnMgaGVyZVxuICAgICAgdmFyIHZhbCA9IHRoaXMuJGdldChkaXIuZXhwcmVzc2lvbiwgYXNTdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIGRpci5maWx0ZXJzID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpIDogdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBmaWx0ZXJcbiAgICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJwb2xhdGUgYSBwaWVjZSBvZiB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGludGVycG9sYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KHRleHQpO1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZtLiRldmFsKHRva2Vuc1swXS52YWx1ZSkgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHJldHVybiB0b2tlbi50YWcgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAgICogc28gdGhhdCBpdCBpcyBlYXNpZXIgdG8gaW5zcGVjdCBpbiBjb25zb2xlLlxuICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIGNvbnNvbGUgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGRhdGEgPSBwYXRoID8gZ2V0UGF0aCh0aGlzLl9kYXRhLCBwYXRoKSA6IHRoaXMuX2RhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGRhdGEgPSBjbGVhbihkYXRhKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBjb21wdXRlZCBmaWVsZHNcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBmb3IgKGtleSBpbiB0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcHJvcHMpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImNsZWFuXCIgYSBnZXR0ZXIvc2V0dGVyIGNvbnZlcnRlZCBvYmplY3QgaW50byBhIHBsYWluXG4gICAqIG9iamVjdCBjb3B5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gLSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21BUEkgKFZ1ZSkge1xuICAvKipcbiAgICogQ29udmVuaWVuY2Ugb24taW5zdGFuY2UgbmV4dFRpY2suIFRoZSBjYWxsYmFjayBpc1xuICAgKiBhdXRvLWJvdW5kIHRvIHRoZSBpbnN0YW5jZSwgYW5kIHRoaXMgYXZvaWRzIGNvbXBvbmVudFxuICAgKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIG5leHRUaWNrKGZuLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQXBwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYXBwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBhcHBlbmQsIGFwcGVuZFdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJlcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHByZXBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kYXBwZW5kVG8odGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGJlZm9yZSB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGJlZm9yZVdpdGhDYiwgYmVmb3JlV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYWZ0ZXIgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhZnRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5uZXh0U2libGluZywgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kYXBwZW5kVG8odGFyZ2V0LnBhcmVudE5vZGUsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgaW5zdGFuY2UgZnJvbSBET01cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHJlbW92ZSA9IGZ1bmN0aW9uIChjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBjYiAmJiBjYigpO1xuICAgIH1cbiAgICB2YXIgaW5Eb2N1bWVudCA9IHRoaXMuX2lzQXR0YWNoZWQgJiYgaW5Eb2ModGhpcy4kZWwpO1xuICAgIC8vIGlmIHdlIGFyZSBub3QgaW4gZG9jdW1lbnQsIG5vIG5lZWQgdG8gY2hlY2tcbiAgICAvLyBmb3IgdHJhbnNpdGlvbnNcbiAgICBpZiAoIWluRG9jdW1lbnQpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZWFsQ2IgPSBmdW5jdGlvbiByZWFsQ2IoKSB7XG4gICAgICBpZiAoaW5Eb2N1bWVudCkgc2VsZi5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5faXNGcmFnbWVudCkge1xuICAgICAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMuX2ZyYWdtZW50U3RhcnQsIHRoaXMuX2ZyYWdtZW50RW5kLCB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcmVhbENiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlID8gcmVtb3ZlV2l0aENiIDogcmVtb3ZlV2l0aFRyYW5zaXRpb247XG4gICAgICBvcCh0aGlzLiRlbCwgdGhpcywgcmVhbENiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNoYXJlZCBET00gaW5zZXJ0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AxIC0gb3AgZm9yIG5vbi10cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDIgLSBvcCBmb3IgdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHJldHVybiB2bVxuICAgKi9cblxuICBmdW5jdGlvbiBpbnNlcnQodm0sIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBvcDEsIG9wMikge1xuICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgdmFyIHRhcmdldElzRGV0YWNoZWQgPSAhaW5Eb2ModGFyZ2V0KTtcbiAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgfHwgdGFyZ2V0SXNEZXRhY2hlZCA/IG9wMSA6IG9wMjtcbiAgICB2YXIgc2hvdWxkQ2FsbEhvb2sgPSAhdGFyZ2V0SXNEZXRhY2hlZCAmJiAhdm0uX2lzQXR0YWNoZWQgJiYgIWluRG9jKHZtLiRlbCk7XG4gICAgaWYgKHZtLl9pc0ZyYWdtZW50KSB7XG4gICAgICBtYXBOb2RlUmFuZ2Uodm0uX2ZyYWdtZW50U3RhcnQsIHZtLl9mcmFnbWVudEVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgb3Aobm9kZSwgdGFyZ2V0LCB2bSk7XG4gICAgICB9KTtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wKHZtLiRlbCwgdGFyZ2V0LCB2bSwgY2IpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQ2FsbEhvb2spIHtcbiAgICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzZWxlY3RvcnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYXBwZW5kKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydEJlZm9yZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJlZm9yZVdpdGhDYihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVdpdGhDYihlbCwgdm0sIGNiKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRzQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICBzZWxmLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdGhpcy4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIGNicztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgICAgZm9yIChldmVudCBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC0xKTtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gc2hvdWxkUHJvcGFnYXRlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgdmFyIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGlzU291cmNlIHx8ICFjYnM7XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgaGFja3kgc29sdXRpb24gdG8gdGhlIHF1ZXN0aW9uIHJhaXNlZFxuICAgICAgLy8gaW4gIzIxMDI6IGZvciBhbiBpbmxpbmUgY29tcG9uZW50IGxpc3RlbmVyIGxpa2UgPGNvbXAgQHRlc3Q9XCJkb1RoaXNcIj4sXG4gICAgICAvLyB0aGUgcHJvcGFnYXRpb24gaGFuZGxpbmcgaXMgc29tZXdoYXQgYnJva2VuLiBUaGVyZWZvcmUgd2VcbiAgICAgIC8vIG5lZWQgdG8gdHJlYXQgdGhlc2UgaW5saW5lIGNhbGxiYWNrcyBkaWZmZXJlbnRseS5cbiAgICAgIHZhciBoYXNQYXJlbnRDYnMgPSBpc1NvdXJjZSAmJiBjYnMuc29tZShmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiLl9mcm9tUGFyZW50O1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzUGFyZW50Q2JzKSB7XG4gICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuICAgICAgICB2YXIgcmVzID0gY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGlmIChyZXMgPT09IHRydWUgJiYgKCFoYXNQYXJlbnRDYnMgfHwgY2IuX2Zyb21QYXJlbnQpKSB7XG4gICAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkUHJvcGFnYXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBicm9hZGNhc3QgYW4gZXZlbnQgdG8gYWxsIGNoaWxkcmVuIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiBAcGFyYW0gey4uLip9IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGJyb2FkY2FzdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpc1NvdXJjZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZyc7XG4gICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICAvLyBpZiBubyBjaGlsZCBoYXMgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudCxcbiAgICAvLyB0aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byBicm9hZGNhc3QuXG4gICAgaWYgKCF0aGlzLl9ldmVudHNDb3VudFtldmVudF0pIHJldHVybjtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlbjtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBpZiAoaXNTb3VyY2UpIHtcbiAgICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgICAvLyBvbiBjaGlsZHJlblxuICAgICAgYXJnc1swXSA9IHsgbmFtZTogZXZlbnQsIHNvdXJjZTogdGhpcyB9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgaWYgKHNob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgICBjaGlsZC4kYnJvYWRjYXN0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSBhbiBldmVudCB1cCB0aGUgcGFyZW50IGNoYWluLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkaXNwYXRjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFzaG91bGRQcm9wYWdhdGUpIHJldHVybjtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgLy8gb24gcGFyZW50c1xuICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBzaG91bGRQcm9wYWdhdGUgPSBwYXJlbnQuJGVtaXQuYXBwbHkocGFyZW50LCBhcmdzKTtcbiAgICAgIHBhcmVudCA9IHNob3VsZFByb3BhZ2F0ZSA/IHBhcmVudC4kcGFyZW50IDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlzdGVuZXIgY291bnRzIG9uIGFsbCBwYXJlbnRzLlxuICAgKiBUaGlzIGJvb2trZWVwaW5nIGFsbG93cyAkYnJvYWRjYXN0IHRvIHJldHVybiBlYXJseSB3aGVuXG4gICAqIG5vIGNoaWxkIGhhcyBsaXN0ZW5lZCB0byBhIGNlcnRhaW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gICAqL1xuXG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgZnVuY3Rpb24gbW9kaWZ5TGlzdGVuZXJDb3VudCh2bSwgZXZlbnQsIGNvdW50KSB7XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgLy8gaG9va3MgZG8gbm90IGdldCBicm9hZGNhc3RlZCBzbyBubyBuZWVkXG4gICAgLy8gdG8gZG8gYm9va2tlZXBpbmcgZm9yIHRoZW1cbiAgICBpZiAoIXBhcmVudCB8fCAhY291bnQgfHwgaG9va1JFLnRlc3QoZXZlbnQpKSByZXR1cm47XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgcGFyZW50Ll9ldmVudHNDb3VudFtldmVudF0gPSAocGFyZW50Ll9ldmVudHNDb3VudFtldmVudF0gfHwgMCkgKyBjb3VudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogU2V0IGluc3RhbmNlIHRhcmdldCBlbGVtZW50IGFuZCBraWNrIG9mZiB0aGUgY29tcGlsYXRpb25cbiAgICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAgICogZXhpc3RpbmcgRWxlbWVudCwgb3IgYSBEb2N1bWVudEZyYWdtZW50IChmb3IgYmxvY2tcbiAgICogaW5zdGFuY2VzKS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8c3RyaW5nfSBlbFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignJG1vdW50KCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJywgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsID0gcXVlcnkoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBpbGUoZWwpO1xuICAgIHRoaXMuX2luaXRET01Ib29rcygpO1xuICAgIGlmIChpbkRvYyh0aGlzLiRlbCkpIHtcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgICAgcmVhZHkuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kb25jZSgnaG9vazphdHRhY2hlZCcsIHJlYWR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBfZGVzdHJveS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlckNsZWFudXBcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kocmVtb3ZlLCBkZWZlckNsZWFudXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY29tcGlsZSBhIHBpZWNlIG9mIERPTSBhbmQgcmV0dXJuIGFcbiAgICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ11cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGNvbXBpbGUgPSBmdW5jdGlvbiAoZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgcmV0dXJuIGNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGV4cG9zZWQgVnVlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEFQSSBjb252ZW50aW9uczpcbiAqIC0gcHVibGljIEFQSSBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlKG9wdGlvbnMpIHtcbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuLy8gaW5zdGFsbCBpbnRlcm5hbHNcbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5taXNjTWl4aW4oVnVlKTtcblxuLy8gaW5zdGFsbCBpbnN0YW5jZSBBUElzXG5kYXRhQVBJKFZ1ZSk7XG5kb21BUEkoVnVlKTtcbmV2ZW50c0FQSShWdWUpO1xubGlmZWN5Y2xlQVBJKFZ1ZSk7XG5cbnZhciBzbG90ID0ge1xuXG4gIHByaW9yaXR5OiBTTE9ULFxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gdGhpcyB3YXMgcmVzb2x2ZWQgZHVyaW5nIGNvbXBvbmVudCB0cmFuc2NsdXNpb25cbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyYW1zLm5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBjb250ZW50ID0gdGhpcy52bS5fc2xvdENvbnRlbnRzICYmIHRoaXMudm0uX3Nsb3RDb250ZW50c1tuYW1lXTtcbiAgICBpZiAoIWNvbnRlbnQgfHwgIWNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LmNsb25lTm9kZSh0cnVlKSwgdGhpcy52bS5fY29udGV4dCwgdGhpcy52bSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmVsLmhhc0NoaWxkTm9kZXMoKSAmJiBjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0uaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgLy8gaWYgdGhlIGluc2VydGVkIHNsb3QgaGFzIHYtaWZcbiAgICAgICAgLy8gaW5qZWN0IGZhbGxiYWNrIGNvbnRlbnQgYXMgdGhlIHYtZWxzZVxuICAgICAgICB2YXIgZWxzZUJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgZWxzZUJsb2NrLnNldEF0dHJpYnV0ZSgndi1lbHNlJywgJycpO1xuICAgICAgICBlbHNlQmxvY2suaW5uZXJIVE1MID0gdGhpcy5lbC5pbm5lckhUTUw7XG4gICAgICAgIC8vIHRoZSBlbHNlIGJsb2NrIHNob3VsZCBiZSBjb21waWxlZCBpbiBjaGlsZCBzY29wZVxuICAgICAgICBlbHNlQmxvY2suX2NvbnRleHQgPSB0aGlzLnZtO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsc2VCbG9jayk7XG4gICAgICB9XG4gICAgICB2YXIgc2NvcGUgPSBob3N0ID8gaG9zdC5fc2NvcGUgOiB0aGlzLl9zY29wZTtcbiAgICAgIHRoaXMudW5saW5rID0gY29udGV4dC4kY29tcGlsZShjb250ZW50LCBob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUodGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICB0aGlzLmNvbXBpbGUoZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSksIHRoaXMudm0pO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLnVubGluaykge1xuICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJ0aWFsID0ge1xuXG4gIHByaW9yaXR5OiBQQVJUSUFMLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKHZhbHVlKSB7XG4gICAgICB2SWYucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LXBhcnRpYWwnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB0aGlzLmluc2VydCh0aGlzLnBhcmFtcy5uYW1lKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdwYXJ0aWFscycsIGlkLCB0cnVlKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBwYXJ0aWFsKTtcbiAgICAgIHZJZi5pbnNlcnQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbGVtZW50RGlyZWN0aXZlcyA9IHtcbiAgc2xvdDogc2xvdCxcbiAgcGFydGlhbDogcGFydGlhbFxufTtcblxudmFyIGNvbnZlcnRBcnJheSA9IHZGb3IuX3Bvc3RQcm9jZXNzO1xuXG4vKipcbiAqIExpbWl0IGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgKERlY2ltYWwgZXhwZWN0ZWQpXG4gKi9cblxuZnVuY3Rpb24gbGltaXRCeShhcnIsIG4sIG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPyBwYXJzZUludChvZmZzZXQsIDEwKSA6IDA7XG4gIG4gPSB0b051bWJlcihuKTtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IGFyci5zbGljZShvZmZzZXQsIG9mZnNldCArIG4pIDogYXJyO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGVsaW1pdGVyXVxuICogQHBhcmFtIHtTdHJpbmd9IC4uLmRhdGFLZXlzXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyQnkoYXJyLCBzZWFyY2gsIGRlbGltaXRlcikge1xuICBhcnIgPSBjb252ZXJ0QXJyYXkoYXJyKTtcbiAgaWYgKHNlYXJjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKHNlYXJjaCk7XG4gIH1cbiAgLy8gY2FzdCB0byBsb3dlcmNhc2Ugc3RyaW5nXG4gIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gYWxsb3cgb3B0aW9uYWwgYGluYCBkZWxpbWl0ZXJcbiAgLy8gYmVjYXVzZSB3aHkgbm90XG4gIHZhciBuID0gZGVsaW1pdGVyID09PSAnaW4nID8gMyA6IDI7XG4gIC8vIGV4dHJhY3QgYW5kIGZsYXR0ZW4ga2V5c1xuICB2YXIga2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRvQXJyYXkoYXJndW1lbnRzLCBuKSk7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gYXJyW2ldO1xuICAgIHZhbCA9IGl0ZW0gJiYgaXRlbS4kdmFsdWUgfHwgaXRlbTtcbiAgICBqID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGopIHtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJyRrZXknICYmIGNvbnRhaW5zKGl0ZW0uJGtleSwgc2VhcmNoKSB8fCBjb250YWlucyhnZXRQYXRoKHZhbCwga2V5KSwgc2VhcmNoKSkge1xuICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250YWlucyhpdGVtLCBzZWFyY2gpKSB7XG4gICAgICByZXMucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fEZ1bmN0aW9ufSAuLi5zb3J0S2V5c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcl1cbiAqL1xuXG5mdW5jdGlvbiBvcmRlckJ5KGFycikge1xuICB2YXIgY29tcGFyYXRvciA9IG51bGw7XG4gIHZhciBzb3J0S2V5cyA9IHVuZGVmaW5lZDtcbiAgYXJyID0gY29udmVydEFycmF5KGFycik7XG5cbiAgLy8gZGV0ZXJtaW5lIG9yZGVyIChsYXN0IGFyZ3VtZW50KVxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgdmFyIG9yZGVyID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xuICAgIG9yZGVyID0gb3JkZXIgPCAwID8gLTEgOiAxO1xuICAgIGFyZ3MgPSBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzLnNsaWNlKDAsIC0xKSA6IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgb3JkZXIgPSAxO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHNvcnRLZXlzICYgY29tcGFyYXRvclxuICB2YXIgZmlyc3RBcmcgPSBhcmdzWzBdO1xuICBpZiAoIWZpcnN0QXJnKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBjdXN0b20gY29tcGFyYXRvclxuICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZpcnN0QXJnKGEsIGIpICogb3JkZXI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJpbmcga2V5cy4gZmxhdHRlbiBmaXJzdFxuICAgIHNvcnRLZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJncyk7XG4gICAgY29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiLCBpKSB7XG4gICAgICBpID0gaSB8fCAwO1xuICAgICAgcmV0dXJuIGkgPj0gc29ydEtleXMubGVuZ3RoIC0gMSA/IGJhc2VDb21wYXJlKGEsIGIsIGkpIDogYmFzZUNvbXBhcmUoYSwgYiwgaSkgfHwgY29tcGFyYXRvcihhLCBiLCBpICsgMSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2VDb21wYXJlKGEsIGIsIHNvcnRLZXlJbmRleCkge1xuICAgIHZhciBzb3J0S2V5ID0gc29ydEtleXNbc29ydEtleUluZGV4XTtcbiAgICBpZiAoc29ydEtleSkge1xuICAgICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgICBpZiAoaXNPYmplY3QoYSkgJiYgJyR2YWx1ZScgaW4gYSkgYSA9IGEuJHZhbHVlO1xuICAgICAgICBpZiAoaXNPYmplY3QoYikgJiYgJyR2YWx1ZScgaW4gYikgYiA9IGIuJHZhbHVlO1xuICAgICAgfVxuICAgICAgYSA9IGlzT2JqZWN0KGEpID8gZ2V0UGF0aChhLCBzb3J0S2V5KSA6IGE7XG4gICAgICBiID0gaXNPYmplY3QoYikgPyBnZXRQYXRoKGIsIHNvcnRLZXkpIDogYjtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyBvcmRlciA6IC1vcmRlcjtcbiAgfVxuXG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGNvbXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIFN0cmluZyBjb250YWluIGhlbHBlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKi9cblxuZnVuY3Rpb24gY29udGFpbnModmFsLCBzZWFyY2gpIHtcbiAgdmFyIGk7XG4gIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxba2V5c1tpXV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxbaV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTE7XG4gIH1cbn1cblxudmFyIGRpZ2l0c1JFID0gLyhcXGR7M30pKD89XFxkKS9nO1xuXG4vLyBhc3NldCBjb2xsZWN0aW9ucyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LlxudmFyIGZpbHRlcnMgPSB7XG5cbiAgb3JkZXJCeTogb3JkZXJCeSxcbiAgZmlsdGVyQnk6IGZpbHRlckJ5LFxuICBsaW1pdEJ5OiBsaW1pdEJ5LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlbnRcbiAgICovXG5cbiAganNvbjoge1xuICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQodmFsdWUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGluZGVudCA6IDIpO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqICdhYmMnID0+ICdBYmMnXG4gICAqL1xuXG4gIGNhcGl0YWxpemU6IGZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQUJDJ1xuICAgKi9cblxuICB1cHBlcmNhc2U6IGZ1bmN0aW9uIHVwcGVyY2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA6ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiAnQWJDJyA9PiAnYWJjJ1xuICAgKi9cblxuICBsb3dlcmNhc2U6IGZ1bmN0aW9uIGxvd2VyY2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaWduXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFscyBEZWNpbWFsIHBsYWNlc1xuICAgKi9cblxuICBjdXJyZW5jeTogZnVuY3Rpb24gY3VycmVuY3kodmFsdWUsIF9jdXJyZW5jeSwgZGVjaW1hbHMpIHtcbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8ICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIF9jdXJyZW5jeSA9IF9jdXJyZW5jeSAhPSBudWxsID8gX2N1cnJlbmN5IDogJyQnO1xuICAgIGRlY2ltYWxzID0gZGVjaW1hbHMgIT0gbnVsbCA/IGRlY2ltYWxzIDogMjtcbiAgICB2YXIgc3RyaW5naWZpZWQgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZChkZWNpbWFscyk7XG4gICAgdmFyIF9pbnQgPSBkZWNpbWFscyA/IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0xIC0gZGVjaW1hbHMpIDogc3RyaW5naWZpZWQ7XG4gICAgdmFyIGkgPSBfaW50Lmxlbmd0aCAlIDM7XG4gICAgdmFyIGhlYWQgPSBpID4gMCA/IF9pbnQuc2xpY2UoMCwgaSkgKyAoX2ludC5sZW5ndGggPiAzID8gJywnIDogJycpIDogJyc7XG4gICAgdmFyIF9mbG9hdCA9IGRlY2ltYWxzID8gc3RyaW5naWZpZWQuc2xpY2UoLTEgLSBkZWNpbWFscykgOiAnJztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgIHJldHVybiBzaWduICsgX2N1cnJlbmN5ICsgaGVhZCArIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICsgX2Zsb2F0O1xuICB9LFxuXG4gIC8qKlxuICAgKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICAgKlxuICAgKiBAcGFyYW1zXG4gICAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICogIHRoZSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlIC4uLiBmb3JtcyBvZiB0aGUgd29yZCB0b1xuICAgKiAgYmUgcGx1cmFsaXplZC4gV2hlbiB0aGUgbnVtYmVyIHRvIGJlIHBsdXJhbGl6ZWRcbiAgICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAgICogIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICpcbiAgICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gICAqL1xuXG4gIHBsdXJhbGl6ZTogZnVuY3Rpb24gcGx1cmFsaXplKHZhbHVlKSB7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSB2YWx1ZSAlIDEwIC0gMTtcbiAgICAgIHJldHVybiBpbmRleCBpbiBhcmdzID8gYXJnc1tpbmRleF0gOiBhcmdzW2xlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJnc1swXSArICh2YWx1ZSA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgPSAzMDBcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShoYW5kbGVyLCBkZWxheSkge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGlmICghZGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gMzAwO1xuICAgIH1cbiAgICByZXR1cm4gX2RlYm91bmNlKGhhbmRsZXIsIGRlbGF5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBWdWUgYW5kIGV2ZXJ5IGNvbnN0cnVjdG9yIHRoYXQgZXh0ZW5kcyBWdWUgaGFzIGFuXG4gICAqIGFzc29jaWF0ZWQgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBkdXJpbmdcbiAgICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSBzZWVuIGFzIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgZXZlcnlcbiAgICogVnVlIGluc3RhbmNlLlxuICAgKi9cblxuICBWdWUub3B0aW9ucyA9IHtcbiAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgIGVsZW1lbnREaXJlY3RpdmVzOiBlbGVtZW50RGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgIHRyYW5zaXRpb25zOiB7fSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBwYXJ0aWFsczoge30sXG4gICAgcmVwbGFjZTogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvc2UgdXNlZnVsIGludGVybmFsc1xuICAgKi9cblxuICBWdWUudXRpbCA9IHV0aWw7XG4gIFZ1ZS5jb25maWcgPSBjb25maWc7XG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZVsnZGVsZXRlJ10gPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2FnZSAvIHBsdWdpbnNcbiAgICovXG5cbiAgVnVlLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gIFZ1ZS5GcmFnbWVudEZhY3RvcnkgPSBGcmFnbWVudEZhY3Rvcnk7XG4gIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMgPSBpbnRlcm5hbERpcmVjdGl2ZXM7XG4gIFZ1ZS5wYXJzZXJzID0ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgdGV4dDogdGV4dCxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgZGlyZWN0aXZlOiBkaXJlY3RpdmUsXG4gICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG5cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5kT3B0aW9uc1xuICAgKi9cblxuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwO1xuICAgIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICAgIHJldHVybiBleHRlbmRPcHRpb25zLl9DdG9yO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICsgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY2F0ZXJzIGFuZCB0aGUgaHlwaGVuLicpO1xuICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFN1YiA9IGNyZWF0ZUNsYXNzKG5hbWUgfHwgJ1Z1ZUNvbXBvbmVudCcpO1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgZXh0ZW5kT3B0aW9ucyk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb25cbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgICAgZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IFN1YjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YjtcbiAgfTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZS4gVGhpcyBnaXZlcyB1cyBtdWNoIG5pY2VyIG91dHB1dCB3aGVuXG4gICAqIGxvZ2dpbmcgaW5zdGFuY2VzIGluIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MobmFtZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBjbGFzc2lmeShuYW1lKSArICcgKG9wdGlvbnMpIHsgdGhpcy5faW5pdChvcHRpb25zKSB9JykoKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH1cblxuICAvKipcbiAgICogUGx1Z2luIHN5c3RlbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gICAqL1xuXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgZ2xvYmFsIG1peGluIGJ5IG1lcmdpbmcgaXQgaW50byB0aGUgZGVmYXVsdFxuICAgKiBvcHRpb25zLlxuICAgKi9cblxuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICBWdWUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhWdWUub3B0aW9ucywgbWl4aW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHNpZ25hdHVyZTpcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICAgKi9cblxuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIChjb21tb25UYWdSRS50ZXN0KGlkKSB8fCByZXNlcnZlZFRhZ1JFLnRlc3QoaWQpKSkge1xuICAgICAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGlmICghZGVmaW5pdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IFZ1ZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGV4cG9zZSBpbnRlcm5hbCB0cmFuc2l0aW9uIEFQSVxuICBleHRlbmQoVnVlLnRyYW5zaXRpb24sIHRyYW5zaXRpb24pO1xufVxuXG5pbnN0YWxsR2xvYmFsQVBJKFZ1ZSk7XG5cblZ1ZS52ZXJzaW9uID0gJzEuMC4yNic7XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbkJyb3dzZXIgJiYgL0Nocm9tZVxcL1xcZCsvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zb2xlLmxvZygnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnKTtcbiAgICB9XG4gIH1cbn0sIDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUvMS4wLjI2L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvcHJvY2Vzcy8wLjExLjUvcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvKmVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cbi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4xLjBcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wNy0wN1QyMTo0NFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYyB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjEuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2csXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4wXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wMS0wNFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6XG5cdC8vIElFOiAqW2Rpc2FibGVkXTpub3QoYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgb3B0Z3JvdXAsIG9wdGlvbiwgbWVudWl0ZW0sIGZpZWxkc2V0KVxuXHQvLyBub3QgSUU6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBDaGVjayBmb3JtIGVsZW1lbnRzIGFuZCBvcHRpb24gZWxlbWVudHMgZm9yIGV4cGxpY2l0IGRpc2FibGluZ1xuXHRcdHJldHVybiBcImxhYmVsXCIgaW4gZWxlbSAmJiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXHRcdFx0XCJmb3JtXCIgaW4gZWxlbSAmJiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHQvLyBDaGVjayBub24tZGlzYWJsZWQgZm9ybSBlbGVtZW50cyBmb3IgZmllbGRzZXRbZGlzYWJsZWRdIGFuY2VzdG9yc1xuXHRcdFx0XCJmb3JtXCIgaW4gZWxlbSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSAmJiAoXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFNi0xMStcblx0XHRcdFx0Ly8gQW5jZXN0cnkgaXMgY292ZXJlZCBmb3IgdXNcblx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgYXNzdW1lIGFueSBub24tPG9wdGlvbj4gdW5kZXIgZmllbGRzZXRbZGlzYWJsZWRdIGlzIGRpc2FibGVkXG5cdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdChcImxhYmVsXCIgaW4gZWxlbSB8fCAhZGlzYWJsZWRBbmNlc3RvciggZWxlbSApKSAhPT0gZGlzYWJsZWRcblx0XHRcdCk7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90d2hpdGUgPSAoIC9cXFMrL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRcdHJlc29sdmUuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IEpTT04ucGFyc2UoIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKSxcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0ID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0W107XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG5cdFx0cmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdGlmICggZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHR2YWwgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF07XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHJhZigpIHtcblx0aWYgKCB0aW1lcklkICkge1xuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApO1xuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90d2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmYgb3IgaWYgZG9jdW1lbnQgaXMgaGlkZGVuXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiB8fCBkb2N1bWVudC5oaWRkZW4gKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdG9wdC5kdXJhdGlvbiA9IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0XHRqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKSA6XG5cdFx0XHR3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aWYgKCB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aW1lcklkICk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0fVxuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdHJldHVybiB0YWJpbmRleCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nLFxuXHRyc3BhY2VzID0gL1tcXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IGluZGV4IDwgMCA/XG5cdFx0XHRcdFx0XHRtYXggOlxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdW5jYWNoZWQgdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLCByZWN0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcblx0XHRpZiAoIHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQgKSB7XG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvanF1ZXJ5LzMuMS4wL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9BcHAudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9BcHAudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxBcHAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMDY5MjUxMGIvQXBwLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5ib2R5IHtcXG4gICAgbWFyZ2luOiAwO1xcbn1cXG5cXG5odG1sLFxcbmJvZHkge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi50YWJsZSB7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbn1cXG5cXG5kaXYubW9kYWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjYpO1xcbiAgICB0b3A6IDBweDtcXG4gICAgbGVmdDogMDtcXG4gICAgei1pbmRleDogOTk5O1xcbn1cXG5cXG4udGFibGUtY2VsbCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9BcHAudnVlPzFlMGU5MzUyXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdKQTtJQUNBLFVBQUE7Q0FDQTs7QUFFQTs7SUFFQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0Esb0NBQUE7SUFDQSxTQUFBO0lBQ0EsUUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxtQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJBcHAudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAgICAgYmFja2dyb3VuZFxcbiAgICAgICAgbWVudS1iYXIodi1iaW5kOmdhbWUtZGF0YT1cXFwiZ2FtZURhdGFcXFwiLHYtYmluZDpub3RpY2U9XFxcIm5vdGljZVxcXCIsdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiKVxcbiAgICAgICAgYmV0LWFuZC1ib251cyh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIix2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIix2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiLHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIsdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIix2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIilcXG4gICAgICAgIHBsYXktcGFuZWwodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiLHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCIpXFxuICAgICAgICBzdGF0ZSh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIix2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiKVxcbiAgICAgICAgLy8tIGJldC1tdWx0aXBsZVxcbiAgICAgICAgbWVzc2FnZSh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIilcXG4gICAgICAgIG1vZGFsLm1vZGFsKHYtaWY9XFxcImVycm9yXFxcIilcXG4gICAgICAgIHRpcC1tb2RhbFxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWUnXFxuaW1wb3J0IE1lbnVCYXIgZnJvbSAnLi9jb21wb25lbnRzL01lbnVCYXIudnVlJ1xcbmltcG9ydCBCZXRBbmRCb251cyBmcm9tICcuL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlJ1xcbmltcG9ydCBQbGF5UGFuZWwgZnJvbSAnLi9jb21wb25lbnRzL1BsYXlQYW5lbC52dWUnXFxuaW1wb3J0IFN0YXRlIGZyb20gJy4vY29tcG9uZW50cy9TdGF0ZS52dWUnXFxuaW1wb3J0IEJldE11bHRpcGxlIGZyb20gJy4vY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWUnXFxuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9jb21wb25lbnRzL01lc3NhZ2UudnVlJ1xcbmltcG9ydCBnYW1lRGF0YSBmcm9tICcuL2RhdGEvZGF0YScgLy8gIOWKoOi9veaooeadv+aVsOaNrlxcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuL2pzL3JlcXVlc3QtbGlzdCdcXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcXG4gICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHRoYXQuc2NyZWVuU2l6ZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXFxuICAgICAgICAgICAgdGhhdC5zY3JlZW5TaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5pbml0KClcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdXNlckJldDoge1xcbiAgICAgICAgICAgICAgICBiZXRtb25leTogMTAwMCAvL+m7mOiupOS4i+azqOmHkemineS4ujEwMDBcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGdhbWVEYXRhOiBnYW1lRGF0YSxcXG4gICAgICAgICAgICBsb3R0ZXJ5bnVtOiB7IC8v5byA5aWW57uT5p6cXFxuICAgICAgICAgICAgICAgIGlkOiAnJyxcXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAwLFxcbiAgICAgICAgICAgICAgICBsb3R0ZXJ5bnVtczogJydcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvdW50RG93bjogMzAwLCAvLyDlgJLorqHml7bnp5LmlbBcXG4gICAgICAgICAgICBjb3VudE51bTogMzAwLCAvL+W8gOWlluaXtumXtOmXtOmalCDpu5jorqQz5YiG6ZKfXFxuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxcbiAgICAgICAgICAgIGJldHM6IFtdLCAvLyDkuIvms6jpm4blkIjvvIzlj6/ku6XljZXmrKHkuIvlpJrms6hcXG4gICAgICAgICAgICBub3RpY2U6IHJlcXVpcmUoJy4vZGF0YS9ub3RpY2UnKSxcXG4gICAgICAgICAgICB1c2VyaW5mbzogcmVxdWlyZSgnLi9kYXRhL3NpbmdsZXVzZXInKSxcXG4gICAgICAgICAgICBzdGFnZVNpemU6IHsgLy8g5pW05L2T55S75biD5aSn5bCPLOaJgOacieWPmOWMlue7hOS7tuWGjeasoeWfuuehgOS4iuS5mOS7peaUvuWkp+WAjeeOh1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMDhcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHNjcmVlblNpemU6IHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgaW5pdCgpIHtcXG4gICAgICAgICAgICAvLyDliJ3lp4vljJbor7vlj5bmlbDmja5cXG5cXG4gICAgICAgICAgICAvLyDor7vlj5blvIDlpZbmlbDmja5cXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4ocmVzID0+IHRoaXMubG90dGVyeW51bSA9IHJlcy5kYXRhKVxcbiAgICAgICAgICAgIHRoaXMuZ2V0VXNlckluZm9CeU5ldCgpXFxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluWFrOWRiuaVsOaNrlxcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2dldExhc3ROb3RpY2UnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIHNob3coKSB7fSxcXG4gICAgICAgIGdldFVzZXJJbmZvQnlOZXQoKSB7IC8v5LuO572R57uc6I635Y+WdXNlcuS/oeaBr1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldHVzZXJDb2RlRnJvbU5ldChSZXF1ZXN0TGlzdC5nZXRDb2RlKCkpLnRoZW4ocmVzID0+IHtcXG4gICAgICAgICAgICAgICAgLy8g6I635Y+W55So5oi35pWw5o2uXFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXFxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcXG4gICAgICAgICAgICB9LCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMuZGF0YSkpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICB6b29tUmF0ZSgpIHsgLy8g5Yid5aeL5YyW5pS+5aSn5YCN546HXFxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnNjcmVlblNpemUud2lkdGggLyB0aGlzLnN0YWdlU2l6ZS53aWR0aFxcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHg6IHgsXFxuICAgICAgICAgICAgICAgIHk6IHlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJldHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGV2ZW50czoge1xcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyaW5mbyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmluZm8pKSkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoYXQudXNlcmluZm8sIHJlcy5kYXRhKVxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LnVzZXJpbmZvT3BlbmlkID0gcmVzLmRhdGEub3BlbmlkXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldExhc3ROb3RpY2UoKS50aGVuKHJlcyA9PiB0aGlzLm5vdGljZSA9IHJlcy5kYXRhLCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMpKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2FuY2VsQmV0JylcXG4gICAgICAgIH0sXFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5pbml0KClcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcXG4gICAgICAgIGVycm9yKCkge1xcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2hvd1RpcChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd1RpcCcsIGV2ZW50KVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wb25lbnRzOiB7XFxuICAgICAgICAnbW9kYWwnOiB7XFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJtb2RhbFxcXCI+PC9kaXY+J1xcbiAgICAgICAgfSxcXG4gICAgICAgICd0aXAtbW9kYWwnOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZScpLFxcbiAgICAgICAgJ2JhY2tncm91bmQnOiBCYWNrZ3JvdW5kLFxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcXG4gICAgICAgICdiZXQtYW5kLWJvbnVzJzogQmV0QW5kQm9udXMsXFxuICAgICAgICAncGxheS1wYW5lbCc6IFBsYXlQYW5lbCxcXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxcbiAgICAgICAgJ2JldC1tdWx0aXBsZSc6IEJldE11bHRpcGxlLFxcbiAgICAgICAgJ21lc3NhZ2UnOiBNZXNzYWdlXFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxufVxcblxcbmRpdi5tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH0pLFxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG5cdFx0aWYobmV3T2JqKSB7XG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlcztcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdGlmIChtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG5cdFx0Ly8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuXHRcdGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJztcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgICBtZW51LWJhcih2LWJpbmQ6Z2FtZS1kYXRhPVwiZ2FtZURhdGFcIix2LWJpbmQ6bm90aWNlPVwibm90aWNlXCIsdi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIpXG4gICAgICAgIGJldC1hbmQtYm9udXModi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHBsYXktcGFuZWwodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHN0YXRlKHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiLHYtYmluZDp1c2VyaW5mbz1cInVzZXJpbmZvXCIsdi1iaW5kOnVzZXItYmV0PVwidXNlckJldFwiLHYtYmluZDpiZXRzLnN5bmM9XCJiZXRzXCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiKVxuICAgICAgICAvLy0gYmV0LW11bHRpcGxlXG4gICAgICAgIG1lc3NhZ2Uodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6YmV0cy5zeW5jPVwiYmV0c1wiLHYtYmluZDplcnJvci5zeW5jPVwiZXJyb3JcIilcbiAgICAgICAgbW9kYWwubW9kYWwodi1pZj1cImVycm9yXCIpXG4gICAgICAgIHRpcC1tb2RhbFxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWUnXG5pbXBvcnQgTWVudUJhciBmcm9tICcuL2NvbXBvbmVudHMvTWVudUJhci52dWUnXG5pbXBvcnQgQmV0QW5kQm9udXMgZnJvbSAnLi9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSdcbmltcG9ydCBQbGF5UGFuZWwgZnJvbSAnLi9jb21wb25lbnRzL1BsYXlQYW5lbC52dWUnXG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9jb21wb25lbnRzL1N0YXRlLnZ1ZSdcbmltcG9ydCBCZXRNdWx0aXBsZSBmcm9tICcuL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlJ1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9jb21wb25lbnRzL01lc3NhZ2UudnVlJ1xuaW1wb3J0IGdhbWVEYXRhIGZyb20gJy4vZGF0YS9kYXRhJyAvLyAg5Yqg6L295qih5p2/5pWw5o2uXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFtdLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgICAgdGhhdC5zY3JlZW5TaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckJldDoge1xuICAgICAgICAgICAgICAgIGJldG1vbmV5OiAxMDAwIC8v6buY6K6k5LiL5rOo6YeR6aKd5Li6MTAwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdhbWVEYXRhOiBnYW1lRGF0YSxcbiAgICAgICAgICAgIGxvdHRlcnludW06IHsgLy/lvIDlpZbnu5PmnpxcbiAgICAgICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAwLFxuICAgICAgICAgICAgICAgIGxvdHRlcnludW1zOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdW50RG93bjogMzAwLCAvLyDlgJLorqHml7bnp5LmlbBcbiAgICAgICAgICAgIGNvdW50TnVtOiAzMDAsIC8v5byA5aWW5pe26Ze06Ze06ZqUIOm7mOiupDPliIbpkp9cbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGJldHM6IFtdLCAvLyDkuIvms6jpm4blkIjvvIzlj6/ku6XljZXmrKHkuIvlpJrms6hcbiAgICAgICAgICAgIG5vdGljZTogcmVxdWlyZSgnLi9kYXRhL25vdGljZScpLFxuICAgICAgICAgICAgdXNlcmluZm86IHJlcXVpcmUoJy4vZGF0YS9zaW5nbGV1c2VyJyksXG4gICAgICAgICAgICBzdGFnZVNpemU6IHsgLy8g5pW05L2T55S75biD5aSn5bCPLOaJgOacieWPmOWMlue7hOS7tuWGjeasoeWfuuehgOS4iuS5mOS7peaUvuWkp+WAjeeOh1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDA4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuU2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAvLyDliJ3lp4vljJbor7vlj5bmlbDmja5cblxuICAgICAgICAgICAgLy8g6K+75Y+W5byA5aWW5pWw5o2uXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4ocmVzID0+IHRoaXMubG90dGVyeW51bSA9IHJlcy5kYXRhKVxuICAgICAgICAgICAgdGhpcy5nZXRVc2VySW5mb0J5TmV0KClcbiAgICAgICAgICAgICAgICAvLyDojrflj5blhazlkYrmlbDmja5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2dldExhc3ROb3RpY2UnKVxuICAgICAgICB9LFxuICAgICAgICBzaG93KCkge30sXG4gICAgICAgIGdldFVzZXJJbmZvQnlOZXQoKSB7IC8v5LuO572R57uc6I635Y+WdXNlcuS/oeaBr1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyQ29kZUZyb21OZXQoUmVxdWVzdExpc3QuZ2V0Q29kZSgpKS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8g6I635Y+W55So5oi35pWw5o2uXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGF0LnVzZXJpbmZvLCByZXMuZGF0YSlcbiAgICAgICAgICAgICAgICB0aGF0LiRlbWl0KCdnZXRVc2VySW5mbycpXG4gICAgICAgICAgICB9LCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMuZGF0YSkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHpvb21SYXRlKCkgeyAvLyDliJ3lp4vljJbmlL7lpKflgI3njodcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zY3JlZW5TaXplLndpZHRoIC8gdGhpcy5zdGFnZVNpemUud2lkdGhcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd01lc3NhZ2UnLCBldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0dXNlcmluZm8oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJpbmZvKSkpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXNlckJldC51c2VyaW5mb09wZW5pZCA9IHJlcy5kYXRhLm9wZW5pZFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0TGFzdE5vdGljZSgpLnRoZW4ocmVzID0+IHRoaXMubm90aWNlID0gcmVzLmRhdGEsIHJlcyA9PiBjb25zb2xlLmVycm9yKHJlcykpXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjYW5jZWxCZXQnKVxuICAgICAgICB9LFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKVxuICAgICAgICB9LFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcbiAgICAgICAgZXJyb3IoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dUaXAnLCBldmVudClcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnbW9kYWwnOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJtb2RhbFwiPjwvZGl2PidcbiAgICAgICAgfSxcbiAgICAgICAgJ3RpcC1tb2RhbCc6IHJlcXVpcmUoJy4vY29tcG9uZW50cy90aXAtbW9kYWwudnVlJyksXG4gICAgICAgICdiYWNrZ3JvdW5kJzogQmFja2dyb3VuZCxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcbiAgICAgICAgJ2JldC1hbmQtYm9udXMnOiBCZXRBbmRCb251cyxcbiAgICAgICAgJ3BsYXktcGFuZWwnOiBQbGF5UGFuZWwsXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxuICAgICAgICAnYmV0LW11bHRpcGxlJzogQmV0TXVsdGlwbGUsXG4gICAgICAgICdtZXNzYWdlJzogTWVzc2FnZVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuYm9keSB7XG4gICAgbWFyZ2luOiAwO1xufVxuXG5odG1sLFxuYm9keSB7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4udGFibGUge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xufVxuXG5kaXYubW9kYWwge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XG4gICAgdG9wOiAwcHg7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiA5OTk7XG59XG5cbi50YWJsZS1jZWxsIHtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEFwcC52dWU/MWUwZTkzNTJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9iYWJlbC1ydW50aW1lLzYuOS4yL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmFja2dyb3VuZC52dWVcIilcbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTc2NThkNmRlL0JhY2tncm91bmQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYudXAtYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDg5JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKSBzb2xpZDtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuYnV0dG9tLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiAxMSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKmJhY2tncm91bmQ6IHdoaXRlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT9iMjkwODVhZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7QUFNQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxZQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLGlEQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLHNCQUFBO0lBQ0EsdUJBQUE7SUFDQSw2QkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJCYWNrZ3JvdW5kLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgZGl2LmJhY2tncm91bmRcXG4gICAgXFx0ZGl2LnVwLWJhY2tncm91bmRcXG4gICAgXFx0ZGl2LmJ1dHRvbS1iYWNrZ3JvdW5kXFxuPC90ZW1wbGF0ZT5cXG48c3R5bGU+XFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LnVwLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiA4OSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3JkZXItYm90dG9tOiAycHggcmdiYSgyNTUsIDI1NSwgMjU1LCAuMykgc29saWQ7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9kb2NrLnBuZyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5idXR0b20tYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDExJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogd2hpdGU7Ki9cXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRiNGE2NjA5Yjk4OTY1NWE0ZDY3ZjI0NWJkNTdlNDFkLnBuZ1wiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQmxDQUlBQUFBREVoNlNBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVSa015UkRrNVJqTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNVJrTXlSRGxCTUROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2psR1F6SkVPVGxFTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxHUXpKRU9UbEZNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt5RGExSXdBQUFCeEpSRUZVZU5waXNBcnNaR0pnWUdCKy8vRWJpQjdGQTQ4QkFnd0FyN2dFdE9qSDlRUUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kXFxcIj48ZGl2IGNsYXNzPVxcXCJ1cC1iYWNrZ3JvdW5kXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJidXR0b20tYmFja2dyb3VuZFxcXCI+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZW51QmFyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWVudUJhci52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcTWVudUJhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYTVmYTUwOTgvTWVudUJhci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVudUJhci52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ubWVudSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiA1JTtcXG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XFxuICAgIGJhY2tncm91bmQ6ICNlMTRmNTA7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbmRpdi5ub3RpY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA2MCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEuNWVtO1xcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xcbiAgICBjb2xvcjogIzc4M2EzZjtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lm9wdGlvbiB7XFxuICAgIHdpZHRoOiAxMiU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICAgIC8qIGJvcmRlcjouMTVlbSBzb2xpZCAjZmNkMTllO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xcbiAgICAvKmJhY2tncm91bmQ6ICNmZjllNDA7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWU/NTQyYjk2ZmFcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7SUFDQSxtQkFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLGFBQUE7SUFDQTsyQkFDQTtJQUNBLHdCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1lbnVCYXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy3oj5zljZXpg6jliIZcXG4gICAgZGl2Lm1lbnVcXG4gICAgICAgIGRpdi5ub3RpY2VcXG4gICAgICAgICAgICB0YWJsZVxcbiAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgdGRcXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuKHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcXG4gICAgICAgIGRpdi5vcHRpb24oQHRvdWNoZW5kPVxcXCJ0cmlnZ2VyT3B0aW9uXFxcIilcXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIix2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBPcHRpb25zRGlhbG9nIGZyb20gJy4vT3B0aW9uc0RpYWxvZy52dWUnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZScsICdub3RpY2UnXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbmFtZTogJ2xpdScsXFxuICAgICAgICAgICAgaXNTaG93T3B0aW9uOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgndHJpZ2dlck9wdGlvbicpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgICdvcHRpb25zLWRpYWxvZyc6IE9wdGlvbnNEaWFsb2dcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLm1lbnUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogNSU7XFxuICAgIHBhZGRpbmc6IDElIDMlIDElIDElO1xcbiAgICBiYWNrZ3JvdW5kOiAjZTE0ZjUwO1xcbiAgICB6LWluZGV4OiAxO1xcbn1cXG5cXG5kaXYubm90aWNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogNjAlO1xcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcXG4gICAgYmFja2dyb3VuZDogI2VlYmViZTtcXG4gICAgY29sb3I6ICM3ODNhM2Y7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmRpdi5vcHRpb24ge1xcbiAgICB3aWR0aDogMTIlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogYmxhY2s7Ki9cXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC41ZW07Ki9cXG4gICAgLypiYWNrZ3JvdW5kOiAjZmY5ZTQwOyovXFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEMEFBQUEwQ0FZQUFBQTViVEFoQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSTVRek5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVJNVJETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qY3dNemcxTVVaR00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pjd016ZzFNakF3TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrbXJwNU1nQUFCa0pKUkVGVWVOcnNXMmxzVkZVVS91NTBZTHBDTnlpRnNwUkM2VmdzRmFSb0VJd1NqWWdvbUFJbDRoSmMvZ0FhLzJoaWpJa3g4WWNtR3FLb01XQVFrYUFnQ0NvcWFBeTdwVURaV2twWEtFc0RwUXVkbG5aS1o2N24zRGN6bmFtZGVhM08xSm5CazN6dGZlK2V6cDN2blh2UGN0K3RrTVhyMFlzTUppeHc0RjdDU01lOVlKZFd3aVZDTVdFN1lRZHluKzNzcVNSNkliMlE4QjVoQWtKZktnbXZGOHhldGMwYjZRakN1NFRYMUZWN0l6MjNxOEROZXFETENraDc4Rk0wR0FHakNZaE9CbUtHQTFHSnpoNDI0aHRFM3NZWFJyYy82U1o4dlF4b09oOTZkclhkMG1CdDFiNS8vRGhnV0JaY3ZNanE3cGJPSjJ4UnR5LytDWFEwSTJ3a01oNFlmWS96YWhGWmV5dVRaZ2RWUlVoRC9WbWcrVHpDVHBURnpkeTZUQmpQMDN1UklueXpnYVpFamU3Znk5U3BRT2Fqa0FrWm1sTm9vdWRWdmd1aTduandrbVpldk1hamswYlIxV0tqSXl3QmxqcW01SnR3OWhKSTgwTFBlOE95NlNrU3ptNkhLUGttZUlsYnJqQnBiaTFnMHRQVnpiWnJ4RUQ2dEhCUHdoNzkzTmRZQVhIbG1NdVR5cHhsa0dOblVZU1BEU3loemphSUMvc2dUbTBFN0YyOTY3VFZPMXQzRytqSENOWHNhbmRZMmdzeUg5TWZmT0k4bDc3TWVRcHk0dHpBRTFhcFZJd2FTMll2OXY3OUZUOGxxVXphcEpwMm0yWnBMNUNKNC9YWE8rczQ5Y2ZPSHZBWkxNZlA4YzdCYm5NOUlyYzRMZjB3clBEVDUvd3I2dm81VExldTlBblJXS1ZQdWJHeVcvLzgzZ0duSzZwLzg4M2piNlI5cldmR3VSLzBSMVU2bXI0NCtTVkUrVS9rWkZvRHo1Ykc0TEhFNlUwNlBEUXhlbGphMTFPOGZBUW8zUXA1UjM3di9kU25kTnhTUW5GOHJVS3dTYi9XdEFvSkRlWEFwUG5rdENZNnBuUUZXWGduRVM0S21RU3R6NVoyRWI5VVNCVnJvWEpab1NwKzl0NGhaMm43N1VpNmI1YVdvMllBNWdXUVNZNDEzVkNoNWQzdVRpeWNwcmVjOGd6azVBTFBleWs1QU9QTVpncFRHOExMMG16aG5vUTkrcm52ZXBubTZKd0Z4OVFYS0RWOGtCSy91TURINmVyZnRmRG9yZUQ0SnhrWmZGUllMc2xhMkoxN1QzMGVNdXVKd0JOVzJYU3NHa3RPZWJxL0dabmRKMlJTcHY3MFZ6b08vZlE1QTU5MVQ1aXJ3NlBmanF3UGprNzAzU0VHam5sL0NnNmQzRnR3SnFiSCtmcTVidjNxUFFOZmNGVHU2bS91clJPblM3Y0FJM0wxZFJ5Zkk0NStwbjFzeGtNRDRNZ3NFRlY3eUpHdDYxTyswZmVDby9ZUVFMazNid0Y1eTh1VmpudkJVZmlSUW1nWEhCd1NlSnM0T3g4eTJleVkwblJkc2dYaTRxRXdMamhxRHdDRThDZzQ1TzFZY09EL2dzTjdHQnd6RTZDVTAyTk5jOTVkZXpCTUM0NXBMMEhtUHVkNWoxL3pNRTZzaHpqMmVaZ1ZIR1Robm9ROStybnZXb25tNkZUYU13aHl4a3BLRFI4QlRFTUN5OEpLY2JyeVp3cVBIOU1xdmVYSGdtUHlVdjNCdWRKeUZoeDVLN1EzRG9FbXpHS0tVMlBKYVMvNmR3dFlhcTg2ZmM4R3BlUFE1MWM2QTUxMmMxWG56eTFnZnliOC8zbkJZZXV5ZGFoV3hDRGZCVWQ5cVg3aW9uUWMraFc3QnI3Z0tQdmVPd2VEd1ZGaXlDNURwL1ZXazdvYUZPMTdQWnphcEQ4cTZ6aGY2eHhlRFVHaEROYVd3TE9sTVhnc2NlUlQ3OS9mR0sycFdqdWJqVGVhTExWUk1aR3BHSkttblNqeTloUXY3QVdvaXVFZGtkN3o4bldhaml2WDZZUTQrTDVDVUVqOEdQV3J1YUdsT21KZWRrWnVlbVphbmpxT2RNMzNGRlp2TVhnZkxDb0ppRTVVKzFHaTdvUkdyblJyY0FmbnNmY0JrVU5SdFAvMERyRjhaRXJCSjkrOXM4WVVPVGdSTlg4QWRjWGhsM2VtM2dXa1B3QnJSMmZqeXZ5M1hqRzBXVzYyN3Z2MXlGZXFrem9RbDZvYnZrSUt6SWQ1a1RCUFMwdGJTOFJrazJsNDhlRVNTODUwc3lscGVFSW1VdTdVVGdqeXdaUlFsNUdVSGs5NlhEWEx6OVQ4K01HYmEzK2g1bFVtemI1ODlJRTlSMHR5ODh5eENjbERNNUNRRGd4TjA0NGRkbEZFczNVaEpONTFpUWhhdDVRQkptY0I0KzUzYlc5Vm43dTQrKzJYVjM5dHQ5bVpSS2xZRWhmSHBPY1RsRTlmL3VxaXZGa1A1eTBsajU0UzZvWnViK3U0dW45MzBlWXZQdnkyMEhtTHNGTWRreXlZdllyOStVeW5ja3hzbEhIWmlpZG5tS2RrVEk5UEdwSnVNZzFPRkFaK2pNRXRsSGpZS0E0M1VsaXFPWHV5cW1qam1tMkZiYTN0N3E4OHVQNnRkWjBDSnVJOEY4d0lYNkhDSHlmVUtxRHA3Vm9SQkZyNXlBeER3aFdFWTA3SHhJN012WlBQU3Q0Z0pNQjV2aXkweFVMZ2N5RmxIdjdPemRJOTYyeGU1K1RDd1NmRm96ekwwS0FWdThOWmNUN04vOVpRMjl2bTMxOENEQUFxOVd5Z3dnZEVaZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8t6I+c5Y2V6YOo5YiGXG4gICAgZGl2Lm1lbnVcbiAgICAgICAgZGl2Lm5vdGljZVxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICB0ZFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbih2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6MjYqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcbiAgICAgICAgZGl2Lm9wdGlvbihAdG91Y2hlbmQ9XCJ0cmlnZ2VyT3B0aW9uXCIpXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XCJnYW1lRGF0YVwiLHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgT3B0aW9uc0RpYWxvZyBmcm9tICcuL09wdGlvbnNEaWFsb2cudnVlJ1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ2dhbWVEYXRhJywgJ3pvb21SYXRlJywgJ25vdGljZSddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAnbGl1JyxcbiAgICAgICAgICAgIGlzU2hvd09wdGlvbjogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd0cmlnZ2VyT3B0aW9uJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnb3B0aW9ucy1kaWFsb2cnOiBPcHRpb25zRGlhbG9nXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubWVudSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGhlaWdodDogNSU7XG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XG4gICAgYmFja2dyb3VuZDogI2UxNGY1MDtcbiAgICB6LWluZGV4OiAxO1xufVxuXG5kaXYubm90aWNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDYwJTtcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xuICAgIGNvbG9yOiAjNzgzYTNmO1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuZGl2Lm9wdGlvbiB7XG4gICAgd2lkdGg6IDEyJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xuICAgIGZsb2F0OiByaWdodDtcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xuICAgIC8qYmFja2dyb3VuZDogI2ZmOWU0MDsqL1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1lbnVCYXIudnVlPzU0MmI5NmZhXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9PcHRpb25zRGlhbG9nLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcT3B0aW9uc0RpYWxvZy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtM2QyNzE0MDYvT3B0aW9uc0RpYWxvZy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9PcHRpb25zRGlhbG9nLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5kaXYucG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogMjAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKSByZ2JhKDAsIDAsIDAsIDApICNmZWQwOTUgcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuXFxuXFxuLyog5b+F6ZyAICovXFxuXFxuLmV4cGFuZC10cmFuc2l0aW9uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzUzZGRlYThlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsaUJBQUE7SUFDQSxpQkFBQTtJQUNBLG1CQUFBO0lBQ0EseUVBQUE7Q0FDQTs7O0FBR0EsUUFBQTs7QUFFQTtJQUNBLGlDQUFBO0lBQUEseUJBQUE7SUFDQSxpQkFBQTtJQUNBLGtCQUFBO0lBQ0EsMkJBQUE7SUFDQSxpQkFBQTtDQUNBOzs7QUFHQSw2QkFBQTs7O0FBR0EsNkJBQUE7O0FBRUE7O0lBRUEsVUFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLDZCQUFBO0lBQ0EsbUJBQUE7SUFDQSxtQkFBQTtJQUNBLHlFQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSxvQkFBQTtJQUNBLG1CQUFBO0lBQ0Esb0JBQUE7SUFDQSw0QkFBQTtDQUNBOztBQUVBO0lBQ0EsY0FBQTtJQUNBLG1DQUFBO0NBQ0FcIixcImZpbGVcIjpcIk9wdGlvbnNEaWFsb2cudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g5Y+z5LiK5L6n6YCJ6aG55YiX6KGoXFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XFxcImlzT3B0aW9uU2hvd1xcXCIsdHJhbnNpdGlvbj1cXFwiZXhwYW5kXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm9wdGlvblN0eWxlXFxcIilcXG4gICAgICAgIC8vLSBpbWcodi1iaW5kOnNyYz1cXFwibWVudUltZ1xcXCIpXFxuICAgICAgICBkaXYucG9pbnRlclxcbiAgICAgICAgZGl2LmlubmVyLXBvaW50ZXJcXG4gICAgICAgIGRpdi5vcHRpb24taXRlbSh2LWh0bWw9XFxcIm5cXFwiLHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiLEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEpXFxuICAgICAgICB9LFxcbiAgICAgICAgcHJvcHM6IFsnZ2FtZURhdGEnLCAnem9vbVJhdGUnXSxcXG4gICAgICAgIGRhdGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaXNPcHRpb25TaG93OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgbWVudUltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZycpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBpdGVtU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMjYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbWV0aG9kczoge1xcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gZmFsc2VcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGV2ZW50czoge1xcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gIXRoaXMuaXNPcHRpb25TaG93XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuZGl2LnBvaW50ZXIge1xcbiAgICBoZWlnaHQ6IDBweDtcXG4gICAgd2lkdGg6IDBweDtcXG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcXG4gICAgbWFyZ2luLWxlZnQ6IDIwJTtcXG4gICAgbWFyZ2luLXRvcDogLTFlbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmVkMDk1IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcblxcbi8qIOW/hemcgCAqL1xcblxcbi5leHBhbmQtdHJhbnNpdGlvbiB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8tIOWPs+S4iuS+p+mAiemhueWIl+ihqFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XCJpc09wdGlvblNob3dcIix0cmFuc2l0aW9uPVwiZXhwYW5kXCIsdi1iaW5kOnN0eWxlPVwib3B0aW9uU3R5bGVcIilcbiAgICAgICAgLy8tIGltZyh2LWJpbmQ6c3JjPVwibWVudUltZ1wiKVxuICAgICAgICBkaXYucG9pbnRlclxuICAgICAgICBkaXYuaW5uZXItcG9pbnRlclxuICAgICAgICBkaXYub3B0aW9uLWl0ZW0odi1odG1sPVwiblwiLHYtZm9yPVwibiBpbiBnYW1lRGF0YS5vcHRpb25zXCIsQHRvdWNoZW5kPVwic2hvd01lc3NhZ2UoJGluZGV4KVwiLHYtYmluZDpzdHlsZT1cIml0ZW1TdHlsZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVhZHkoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhKVxuICAgICAgICB9LFxuICAgICAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZSddLFxuICAgICAgICBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc09wdGlvblNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lbnVJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZDoge1xuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyNiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSAhdGhpcy5pc09wdGlvblNob3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5kaXYucG9pbnRlciB7XG4gICAgaGVpZ2h0OiAwcHg7XG4gICAgd2lkdGg6IDBweDtcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xuICAgIG1hcmdpbi1sZWZ0OiAyMCU7XG4gICAgbWFyZ2luLXRvcDogLTFlbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZlZDA5NSByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5cbi8qIOW/hemcgCAqL1xuXG4uZXhwYW5kLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcbiAgICAvKmhlaWdodDogMzBweDsqL1xuICAgIC8qcGFkZGluZzogMTBweDsqL1xuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cblxuLyogLmV4cGFuZC1lbnRlciDlrprkuYnov5vlhaXnmoTlvIDlp4vnirbmgIEgKi9cblxuXG4vKiAuZXhwYW5kLWxlYXZlIOWumuS5ieemu+W8gOeahOe7k+adn+eKtuaAgSAqL1xuXG4uZXhwYW5kLWVudGVyLFxuLmV4cGFuZC1sZWF2ZSB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIC8qcGFkZGluZzogMCAxMHB4OyovXG4gICAgb3BhY2l0eTogMDtcbn1cblxuZGl2LmlubmVyLXBvaW50ZXIge1xuICAgIGhlaWdodDogMHB4O1xuICAgIHdpZHRoOiAwcHg7XG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xuICAgIG1hcmdpbi10b3A6IC0wLjllbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5kaXYub3B0aW9uLWxpc3Qge1xuICAgIC8qd2lkdGg6IDMwJTsqL1xuICAgIC8qaGVpZ2h0OiA3MCU7Ki9cbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiAjZmZhOTU2O1xuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcbn1cblxuZGl2Lm9wdGlvbi1pdGVtIHtcbiAgICBwYWRkaW5nOiAuNWVtO1xuICAgIGJvcmRlci1ib3R0b206IDAuMWVtIHNvbGlkICNlODkzNDI7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogT3B0aW9uc0RpYWxvZy52dWU/NTNkZGVhOGVcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUZjQ0FZQUFBQmhyWlJwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSkJNRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVKQk1UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qa3lOMEpGUWpsRk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2preU4wSkZRamxHTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZVBnT3VnQUFLUk5KUkVGVWVOcnNuUXR3VmZXZHgvODg4eUFoUUJJQ0pJVkFKSVpFbmdHaENCUzNPZ2hVcFZoY2Q4RlJaMXVtTG5hRzdhelRkYmJhcVRyck9uYTZ6Q3hLaDdaYkhHSGFpa1hVSXJMaUZua0o4Z3FQQUEwbVBFd3dJVHdDaER3QXlaN3ZQL25kbm50eXpybm52c0s5eWZjemMrYmUzSHZ1ZVg3L3YvLzMvL3YvVC83ZFdnNnNVb1I0NU4rTnBadXh2QndyQi9UWWpCLzUvZDJUOTRnRUlXYXprRitPeFlQc3p2dEVRaER6UzIyZlVkQWtqc1ZjOVhucjhyY0kvZThVTklsZk1WK3JiVjFpV05RVU5QRXVaaUdHUlUxQmsrREVIT09pcHFCSjhHS09ZVkZUMENRME1jZW9xTDNrb2ZzYXkyQmpTZUg5N3RROFpDd3ZCQ1ZtcTZpejd4WlI5emFXOXlOOGZCZU41U3RqYVFwRjBNT001ZnZHOHJDeGpPYTk3a0lFSzJaN1ViL2dLeHlScDh4WTNqV1dGY1p5MnZwbE4wdlhkNCsyQS9tM3RsS20xSzJiU3Qxc2JuMGxuWmRHSXdCZXExR3E0VUo0MjBsT1Y2cFBsbEpKQXlKN2ZEMTZHZUUzMFZDc3p5VmZONWIvTkpZWEg1dnhvNi90Qkoxc0xHOGJ5MXo5MTVVcVkva3kvQk1rSkpJazlWY3F6VEFRZmJQbGt3K05aWUVoNmdaem94QURUbFpyTWQ5c1ZLcHlsMUxWSlJRemljR2E1RktyTnFIUkc0MzRaSTZ4clBuRDF2L3VaaGIwdnhqTGQ3VzErSElYaFV4aUgyZ1Vvb1ptbFpwbkxEOFd5OUhQZUQxbExHbnE3RDZsNnF0NXNVajhrREpJcVNIRmVIZlpXSElSb1JkcU1WODdSekdUK0FPYWhYYWhZYVVXZGI5MTY5YUR2a1lnSWZGSW0zYWg1ZTR0TFdwOHE5bSt5QXRENHJTaDJLcGRROHZqdW5mdjNpMWQvL1YxTXk4TWlVL2F0R3RvT2FON3QyN2Rlb2k4Q1lsTDJyUnJhTGs3QnllUlRnVUZUU2hvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNqcG9sdjU2aDE2aVNjbEpiODlTTmw2L3FUNHVxVlNydDV3SWVWL1lCb2s4Y2ZNZi9FOVdYdzRvZURlVy9lQWUxKzhoenJYYlRxaXhJekxWNGxtRktpZWpqK082U2IxN3FnMTdUdXRqdW12WUFEVnVlSHBRNTdKKzF5bTF2N3cyNEg3QzRlTFZablhtZkgzWTJ4bWFrYUlHcENaUTBMRW0rRUJBbUdWVm1lcGdSYTFhc3VKVE5YdGlybnJpMi9sYXZIWThlVitCK3RucTNXclY1dU1CQzR1VitxWWJlajgvZld1M2V2bnh5WDZpaHRoLzkvSFJvTGIzM3ZOejJuMjJ0ZlNyb0xkangxUDNGNnA1VTNJcDZOdUY5ZVkrL05LSG5uNkhLSXNGVm1MTlg4clV4cjJuMU5tTDE5U0xDeWM1cm85b0RtSGlOL2VQeS9GOGpJdG1qbFFwaWIyMDRPeEVIUWx5czFLMUdFTmx5K0dxc0lNRUJSMERRSmpUQ2dlcFArMDhxZTdPSCtpNjd2U2l3ZXBLdy9XUTlvT28xeWV4cDFyK3dTRS9VZU56cnhIUnJiQktBUTFIMEFESFNFRkhBRVE5K0ZRM3IvelBjKzlTK1VQU1ZObloxa2d5ZkZCYVJQWU5tNEVvS3Q1Njc0bHp0dXYxVFc3OTkzODRUcnRqblRoeW9HODdUb1ducGs3Lzl4K1YzamMyZldwbVdoSUZIUW11TmQyMHJmTE1uelUwdDJZSy91OWdhelFweU9rZjhlT0FtTU9wZXQwRUxkOGo0K0hrMWNQTkRNV2piZWlVZ3JaV3ZWSzlXajB5b2pQOEx2aTdzZG11clg1cHJWc0ZoTytTRW5yWWlzcXR3ZWQwVEtIVUNORUFOVVNvMU5VM3EwdjFUUlIwUjdMeldJMWErVkdwZnI5ZytraHRQNnhJdysycFpaLzRQb00xRWFGQzNNdmVQNlRPbkx1cTVuMXpSRlJiOUU2cHhXQ3pKTUhVRG9GcWlFQ0ZOVG1CSHJwRE1LZTNJR2FuRzRkYzcrKzNmcUdxTGpqblpQT3orMm5SWTN0b0REMDY3UTQxZFZSV3hJODVIcXQvdXlCQlFVZUJXUk55MVByUEt0Ujk0Ny9oR29XUU9YaDIvdGlBRGNBNXhVTjFwSWF3WDMxbm4zcm13VEZCcGVLODREV2xHRTZQS0N6WUd4dU9SS1ZXbVR0cFdNU3ZDUVZ0RXVLS0pUTWk1ai9ocjVGemhvMzVhUCtaMjNyandvbmthQ2hIc2lZd2J3c05kVWJvQ0NQcFBEUjQwRlVkRFAxVEV0WFNlV05kODdPd0d0R3dHNUdJNkU0KzF3ek9UWDRYS0h2aXBWRnJia3pUY29RSnFzL1RSbU90cE9Kdmc0YlFFU0hWSHhwM0VrSFErSFBxNUVDK0dGWUNyZmFNMU1TUXFsMjNxR2NuTEhQRE0xcTQ5UVJDaUxCUVlQN1VFYTZGMks2bkU0WGhsYlVIZEdONTRiMzVNVzgxWWw3UVRpTDZ5ZmVLMWZpOGRCMTVjSkZmV0xOSGl4VU5PeWN2alFZazFzSDRESzlkelBnTmZEcjI0NVQra3VPejY5QUpKMlhtRmJlTUROS1FFL0l5ZFVNWDU0Nkc4eU5UaDl0R2JIVDFvM2RVdnFzOGYwMnQzTlQ2T3dTS1VWSEk3M2M1UVNNQ3cxcmdkZGpBVlBYc2IzZjRMSUdmOEI4YW8zNzhteDNhZnRpTmZFT1V4MDJGM2NCZ0k2KzJCcitwdnRTZ2ZqaTcwREg5SlpFNTJwRTQxRFlHQkQveGprd3RUbHlmc3FvNjJ4RitxTGtRamRHR2tMRXMrTXl0RU1RcU1Uc2VHdEVYUXNHclcrb0kvbTd4QTBXdHdscC9VRmUxNW1yelAvNjRUNzlIdGVubHh1QTMwbzN0MWxFVEwwQzh6eTBZcjhVSiszRCthcE12Q2d1b3VSQ05VU3VLcFVOTmlFSWNUMktPYVVFSEE2STIvQ1NpQ253alJDa2VVQ0tOVncrNGFYK2x0aEs0eVIyZGd3MTEwRDh5TTRHaU5jU0pBVkFOVFRmVmErc082aUd5d3FQVDhyUzF3SG1qSmtQMktGWWF4cDAreStIbUp6SE9HRlVyaEF6RU8zcnRMVU4wUjI0Yk54VTMrWFprYjBLeEw4aWJ1elZDY1Y0WUgyMGVFanF0S0Z0dEw2M3kxWEtJNHJodXVHWnZmbExtT2hhY2d1NGdJRno0Uk53VXlYd0UwL1dMNkk2SWptamZrYWtxUkV5SUN3WEpiSm04NFBiWUdDTDNqbVBWUHVGaSs2aDVVRmh4ZnZLNVJIRVJOY2JHN0RwZXJhMWN2RVhxVGlGb1ZOWGJqMWI3SG92Q2pZTXdJV3hrUVI2WU1EVGdqY0hOeC9xSWRNaHVSQnV6aDRXd1VQalF3QTIySURWWU9qdHdMVENXMnp4S0VPZUV4clU1aytGa1RTQnEvQjQxSFNJL2pndmp2cG0yaXpLSVpQdkthM1dPMmh4cFJCam9NWlBVa3dnVnFUUU0ycmQ2WTRoQUJqbGhISWZjZEtjeDJWYmN1cXFkdW91M0hEbnJlMjk5ekVrS0pLS3ZXLzRZeDQxZVRUQnpkTFpQbFBXTk43U1ljUzI4RkdZN3Y0Mk1FUjR2ayt1SHpFYzg1S05qVnRDNFdVKy92dFZ2Q0tQa2U2V0tOZ3RnU3NFZ1gxVXF2bERTVU5zTS80aWJncHVNeUNNTkh4SHVoU3ZOdnNKZ3Z2bE9ZN0t0dUsxajExMk1jOXQ4NEV2SG5rdWNDNnA5UExQb0JXeG5oaEZGelkwODg3VXcrM1N2M2RjNEpuaHl1WDdJa0NEQ3h6cVlTYloxeHBXeURURjNjT2pja0VlQkVJRncwM0NURUxrUVBUQ2dmMHh1dXFjSWhIejA1MlhudE1lMnEwTEZ1M2FVZDhZNTNKbWRabXNCekJZcUVLaDFNTERLeTNIYlBZRHI5U0hZYUQyRUVESHk1OGErb0Vua2E3Mi9WbDMyaThLZGhqWkI4eUhaTGdRaWJLY1NzUTM4VjJDRWdpYUVnaWFFZ2lhRWdpWVVOQ0VVTkNFVU5DRVVOQ0VVTktHZ0NhR2dDYUdnQ2FHZ0NhR2dDUVZOQ0FWTkNBVk5TR1R4UFlLMXIrUXdyd2FKVzRxdHp4UVdqeHZOcTBKb09RaWhvQW1ob0FtaG9Ba0ZUUWdGVFFnRlRRZ0ZUUWdGVFNob1FpaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0ZIbFlkZitsQXZkbUNLTk13Zys2dU5SL1g3WUFubE55UXduTmF0RFV5RW1aR2FxSEl5K25oYUgvTmhZd1paVFA0WjdJU1VtQUJ6ZjNtdFdqeXIwUFArZ2dVVGlaNDVYeC8yZG9abXBIVFlaS1NkWHRBUW1kZnBnWVBodmVmbnRMdjV5OVlmMU8vTlV5WTdnZW1DTWNVeU9IdnhtdU5jM3hEN0U5L09iN2U5K3FZYmVxcm1uNzYxVzczOCtHUS9VZHZOOWhycytZQ3RwVjhGdlIwN3ZNNDBTMEY3SURtaHAyOStiek15dDdiZGQ4R3NJeUFDWVdMMjVSOGMwcEVYazdlN2lSbnJDUkNtMnpGZ3ptMnJvTEg5bE1SZVduQjJvbzRFdVZtcFdveWhnaW1wdmN4elRrRUhRZjZRTkQyQnVwMjNCWGJmQmJPT0djejlqVW5hRVhsbjNqV2tuY0RnZVNGMmZJL0o0dDFFS0tLZlBUSFhzYnBHMU91VDJGT3ZaeFkxUHZjYUVaMzhQY0NNc2VITUdpdHpyT01ZS2VnNDVZRUpRM1hFUFZaNXFaMVlsLys1VkcwdnJkSVIvOG43Q3RUZUwycFZldCtFZHRFWHdsL3psekw5L2p1VGhnVXNSRFYxamZvOXRoV0xaS1lsVWREeHl0UlJXZXIxcDcrbHhReGZiZWFmN2k5UWd3Y2txMGVtRGxmYmoxWnJ1NENHM1hNTHh2dUorcFcxQjlTbCtpWmQzWHV4RWJBZktBVEJOaXk5QUc4Zmo3YUJnbzRnaUpSb21LMy9yS0tkenhadmpjaXFvN1poRnlCZ2lGb3lINGp3QzZhUERLb2hGUTB4ZzRrakI0YjgyN3I2Wmwwd0tlZzRCVkZ5MC81S0xXVGNTRmdMdHh0cUZiVTBFTWVPeUhSc1ZEcGxRN3o2L0dEQmNiZzFjTDM0Y3pUTUtlZzRReUl5Qkl3R242U3EzQnBkNGkreHZtUTZFSm5kQkJTUDFUOGE1aFIwbkZGOXFjSG5lMmROeUhHMUFNaU5Iemw5VWUwOWNjNG5VRVJsTDUwazFueXhVNEZ4aXVSZUtEdDdXYjJ4NFVoRWZiZ3cxMmprU3MxRVFVZmh4bmk1OFhicndGdWFJeWx5eFZpY1VteVY1NitwbFp1T3RzczVJeTAzcFNBcnJQUllwQ041US9QTmlOWUU1bTFkYTRyOTd2cVlGYlNYRytQbHhqbXRZeFowb0s1ZFJONEplWm5xU3NOMVhSaEdaUFhWR1pGb1k5Y0RHQ2pDbzNESjd3SmxUK1QzYnZ0QnRvZGQzeEhBZkdOQ3VSRmUxZ2xHVVBEVWhVUDdxMmQvdTBOYmpJNFFkQ0RjZWdKMWQvNzdyVDJhODZlT2NLMUYwQkZrdFJJb0RHanNuamwzVmZlaXhyclZFT0p1dEIwOExQRFNwUjFwVGhzM0Z3d1owQ2Ntcm9WYnIySlNRZzlkcThBbVlUek02aTBuSEVmNG9TUEkvQjBzRnNTTTN3NGRtS3BHNWZSbmhJNFd0WmRiZTlZS0luaVJnKzJBMkxqM2xGNGlZUnVpQmF3R3hEN3hqa3p0LzlGbFgxWlZaOXQ0UllNWUFuNXg0U1FkclNGd2ZJYXNEVHFTb3BVbnA2QU5NTjRDNUEzdUc3RnRldTJBTUl2K2R0UVFvUUR4b3VNSG5UNmJEM3lwemw5dDBwOGhDcHNidHlpZ1VyQ1JpdnpKOTRwandsWjFha0hEYmtpbW9kaW9UaU9GbHc0SUdYQUUvNHhqNkp2Y1cwZTBTQkpxRi9qT1l6V3U0c00yY1g0WWRIV210bDY5dHU2Z0hwZGl6dkpnR0N6T0MyTDJNb1NXSGpvQ3JOdFo0WXNvSGRueVJqU1RBVWRvWUtFcXhzMkhMNDBVS0REUHZSbmEyTzlYMzlubm1zSkVBeEdkUjc5NHQwU3ZDekZQSzhyMnkvSWdpcU93d21xOCtVbFozRDVSRXpmRkVEZGNJZ2dpU2tlS0djTTd4Vk1pVzNCbmRwcjJvekxJUDF5ZktSRVQ1MllkRk9XMWtld1V1WGNjcS9aRlkyd2Z3VUJ5N3VZb2plT0hxT0dsWVQ5MkhhOVdpeDhvaWp2YjBUTmV4Q3lENnBGQzZvam9MR003NUtrUGM3ZTIrZVpEMU9nMURMWVh6ZXhoSVN4RXg2VVBqUW42M0Jvc25SMHlidHZja3dtL2orT2JWampJdGVESmVjbTRiMFJ6SE5mMG9zRnhrN2JyR1U5aWhxaWlmV0VSMVE2ZHVxQWpsSXp0c012RDR1YkRROE4yNE9iakdHRkxwaFFNVW1OeTA5WDR2SFJYOFd3NWN0YjMzdnFZRS9hSmZTUDZ1dVdQSWQ2UDlwL1I3MmVPenZZZFYzM2pEUzFtaUJGanZJT0pzdUszN3hvMlFLM2FmRnpYaWxod2J2R1FqNDVwUWVPSmFrbVBCUnI0RXc3d2w5WkhqaUFxTDJrckhOT2M0cUhxN2UzbHVoQ1lVM3BPaFFGQ1JNWUIzeStkTjdhZGFGRW9zQTJ2ejFOaU96T01LR3B1NU5sMTVTTTRlTzIreGpGaEZDQitnOHdTT2xnUTRSbWh3d0JQZkJ5dnZOUWhnMklrb3VWbjl3dTZheHZDK2VIc1F2MUE3SUh5QzZxaTVvcXU4clBUVTJ5UEd3VUVRb1lYdHlzczJBN1NraHYybkE2NGI2UWNVYURNNG5XeUxSQ3o5Y0haUU04ZDR2aXhST3NoaEVqVHJlWEFxaGI5cm15RDZxckV5ODJLeEhuK3RlcXlYeFR1TkZpblJ1N0tkQVV4eTNsMktoSGJ3UCtjUkNob1FpaG9RaWhvUWlob1FrRVRRa0VUUWtFVFFrRVRRa0VUQ3BvUUNwb1FDcG9RQ3BvUUNwcFEwSVJRMElSUTBJUlEwSVJRMElTQ0ppVHU4RDN1dksva01LOEdpVnVLcmYvR29IamNhRjRWUXN0QkNBVk5DQVZOQ0FWTktHaENLR2hDS0doQ0tHaENLR2hDUVJOQ1FSTkNRUk5DUVJOQ1FSTUttaEFLbWhBS21wQXVJbWpNZ0lvNXArMCt4enpkTDZ6Wm85L2JnY25sc1U0MHdIYXQyOGFFODE3Qk9TMzk5UTdiYzRzbExsNXQxdWVGMTFnbkxxWlFmV1h0QVhXd29sWlBvcjcwb1RHK3Vhd3hNMnA5MHczOTNadWZsT241dHEwM1l1MjJFM29PNzNsVGNpTitYREp2dG16N3RYVUgxZmJTS2ozcFBTYTFEd1RtM3NZYzQzWVR5cU1nWXI1d0wvenozTHRVL3BDMHFGMy9yY1oxeDdsaVh2Qm9YTWN1SjJpSWVObjdoN1J3Zi95YkhXcmh2Zm0rU2VFZm1UcGNiVDd3cGRxNDk1U2FVcERsTi9YdjhjbzYvWW9KNmFOQi81UkVkYW0reWZmM005OHBVbGNicit0Q0JMeUkyZ21JR1dMM1FrTnord0tCaVBxejFiczk3Kys5NStkMENzc1JGNEpHUkg1eDRTUmROYS81UzVtTzFOTUtCK2tJalFVQ3grZTFseHY5Zm5mbzFBVlhLM0JuZHBwdm5tOHZFWEh1cEdHK2dnVDZwU1JvUVplZHZhd2pKTGIxM0lMeHVrYUpoS2pCenhkTmRweWZHM1lsa09oUjZIQ2NUbGgvTHdWaCtLQTB0ZXdIOTFEUTBRUmlHcFhUWHgycnZLU2VlOU0vK2d3ZG1LbzI3RG10RnhIZmNXTTlBSEd0M2VZdUZpOFJzYVRpZ3ArZzdTS2tXZFJaL1pMODFvUHczOWh3cE4zdnR4eXUwZ3VZT0hKZzJJWEFETVRzSnN5SFgvcXdVelVLZThiYkFlZGs5RkY3djZnTktENElHK3ZBUDAvSXk3UmRaMmhHaXUrOTIwMUh6YkQ4ZzBOcXBFZWZLcUtXNkc4V3Z0MXhXeit6RTNRa0lpZk9BMzU5UnRGZ1h6dWtzOUV6SGc4YURSTnBuQ0RDMk4xa1pEN0EvS2tqSEt0c085SFlyVnRUMTJwbCtpVDZYNjRDbzdZd2l4R04wRFBuNjFXRElacHpodjFCZ3hXUlg0NE4yelo3VldSSU9yS3hKWVU4Tnl1VmdyNWRWSjYvcGkyR1hWWHZGb25RZ0VSMDlpcG1pY0xQUERpbTNiN0txbG9ibDhNTVd3UFJuNnE1cXY4K2UvR2FmZzNVK01JNW9HWWhGTFJhdWVtb0ZpZWl5NVAzRlhnU0tIdzJ4Q3dOSnp0bWpzNzJpNHBvWktKaENWRkR1SklHUTlURi9sRUw0RE03ejJsdWVHRzdBRkhRMnZBa0ZMUk8yYjI5dlZ5bjVSQUpJVlR4cDVLNVFFUEs2ck9SRlhITEF2Uk43cTFtVGNqeGlRMnZpeDhvVXErK3MwODMzRjU1WXJMK1RGSi9zQmNBOWdEV0l6TXRTVWRxV0lhaVllbnEyZmxqUGRrWDBzVUZEYStIRGhQa21GZHRQdTRUbjVuV0xNWUozOS9pcWEyK1dtd0Z2cmRydEUwZGxhVTdSYkN0UCswOHFSdG5rdm9iazV2dTgrOVdxaTdVdC9zTXg1cWRudUluZEtmVW9EbkxFYWlCU2pwSm94RFJEbEh6d3BYMjNhOFFxRlBHd0NwbWM0UzNBeDAxRUIxRWpiUWJhb2JXQ04yK2N5WWpOVkcvMXRVM3Q5c1hqc05hY3ppbEJyMTJvQUFVRXRKSnNod1FZVTVHKzBNMmQzZzQ1VlhkSXJOMUgvRHFzRGY0RFpnOU1kYzJLeUFOUFhOdm9XUVR0SisrYTRqZjU5YklLMW1PbjN5dldOY09ialMwZFkrUGpHSVhkMmNncmtmYlNiWUJmamFZUXVHbE5vQlhGbUIzbkpEYVFmeThSR2NVZ2tDWmpSTm52VWZtYzVmdFU0Y2tqaU0wUkdQT0dpRFA2MVF0TzQyd00zK09USVJUdzgwc0hHdVh1aG5ZQ2dnWTZ5QWpna3dKc2g2UFRzc0xlRDdpdlZkK1ZLb3RqVnR1V01TUGJuL1VBT0g0YkxGS0ZQUnRadDNPQ25YbTNGWDF5Ky9mbzIrK05MQkVsTWozZ3NFRGtuMGo0YXhlMWV4WEVZWHRCSTJocUJDbWdQZkZlWm0yZ3BQdWJYU0xRMnl3SDhobGUrbTR3TEhJQUNjTXZqTGJJYXRnUzArMzFnQklJWWJhZUJTdjM1bHo0bkVqYUloVk9rdEVMTGhCa204RzU2KzJldG1VeEY1Nm5JWVpTZm1oNTFBd2QzMmJRWVlESXNQNkdLbUhCaUlFaDFTZ2xWRnQ2VHdNR3dYNGpaZE9JTEVvVXdvR3FiekJmYlZmbDh5S1hZTldmRG9zVGpDTlNQUDFrM09pNVlnQk1INERUQzhhckY4eDBBYzNDSUp3OHNGV3JqUmNENWdiaG5na0JiaDRWcUZLNzV1Z2g2ZWlNT0U3cTFnUjdVUmtpTGFJc3VaSTcrVGJqNXkrcUY4aFptd1QwVjB5SzlaOVNDTVR2bHdHWE5rSjFoeDVVVmdsWjI2K2Z0YWh0T2EyQWh1RkhZamthU1VpSGoxenlTZUlTTllDWWpWZ0d5QVFHWjRxMXNQNlpJdzBBaVhhbXNYN3BiRTlqQXEwRzdxS1FnS0syd1pPb1FNSkJjSzZEM2grS1N4dXZuekppay9WcnpiK3pXYWhGa1BPSElWRFA5bnpXWVgrL083OGdYcWNpendsWXg0WEE5QkdRZTJHaHdZWW9hUFlHSlNSY3hLRlJPREZwcEYwa3RvS0pST0FmU3hiZjFCSGZYU3VtS09rUkZEVURtYkJTbTViUU03Nk81T0crWTVSUnRkWkc1VVFLZlpqVGdmaUZRVUhBNkZrSHpnbWFRdmdPeWRmTG85R09VVnZzVkRZWDdLeGJiUkRsaHMxRHZabHRUallkenozY01aRmhONTF2TWJQYnBoVFkrYWJMS210WU5KNFlsL2dzVVhNZGo0V1ZrSkVqb2lIYUFneEkzSWlqeXplRkdOUDNOS0tFSjlFUzRqZkRMYVBqaDJ3ODFpTkxtREFXc0NzWUlRZmtIRWtadEE3Q1N1RDQzemkyL202c0sxWU1rTWZMejdIZVRnOWo4a0lIYVhHSUNJZmJnZ0dFT0hpaTZlMDVvZjNsOWVHbEpiQ29DT0lCamdOcmtma3dyNjNINjNXdGdEaWgzZisxKytPMHlKQjJnMlBoOEZybzBwSDR4TzFDSTViSWg1K2o4WWxmZ3Z2YXBkdHdINmt3MFhFYkhkTUtCaFNtR3R0Y3RUWUY1NnpsR3YzOHVPVC9jYXR5RU1JK0I2akJ0MDZuSnpTb3hSMENCeHJxMGJGbnlLaVNIU0dVUEMzZEU5TEZnQkNRVUg0eGJzbGZ0dHk2emIyOHBTSTNIQ3B2aEh4NURPeERJamFFTFdrMTdDZXVlcVhUSTNkbUJDSVVCNEloZ2pOejA0S2lNSTQvNmVXZmVMM3VSUjRxY0hzQ3AzMVhFVFVhQ3czTm4vdE94Y1VTSE42VUJnWVpNMUhRZHVBRzRvcU96bWg5VkRSTUlKWGhKZ0FCZzJKZDRSZy8ySEdIWDY1Vm1sUTRjYktkK0VlRHhxbWR0RlZ2dnY5MWk5MEdnL0NsZU9VUW9PVUlrYjVPUlVZWkNHR0RPaWp6OVBPTTZNZ0lCSmJueFNmWWZMM01oVFdXdWpzOWdkUlkzeU1lVit3ZG1aQjQ5cWhJQVhxbm84RnVyVWNXTlhTYWlRM0tOSjVRTFR2VXVPdzI2Wkc1bjlPNnFSMDFZY0tLR2hDUVJOQ1FSTkNRUk5DUVJNS21oQUttaEFLbWhBS21oQUttbERRaEZEUWhGRFFoRkRRaEZEUWhJSW1oSUltaElJbWhJSW1oSUltRkRRaGNZZnYwZUI5SllkNU5VamNVdHoyYnd4OGdpNGVONXBYaGRCeUVFSkJFMEpCRTBKQkV3cWFFQXFhRUFxYUVBcWFFQXFhVU5DRVVOQ0VVTkNFVU5DRVVOQ0VnaWFFZ2lhRWdnNk1UQnFQeFF0TGY3MURyNHRwa3IydS8vQkxINnFTa3hjYzE4RjNXQWZ6Y1VmaWZEQkp2UnZZbjl2eEVIL2lhblpHVENhSmlkWXhiUyttUkhhYnFoZnpYV05hWkdDZW5qaGMxdTJzMEsrNVdhbGhpL201TjNlcnV2cG1OVFF6eFhhcVpmQ3oxYnYxNjN2UHp3bDVYeWlvb2JMc0IvZFEwTkZrNlVOajFJOS9zME90L0toVWpjOUx0NTB4RldMQlhOZmd5ZnNLSWphcktxS3B6SUc5YXZOeDIzVWVuWGFIcHpteGNVeFk5OVYzOXFtZnZyVmJyVmd5STJxenYwckJab1NPUVRESityeHZqbEMvKy9pbzJyUy9Vay9tYnVYTlQ4clVwZm9tdFdENlNEVnVlSHJFN003YjI3OElLSktQOXAveFBNazcxc014cnQxMlFoL3pEMmNYUnZYYUJSUGxZYXNvNkE1aTFvUWN0ZjZ6Q25YaTdHVmJxN0Z4N3lrMWRrU21XalJ6Wk1UMithZWRKN1dJWjAvTWJTZThpMWViZGEyQlFyVG8zdURzRFk2eHJLcE81UTN1U3dQY2xRUnQ5WUg5VWhKVTFZWDZkcC9Ea3pyOXhzNFBydDV5UXUwOWNjN3Z0L0RKc0JSekp3MVQ5NC9MMFlVRVViUi9TcUt0SDM5N2U3a1c4MVAzRjZyOElXa2hSVDVZbWVVZkhGTERCNldwRng2YnFHc2kwb2tGSGF3UEZLOGJDSWpadW0zNTdiV21tMXJNRUpvdUlQUEd0dk81NWhyQnp2NVlnV0RkemhHRmltTHVRcFlqbE5hK214ODBSMjFFZElqcTU0c21hKzhOMy96MDYxdmJaUnljQ3BEc0I2SjF5ZzQ0ZlM0RkIrMEQwc1U4ZEVlQmFQenk0NVBWeWsxSHRXQVJoU2ZrWmVydnFpODE2TWdNOGM0Y25lMzNXYkRBZ3lNcmcyMTVpZktoRXE4TlBRbzZnaUEvREJGRDBIZ1Z3YUd6UThScjkxa3cyWk5sN3gvU0hoeVdKaHE0MlJ3S21rUVVaRTlRV0NLWll2UnFjem9qSE12aEVqbWozZVdNREF1eUp3Q3BPK3lUZExFSUhVNDNiaUQ2SnZmV3IwamJpV2NPRkRXejAxTkNLaXl2ckQzZ2w0bkIrMGgxcnBTZHZhd2FtdDBMeDlDTUZGODJ4Y3Y2SUZvMVNKY1dkS1M3Y1pGZEtQL3FpdHAxdkZyN1dCSFh0S0pzTlc2RTh3MnN2ZHlvWDBjT0NjNmZJdW9qeHkyZE5PSzVrY05HNzJkS1VxK3dPNFRlMkhBazRIWEMvc1Q3ZTFrZmhET2VoSUlPY0RFbHpXVytNZWFXdk5lTHY2MzBLMStrUk1jSlJDMXBPMFF1YzQydzVYQ1ZYc3lZUDVNSWoxd3lmaWNkTXdKRy9vbUE0WmtoWEhQRHNyN3BocytDUktLWEV3Vm1VUDlrdjgvMmw5YzY1dWp0MWdjb2FMUWNVUWFkSG1CZ1dsSlkyNWxlTkZndjB3b0g2ZEZ2RXFVQnFtRno1TEtMWW5hZllSdFk1QmpOb05Bc2ZxRElkcnpISTFPSGF5K05KUkpNS2NpeXRRbE9nblphbjRMdUFDUXFacVFsaHJVZGN3UzE4NHgya2Q3Y2V3aUIvdkw3OTNqcTNmdU9FYkhSZGU0MHFnNmZZelJoTUdDc3Q5UFEwNjVJWEdZNTBCR0J5QWd4NVEvcDJCd3JHblFiOXB6Vzc1OTVjSXlPeEJqTDRRVUlMOUFRVVJTTVlMcStmL0Z1aVhwdDNVRXFPWjRGdmErOHRxMktIQlJTQmlBY2tJbEFZWUozUjNTSEY0WVBqc1FUTEtHeXZiU0tTbzVYUWFPS2xjSDdxTUpEeVFDOHNHWlBTSkVaZVdQclFDVDRYdndObndrcmNqdXlQbDJwSjdCVGVXaUlHVldzRE40UDFUdWVPWGMxNlAyYXgzTTh0MkI4TzkrTDhkRHcxVFYxalZya2tYNzZCRGJMYWtYa1dVbW5YRGhTaTliT0lZdzNjY0p1ZlFvNlNyNFZUNmRnVUwrSU9WQmF5NjZ4QkxzUlRFU1QvVW9yMzJtL0VCb2VvVUpuQ2RKdUdKSnFUZG1GQ2dvUUN0S0xmOWpyM0hoMXlKZEx3OVVyd2E1UFFRY0pudUhiY2F6YXp5TmE4ODVPQWxpeTRsUEhkZWFhckFvaTMxUExQdkg3UGlNMVVlOGJ6eTJpQUtFQUJIcFdFQkVaa1J0ak15QnFpS09rNG9KNmRuNTRBNDRXenlyMDFRNTJvSkE1RlJ6bW9XTU1QQVNMNS9pUXpVQUQ4TkZwZVFFekFLaitrWFU0WG5uSjluc005VFFMQU51REtCQlZDM0w2NjF3c0lqdVdpcG9yS3F0Zmt1ZElDMUVqZ3M4cEhxbyszSGRHVzQ5QUJLb3RjQnd2THB3VTB2V3p5eXYzU2V5cHJqUmMxNjllMWdmV3pxUllwbHZMZ1ZVdHJmWHhocGc4UUR2dlNFZzcybWFTamZrc0I4Vk1nb0hEUndrRlRRZ0ZUUWdGVFFnRlRTaG9RaWhvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNwb1FDcG9RQ3BwUTBJUlEwSVJRMElSRUNOKy96OWxYY3BoWGc4UXR4VzMvYU1ZbjZPSnhvM2xWQ0MwSElSUTBJUlEwSVJRMG9hQUpvYUFKb2FBSm9hQUpvYUFKQlUwSUJVMElCVTBJQlUwSUJVMG9hRUlvYUVJb2FFSW9hQi9yZDUxU1MzKzl3L2E3WDIwOHFwZkc2emNkZjE5eThvS3FQSC9OOGZ1eXM1ZlY2aTBuOU56amJyeTI3cUQ2dUtUU2RWOEE2K0NZc2QrT0JPZUJmUVk2dm5pbFp5d2ZIRzc2dFNibkN6K2phTERmWE9BbnF5L3IzOXcvTHNmM0dVUzZjZThwTlhaRXBrcnEzZFB4SnY5czlXN1ZQeVZSL2ZMNzk5ak9MMzcrY3BOYXUrMkVLcXVxVXk4dW5PUjR2TnRMcTlUVnh1dCt4MkFIenV0M0h4OVZQL2xlY1lkZTB6YzJITkhYNmVlTEpxdHh3OU1wNkk1a3c1N1QrdUk3a1p1VjZoUGZyQWs1YXYxbkZmbzMwd29IK2NTN2N0TlIvYnJvM256SDdlUVBTVk5QM1Yrb0JiYnMvVVBxdVFYajI0bC82cWdzWFNnT1Z0UzJLelRtNHdYenA0NEllRzViRGxmcDE0eTBSTnZ2VVJ2c1BYSE8wM1Y2OHI2Q1Rpbk9UaWRvTUh4UW1scjJnM3ZhMlFORVZHc1VIem93VlYxcHVLNDI3YS9VZjljMzNkQUNoQkNQbnJta0Z4UUN1NXMvYjBxdVhoOVIrSlcxQjJ4RnZYaFdvVnF5NGxPMTVpOWxmb1ZHamdPRmIvYkUzS0RFaGNKa0I4VHNWcGpOSERsOTBmTStaWnZKQ1QwcDZOc0p2T3VaOC9YdGJweGRGTGYrRFZGakFZakVUamYva2FuRHRhWEF1bi9hZVZJdG1qblM3L3VjakQ1cXdmU1JLaVd4bDkvbjhLTVFPU3pMRTkvTzkzUXVPRVlVVmllc2hkZ3VncVB3b2JCYWp6T2Nna1JCZHhCYlM3L1NsdUM5NStmWWZtLytYQ0s0M1dkdUlPSXVmV2lNZXZFUGUxVld2eVRYMytGWTdIanMxZi8xdlVmaFFlUVhwTkhhTjdtM2ZxMnJiMjdYa0owNGNtQkFnWnJGakpyRUNyWVpLTG8vL05LSEVha3RLZWdvZ2t4RzN1QytLak10cVYxalRmeHRJT0RKelRjTlZiTlRKQlhST0gzZko3R25hODF4cWI1SkwxYmNCSTF6TVl2WnJxR0xRbUVIQ2hKcUg5UWsvVklTZ3I2K1R0dWxvS1BFb1A3SmFwc1J5YTJOTW53V0txaWFuYUtTUkRtdlVVdHFES1Qya0ExNS9lbHZhUnNqbVpabmY3c2pZTlpuK1FlSFhNVXNCY0t1VU9EM0VQU1Vna0hxaDdNTE82WGw2RlFkSzhoMG5EbDNWWjJxdWVxWGtzTk5uRHRwV013Y1orbnBDenBLaXBoQlEzTnJ3M2JtNkd6SDMwSE0ybElZdHNoSnpHNlVmM1ZGdjZJV1k1WWpEc0JOUnZTUmxCajR2NE5WT3ZOZ3RTRm13U00zRzJ5akxGU1FGNGZOc05vVUtZUldtK0praTBMaDdNWFdqcU5oQTFNcDZIamg3OFptcXpHNTZlclZkL2JwdngrZGxxZGZrU0d4QTVIUmEzb3NFaHlydkdRYmlhc3ZOZWhYcDRJWGlTeVJaSG9DV1JzejA0cXkxYlB6eDFMUUhZMWRxOTFMU3g0cFBITTJ4UG9iTDl0d1c4ZmFJeWZWUHZMaFpvNjNDUjNyT25YaFc3TWx3V1JIOXBYWCt0NTdhUlFpQTRPYUpEV3BGeU4wUndKdjdOWTlic1VxcEVBNFpUQzhaZ3lzSFJobTRacHRDR29KTlBic3NpRk8yWlZnc2lOU2tDUzc4dkxqay8wOHZGMmh3WHBUQ3JJbzZJNGswSmlKY0hIeTBwSXh3RTFmZUcrK3ArT3dDdGRxUS9LeisvbGxRNXhxQXFmdm5VREh6NjdqMWZyOU13K08wWTNMUCs4NTdaanBrRjVQRk9aNDYxS1BLMEVqR29aUzdac0pWZ3hPQXBHOE5tNDZCRkpUMXhpd1E2VEIrQjNPQVFYaGhUVjdkRmM2b3FTa0ZlL09qMDZlZC92UmFsM3c0SWRSOExBL0ROaENXd05qVkp6T0RXTkUyQ2lNRXNoY0JQSjlFSmRUMmd1L2oxVGpEOTNpRW1tUkQ4YllEM1IyQktyMmtkTmVzV1NHWGgraS91bGJ1OVY5NDcraDMrUFlvOVVkTFFWbTNJaldhSXVCV3RqbnlvOUtWVUZPUDcrc2lmbmM0bkhBVTF6bG9RdHkrZ2RjQjEzTmRrdWtrSjQ2UkZySkIwUFVFQUErUjdlMEcxZ2Z3MDh4SmdSUlV3cEN0UExrNkxxWEFpTzJDQVVIMWdQN3graENHUnR0UGJkNEpLWWp0TnhrOFo3NEd4Zi96dXcwblQzQXE3V2g1alJnWHNaUGhHTXozdnlrVEZmVnVPRm9WRWxrRTFGTHBNWUFKN2VlUElua0dPUWtZMEpnV2FMQnFzM0hiUXNNeEkxOXl1akM2VVdEZlIwM2l4OG9Dam5YVFVGN2FQRGh5UTdoNmRlM09qYkN6S1BxSWdXRWpPR29HR3N0SFNMLyt0MXg3VElFWmxIakdKeUdvSnEzYSs0QThsb1FnZ0hYVFJwM2R0ZEw3QkgyTGRjTmtkdnFxeW5vQ0FzS1lwSUdEYUlLSWdsNnU2eWVFOVcrMCtENmRUc3JYTVV1RWRoY1ZjTkR3bE5LTll6UmMraGVkeEtjV2RUQitIQjQydi80NHo3SFlhdWhXZzJKL2s2Tk8zUzJvQkNad2ZYRnRZaFVvYUtnYlc0OEl1UERiVDVZeGl4REFHaGdtUzg4QnZjN05XU2s2blZLcDZHQkpoRVlRc09RVWZoYzdBOURTYTBEK3QwOHN2YldDVDBjMTVmaG55Z2tFcEZoWVhBTU9MZHdCWVh6V2JiK29INlBjN0JlRTJ1dGcwSUZ5NEV4M1RpdXpRZStWUE8rT2FMZEkyNFVkSVFhWUlpTUVvMXhveEhSMEgyTFNHaCt2czl1ZkxINXUwQml4czFIZEVUa1FtTkpiaTR5RVVoOW9WdmFyZVV2RHlFSXRaY2IvYXdUaENTV1JIeTRDQmNXWnVtOHNXcG9Sa3JZWXBiemdWQlJJTTFSZTlmeEd0ME9rRFNvZWN3MkNxMjBFeERkc2FCbVJIYWtPQzh6THNRZHM0TEcyR1pjV0lqTW1xV0F1UEg1aUt6d1I0M2htVU81K1ZMVjQ4YWhvTUNESW9wSkppSVVNRERxL25HdGc2QlFxOGkrRU1XdEFyRVdGcnZuQ3QxeThTQzliNEl1Z0dZL2pzQ0E2Q3RqcjdFTlJHQ3JmY0o3ZExaZy9NdmIyOHQxWnd5R3VXS1J0S2hkK3lHVzZOWnlZRldMZmxlMklhWU9ESkZtN3hlMW5sTnVpTXh1NHhuazJVUHI5ckNmWDd4Ym9sNTRiS0p0QkVKVVJYUkcxekc2clFQbHNxMWQ1WTlPdThQWHlKTEdyWnNQdHg2elpCNWsyK2J0QldwN21QZUI2NU9kbnFLamJUQzlxenVQMWFpS21pdTZnTUNXUkx0bk5tVGFacEtOV1VGM2RPR0o1YWhEdkF1YS96bXB6YitTemdFRlRTaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0VUUWtFVENwb1FDcG9RQ3BvUUNwcVFnSUp1dWRWeVE3L3JSbTJUT0tWTnU0YVdiM1p2YnI3ZStnaEd6d1JlR0JLZnRHblgwSEpkOTdvTFY4cjFYOGtEZVdGSWZKTGMrczh2b2VYdTVjZFB0ejRtblRxWUY0YkVKNmxEOUl1aDVaM2QzMXIrN3ArYm02NWZWTW5wU3ZVZnpvdEQ0Z3RvMXRBdU5HeG8rWVB1ZFJldm5QeDA0KzYzOUplWmhVb2w5ZWRGSXZFQnRKclorait1b1dGb3VjZGRDUWxYRHV3cTdUMTZZa0dmakt6K2Q2cTBieWgxNjZaU1RYVzhZQ1MySS9QZ0NmcnRYdzlYZlBCZnovLzJYZVB0NXoyTzdGN1o4czd2TmpiczJMeXZ2bWo4eUY1YTFIME1rNTFrV0pCdVBReHgzMUNxNVd0ajNSWmVSSEw3UUdxdVYxS3JYODRjcFZTLzF2K21XbmJrNUo5Zi9wZmxmN3oxOWExZHhwK1g4WDg1OUJlUHpmalJPT05sMUZOTEYweWFNZXZ1ZjB6cWs1akZxMGhpbGNaclRUWGIvdmZ6My8vUGY2MzkzUGp6bUxHVWFOMmJCTjNOZU1IOFhhUDZwQ1QxWExSay91UlJZL01tOVV2dk96d2hvZmVBYnQwUnJnbTVQYlRjYXZtNnVmbjZ4Ym9MVjA0ZU8xaStaL1hyNjNaZnEyKzgyU2JtZzJJaGZJSVdER0YvbzAzWXFieU1KSWE1Mmlia0wvMmN5ZCtuMnVvV2ZZbERqUVgveUd3QTJwT0s0ejdJN2VVV25JYXhYRFNXU21NNTAvYVpILzh2d0FDODFiNUhaZkt2dXdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZ1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwib3B0aW9uLWxpc3RcXFwiIHYtc2hvdz1cXFwiaXNPcHRpb25TaG93XFxcIiB0cmFuc2l0aW9uPVxcXCJleHBhbmRcXFwiIHYtYmluZDpzdHlsZT1cXFwib3B0aW9uU3R5bGVcXFwiPjxkaXYgY2xhc3M9XFxcInBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImlubmVyLXBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm9wdGlvbi1pdGVtXFxcIiB2LWh0bWw9XFxcIm5cXFwiIHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj48ZGl2IGNsYXNzPVxcXCJub3RpY2VcXFwiPjx0YWJsZT48dHI+PHRkPjxzcGFuIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwibm90aWNlLnRpdGxlXFxcIj48L3NwYW4+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PGRpdiBjbGFzcz1cXFwib3B0aW9uXFxcIiBAdG91Y2hlbmQ9XFxcInRyaWdnZXJPcHRpb25cXFwiPjwvZGl2PjxvcHRpb25zLWRpYWxvZyB2LWJpbmQ6Z2FtZS1kYXRhPVxcXCJnYW1lRGF0YVxcXCIgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiPjwvb3B0aW9ucy1kaWFsb2c+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxCZXRBbmRCb251cy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTcxMzhjMThlL0JldEFuZEJvbnVzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmZvcnplbiB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDgwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5iYWxhbmNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJvbnVzLWJhciB7XFxuICAgIGhlaWdodDogMjAlO1xcbn1cXG5cXG5kaXYuaXRlbS1iYWNrIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyBkaXYge1xcbiAgICAvKmhlaWdodDogMzAlOyovXFxufVxcblxcbmRpdi5ib251cy1pdGVtIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5iZXQtbnVtIHtcXG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuZGl2LmJldCxcXG5kaXYuYm9udXMge1xcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duIHtcXG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1udW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1iYWNrIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5jb3VudC1kb3duLXNob3cge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgaGVpZ2h0OiA5MiU7XFxuICAgIHdpZHRoOiA5MiU7XFxuICAgIG1hcmdpbjogNCU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MTdmNTY4YmZcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyR0E7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxnQkFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxrQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTs7SUFFQSx1QkFBQTtJQUNBLGdCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLGdCQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0EsbUJBQUE7SUFDQSxlQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxXQUFBO0lBQ0EsV0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJCZXRBbmRCb251cy52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLSDlsZXnpLrnlKjmiLfnmoTkuIvms6jph5Hpop0g5Lul5Y+KIOWllumHkemHkeminSDlvZPnhLbov5jmnInlgJLorqHml7ZcXG4gICAgZGl2LmJvbnVzLWJhclxcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYmV0XFxuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5mb3J6ZW5cXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvd1xcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJldC1udW0odi1iaW5kOnN0eWxlPVxcXCJiZXROdW1cXFwiLHYtaHRtbD1cXFwibG9ja21vbmV5XFxcIilcXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmNvdW50LWRvd25cXG4gICAgICAgICAgICBkaXYuY291bnQtZG93bi1iYWNrXFxuICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLXNob3dcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLW51bSh2LWJpbmQ6c3R5bGU9XFxcIntmb250U2l6ZTo0MCp6b29tUmF0ZS54KydweCd9XFxcIix2LWh0bWw9XFxcImNvdW50RG93biB8IHRpbWVcXFwiKVxcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYm9udXNcXG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmJhbGFuY2VcXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvdyhAdG91Y2hlbmQ9XFxcInNob3dNZXNzYWdlXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuLi9qcy9yZXF1ZXN0LWxpc3QnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICd1c2VyQmV0JywgJ2NvdW50RG93bicsICdjb3VudE51bScsICdiZXRzJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgdGhpcy5nZXRDb3VudCh0aGlzLmNvdW50KHRoaXMuY291bnREb3duKSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBiZXROdW0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMyAqIDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XFxuICAgICAgICBnZXRDb3VudChmbikge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldENvdW50KCkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoYXQuY291bnREb3duID0gcmVzLmRhdGEuY291bnREb3duXFxuICAgICAgICAgICAgICAgIHRoYXQuY291bnROdW0gPSByZXMuZGF0YS5jb3VudE51bVxcbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJCZXQuaWRudW0gPSByZXMuZGF0YS5pZG51bSArIDEgLy/lvIDlpZbmnJ/mlbBcXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnZXJyb3InKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZm4gPyBmbigpIDogbnVsbFxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDkubDlrprnprvmiYtcXG4gICAgICAgIGNyZWF0ZVVzZXJCZXRzKCkge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5kYXRhLmVycm1zZyAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdzaG93VGlwJywgcmVzLmRhdGEuZXJybXNnKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcXG4gICAgICAgICAgICAgICAgdGhhdC5nZXRDb3VudCh0aGF0LmNvdW50KVxcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnY2FuY2VsYmV0JylcXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuY291bnROdW1cXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvdW50KCkge1xcbiAgICAgICAgICAgIC8vIOi3neemu+W8gOWlluaXtumXtDMw56eS5pe2IOS5sOWumuemu+aJi1xcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA9PT0gMzAgJiYgdGhpcy5iZXRzICYmIHRoaXMuYmV0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyDlgJLorqHml7bkuI3mmK/mlbDlrZfml7bkuI3ov5vooYzlgJLorqHml7ZcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dUaXAnLCAn5YCS6K6h5pe26K+75Y+W6ZSZ6K+vLOivt+WIt+aWsOmhtemdoicpXFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvdW50RG93bilcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93bi0tXFxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvdW50RG93biA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8g5YCS6K6h5pe25bCP5LqOMCDml7Yg6I635Y+W6I635aWW57uT5p6cXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdldEJvbnVzTnVtKClcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIDEwMDApXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbmltZyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5mb3J6ZW4ge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmJhbGFuY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S9meminS5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJvbnVzLWJhciB7XFxuICAgIGhlaWdodDogMjAlO1xcbn1cXG5cXG5kaXYuaXRlbS1iYWNrIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyBkaXYge1xcbiAgICAvKmhlaWdodDogMzAlOyovXFxufVxcblxcbmRpdi5ib251cy1pdGVtIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5iZXQtbnVtIHtcXG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuZGl2LmJldCxcXG5kaXYuYm9udXMge1xcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duIHtcXG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1udW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1iYWNrIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1zaG93IHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGhlaWdodDogOTIlO1xcbiAgICB3aWR0aDogOTIlO1xcbiAgICBtYXJnaW46IDQlO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU5JQUFBQnpDQVlBQUFEdDJWd0pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dSREE0TkRRMlJUTkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1JEQTRORFEyUmpOR016UXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tVMlFrTkVOMFpDTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1UyUWtORU4wWkRNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtqcVRnSUFBQUdMSkpSRUZVZU5yc1hRbHdIRmVaL25wNmJzMk1wSm5SWmNtU0R6bDJJdG54Q2ZoS25NUW1KRTY0S3NGQVFZQWlxYzFpb0xZcXl3YVdLbXByZDFtU2JMR3dMTEFzeDRaa2dYVVNTRWhDc292dEhJNFBKZmhjUjBxd0xWK3lKVm0zNXREYzNiM3Y5UndhaldaNnhySmtaelQvNTNydTF2VHI2NzMzdmYvNy8vZTZXMUIrZnhOeXdNalNSeE5wTFV0ekVyOFJDS1VDUDBzWFdUckswbk1zUGM5U0pEMkQ4TmtCZGFtSGt2VUFIMlBwTVphYXFTd0pKUXdiUzBzUzZWTXNkYkwwTUV2UFptYlVaZnd0eW9wS29HZUpSQVRDSkhCTy9DN0JFVEY5Z3g1cEppa200Ukc5aUwrbThpSVFja01uNEd1TUt3TGp5dGNtV2FSZ1JObEdKQ0lRQ2dQbkN1ZE1pa2pjSHIzMmJ0UnNOQWovd3RjcFVhSlVXR0tjK2Q2cjN5ZzNwNElOeSticVA2M2pVVGxGbTRXOVlTZjJlMXJRNFcvQ1lOU0JtQ0pTMTBTWVBWWkdrT0EyZU5CaTY4TDY4ZzdVbVlhMUpSNVExMW92Zm9hdC9seUEvWHJSOHgvTzUrMW1ZV3V1SFRoaGZ0dS9FZnU4TjBJUURSRDFPZ2c2cmdvRktuM0NMSUlDUlpZaHhXUW9VaFRySEcvajN1bzNZQkJpT2Zmd2haU1h5LzlpK01ONnRtNHk2ckZTaTBRLzd2NElPbU1MWVhHWVlEU2JZVEFab05QcjR6UVNpRXlFMmNBaFJSVmtjaXlHYURpS1NDaUVONE9yTU5CZGllMzF2MWV0VlRZdzdxeGdDek1ua3NVZ0N1NWN4Ly9kd0UwNHF5eUN2Y0lHczgwS2c1R1JTQlNoMHdsRUlzS3NJNU1zczJTVkVJMVlFUElIY003WGpHY0hiOElucWw3THVndmpUbFdTU0VZbTBnelovS1BlaUF0L0NxK0JyY0lCcThNR1BTT1JRT1FoekZhd3RxMFRlZEpCTk9paFowbW5GL0hXeUJwc0RCOUhuWEVvbTUra2p4c21kV0FwZTVTaGJXd1p6QTQ3ck9VMjFSS1JCU0tVRHFjRTFZV3hDbVdRSlVubHdzZU5yK2JLTG1wR0RFNHJpMVU1cHljU0VVclVRdkcyenpuQXVhQ1ZVeCtQVmVTSVNPaHJZU1U1UnloMXk4UTR3TG1nTlRxa1R6cFoyYUF6bXFEallXNUZLYXFidjNUaEVnYjc0bU1BOHhZMXdsWnV5N25kWGVORTdkemFhVGx2KzZGM2NMN3pvcnJlMU55QTF0VTNaTTMzMG82ZHFmVzF0NjJCczZweVN1ZUxoQ1BZOWR6cmw3V1AxblhsQTcvdTlxUG4xZlhXRlUzWStza1BadDJXQzF2dlhUL2xjMTlMY0E1d0xtanhRSzk1QUwwK0hwMHJNbkNTdlBUTS9rVGxJVlY1cDlvN0VRNUZjT1JBQjNxN1IxTU5vcWs1OThDYnlXekVvdGI4ODNmOUhqLzI3andNcnllVUlrZ1Nqejc4czl6a3kyaDhuL3Z5M1FVVGU5L090cnlOTjl2NUxxZnp5RVVRL2x2NzBaK2xDREtid1RuQXVZQzhGaW1YV1V2b3hHTERuS2E2MUhwLzcwQnEvV1Q3bVVtTkl0NGdjamRHVHJSQ2lIVDhZSHVLUkJ1M0xKMnlsU21Fc0g2dlgrMHNEdTQ3bWZwOTRlSmFXS3ltblB0MW5lbExYZDl6LzdVTEd6KzRhbHF0Y2UzY3Fxem5Tcjh1M2lrVnE2K1Vqd1dhMHE1WUF3eThFVHZLeldwbG5uaTdDN2ZlUGZOU2N1K3V0OVYxZnQ3VkcxZk8yTG5PbmVwS1dkdDBzcWZMckZ6WCtNUVBYMVRYZWJra2ovSHdvdzhVZkc1dUxiTlpmWTVWNjFka3RXSWJ0cXlaTnJKZWF6Sk5XZHFwTkN6U09FUGp3aHEwSHptdk5wcmh3UkdWWEdzM3I0R2x6SlRxeWJubFdMQmtudVp4akdaVDNqSTRmT0I0YW4zamgxYmhaRWZudUhWc3JNUERqMDFzckkvK3pialUrOXhYN3I2OGhwYnhCSm1qd293dEg5K1U5eHByRzJ2eDhmdHV3Yk5QdnBaRmR1VEdkVXNYcU5abTl3dUgxUHVzZERtd2Jzc0hWTDl6YTJMdXM3dmFpY1A3aitMU3hiajE3enJiTnk0L2R4MVV5MXk5aG9ZcXJOcXdva2lKVklCRlVqRDcwTFNvUVNVU3h4OStzeHQzZlhxelNxYmhBVzhxRHllUnpXRlRwVktTTkpjcnlYaFBuenhQWFgyRjJxaWUrTGNYVTQzOGl3OXRtOWI3bXRmY3lNam5WQU1OM04rcll5UTBtZ3FUVEZ5aWJ2OW1iZXArQzRHZEVjWTc2b3ZMWUhhZi9CNUhocndUcFRUckxEaUprdVdRanRNbkxzMmFOalhscUYweHowbmxEVG9KSGxpSWhNS3FmNUdzV043SXVTVm9QL3dPWG5vcUxsRmFWK2FYU0ZwdzFaUmozODZENDlicDlsVXBzdVVNalBSUERIUTQyWFZyRVlOYmdoOTkrNytucFl5MmJsdWYxeG9tTzRYMHNrd0dhc1psM1RLVUJLWXM3ZmlPU25IYUsyNVoxbXk0RHNGQU9HNXRXT004ZDNLOHgxemMyaGkvTjFrcHVMRHlSc1RTZW1STzFPdGFGbUtZRVNXek1VNklpajAxMGQ5UnBWNUR6ZFVwSkxudyt1WDNzKzMrcldxNUh0ajlWc29uNUdXY2ZyMjhNOXJ5MFp1WjVSOUoxY1AzdnZYa3RKVHZlNVZFK1lsVXhPREV1Zlh1aVc5SU92Ym0yNm4xaTJmN1dTUGVoYUUrejRSb0UvOXRnbTlSNzU2U3J0KzRaV1hCa3V1eUxjbTk2M0p1TzMrNmV3S2h0Zks2YTExNXovWHdvL2Vyd3dZbk84Nmk3ZFZEQ1BwRE9IMHk3Z010dks0R0d6NzRnVW43Y0JJbE93L2VNWlFDdEtYZExIdmtLR21kY2trVTcyZ29xODdYS29QYXVUVjQrTEg3VlovbEY5OTlXajJHNnNzc2JsTDNNNXFOYWk5ZGNBZkFROFI1eXR4ZGw1c0FYbyt2NEx6Y1B5eWtmaGN0YmNaQTN4RDI3aHp2aU9vYUt2RGh6OTZldmJNUU5NcXVXTnVUZ01ucXBSU2tuUnBOMjNjc0ZVbGF1bnJKMU82bHdESTR0T2RJaWtRYk43ZkNacmVxKy9IbHF2VkxDejVkY2o5TnYrVUhMeFo4UEsyOFcrOVppOVkxMmpNTlh0b1J0OUJkeklKUDhKVXVqdUtGWC8xUkhTTmFlOXZxOFd2T0xLL005ZGtzN1pUWnlTTzg5VVlIZkttWkJxdlZ0RExETVQ3ejUzUFl0N3M5TGxVVzEyRDlsalVUdHZOQnhIeGxNT1lidzk3RU1UaVd2YjgxdGM5US93aWUvT0VmQ3I3bSs3NTgxOVh6a1Fwd1dkcVBkazM0dTNWRlkrcTMweWZpRWkrelRIUHhxTmhkcEpLTTJ2SEduU1FSUjZVN0h0WWVHUnhCMnl1SDFQV2FoaXFVVjloVGVYanY2aHYxNDFUSG1SVDVrdnRwWWMvTEJ5Wklubk1uemlka21rbDlJSEs2d2NtV0MwT1hodkRTYjl0eWRnenBzSmZiTHZ0Y25PUTMzOG5MMWo4aHNGTVNLTVdvSFc5UTZiMW84ajU4STc1VWoxcmhjc0Njb2ZGNW1EeTV2V2xoUFNwZEZacm40Y1JNNzdXNTVFazJaSDdlbGV1V1RwSlRrK1JUSW4raFpiNS8xOEdVTlhqZ29ZOU5KSHZhdnJ4anFLMnZuckR2WTkvNHo5UTYzN2ZNWnRVODE1SDl4L1A3VURmTVIwbVlwRklNTm5Ebk9JbWFlbmZxUG54cGc1SGxsZlpKKzdscXhzZWZRb3hVK2U2ZkQ0cGVEbHBXWDY5TnBBS1V3THhGOVNraTdmajUvNkJwUVp3c2kxcm1UN1l5UXR4WDdPc2VuQkJzVWExMEFaWWtVOXBsUTFOei9jUk9MRzFzaksrckhWbEdQWlJXc0tHSXdSdE9FbFZwWWQ2K252SGZYZFhPQ1pXdWRZeGM0TExtdnUzWlg4QmtzaGdSRGthbS9kNFdMR25DSzM4NEV1OFltSHhOV2RDTUJwMStINW1FNExMdmNySDEzclZxbWFtK0paT3YrOUw4d2p1M2JXWXBMcWwvOU8ybnhqdUpaOXF3L1p2YlVHWXZtOVdxVDN1S1VCRkx1L1NHNDZxdVROMUg5N254NkpQVFhZR2h2cUVNSDZBNnJUZjE1TDEvbzhrd1laOU1YTHJRZDNuU3BvQXk1M0x6azEvY3pLenU4QVN5Ry9tVHpGbWtsR29KTXJEMjFwV1hYYmN1MW1razczVkN1YVZkODU2WDI5SjhNTE5LOUxkZVA0SmI3OXBROVA1UnlRVWJYbjc2bFFtVm1ld05mL2ZMbDlIYkhSK0FyYXN2eDVoL0RKNFJYODdqOEx5SDkvOGZWcTIvTVdlZWpzUHZNbW4yWm01bi9VdDM1cnkycVFaUnpwMk1keEptczVINWNYUEcvYnR3UkxVVTZSMEJ2NzdNZkJ3OTV5K3BxV1hWOVlYN25Xbld1NjkzYUZJNWhKak1UWFpndDkyMVVqMHZMNXREKzAraHBzNkZPVTIxQlFWdlpsK3dvVWlSYm8wV3Q4NU5yU2Y5Q283NmVkVm9lL1ZJVmg4Z1BjUmJpTHliNnJYbGtvcGE0RkZGTGVKbWRnVDU4bDRPa1hJZGkvdGxPMzZ4ZTBMbnRaUWRsdzh1SDJsN04zVWR2Rnp2L01SdHMxZmFhWXdrb1JqbmhyZXVpSk9uWm80YlMyNXNUdDNEMW52SHA3TXNhbG1JM2MrL2tlRTB6MUh6cnIxbFJXSWRpWkg3M0dYQWd4UHB4NTNVeUNyS05MZFBrb3BtZytiNVRHeDc4djZtcVpzdHFDeTFBZzJOL1BIMXRIeXRxeGFuN3VQbU85YWcvZkNKUkgyNFVMelBHbWh6Z2IreWVHNzRKOWFzM2VSM3hPL0RraWM4U2lDVUFvTCtBTDRoL1ZYMnp1M0JRS08yUlNyMnFRMEV3clQ2Ui9sOEpPSUtnWEJGS2xqVElzbFVkQVJDUVV6U3RFaGpZVVlsbzh4ZkZBNjlUcUNQdUJCSTJXa1JTVXZaU1d5akZJc2ZSYy9mR003ZlBLa1hTQTRTeUI0Vkt1MHlndzB4aVNXV054VGozOUFVMUozNWtpd1ZnWUlOV2xUVGVCMVhURmFnZnNlTUxSbVhWT25ITFphTzNoTk9tSTA4RXBTcEJ4c0toU3IvMkg5aGlmTk9VYTJVU05hS1VPUXlMc2JhdEpSWUJpTks0dFBsVTdGSVV4aEg0cm1qektlS3FtYUxXNmlFdFdKTGtac3VDZ1Zxb2tMc3czWE9UdFE1aCtGMmVHRzN4eDlPOVBuTUdQU1dvMmU0QXFlR0YyRlVxcUhDbWs3bzRzYUFod080MnByMHhJU2lGQkpzbUxuSUFiK2dDTHRBOVdFQ2RwWGNVbkZDY1U2SlBCSklRUXNWVHQxRnJKL2JoaHNXRC9HUGtTWitIV01wL2d5UnlXNkNlMDRRUzlDSFd3UHQ2RGpweFA2dWRSaFJHcWp3cGlUVkdIRlk0MHlxS2FrZ0l6SGxBZG5wbjJ2SEw1aGZlTG9ieGkyV2FybjRad2RMa0ZoMS92L0ZmZmY4bWJIRm9SSkg4bCtBdjhzRE9jQk1laXlhcUNrOWRGWURiSFBMSWRxcjBMTGNoNWJGeitCWHp5MUJkOW1IaUJuNU9uUWhRUmhPSEVYUmVrWXZOeGRtMmtlNlVpMGFUZHhWT0VHd3BOWFNKWmV6bUZ6VnZZL2p2Z2Y1VTd0bGlQbk9ZL2hZRjJTL3pLeDFHWXcyQjBSai9GRjRLUnhCWk1pSGdYTVhvTE4zdzdtOEVYcDdBejd6NlZONC9DZTk2Sy83QXJFbGd6UXlDcmMyaGJkV1RTSnA2TEpyTU5kT3RWcXh4SGxqS1FtclNrRmRRaExPaGxmdXVicWZ3QmUyZTFRUytVOTN3SE5zQUJaWEV5cHZiSWJnZGt3dWUwR0FNdWpGeU1sTzlPM3FSUGx5RDJ3TFd2Q0ZCNzM0eFk4ZXgyRDk1MHN1SUtDU0plSFRxTXVaOUZIRWZENVNFVXhNNVFVa0orMXh3bkp4LzBxWElGZXhFU3phOVJidS95cC9Qc29GMzRtajhCejJvV2JkN1RBMDFRQ0JJQkNVNHA4U2lVbXFOaGNNZXJVUWhISW5uRGZmaE9qNWZ2VHQzdzBsZWd6MnhTdnh4ZTBEK01jZi9BbUd4dmZOZXNLb2lmMm5YT1dLVnFiNllKL3lIcC9Bd0s5UFRvK21wUGxlS3Jrd1RqSmRZb3FURHRmK3MwK0tMT09ySDNxQnJTMUU4QUt6UkVkR1ViZnB3eENyeXdIdjJMZ2wwc1VROVl1UW93cE1MdjRpRmd0aklDT1lOd0JEUXpYcWJ0bUtuajB2UUcvdGdHVnVDNzV5eC9QNDk0NDFSZmZOWC9VVjdFbkNwSk1GR3I2TWNQWGJtaGEwSHpXWGkvY3hpbVJGWkswREpZMVlRcHhZRTRnMncyUXpkTytFNDJOdUtNRmVqQnp0aGF0bEk4UXFPNDl4eDFzVFA3ZW9oK1NMUVJGOTZtY1hZeDREOUM0MUJCclB3UEtLMVE2NFc5YXpZK3lGdWNxSjhrVnVHSGIrRWJINjI5OVRKRWxhbENSUmt0OHVTUDB0RkVtRDBwWGdXNFR5OVM1UzZoVzdrNjFaa216cEJPUHJ5WWtlUXZJM0plMzN5MmdNZDdUeUYxUld3Tk4rQmdheEJwYm11VkM4M25obDhjOHNxaWNPSWhaZ0Z0WG1oMmdLSXpMV0FIMllXU3ZCekN5YUZHK2hIcSs2ci85Q0RUeHZuMFhGbWhXNG8rVWdYaHk5ZmNhSm9TNFRpa1dSbFZSOFYxRW1FaVl2U1diSmlMMWV5eUJsL2V4SkNUbXlpcExtbHhXQUpLR1NIN0FXTW41WGZhUFJYdHl3S1FTRWhoRVppc0pXMHdnd2dnaHlsSjFNZ2hTUjJVSkJiSXoxNFNZVFRKVjhIQ25JZktRZ3hycEZHQjFlOEEvTjZ3d2lCRDN6ZmlOQUdUdUdmL0FZTytZUWJsZ1J4ZFBQWElUSldaOHozcFRxUTRRMGNpUitURmZLeVdXS0ZOTWI2Q3F5QnFGb2lqUHQ4SGRTNnhBS0p4OFNmbHVPQmlYNlR6QmpaRVM0Y3doQ3pBU3owdzRsSEVLd24vMXRZSVd0eEJpWm9oRE5UaGl0ZmZBY1BnVkZFdUJvTmtDeFZDSGlHVmJyUlcrMk1Jc1ZnWVZKT292VEFWK1BBZUdMUXpBMXV5RDdPK0YzMUUzZmpSWHhKMUNudFF5dTZBbFptYVllVENjczhLaTFFaG9OUVk2SjBJbk1rNU5qQ0krTUlEQjRIblBXTmFyU0VRWS9SbzVkaE8rc0gzbyswMEhxUk1WUzVrT1ZNYklaOWVnN2VJTDVkMDVZM1JVc3Y4eldHWkU4SWZDdnRacmdRNERxYldaNnloelFUZXhMTXhOaDJyVjBsUGxDWTBPc2Z6S29NK1dWU0FpUzM0ZUtwaHFZclhiMDdIa1hraStnanA5RlIyTnd6S3VBdGQ0Qk9jeWtCWk43Q3JOVy9XMG5vWVFFdUJZMVFBNEZJRWRENnJFa21mV0xFUjg3aDU4S2VrWTF4MlNlek5vM3JiNVhJY1dZdGJsMEZqcXZoVWs0R3hSR0FvVTVQVnltdVZwYk1IeGNSbS9iS2RSdldneTkxWURBUUFDeFVKVEpOeXVUZmdMNjNqek5WSUlEdGF0V3NOOURhdDNwSkJsU05BcDlnQkd3cDRlZFl6blYyMHo0U0VJK0gwbnJUYXYwSE1TMFlneE9JQkJUTFpOTzBTSFN3NGhoWlNUUm14Rm0xcVdpMW83WUtNdDNvZ2Rtb3c1QlpvRU1qRUFXcThMOHFsNG8vakNjaXlvUUdSMVNyUmxpWWNpQk1XYWhmREFFbUd4a0JpOGdWRkM5ellTUHBPUWUxTkpUQ1YxZEJLek5VQWFZcjJUUlljd2JRM0JnQklZeVQxeGxDNHhZaXNRc2p3SFNhQUFHbXg2dWFsRU5MNHRTR0pIQkdFUzlIb0dlYnVpTkEycVVqMCtvaW80cEVFUUZKaXZMTzZnZ2FKNFBNeFgxMVpYc1doYUpoMFFWY2xxbkZhYXFCVGg4MG83Vnl3WUJrWCt0d2dTOVNZTEU1QmtQa1VkakV2TjV3ckRZalBCMEIrRVBSTlY2c0pvTmNMcE5pRERuS1JMa1k0TUNaRm1HS0FLaGlBNmlMY0lPRjhLaFkyNllxaGRTdlUyM3NwTzE0Z2I1TEJKSnV4bkJpOTJic1hycGIyRFFCUkZnWkFvT2hhRXZVeWMwSWNaOEhja1hSVzkvQkdGR0lJZmJBcDBvd0R2SThub2owT3NGaUE0RlJsR25FaW5pa2FHWXJleFlJVDdnZ3hkN3R2Q3hYc0tNU0xzOEZpbjNaRHdLTnN5SW45VDRFWnh0Zndyekcvd0lSYzBJaGN3d2pvNUFielZCQ3NYZzhVUmh0b3R3VlZvZ3gxZ1ZSR1U0cTh6d2VjUHdEMGRSeHNnVVkrU0tqVEc1WjZ5RWtWbWlTcE1QNXpyTUdHdjZDSXhVWnpNVGJOQW9WeHB1dlFZd2x0bnhyMmNlVUxzNWEzU1F5VElGSVowZG9TR3ZPaW0xd21XRTFhUkh5TU9uQm9VUURZUVJHQTNEcEJOUVdjV2tJS3ZRNEtCWDNVZTB5YkJFQjlWamZmLzBBekJhYlZUQTd6VWZpU3pTek1HNjdHNDhzdk1vdm43YjY0Z045a0F1cTBOVXJBWkdoeUg0eHFBekdLRE9CVXBwYTRYNVJqTHpuNWpQWkxSQUtLK0dhRkZnRHZTaXZFckNJMy9jQk92NzdxYjZta0dMTlBYdkk1R1BOS1B3dnY5YmVHUlhERjlmdnhjRy93VU1vUXFDeThVZkZWYkhpQkNOUUluRjFEb1FSRlpWQmtZZ214bUNrVWZ5Z2lnUERjREJETkFqT3pmQXUvWmJWS0RYMEVmU3hmdTY3UDhJVjRGTWEvOGVEKzI1Ri80eEhlYUpBekNPZFVNV0dJRXNCdWhjRlJEY0xqWHhkZjZid3JZWkE5MXFYaC9iNTZFOTk3QmovQU1WNU5Vd1NobzhtZmJYY1JFdUg2WU5mNG0vYTErTzFaMi94T2FHVHRTVURhaFZFbzRDTVNIK2ZMTmVrV0JLUER2VkZ4RHcweE9MY05qK2ViZzNyS1U2dW1yU0xwK1BSTmJubXNQZHVoYm5zQmFQdHUrSCsrd0JMQkE2VUdQc2g4TVlmNHVRTjJ4R1g3UWFaNVFXREZXdWczUHRlcmlwMks2NlRjb1RiTkRha1VoMk5lRnFYY2RLZkIwNnZLTTRNam9JSlJ6L1dMVGd0TU5VN29LNXZKSlBNcUo2dVJZa3VwS3ZVUkN1RGN5T0NqVVJpc0VlNVpzaUpOTVVJUUloeVFYUWdDeUJNTFBJLzZnNWpTTVJDRmY0cURtRnZ3bUVOQzdrc1VnMCtFb2dGTUNsSzdKSUZHd2dFSzV3UUpaZXgwVWdUSU9QUkNBUTByWGRGSDBrbWFRZGdaRGtncGFQUk1LTlFKZ0cwRnc3QXFGUVhVZXp2d21FbVhXU05DMFNqY2NTQ09OY21IcXdnWmhFSUtTNFFNRUdBbUdHb1Ixc29FbXJCTUk0RjZZY2JDQnBSeUFVNUNTUnRDTVFwa3ZhS1dSMUNJUUNqTkpVWHhCSjBvNUFTSk4yK1h3a0NqWVFDTnE0b21BRGdVQklOMHNrN1FpRWF5ZnRDQVJDSVFhSjN0bEFJQlRPSXhwSEloQm1GSG1mUjZJeEpnSWhRUktLMmhFSU0rc2thVW83RVJLVkhZSEFZRVM0QUdtWEF4WFNBUHhLR1pVaW9lVGhrSVkwdDhjL2ZabjQ5SGxtV2lpL1F5VklJRERNbC8rY2t5ZDVwZDF5cVEyS0ZLTlNKSlMyWjhRNHNJSnhJYSswaThrSTZuV3daRzZzUmk5dWpPekJjZXR0VkpxRWtnWG5BT2RDTnNnS1lpbUxGSXhnTkRVZEtDTnREajZGeGtnSGxTYWhKTkVZZVZmbFFDNStxTnhKV0NSbGNFeDMzbTZTNnJJZGlFZnU3dkg5QUs5WnQrR1llUk1VbWc1T0tBRUlyS1V2QzcrQlc4ZDJhRWF2Ky8yNjA1eERuRWl4SXozNkEvT2QwZ2R5WlJhWjlkb2MrRFdXaDEvRGNkTk5PR3RveGFoWUJSa2lsVGhoMXNDZ2hGRXVENkVwK2c0ajBWNjRwZTY4KzNEdXNJVWt3SDY5eTEwbXJ6NjRmV1NIemFqUTEzOEpoQUl4RmhGRzMvL2p5ay8xK1hVSFJaaXFoRUJVc05TVXlZWlZjNkpycUhnSWhNTHd4Qkh6NHkrOGEzcURyZlp4SXNsY3ZiMXkyamoydnJteG1xWkthVDRWRVlHZ2pUMW5qYTgrK0h2SHI5bnFHWlpHZFAzZkhPQ2UxQWhMRno3enRPT0pBMTJHZlZSTUJFSnV0SFVaOWpPdVBNazVrK0NPSkg1dHN4WC92TGVNeDhLamtpem9kaHczZCtsRmpDNnBpczIxR0dDbFlpTVE0aGdKQ2tNL1BXaDk1a3ZQTzU1alhEbVZzRVplbGhTaC94R1htcW42MjlVOGd1ZG1xWm1sK1hhVDRuNW80OWlhVGZNanJmVU9xWUg5N2RBSkZLWWpsQTVrQlpJdkxIaTd2ZUxGMTg4YTI3Kzd0K3dnKzN1UWJUckxVaWRMZkYwZGtCWDZ2K05LN1ZqOVQ5VUd0dUNSdTRaRTRodTVWVEp4UHdyMFRpRkNhWUZQcE9PdUQ1LzZIV0NKejF5OW1FaWovWC9iSDJXY1VUUHk4SGZtem55MkE1OHVWTWxTRlV0T2xtemdNOGxCRm9sUVV1QWtpckRrWjJtWXBZR0VUeFRrQmlzOVk3YkhLSGlHTVpaQ2laM01hU1FpaTBRb1JZc1VTZkFobFBoN0V2NWZnQUVBVk1XM3pOdGNiUzRBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lhrvnu5MucG5nXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU5JQUFBQnpDQVlBQUFEdDJWd0pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEZOa0pEUkRkR09UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRk5rSkRSRGRHUVROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tVMlFrTkVOMFkzTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1UyUWtORU4wWTRNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCs4Tnd2N3dBQUZEMUpSRUZVZU5yc1hYbVVGTWQ1LzZxNzU5cmQyWjA5V0VDd0xEZENMQUlXZUFLaEUxQ1VpQ2ZaMHJPTTdBQitMNGx6MmZrcnNVbU0vM1dpK0NWUjhsN2lISmFkQ0ZsNkJzdVdkYUJuQ1NUWjNBSUpCRUlDeExGYzRsaGdkNWxsajVucDdrcDlOVDA5UGJNelBjMHd5N0k3MzI5ZjBYZjFVRlcvL243ZlY5WFZHdi8xQTVBSGZwRytiS1hGSXQxaDdTTVF5Z1hYUlRvbjBuNlJYaFhwTlpIaXpoUFk2c3R5cVFIUG1jR1RJdjFRcEtsVWxvUXlScFZJZDFycGF5SWRGMm10U0wvS1BsSEoybFpOTGduMEt5SVJnVEFBeUlsZldoeFJuUWMwY0pnazNZQm5OUlgraHNxTFFNZ1BoY0YzQkZlWTRNcDNCbGlrdmpoZlNTUWlFTHdCdVlLY3NZbUU5dWo5dzRtZzM4ZitCZGNwVWFMa0xRbk9QUGZlMzlVRTdXREQzVTNhMXhXTXluRjNGbDdpOWJEYnVCdU9tSk9oQXlKZ1pNcEVBbUZZUXhVdHVoNDZZWWJTQm92VWd6Q2FYWFdYZUFCalc4YXBxOFRxOHd6Q005VnIvMTMzV2pqSVZ1UzdBQW56bXJFVWRocXRBRXdCeHBpa0pDNEloSkVDam9ZRW16YXVjQk1XS1IvRGw3UjN3UWQ2M211NisvbGJOWC9XOFlRbTFnTitEVnJkU1BTOC9qUWNoOG1nS0VnZWkwZ21jb3FsWXhYRUtzS3daWTlGSUpOTE00TkU0cHpCQnpBZkx1dDE4S2ZhUm1tdGNrRndaNTVZQkpGSUlaL0tHdkxkNXpWOUdaeEFFb21NRlVXVmR4UlVTcElJeVNNWFJDTENjT1lTdHlNRytHZEt1YVdBYVJyUXhpYkI2OFl5ZUZKOUorZTFnanVqVWtUeUN4TDZjdmxIRjNrRDdPSHpRV0dxSUpFaWlZUkxNQVdaVkVXU2lxWG9UQ0FNWHlwWnpWK1F5REJCVmNYU05HWHJOb1hFKzhDY0Q0dlpQaGpEcnVUeWs3U2tZWklkUzdtakRIdjVYR0NxVDV5c2lNdzFZTndpazVyMms0aEVoSkZDSmludmhGVkM4akJ1Z0tJcFlCZzZJS1dRQzQrenpYbmpGSm9iRXo2SGFVa1NhVWdtVlpCSmxjSU9yVkpTempHaUVXR2swQ2hwbVlUTVk4SWFTUklKYVFlcWFPRkdRbklCSUMrUm1KYk9aQ0M2V0wyMFJFZ2lUVmdpSms2WEVnOHNFamw5SS9LVENNTTUySkR5bFpnZ2txb2twWjNRYmJxSjlvWkRsMUh2Mmp1a1pXZVd5VkpoaVlRL3BQclFFZ21MbExSSGtqUU1XSm84M0lXTlpZVE9LNTJ3NjkyOU4zemR0Rm1UWVZyTGpROXR2SGoySXF6Lzl6ZnM3VFhmZmh6R05JM0plU3dmdnZ1UDN5enpXbU8ySm1PUUREYW9hSlhFRWlQV0dBcmdDVVBJTzE5ZW5xU0psQWVwQUFQanllQUNCaDB3L0oyMFJrU2U3RWI5Nm91YklYcXQvNGF2UGJUdk5LeDRPZzRObyt1Z3Fyb0txbXFxWE8velFoNkNPSW56RFVFcWo4Mkk0T3pDNFV4YUpVVko4b1liUXVZSmw0WUxDNFZkUGtVUkNWTEJCV2JKdVpSZlJDUXEyTENuekJnRG9ZcUE2N1ZYMjYvQmhTKzY1UHFtWCt5UXl4VlBMNEdXQlhmZDlPL3lCd1BRTXE5WnJ2ZjF4dURFMFl0eXZib21DQk1tajZhS3l4ZHZrQjJ5eWJhT1hUNWNNSXB6RlF6RGNMM1VWZHJKRGxpQTlFaUdaSGlkU0ZRQVQ2MSsySk5VaThmaThQcExiOXVOL0VaeC95T3pZZktNaWZiMjlzMTc3YnpxUnRYQ2ltZCt6eWI3aWFOSnNpT0pVdnNKK2NtRTFrZTZUT2pHY0RuaVcrd3JVdHJaUGhDekFnc0tJejJRaFRvaHg3N3hWNDluV0FKc3hONnNoaCtlV1BVb2RMUjMyUHRRMnJtVkw4cStGU3VYd0pHUFQ4RHh6ODVDNTlVb3pGOXl0L1NONXR3ekUrNmNPMFdlMStIdzEvcDZZdmIxWjlvdXdhWU42YzdGeGNzV2V2NjlaUVhGaWdNQXkrU0NHNUc0RzQ4NDhjYVZEQUUvZkhINkFsdzhkN2trK1hteEZnMk5kWEQ1MGtjUTdlcTNwU0hBUWZ2NG1QR2pJTjRmazc1WE52QWE1MzRrSWFHQUQ1bVNmTVZLdXdFVTRtU05jdnBKZ2tTNUdtMXhSSEkvZnVyNEdXRlJkZ3dJVm1SalhQTllxcGhTQkNDY1hDZzJhcGNVaVU2aWtYT1VDOU5uVFlMbUtlUHlIdC8waTUwWmZrMTFKT3hlNW01dzZIVE02OTdsOTBESDVVN1k4UHdtYVcya1hGdTZRUHBmS2FEMFJNdUorM0I1WGxoUTUyOHFlTSt5SkJLM21qdjNWRVlhbGRqTm8xQmd3ZGxvSjk4NVVVaXY0cU5tR05HYlBuc3FiSDludC9TUE5tM1lER2RPWHJKSjlOVHFoNlRQYy9IY3BZenJkcjMzb2JSY0xhM05ycVFuRkFkM2FjY2NDYkxXQ1Vtbi9qSTY5Ujk2UG4vN08zc2dWQm5NZTN6eHNnVUZuWDhNVXN4ZFBCczIvRGh0aGFRc2ZQcGVtRFo3NmtCVnpnbzRBVlNuaFIwbEJvV2xIUzhrTTdqekJWdUNFL21jK253NGNmU1M2L0g1UzJhN1Z0aXhReWZnODBNblpkK1FrMFNJYlp2M3dlbmo1MlN3WWR6RXNWa3loUTljejdWTnlDcVhkTGtWRGpia09TV0RSNHpLT3hjd1hMM2lLNHZkcGQwcnUrejErNWEzUUkyTGo0VDV1WlZ6ckU4UWQvOFplenRjRTRUR01UV1NvRElpWngyN3d4RnNjTXVQZU9UQmh0akxRc0VHS3NpaVVSbXVoRm1Pa1Fob01kQkt5VVl1Q0ROaGFsTUdrZEJIQ3RkVXdhbWpweTJaRmhBKzFoVFA5NXM0b3huV2ZMdmVRYVFxK1J1Y1BsRkFTTDlZZjV3cXArVHN1cGxnQTgrZU80WGdoaTF2N0ladWE3emRrMy80NE1ESHZkajIrVFRZdW5tL2ZkNjN2amRha3NFTHpwKzZBTWMrYXl0NFh1dTlzNEZNMHMyYUpPNjVmTFNDQlozdHNKSmo2dXEvZERzR3JUWlBhOHBaWGhnc21MTndLbXpmY2todUh6bDRET2JmTjllYlR4YVBaMGc3TDBUQ3NQZnBrKzF5SFpmTlU4ZEJ5N3dKU2VzVjhsT2RlclZDUlFjYkNEZUVzMjNuTTN3aEpFdyt6Snc3elNiU25tMmZlU2FTRTFObWpJWWx5eGZZMit2L1k1TzlQcVpwTkh6MzJUK1M2enUzN0xFSmpzdHJuZDN3Mk1ybFZHR2xVM2J1d1laY2tRdENIa3NoZkpJUGR4eXp0OGMzajhsZFhsYVoxdFpISkJFd1NJQ04rOWdueDczNVNvNDhjWFQ1bVBHTnJ1ZGRQSHZKSml3R0p2QmV1RDF6emxTb2JhQXhkcTdsekJ3YzRKeUNEWU9OdHphK0sxK0pTQWNBZ2pMSWdQdmRjT2ZzU1hZNGZNdWJlNFR2Y3dvV0wyMzEzTUF4Qkk1RVNjazNKM0QvMWZZT09QSkptLzJibnZtVDM0YzNmLzQrWFBqaUdyejM1aTVZc215KzdMTnlzNXlFVWdVYkNBV1I3YlBNYUduS3VWODI2RWo2cGIxcHM0UUZlbVczTGJudy9OYkZMWjd2aXlROGNmU3RuSklQU2JUSnlodnh3Q056SlVFWFBUUUhYbjFwcTMzdG1yOThUTXBBd3MzQlBkaVFIYkdqUWFzNTBUS3Z5VjZQMUZYRGd2dm55dkp5N3BmQkIrSGtWNFlyN0VlYlArZ1RWbUk1bkd1N0FGMGQwYVR6TC9hNVBmclFlbVRuNjBRd0ZJQjVpMmJCbGZaTyt6ejhUVW5aeU1WeU1peTQ5enowOThVODNhKzhwWjJ6N2J0SDczREs0cWJZZjFYa0RBUDlJUEJQb0drK1VKa3FKMEhCK2V5WVFrd2lsQUdQNUt5clhFN0haWEFEZEQwQjYySzVQOVlTK1BQZUNZV0REWmloQ2pTOGdWQ2VWZ2xoVXJDQlFMaVZ3WWJjWnhpQ2hWcjJDSEFDb1J6QVlPRGJEOFZhcE82WURuR3VRa2hUSUtqaGRGdzRBcFlZUlNnUDh5Ty9TbUdtVTBHTDVLYnNESkZCdjI1Q3dqVEJoN1B0S3dyNE5FWnlrRURLenF1MHM1MHNLK2tHRjhReUJiSHdHNXBNWG94THNsR0VrUmxvNEprY0tEcllvR1RwUlVndmRYRUQzU0liempPdUtZSllDczVpUkxRcUJ0VzkzWERYbWFNd29mMHNORnpyZ0lwWUh4akMrbmVIcWlCYVdRMW5Hc2ZENGFicGNFMnNFMjZSaitUb056VTRMejdZNEJYQ1VJRWgvb2taeWZtVDBVcXBaSzA4RStqQmc5dGg1dGxqd0xLNkZsVFRnUHJ1VHBrbVhUd05EM3l5VTVCcEd2enU3dnNnV2hHbXdodEVvQ0ZDWXhFVGJrMS93b0NFbkdtMTBPaHZ0OW00UEE3YWMrckloTTRoSWMxV2NrNUphYTNFVWxXWjYveko1WWFwNTAvQzQzdmVCcitlOFBhUUZIVncxNW5QeFhWdDhKdldwWEI0d2d3cXhGSkJTUm9EM1NJUXhnYncyMzNveXFTKzZNY0gyeUlWWW5aYy9FQTVwRkw4U3JSVVNDamtsS29rcDRNdFI4dy85akVzTzdodGdCV1N4YlJnQWNSV3JzU2FoY0RQZmdiYW9VTVp4NUY0VHdnQ1Z2YjN3SWZUVzRrRXhiaEFMQmxJUzZrcDR5YkREZTQra3ZNdHdSSzlJWXMvR0grNDAraWh4WktXUzhXSnkwZCtKYzRRdnRDeUExdHp5MTdoRjhWV3JRSWVTRTdBSDF1OUdyUzFhM1BtczFSSXd1NWdCUndseTFUNGdjNHN3dkNrdjJOeUw2VGhXVy9LRHFGRjhpUUZyZjlWekNKWXltb3BxZVVJSWxlNEp3cVBmZlIrWHQrUlJ5STJpZVIyZFRYd1lCQllmMzlPNVkxNW5hOGZDOTBVaEJoQUdoTnV4Tm9NdGtVeXJWR3dxZVV0Z0xSYXVuVXYzWmF3VWdvcWxpUlVZUGdOdGtDdC9jQ0I3ZUEzRWpkMm9Vc2tGUE42OE1BMmVHUFJINVRkMStXeGhVaXltRWtMSTVlbHE2eDBNajFhSkQ0TWVsZXhnTXlVUGJZc2wvemNoa1d1NFVDd2NIY1h6RHAvc3VUNTNuVytEWDRyOHI1ZVhWc1doSkVKZ3dIc1Z2K09JdWYrNXBaVGxscmVqZzZqNlh4U09Id3ZTUzVJazB4UmtxRjRCWWJtYzdkb2phYWZQaUs3QjBvTnpCUHovbWoyb21GcGxlUkRQMFVZSjFuQXhaZGhnMDllWjlzdlZHdUZYK3diQW1sWEVndG1WVVRPT3VBT1lsa2ZJc3dnMmlDUXpUUU1tTkIrTG5PbnFvSlpXenZBUnhwUURmWDF3TE44SktXelUwYjFVc0M4OTRwdC9QTDg3VWFTbEVWSkVjVldTekEwbHFWNGFWZnMxeWhHcXJabVZrKzEwejgwK0FDeU9RbkdtR013Y0dvZmQrd3YwQmowUkFKRzk2VG5kZEJiV3lHMlprMUdZQ0VmZXRldEcvZ3dpTVVnc0g0OWFQdjJ5VzNNRys4eDJFUktFVU11VTA5c2s2ZmZvK2FaaENsSWtoSGkxbWtwMlZHUWxhbFVKdjVzcWxHWXBuY3JuQ0tVWXIxRjdCeFYxZHNYZ3lvOVBVRko3S3RmOVVTaXZMOVBYSXQ5VFNraVlkNkpXQng4L2tEQmVKUDlER0hPYXVZWlJIRmVZNU9pdElHdTIxOXZRbWJiNTBWYnBGeGZvcUF4UCs3a0E4dHZ5MEovUXM5c1UwWUpncklaZVhDSXhoSmdoZ1poNkVnNTFydXoyOVRELzcrd2o1VDlGUU1pVW5IMVlwalFyV2hRWnlTdFV2RGxsNkVmcFYxMWNmMC9MQnFGNEVzdjJkdFJ4U2Z2QVNhOTMxSlNpNVN0ek1oSEducWMwWUkya2RSUFA0WEt0V3VCVjFSazFsOXRMZlIrLy9zWit5clJSOG9LTnJEZTNnRjVFNGFMajBSdjg5MlVPdm8wVUFOelkxRlhRa0F3QnlINitvQ0o1QWJNbTdtcEM4SWcra2pNbzQrVTQzMGt3bzFCMFZUWVV6TWF2aDQ5Vy9JaXhPckZ2UEVlVkQrRDVCOFdLRmVGU3VvV21YNmZENjVWUldDYnIvUmo0akRQYUxoVzNvTXdoTkl1bnh4STlnOWdoeGtIdTZlQW5uaEZBU2ZZREZaVXdvdlZUYkR3Nm1FSTNjaW9NQmU1MWllZWhaaG5JRlFoNzhFcDJGQWlaV2UxL1l6SlQvSkxPeVVsRFhLbEFkS09VdEZKVVJVSVZWWkFiNlFlL2pVd09xKzN5YnE2WkdlcnZSMk41aHo1bmFvM3pBdnp4THp4SGxUV2c1Znk4Z1M4aHI4cDJGQVMrQU1CQ0VjaXNQZjZXUGpQcTNINEMvM3FRQU52bWhCNCtXV0lQZlZVOHNXK2pSdnprdWgvdEhyWUd4a0xqU0pQZjZwemw0SU5neFpzb1BEM2JTUHZWS2lzcm9aSVF3TzhyZXR3OFpvR2Y2dGZob29zbWFmdDJTTlRmam5INERtdEFYWlhqNFVHa1JmbWVidU5zU01maVN6UzRGb2xudzlxNnVya0lOWURva3kvMlIyQVA5YXZ3TU84dDZEN2lhWC9QcXVBbndnU2RZZHJvRzdVS0ptWFB4VmtJR3QwbTFva0NuK1hIRXo0TWNHS0VOUTJqZ0pWVTZIcmlnOStHQTNBOC9FK2VOaThEdk40UDB6a0NZaFlWcXBMdUxHbm1BLzJzeUJzVmFyZ3NqOEVGZUd3dEVRMTlYVVFESVdBS1JSOEhid0tBKzlEaERnOXlXNXQzU2hJcGdvcHgvekJJRVE3T3FHbk93cS83cStDVi9TRWNJMU00S1pwbjZzSzhxbWFUNXdiZ1Bwd05ZUnJJMUxPK2YxK0l0RXRqdVFWWjVHeXg5bVJ0Q3ZwZ3c2Sm9FWWkwcXIwOWRTSTFBT3h2bjdRRTNFcC9SQ0tJSnZtODBNZ0ZJUlFSYVdNemlINXBFL0U2RE03dDBUYWVaRE5Rejc1U1htemlRbExvMEZJa0NJZ3lGRWxySXl1NjVKRXFmNGdmUGRKa2ttY2grZmFCQ0lNQmJzS0JSdnlISlVmR2NzVk5TZVUyanhoSDVCZkRZQ3dQVGRWb1lSU2tzYVJ6QkV5K1FtQk1QVFVLdElpcFY4anBpRkNoUElMTEdRTUVTb2dCTWhISWhBRzNVZWlmaVFDK2EvcFZMU1BaSDBpbmNMZmhETFVkcEF4c3NIa3hmdElCQUxCazdMejBDRnJab1VCU2RvUnlza2ltWTRKSXFIWVlFTytkek1JaEhLd1BqeTczWk8wSXhBR1g5cmxkYUxLZUtaVkFrbTdBYk1Ja1VVaUVHNUpzSUVYRUlvMDFvNVFyazZTdC9aUEw3TVFDQ1dBSjJuSE9iMzJRaWcvRnluMVJaTFNCUnVBUmpZUUtOaEF3UVlDWVVpRERkbmZSbkx1SXhES0FhbkJxcDQ2WkFzNVJ6Um9sVURTN3VhRERRUUNBZWhWY3dLaE5Ed2lhVWNnM0FwcDUzSDBOd1ViQ09VWWJMRGZrS1dSRFFUQ29JS2tIWUZRS21sSGMzOFRDRjY0UmRLT1FCaFVFSkVJaEpMNVNQayt4b3dEOVJ5SmZDUkNPY2s0K2Vkcy95VHRDSVFobEhZcUdGUkNCSUtBSDJMRlM3dGE0d3Awc1hISmR6Rk1Eb3lSdENPVWpiWkx5em1SSWtaSFlXbVg3KzMwcWNhUnpMTnBWQU9oWEpEVjFpY2J4MXhuY1hDVmR2T05EOFNaSk84STVXNmRETUdGM1lXbG5XNUNuNlpBS1B0Z28zbFJaTEFUOXFzUENZWmEvRk1ZQmU4SUk5OGE0VFRGTENudmtBUEloVndRcCttMlJlcUxRMWZPeVNCRmVyVHZsekJSUDJ5RkE1TWZIaU9KUnhqSkpFcDlXQXpiZkxOK1JISWdIejhrZHl5THhLLzBLS2ZEQVdOc3Jud3hjdmRNejQ5Z1MrZ3I4SEVBTFpNcUxCMlRId2tteTBRWWNTUXlVbVBzREpnYjJ3cVA5TDNpR3IxdXY2NmN3QXVRU1BxKzg5ck9TWFhHb253blkwYVA5bTJBMXZoV09PQy9IOXA4TFhBTlJvSEo2SU4vaEpFVFdQQVovVkJ0WG9YbXhHY3dKNzRkUmhubkMxNkszQkVMWVZyQ00rc2JLczBGZTcvVjhmTXFQNDlRcVJJSTN0QVRaMTMzL0tqdWE1ZXVLM3RWQ0l4aXZRa1dhcXcwZmExMzZBdXBlQWdFYi9pL2ZhSC9mZjF3WUt0WXZZVEJCdXl5dmJMdW5hcTNmOWZtZjQrS2gwQW9ET1NLNE14dmtEc2k5U3Z0Nnk2ako5VXAwdGxWRzZ0ZjJIbkd0NTJLaVVESWoxMW5mRHNFVjlZalp5enVHS2tPMlY3Y0dkUFppUysvR1BucGN6c3FYdWpzWTFlcHlBaUVOSkFULzdhejRvVXZ2Umo1aWVES2NZdEl2VEplMGY1c3ZUeXA4UWVOR0lKckVHbXFTSlBDQWQ3dzEvZjNMSHhvVXJ4bFhMVXhYbXhYS3d4VUtrNUN1Y0RrWUhUSFdQU0xxSHJ1dDIzK1EvKzhyWEt2MkVZcDF5YlNjVXZXNlVraS9VTzlmV0hqM3pmNnhBSWpkK090aEFjclJBb0FTQkpSVnl5aG5JQWRPNFlWUjBETGd5cnRuSlc2MnIvWG5oQ2NrU2RpK0R2N1lwUjdPRnlvVnFSUkl0V0pWQVU0a2h6SUloSEtDa2lpdUVqWFJlb1E2YkxsRS9XaHdYS2VtR3NXSVR5aEJ5TVIxa1ZCQjRuSUloSEswU0xGTFQ3MFc5c0Q4UDhDREFEc0VJZjdyYUJ6MUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKSUFBQUNWQ0FZQUFBQ3pmcU0yQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG93UkRBNE5EUTNNak5HTXpReE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dSREE0TkRRM016TkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQkVNRGcwTkRjd00wWXpOREV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pCRU1EZzBORGN4TTBZek5ERXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZ09ObUd3QUFNdnhKUkVGVWVOcnNmV3UwSlVkMTNxN3U4N3FQdWZNZVBaQjRDZ3dSd1E5aHgyQXJHSU5aZ0g0UUxJVEJ5OWl4MXpKUkV1SmdJRjdKU213VDR6ZzRUZ1RCNExEQUM4Y21nQVFJSXdnUjVpVWtZYkF0OFJCSWFQUit6RWgzWnU3TW5mczY5NTVuNzlUdXJqNm5xMnJ2Nmo3MzNwRm1SbXF0VXArNXAwK2ZQclcvL3ZhMzk2NnFWbmpORmZBRTNQYm85anpkbmw1b0IzVGJXMmcxMDNhWXo2enFOakR0UktFZDArM0JRcnRUdDhVbldvZlduZ0MvY2I5dUx6THR4M1Q3eDdvOVpSUG4yZUdjTTdROW90c1BkUHVlYnQ4eWJlRkpJSjFaMjZ4dUw5UHRsYnE5eEREUFk3MDl4YlJYRnY1R1RIV2pibC9VN2F1NnJaMU5uYTdPRXRkR3J1cTF1djJTQVUvak5ML2VuZ0hWTmJwOTFyaklKNEgwT0cwRWx0Zm85dXU2dlZ5MytobjZPL3E2ZlVXM3Y5RHRjN3AxbjNSdGo4MzJUTjMrbFc1dk1nTDVUTi9vQm5pVmFTVGNQNnJibitsMi94T0trYTVibm4xTUx2UTFPOWRlckhlL2JWeFlmSllIQ0VQZC9scTM5K2orL2VZcDd0Y25CaVBwSDNxcDNyM0xhSjl0MlZDM0RZeGdMWWxoUTJOeUEyUG9RQVI5L2JlK29yMkNSTzh4amZXVjZTaE1YMFdZUUYwaDFOTjlBaTFJWUVvTllVcmJmamJTZS8wM3RmVkxwQnZsZGRUMDd5Y3Q5YnNhVURjLzZkbzJCNkIvWWdEMEMxczlGNEhtWkZLREphekRpbTdycWdaSkZJR0tGRVMwVjdRbjh5djlXb05GNzJPRGhxYktYaUNpMlJOZElBejBma1B2bHhKTTMwdVNKTjFId3dTbWNRQnpxZzg3ZGRzVERWSndiV0dqRytnbTNSK2tvLzZUQnRUZlB3bWthZ0E2VCsvK1NMZGZTeTI3aVkxWTVNU3dCc2V4QVl1cUNWME5uRGlPVStERWNRVE5GRVJSQ3A0NEI1VEs5dlNWR2FpTTczZUFSRnVTWU1wcnFQZUpaaWJhRHpXUTZPK285MzNkam1sQUhVMy9Qb1JtTW9BOTJJVjlxZ2Q3NDBIS2JwdllLS0I0bWU2ZnY5TDcvNkFCTmY4a2tIZ0EwYlc4bmU0Nmt3dWFVRlFvYmJ3NkhNVldDaDZObUJROHhEalR0VGdGVUJ4bit5aktXOFpJQkNLaUlnSk45bEpaSUJxNXhCRXJZY3BNQkNCNllZTXBhOE1odFdHMkh3emhlRElGUi9XLzlSOVNVSjJqT25BZzdtc2ZOaEdvbExuQkx0Zjk5WWQ2L3o4MG9BWlBBbWtNb2hmcTNZY2h5enhQdEMxcm5YTTRhZWx3WjByL21qckVOYzA0R2pDMW1tYWhHdTBOb0RTQWFsR2NNVkdzREFzUmVLTFVQUFFhY2dDTjZjZ1JWempTV1BtL2t4UlI5REpKWDZjc1JjeEVBRXB5TUExaG9NRkVnQm9NQnJBeWJNREp3UXdjSFBSMTJMa0JGMFFkMkJrTkovblpkS085VzdjMzZMNzdUUTJtVzUvUVFOS2RRS0h2SCtqMmprbXVoUXg1UkJ2aklaeUdkdHlFV3JNR0RRSk52UWIxQW9CcWNTMEZVRlNMUnN4REFFb2RXTHBYS1dveTVyRkI0N0tSeTByMjM1SU1UTWJkcFk3UHVMMlVvVFNva2tFR3FyNEdFZ0dLOW9OK0hZNFBtbkJFdjU0WmRPRnBhaDNPalh1VCtITzY4YjZsKy9HLzYvM3ZhVUQxbjNCQTBqLytPWHIzTWQxZVdQVXpKRmtQRDFzcGdBYTFaZ3FjR2QxU0FORStCVkE5YzJNcGVESmRsSXBwcFVZYUtBUVV5NGs0OE1MOGN3NldsQnBuSXpBYXYwbDZLV1dwRVZNTm9aRzZPbXFERkV6OVBnR0s5ZzA0MkorQ2V3MmdMb2dwanF4c3czOXY5Tk92YUREZC9ZUUJrdjdCbEV6OFg3ck5WR1VnQXRDRE9BUERSak1GemJSdWpVYmRBS2htWEZrR0h0SStPWUJTMThVQlJ4VkJVbzBEVlBCd0hMdkQvQ1VKZkV0WGFmZEtnS29UcUdvWnFQckVUdjBVVUwxZVAyV3ArL3Y2WnVsMTRlbXFuUUtxSWtQOXBHN2YwWDM3THpXWVBucFdBOG00c3F0MGUwdlZ6eHhQNm5BMzdvQmV2WldDcGtYZ01RQ3ExK3VwRzB0YklaelB3bmpYVlUwR21rM2tkc2YvVjJOdzBYVVFsckxyaVZMR2l0UElMd1BWc0o1QVRVZVlEUTJvWmtPRHFhOUJwUUhWMDcvdnZuNFREdlU3OEJ5MUN2dWlTbDZMYnN5LzB2MU1vSHI3WStucWFvOGhpUGFiYk8zUFZNMzkzRG1jaGVYYWpBYU9acUJtSTJNZ2FqWGF4eWFrejZLdlhPY1VBYVJVRmVBb2dLMWdETVYvRk55bzVSelRWOFNjNUxzb3dVbS9BMnVhbmZUdnJHbEdHbWhBMVh1OWxLRjYzUmgrMEd2Q3prRWJuaGV2VmMxSi9SdmRma0wzK1M5cU1CMDdhNENrZjlDUDZOMFhkSHRXRmJzOHJOM1lBOUVjeEZNTm1HNW9BS1VnSWdacWpBQVVtVEIrTXZBb1VmK0k0Q3BEa0xJL2h4Nm0wSG8vdjlUVUEyS21yNVRDTkYwUm1SVEZzSjRGRG8xNkg3cWFkWHZkSHJSN01meDlyd1hQR0s3QVU2dTVPN3BodjZuNy9qSU5wcnZPZUNDWkVnY05sZGhUaFlWdVQrYWdYWitHcGdZUHRVWXpZNkdHY1dPVEEwZ0p3Tm1xaTFPQnYrTG9iUnkvRUVCbHMxVGFIRURWOWI3ZXJVRlg2OEFIOVA1WWZ4MHVqbFpndXB5ZG5tWEE5TTlPZFltbGRvcEJSQU83cnRWdHV1ellSNU1tM0tOMmFoWnF3a3d6WXlFQ0VvRm9MS1FkQUtVWXFRb2VWVms5VDhCSC9sK1ErOVlNV0R5b3hpeVZ2bzAyb0dnZkU1QnE5VkZhbzZ2ZDNTM2RCanc3V1liem85SlJKM1FEZjFIYjRuSU5waStlY1VEU0YwNVYrcXVoWkpBWjNWTjNKanRnb2JZalk2RldVKy9ydW1YaGZjcENUZ1JXQmlBUlBNb1J4VnR3YlVyUVEyQmxCOUFDbGdjcWg2WHl2RllSVUtxdU1vWWFBWXI2UkxPVFpxeTdOVHVkSEt6Qzg2TFZzbFFCM2NqWGFadThRWVBwcjg4WUlCa1FmYkxzL0IzdHlyNlBPNkhUbUlIcHFlYlluV2xkVk5PYUtJL0VpaXprdXpDWGZYandxTzBXMmU2SGtBT1pLZ0NMQVpWQ2xxVXlRT1V1ajl4Y2xublAzWHBlNnFHYmJMRVR3YTBhVUM5UXk5QUt1enE2b1QrbGJYUEZxUUJUZEFwQTlFckRSRUVRcldBTmJvVzkwSi9hQWRNelV6QTkzWUlwM1ZwVE9zeHZaa2xGbFZibUk4TkdiZ1phbWZwWWZoTXJXMFhudGJNUmlOVG9NNFVQRllDMitmOEFuUE9OeWkzRkt6TTNnMUtXU3gyZFlmeS9nc3RUWXpZMkFDSlgzOVEzM2JqUHB0SSt2RVgzSmZWcHlVYVpoNnVOalU1ZklPa0wvRG1qaVlMdWJDRnB3UGVpZlJCTno2UWRNVDJqTzJScUNsb3RjbWQ1WVRVMkhjK1ZNSW91akFFUUM1NFFhQndBVE5UR2NKSEI1WVBLQlJRVXI4UDVyY3BrNVhNMm9od2FNVGYxM1F3QlNyZFk5eVgxS2ZWdHlVWUhYS3R0OVpMVDByWHBDN3RJN3o1VEpxeFRVVjNibTk1VkJKeFdLM05wcEllSXV1MXNOSlFBeU00MktqNXQ3VHMyVlNYNFYwR3BqY0ozaldJMVIzU2pLcmc3ek4yZi9uOStDR0lCVE9ocEtNdmRFYURNRFJibFEyRDA2NDUrL2NPTmZmQ2N3UWs0THl6Q3lVYWZNV08rN2oxdGdHU1NqZGZydGp0MDNLRmtDdTZ2NzhrQU5KVzFWQStScUk0alJ3dTV4bGUraVBiMGorczIyTlEyRDdDSmRKSnpiblFoNW9BTGNmUUpORUN4QVVWQVU1YU9VcFlvWnlJOHlPcUpPVE9PU2tMNnY3czcrMkRZUDVHT0tpaUo1c2htTklSNTRYRUhrZ1pSdytTSkxpb0QwUU9OUGRxRnRWSUFVVlNXTVZGc1JpbEtFUm5EUWdFQUtZYXBQUE9yelNRZ3kzUTMydCtCQldBVjgxMDR6aHVoQjZpY29RaFFhaVRjVVRuc2xMdkZOSThaVy9wUm1UcmovUnQ3QVh1TGNHRzBFYnJ5aTR6dFhnclpGS25IbFpIZVoxQXR1ek5zRlVEVTBpRitJd1ZTbmhzS3VUS3ZScVltQXhBUEhpWkJvTFlBSmdNT0t5R2dDc0RpUUZWa0tRbFFJM2RuMkFrVjYrcElUOWEwSlZVckR6NnlNeitnU1NmV3pIUytDaklUMmU1UGRmc1hqeWVRZnEzc0FoYXdBZmZWOTZZZ29xaU04a1NwTzZ2bFF6d0VFQ2tWWUtHS0FGSUNjS3FVVWFvaFNOQm9HYU9ndzFnNXFLb0NhdXp1Y25lUGpLc2JnMG5WVktxbGk3TGdQaDNOMWZzTHNGOEZDZWZObEFIWDdTOGZEeURSZUtJUGhBNVkxdUhvd2RvK0xheHpKdEx1VElNb0RvS0ljMlVjQ3ltV1RUZ0FLWkZ4VkVCN3F3cDViV1huSGFGUThpaGVCaGJ5UlNvTXFKR0dRaVd5ayszcXhtQWlFWjR5azdLdjlDRHVnOGJnR094VXdWRzVaRXRhbzJCVDQ1azJHLzZUTHZvNEJNWVRVYkx4aC9GZWFCaE5sQXZyellPb0dHNnJNVGhHYktERzJxRVlhaGVPR2YwOXp6R3A0dnR1S3hORnlrb3ZGTStubEhPZVVVNnJtSktBa1RpR3dtOVJWb2E3bUJaUXRyTjIrbTMwM1lWOFU2NUh5UVprQzdKSllDTmJmZ3cyT2QxOXMwQjZwMjZYeUdVUEJYZEVlMEJOVFk5Qy9ISjNwZ3FwRlZYSUNRbXViRUlBK1VsTnh0Q2JiQzVRK2UrYkFGQ2V0aXZlT0ZENGpUS1lxSzlUTUxWYWFmK1RMY2dtSldYZUZ4cmJQaVpBSWdEOVR1aUF1M0FIZEZ1em96QS9ZNktvRkVSVzV6cDZhSlRvYzFoSUJwRE5Qa0hnY0N3RFFnS1NPUzcvWGdsWTNqVklnUExZU1ZtL1VYRy9PY1JNdXMrcFNwQXlrN1lGMmVRdW5DdXo3KytFU0dLN05CSWQvK2NRbURJOVQ5T0JXcnZTMnRtSWlad1FYd2FSRy80ekhjem9JSmY2dytLZHkwVko5YmlKU215RklVcGo3WVBGWktNUjNZaktsbnU1aHVMMFU2NmRWQzY2aS84ZUMrNXhSR2NMY05KTVNHQXlzMXNXazEwdzMrbkJlWElrRnhzYjB5akx3YWxpSkpwM0prNFpvcW5QbEhCTVJYVXJHMHVVWnF3M0F5SlZCcUpDTVZmNWQyUnhrTDkvOXhmWnFGaFNBWm1KV0daeXlpTVdJL2xzNWJwWmx5RkZkdkowRTNNekNjeVVnYWtHalZaZGU0ZHNkQVhaaUd3VjJIN00yUHFVdUxiekladThLTVl4QitQZFVFOXJabGtGUHgxVEhVZENhVUl4MVE5SkovZ2dVbGIyMjNVZklMdVRvaDV4UU9PREsvQmZFVFFldUFSUXNZQnlycm1NaVVWbWx2dVhiRUJnb3R3ZDJZWnNSTFlxbVpwSnRyN3dWQUNKcGxHTE0yQVB3elIwbXJObVZHTWpIZEVZeFRrTFJXeEpRbFZ4WDZxb2ZRcDNuNUpZamJtN21laG9QSEpBT2ZxclNnSFhMUkRuNEhJK0p3VURESXZhMXcvT3RWZGphTStidzdndnlCWlpzVGVyS0pDdERvZkxvdmtrekcwRkV2bkxYdzI1dE1NTjQ5SlNFRFhTU1luaWRLQXFkMTZoVXUvZTFheUlkVjJZR0Y0clg3Z1htTU91MzB1RFJvb1Zmb2ZWdVBNemdISURBNWRCUFRhdDR2WTh2VmdNQXFJTVREcVNheEdZdEszSVppVXU3bzI2L2RSMkF1a1BROG1WZTZPZFVHdG1JeHZwUW1OV1hMdWlWam5xVlFJUmdEK3AwYjZMbFpOckNnR295RGJLR1N1a1JPWUJscW1VTStaSmdUdThKQVFvSmJoby92ZU9BYVQ4Z01UWmUyTWhDbnFKOG5qMWRBUnFQYlVaMmE0a3RIalhkZ0dKQnUrL1FucnpCRFJnclRXWHViTm1wb3ZHMDRQNHhCbWZiTFE3WnhJUWlSRWVBeURsc29HWGcvSjFrQkwwRTFqampteFdWRkFPcU0zL3ZqSW1VbnlpMXd3N3FSa1hSL1lpMjUwSTV5REo5djkwTzREMHJwREFmckMySjQzTzBrcCtMUnNPb2h6aHlZYk9BZmZtWm03WlRtYmRtaW9Ca0dKR0x6TEp4VURPaUdVazVRSkxNZC9wQThwakordDFDRXpWM0JvM0pvdThCQTFocnBuQmNXUTdzbUdKOFA2RHJRTHBweUd3VXRxOEZtdURaaloxaU1aWTErTHhYSHZQcFhuQWtUVVNLQ1dBcUtnWlpCREtBSUlDZU56a0piREFFaHR3dzM3SEFoNEMxNkFjby9OZzhDTTZLOUlzRmR5Y1hvTFJhTXZZNkNXeUhkbHdQaXk4WDJLd3NHa2d2UzFVQm5ta3ZpdHpaMmIyS3duc2FuNWJzUXpsalRMeVFDUXhtU3RJbFMzVWxSTnVNNEo5bE51Um1JaXRyemtaYlNiVjRBS0t2VDRtZ3czV0FEOS9zSjkzOHpuSjFUSTlHcG1VUU1OTVFDVmJsaXhhK0k3TkFva0dQVjB1c3BHYUJteE5tUm13MmJ3emY1aHNpVXNyYWduM3p2TGNtVi9BZGU5eU1WMEFmSTdKS3N1QW1yam01b0xPTHRvV3dPdWxJa0M0YnNVV2FuMDN4ekd4RWpMOVhvSi9aS2UwaE5Lb3BUWWtXNUpOQTl0cklUQjRNUVNrSzZYM3laL08xM2VtYy9GcldseW42eEJGa1N5d3kxeWFCeUxnTlJFNHIwdlNCY3JKMmZoMU44NWRRVFZHY3FJOTZieDJzYlk4bkxkY20rWG1tUEpQcUErNU1WeWU4TTRuRTJUcktwQk5NVXc2VjA0S3BFWW9iN1NncGdDYlUyWlZrTmh6YWNyTHJuSXV6ZFZGN284dUIxRXhPdkx5TkFwa0FESE1ZUXRvS0dFakorcHpzK2tLQW9CaThsekZtUytWd09TUGlnREZWUXg0T3lqSHhkRjZDbVJMc2luWk5yRDlxalRNaEFYU01FbHBUSHh3Q3lFM24wck5zeEgvbTVRdzJJd2I1YWk4V2JGMnhCSmlKem14Qng0enVCbHU0S1lTS1g5S0UwZ1piVkJ5TnJzSXJoSVc4aG5GZC9PY1h2TCt5am1KVWRjVldLbVc1UURKdG9GdHY4YkdMMVlHa2hiMS8xdzYwd3JVb2RPWU51c1R4YU15Q0lkMlNXRExMczExTFl3bWNGakVkM0ZGUUxsSlMwY29DeGxxdDVpcm1PS3NtQkczQnFUNVdvL1ZOUTZZclBjbjZSdXZUMlhoN2JGU1Bac3ZSN1pkRFR5TlE4SUdCNlM5K3ZwZUpwM29hRHhydEZGdHRMd011NHhlUUdETExzMis2L3pGSW16QTJIZXlyWVc4U00wQmtPZk9BT1RTaVFxVlFudzM1d0hLaWVEc0NGUXhMcHRMekFJN2JWMTJjZVhDT3o5bnlrcG1EVTZ5N1pGWVhsVFlZT05BS1pBTWRiR1FwQ1dJbHhwekprckxWc3dBUDRLWEIrOXdkNDdrMHBUVG1jWFBlMGs1TGx5VzJFQXh3MXFMcnF2aU5HM0ZsMXRZUUVIZzJwUTk5bHc1djdNNHBBMDh2U1M0T0c1a0FHTVBDMTlSbGc0ZzI1S05oM0lxZ0JhYXU3d0tJNzFlT3NPaWFvRnE1Qm5zT0Z0bTJKMlA3LzZrd014WWRuNWE0RTZ6eWdxY08rTnlMbzdBQmNWTm0xYXkyNUlZU1hIVHMxMUE4Y0tmejQwNXlWalhsVS9ZVnhEU1NtNTlVNW5GNjJ2WjJDV3k4UWx0YTdHaWdiNU9jb0UwcXozVnBXSmRqWmJoTTJ4VXkrZm04OWRlVFJ0WkgyYnVNdVc0TVllaHdpQlNqT3ZneXlqS0dmb0JBQ1dMUm9CZHp3dWNtMDArbG9CSnVTQlJ0b3VUMmJ1YVZtTHZhWlU5QlNGbnBjV2F2RTZzd2Npc0NLVGVFTW4vTlNXM3R0cmNZUlpBejVlYmdXMWtJOS92K3pOdW5UcGNFRVJjTkZNeUM4WEtmb084YUlUSFNNRFBBZ21WUWdRdytmVTBGeVNLWGY5cHE2eVV6OUxOQnNIRnFhMEQ3cTFwc01JRFNWUFdaZElubHhUTmpLMm5penhGVlVXMkVIdUcyTWdxSzRoM1krRjRyNlFTeUJpcmtuRkNpa3M2dWhPVTNPS3NQTzdKZnkyQnFWaFVkZXRwZ291cnlFb2dUQlNWUkRmWk5rNFg4NnFuTmcrNHQ4dEVJTVdSK2prUlNQRjB0Z3d4TGZDa29rb2lXOG9iaGRpSTd3elhwWUdkNytHV0EyVEdOTEg1SmlYUEJsRXFVTzJYeG9GRFdVMFFtRWpNbnczamlleEF2NFJZU1hKNmt2M1NZU1p4Tm02SmJDNXQ5ZGpHeWdnUngxYVRBN1ZJcnFXc05tWXR0MVpGWlBNanBhUklMY3hHdkVzTGlGWW9mbFoyTVhaR2VySVNpVjJjTFIrTndLVXdpcjliT2F4cnhSYWxyQVFCVmhLY0JDTzZMZmZXbUEzbGt5NWFXRXZPOFlEVXFxdExKZk4zSUlaQnZXa2l0YmlnajZxNU5aNWQvT2dqZk5jNVA1MVpmTXNPbzdraEt1N29SRC9STjFHSkJGUWc0YW1ZNk5KTm12cnBac1d0OVRSeC96REhWM0J2SXhkbm5peEZOdS9JTTg5VXM2WXU5WUNrUVNndXBMNFNOVk9FamhmQ1VoTzVOVjlrKzJ6RXZSOWlJMWNYZVhVNWJ5UW1rOU54SmhwNkV5bkZIcmRCNTVaZ3ZOeVZPREJOK2F3S2s3QlN0WDZFQ2R6YmFIVTR3MHBrKzBEMDltSVBTTnF0dlVENndGbzhOVjRrWFVsMTNnbmRtdURmZzNlYjZBS1owUVZPd1RNMDRwSmZtOUpuSUgvNENBQTNUMDBwcGxqcWFDcmxYSGZRWlltc05Lbk9ETGszKythTURTdVI3Y1hNWkFFektTcW0zM29rcWtYcVl1a0RHN1hXYUVYVlNFbjZxRHhhazM0dWw0ZG4yYWkwTTdud0dVUWpjOU9ZckF3NFNGTzAzUkdXQUtIaHNkNTRLc1c3SS9FbWtsZ3BlRk15N3dmdjlFSnljaFRCUmFudFpTQ3BpelYyNGhHUXZ2eGJlODdSbnpsWEdudlVyYmZTWkZWYTVZK3I2S05RYmxKNUkwaEFsYStrcHFDTWpSVGIyUXBLaHUweWJCR2Uyd1oraE1XT05uQytqeW5HK296SnNGSkp5WWwzYno3VGlSa2g3ajdPRno3VmpXeVBzbXM3OTNOWDdqNHdBdEw1TytOL0pIMVBSOVZBVWRvOGl0aEhWVlhTUnlXYVE3NGptWTR1cFhZK3M4c21BQ0U4eGpyQVIrd1ljTCttQm9HbkZLaHFybDNRaG5JZmxQVzNLbG5RZmd5bTFPYmE5b1FCYWJ0b2YrMzVJeUJOMWRVelJMZW02cVBudjRZdmIvUDZpRDFTUVJBa01odHgrU3JHelFqckRwU3VBZUFxSGVGOHlodEl4dVIzSkZZS2dVMlZyYnE3R1ozRXY4NmYrVXNZa0RhTm5ZdEdRR3JFOEV6cHdHNlVBYW40YVBQS2ZxM0N6d1RnS2kxS2NHdENoQ04yb0p0M3NhTTBFTVlHRmRmQTltcHNDcGo1YWZ6eVBFcjUycVRLRGFXODdEMnZtOFNVeTBRVzRTSzQ4YnJlMUFnRGNtSVNucDRDS1JYYXNYcTZkR0F2cXBtMW5GVkZWZ2tKN1VrWEFRMDlEMHY1MkdQQ1k4WE5RaEFuYVNvZVBDQ0JpbDlSalYyN2tnM0xGWU9KNmcvZjRlSjNWZWJpS2dqdS9MZEdaa0lsWVVBVTNMRjZLbUdJR0lsVTl6N3B3SDdjR0MrUU5lRlRHQlZiRzFSQ0NLb0NKd2k4cHhqbTRoS2dYTmxBUVdCRnVJRFlCbWxGTmZES1Fkemp2eFFIR2RHOU1TekU1YlFnM005QndTMUVlSG1tbXpBUTJQWm11anRiOVVRRTBwQWU5MlJBSkQ1UVdGV256YktqVklDQm9PeTlvRHJneG4rN29IYUx0MUlubDN5K3JFSmZLWFFLdjZlMktDcktNekRLUE1ZK1NqRVFTRXJ1R3dOSnlTdjJKMUcyVEdxazFLU09keE0vU2dHVUxqRWhwdEhLczc2Y3RKVHFiK0FNTFdFWDVPSW1LaW9tTnhQS09pdmhobElRV2lvaXZHanE5aGlLM0JwZDR6Q2drUXgyVWlDUlJ0b2hNbEpjY3hKdllYQlU4ZFNiSXErUXFGUVZIeXZxWmNCWnRXV1BjUFRxdUlvTjJvSFZhK1UvVG81UUorMlRTUTVUMVdTNVNkSW1jWWlSVXV4a1FGTENZTGFVa1ZRTVd3elVxdFA1UkNkWEF1dVhyS2RkWWpCL1BVcWg2bDhDOExJWVNnVTE0YmJkY1pNYml5bjVZY0MxYWZBMDA3U1RTUUdJTTI3SEQwczVoZHZFbW1nckhTMmRXM0ttWWpJaXdCNXFpOWNIRTJ1bVUyV1dDdDRvVHIwZy9VL3owclRNU0pGRmM2ZjQycmNOTUtyeUdWUjUxS2xVYWRTakpnd3FUcVcyMlk0ZUxRSW9VVkZJYkUvbFFDcTllcVZPRDlpY0t0Q0ZEeFBpSTdYTjMzdTY5bG8xMjZkUVU4TUUxbVhlUWpnN050emtZY2kvZ2R2OHZhZnhGc0tBeHM1R0RpVDdtU3dWN3ljOHpjR0JsYzlRY2c3NkgySzRrMHJPVS8yNjhMVHMwWkxIKzZSUHBVZ1pLVUdVbjhHVURCOG5QT0FXK2hhcnZZOGg1aGs5RzN2VVFzZlpMM0dMMXhmNkNENzIrQXRnUUdPbk8yS2svaERXcEFOck9OUTM1Rll2SGlmc1RLeDJUcXpLRENpY0ZYbHNZUkVrNk1NSlViQXJDbWZIYXRlSkUvejJiZXZyOEtGa2U4S0F0R25zdEhOR3d0NEFWMFFnNVdpa3pzUHlINERCRHQydS9rR3Y3eXM1dWNMQnlCb1ZiVENoUXp6b2dHaDBQREpZd0NESXd0ZVAyM2UvbGNKWXVLNzA5Nk9OQVdZejJNa2U0TlhwdzVJb3RKSkJlbExjVmdyRndOOHg2R2d3eEM3b3VDenpiMlRwQSsxalJ0WXN1alR6SCtMNHRjT0k2SnlIK3c1MHJzZStQaFNrUFRJUWQyOGhQS1ZhSzhNU1FwVEl6N2JKc1pNeVVtZUFJcERxd3o3Z2xseitaQ0lVTjZXWnNJTDhkUmpUQWdIWVlNSVNJMkhKNTRVN0hpZHhQU1dhQ0NlR0RHN3VMZjFlUTJOQUJOSUFsM05Hd3FYMVpGNDZzREhzV1RRM01UaThXd29aWEdDZ00wdmVReFR1WmdkVWhlOUh6eUJvZzhHSzF0ekdIQWMyWTZQSGhzaENIRjJMaVQ2Ni9EMFBkeDc3YlFKMFJzNFFCcVJ0dFpNY3pZR1VIRjlMSGhFWktlbW5KMHdRS3pPQlRDM01mVnBCZDBrZGlLd3VjWURLM1FBSWpIQkd5ODI1am96OU94YU1pSnpGME5ZY25GdERMazZjZ0oyY2ZneXJVeXc1RjdvUldYcmVGQVBDZG13MXhVNlNBdW1CRThORDBvRlRHbzBKSmxuQ0FKTXQrK1JTVWNtd2tIMlRTYUtmdStzZDFpaWNHejB3WVZFWVdNeGpnNmR3ek1pZG9jTjh6bmVnRGNWU0tZeG9zU2lHMkFtcnhva1R5bkhEUm1UenFRQWpQWGhpK1BBSVNGOCsyTDFmT3JDcDBhaUdsQUpJZ3NuZHNwdW1TZ2RhUjZMUWdZSjdzejZEcnR0QjM4VjVZQUpHVERQTkVlTWduTTk2N1JtZnUxNFVzdXBTaElvVmIxV3NUUGJvU2NFa3RYMHp3RWpYLzdCN3o4aTFmZUgyN3NKR0gwK0lPcW5YU1drT1M4c0VVZ29BSy9BU0Nya1Z2cFBkcUlidmVHUmNIRHF2SFVNN0VacmZjTXhDQmFEYUlFTG5OZGppWEFJSlNIMk1yQVRnKzZDc3Z3T2hQOXBIa2MzSjl0SkdtTG4ranU1eG9JRzA5RDlLQnl5dDQ0TWlLL1hYQVJNY3RVbThHM0p1eTR1WU1RaE0yNzF4MU82eWt1TjZYS09Pd0lUMlp5MUFCY1EyT2lLM2NDNFdSSTZ1d3FJMkVuNFBWdEU4VXBvRC9kQU9KNGpZVXJjMnpHeE50cGMyZzVtK0JhUWpLMFBSdmMzMDF0TUg2eUtFU2dwVkJYZUZkS1hYMmJ4cjgrOUlSOEF5a1JPeWVtWWNvVmdNRmVJa0JDZWF4Wkx2c1YyYW56T1Q5SlBkRHlpd1U3aytxaXEweDlkRU5wL3V5VUF5bU9sYVFMcDlmdkFENlFQVGd3Mk56bVNVbUN0VlFadlFTYVdkV1NRdWtaVThCZVBjOGJ5UkVaMFU5Z2hVQlhBVi9nM084Zmt4M1BrOXhyU3VEY0pzaExJK2xGMzdwUHFJUDRaRU50bDhackFoQXVtTytjSHRoSjBVU092dlBaZENzZDRudjcxeG0zUldFbHRSdjZzUm1uaXVEYXZxcExLc00vTSt5MHFJZ1FnSG1idStvSHRjWXpzUmx1WHVTaldIQ3lCenJaeitjb0JWQkxnWWlXSUpHMDNRajFYMFVmRXdUQi90bnFRMkR3aHR2T2JiRzk4ajdCQ0c4cUZ2ZzYvZXBiMWJCOFhFNU16R2NucnlWSFJYMGttU3lBVGVIWlV5Ri9KYWlXWEVJZ2lkbkUrQlVkQVIza1Z3b01kS1BrT0JvNyt3cUxrUXZkeVVyOThZSWV4cG84MzBEM004VnF2anBTRy9BZExNaGxpQ0JjSUtZWWF3azVkSXdQeGo0K0hGNGZlbEQ4NTIxeUFaSm55Q2o4c3BWM0Z2V09heXdxemszYzNvaFBvRjQyR29ybWE1TEFqcUkyOFVBS0xueXRCSmR0cWc5dk5QYnQ2b0doc3hMaEJ4azI3TjBVY0VKbTNyMmU2cUNDU0RsWTRMSk9LdmpWc2U2djJEOU1FZC9UYmdZRGhLVWszcTN2ajh6aVQrM1MzWTJ0ckhDN1BSQmhNd1lMTDFqakd6d3o3RmlNMWpKdXM2ME5hUVZzYmNUakg0YVFuMEkwRTNxVHFCemdTdUhGVFZyUm43a3EzSjV0Sm1zTEp1c0dNejB2dSt2bjZyWmpYV0tVYjY1TlByU3hxcHc0SytxTzdlUVBoSjRHWnhBNnpFSHUrVklSeGpZVEh2WTcrMkFXV0g4ZUdCYldnWGI1bk1PUCtkRHNnWkJrR20xRlBPUmhoZ28rcHViYVNQdEkzSjFwRlF5U0NNRUZZSU14WWphYkZFa1Z2bnJxT0R4Zm5sNFVHUmxUYVdZRGpNQkRjaVZuSnZZZEVkcnREN0hZS0NpME0vR2NpNEdPQmNuVnRmUXdkWVRCNEowUjVhWWdNSWdpem9nOGgyelp3Z0Q2YzdaRGJpcWdVaHQ0WkcvNUtOeWRiU3BqSHlROElLWWNaZ3g1clBSbUZjKzlhSCt6ZExKNWpyclduS0c3QlpibDg2WVZCMGgxaUp1eHVSZFhGbFlISUVNUGhNWWJrNFJMWkE2LzVuWGJjTEttUyt5MzB0Z0FpQlNhS0tyRnpPUnJ6SVJ2YSt6cmRoNnRZR3FhMmw3YnVIQm45SFdER1lBUTVJYSsrN1lmMG1BcVhrM21aWGo2ZlVaNmNDdG91Vm1PaURkWEY4MFpRdlRUakZVNHMxbkRJSCtMcElhallqdWVVVnNNK040RnhqSUVqdzNQUG0rbW96YkVRQ20yeExOcGJjR2gzMndadmJOeEZXSkNDUk5tcC82NEhlc2NNbmg3ZExhTnkxZm5MczNxQmFUc2wyMTFnaGduTXl4dUFMYVhTSFRuaGdDdFhVa0FFVVYyc0xzSkxqL254M0dhckJ1U0RpaXJudTJDY01zM2VRamNwRmRxcDlORG1RYmNuRzB2Ykk4dkQycjkzZG16ZU0xUGVBWkJLVEpKN2FOOXpUKzJvb3kxM2ZXSU9oeVhSWEV0MklFN0VTdW9WV0lYUzJFbnN1TTJFeDYxeU1yQmhBRlVDRlVKR1JpbnprakE1QWk0WGNhd0NHaWV6Znc2VXdpdjJCQ0JPeVVUV1JUVFlsMjA0SHN0bGZ2YXYzRlFPaURZTVpqNUhBMUUxVy91UG5WbS9xQmlZRTdGNDVxcEU3ek9wdjZJK3FkdUtRY3EzRUNGQlJQQ015NHB0eGN3d2IyQWxEY0Z3VDc3YTR5ajh5UTB1UUE1RElpcjQ3ODhTMTQ4b3I5VTJKTmtMSlRpWUpTVFlsMjBxYnhzU3F4Z1pwNkJXREZaQ0FSRDV2ZGJHZHJONTJlSENUS0xvN0t4QjFUZjJ0WkpDU3BKVThBRWd1RHR4eDF1Q05hbVR6UTE0MTNnM1ZpOEFCSHpic0NBQzM4dStBeHdVUUFuc2RHQUFSTXNWZGpxMVpsOGJsamFUNnVlZldocWxOeWJiU3BqRnhJMkdETUZMVVJ4NlFUQ2hIdExYNi9odmIxNk9RSGxYNno3dVdjbGJ5UlRjQ1U3U1U4a3FzaXhQcVo1NExLTG81ZEZ5YXJadFlRRG5zQmpoaGljUWQ3SVk4Z0NUaGo0VWNFM29nOGd2UDZDVXRPWmNXaXRRRU5ob21xUzNKcGtxY25nUkltREFnSW93a0lVWUNrL1plL3ZSM093L2VkM3g0aStqZU5oWUJPeHRaMlVRYWpPVlNLZ3F6T0R3WEIvN1FqQklXc2pQWkxqTUlnQUkzVXoxWmlRU2R6M1BudFVvcHdLVWxvSlNkeE5HWG9UNWtiMDUrY0JLQkNEdWQxS2JTcHJGd0syR0NoaUdaL0JHV0FZa29pNmFZckgza1crdWZrMDZzOUsvWnN6UXZzeEpXRTk3SUZEYTVpQXRZbDhaa2pMRW9nTUhSS2phZ3JNbzlDR1dRUUFNUFBEN1RvUXNhdE5NRGJBYmVUV1J5a1ora3Qwb0V0bjJUanRsb3o5S2pxVTJsVFdQaE9oUHlMN3R1alFXU1VlSkVYVXZ2L1ZyNzl2bmw1R0FvRmFEVzIyTld3ckppTHVmaUhHM0V6YnhndzJXM2h1Vm9IMjVJTEFNQTEyWDVaUktoY2VPVUdFQzZPU2FRa3BSU05wd2RjY2xOeklSU2djMzFQNEdJYkJnSytRa0RoQVhEUnUxaXRCWmlwRHg2U3ovMDRiOWR2MFprSlgwbCswOGVHckZTc0ppTEZWeWNXeW9BWVhnc0N5YS8ydTVuc3dINEVZNTJ1RjJKa1VBYURDZVBBUyt5a095YW5TRXY3R0E1ZVphdzU5S0s0SE9LczBNdHNNbDJaRU1WbUhkaU1OQTJtT2l5eVdyaHN3TVQ0aTI5KzB0cnR4MWVDZzh2YWF3c1prbEthNndTRjVHRmdJVmVVaTQ0UE5iTEQwa2xDbURMSS9hd1diN2FMekVST3hxQU9ZWUhrUE0rSWo5V0tqRGlzaHlFWEkyV3I2bVI3Y2lHMHFadGZ6dGh3SUJvSlMvU1ZnS1NFVkkwUklCbWxyVGZkOFA2SnlFd2Z2eUFSblRTNjVseDNTWENXNXljQ0VJaUxqeldPalFXU0FhVUUzVnhJVDNJVE1TbkN2emtwZ1FnYVV4VTlkOVhCaUtubnptQlRSNUUyNHhzRjloUTIvNXF3MGFreE5kZGtWM0dTSG5KaElUVmtnNzc3dnpoL0VBczV0TGM4RjBuRHNPUXhpc2xHQmJlSlg1YkdrdFUxdG5vdXBnU1FGbWdBb0dSV0ZKaUdBbjRjb3NFSUh1VTVpWkFoS0hsSmZ3cWdpdXdhWVlJMllwc0ZwclhmK2VSd1RmSTlvYU5sb29sa2NwQU1zaHI1NnowOXMrc1hETklRSnprdEh0dEFXcnQ1UXpwMW1SS1h5aUczRm9vbkdjVGU1NTdZL0kwREtEWVVvakhOM3p0WDhxSWkrZDN4ejI1ckFpK1lQZW5TMkhGL25KMWtYT2o2cHQ4b0xVUjJZcHNKbTFrNjdkZHUzSjFFUU1TRzVVeFVwNEtJRXBidlBHZTNwRWI3dXArVmhiZUFPY3NQQUJKdDV1TitiV0VONitYS29HSkMrY3hRT01ZeW1hN2pBSkNJUlpLYW0zQUYzamR6ekVBQXNEZ05DWSthUW5NQ2lnaG9lM3JvckhBVGxJYmthMUNTL3A5L2U3dWRXVHozUDVjeUY4WlNBVldvdG1VcTIvNnk2WFBuMXhQSHBKZFhBLzJMRHc0Y25FVXlZWDBrbDlPUVQ0VklIU2FsNi9oc3N4Y2pnajhqRFlJT2tqOFR4VG5qS3Zra3BUU05aZmRYR3gvbFBkdkNpSWRvWkZ0OW1vYmhWWVlJUnYveXY5ZStwekpZaDh2WTZNcWpKUnJKVUxraVpVT3R0OTEvZHFIS1k4bEhieHovU1JNbnp5U1pVdFIwa3ZTM2VpSzVUQ1lwTHViVFQ0V005WXNhSUFGbDlpa0Jia0M0OEJ0QUpXd2FJQ2h1Y0lzMzY5MmxFYjVQckxOWENCblJMWWxHNU90alV0YkRHbWp5a0FxUkhESEtQejc0TTNyOTN6emdkNy9EWDJHSW9Gb2JVVk1WRllHVTZCVFEzcURuZmdZR0xRdkQrNlhtU2lVTHJEQUl3S29vcTdqSXJ3SlFGUk1QSkpOU3FJMDBMYjlQTm5ZaFBySFFwSGFwSXlVNTVXV3pJbmJWL3o1MHFlT3J5VVBoTW9uNXg2N0Y3QzdrZVlxZVBFdGdjbEoya0hWRUZvQ0ZQb1RIME96UVlTY1VTaTM1TTQrQVhhdUhNb0FxcEs2QUg4OGVCVVFwZUthdklPMkJka2tWQVlobTJyYmZ0ckltV1BHNW9NcUFLa0VKSVBJRFhQeXhhWDFaRjByK3ZkclpkK1ZQa05MQmg2WXZ3ZUcvZDQ0NjEwQlRGWlZHekd3b2xwQXpBS0liSUFZbnArMm1jYk5oL08vRDJRQVNTekVaYWt0Rmk0SFVacTkxallnVzlRRG9UN1prbXhLdGpYdWJNRU1Yc050QTFKaGlBblJIU241bFU5L3QzUDQ2bHMzUGhMNnpGUnZIZmJQM3dzRG1qQlFFVXplR0c5M1JiWFFMSkFLZ0xMcmE4QVdYNnV0azgwSmVRZ3pZQm1BbUJJUG0yd1VFNzAraUtqdnlRWlRnY1VnYUNOYmtrMExObDdPWjRoc0s1QUs2UUFTWURTTWJ2M05IMSsrNmJ1SCtsOEtmV0IyWXhuMnp0ODNHdWRkRFV6SWdNbGxKeWFrTHdFVVYxdnp5eVJRY1R3UzhPVVJyL1pXRFVCRjUrVzdNcTZ5SHdaUlB2NTY3L3o5cVExQ0c5bVFiR20wOEZGajQ5NGt3SmdJU0lWMHdGRVRGdlplL1djbi84L1JsZVR1ME9mbTJvdXc2OGo5bWErdUJDWW5uOEs2T2tjN2hRQ0YvSkkwM0RTa2FtT1IwQitiNFFLdDRrUktLQ1k0T1JaeTlaQTdKbHNBRWZYMWJ0M25jKzBUUVp1UzdjaUdCampIalczYlZWM2FaaGtwZDNFa3dtZ213Y25samFSeitZZFBYcVhEeGFPaHorMWFYVWpCTkN3QkU0TGZVV0YycWdBb0MxU09saEdtYWsvVWdGbFRhWVFoTEwwMkYwQWNDeUV6VzFsbUlnTFJmYkJ6ZFNGb1M3SVoyWTVzU0xZME5sMmF4S1Z0R2tpRjNOSng4OFdyM3puVVg3cnlFOHQvM0IvQ2VobVlkcE5tR2c1RU1ObEx3M0N1anBsRHhnQUtRY2d5ZTdOcEp4aURCS0VSQVZBNkN4ZTgyU29DZ01RVjRRcGxENUdKQnJEbjBYczBpSTZIRGFodFJUWWoyNW5FNDd5eGFYOHpnTmdVa0FwUjNCRnpBZTNQM3RhWi8yOWZYcnRxR0lqa1VqZTNkZ0wySDc1TFJ4SjlRWUQ3QTdxS3JnN2RnWEhvekV0bEpqMkNCeXAvR1dRL054VENUbWhFQUpQVTlPcHpMb0RBV2tuWFlpSGtsNzJ4K21vVW5mWFR2dDNSWGd6YWoyejA3aSt0WFVVMk0xSmwzdGh5WTFLWHRsVkd5a2RTNWtpbXRFRG52M3h4N1k3MzN0RCtuNVM2Q0gyVzFsbzY1OUFkZ04wT0E2YXdxL1BtcG9GZnpmZFl3alUxVjB2ejVyQldtclF0NUp2OGM3anM1NDBXQUh2UUhUZnZuM3NVUmc0aTZrdnEwNWtTWVUyMklSdjkxNzladXdPeThmbkhjcy9Dalh3ODVVQnk5TklqSnUvUSs5M1ByMzd2UTk5WS85TlFHWVcybGc1SHozLzRkb2pXbGtkSlM3czI1N282ZjU2VDk5UUF6dVdCUDVXSUJVWnBvVll1NEhMQUErQmRwKy9DWERmbWpRRGtYUm1PUlRYMUlmVmxxeVRFcDQrUWJjaEdSbHd2R050dFNoY1Z0L2lkVjF5OGxjL0Q4MTkwN3ZEYXJ5L1NSUkVLNkluTHJiKzVzM3RrejB4MDZKS24xbjlTS1Jtc05MOThoL2JsZlJWRHJ6a3pldXlsQ2p6cVhIbFBvbGJPczQ2NVI0YXFTay9ZM3RKVytyZ3RmZ28xc2dWWE55THpXU2k5OGZRTk9IWHlDSnh6OUY2SVM1NnJSMHlrUWZTK3QxMjdja3RCNDlKaTY4YzBpSHBiL2ZrUmJNK1dvL3R3WHVSN3gyZFdibm5QMTlxbG1vbFM5dnNYSG9UZFdpQmlyOGVJY0ZjNzhlNE8yQlZwSFUzanJmT0JvbXNxYjNMcHhJb0pVV0lmZjJLbDdNWWNFTkdzSGQxWDFHZlVkNnJrcVVOa0E3SkZBVVNMeGxZTGsrYUxUaGtqM2RWdHdPdGV1Z2MwS3czTVJlWE0xTHpoN3Q0eC9adnZldkd6NnBmRWtXcUV6dFBzYmNEMDZnbm8xS2RoVUcrT09pL0VUdGxid25QdXZTZXloeDV6cmlTdXFrWkFiZ0FndkNlekQvRERRaGdBMFhpaW1uWmxCeDQ1Q0ZPZDFmSTdmSWp0UC9waSswL2VkZjNhN2FadVJtSCtJYU9MTmkydVR4VWp3U2YrODBYNUtJRjVjNkYwd1lNLy92TGF3VGQvYlBtZHExMDhWbmFPK3FBTDV6MXlKK3ljdngrUy9qaEZrR29uN2c3MVNoSVNTM0ZyWjh2c1VybSt4azdubHZKVVBQdUFtNDVnSXJJMElLR20rMlR1eVAxcEgxRmZsVzNVNTdydmY1OXN3SUhJMkF4T0t5QVpNQ1VGTUQyY3U3bFBmcWZ6NkdVZldQeTlzZ3g0M29rN1Y0N0NlUTkrRCtyTHgwZXpVMEx1Ymh5NENVc2JGMEVsQXF0cW5TMmNBUzhDUndhUE82d2s0TVl3SzNWUVgxQ2Y3Rm8rV3VrYXFhK3B6Nm52Qys3c1lXT2JkV09yYmRzVVhuUEZsazV3M2ZLczk3YzMvdjY5Qk5CcDNjN1Q3VUxkZHV2V21HdXArUHAvdmVkTlAzNWgvUldWSThPcE9UaDU0T21RVE0xQUZHVzRqK2hSdkt6L2NWeVVxdUtvdGlpNkt6eHVWQmJRZ29zenMzSFN0YTQzMnJENzJJTXdIVmlxbUt1ZHZlb0RpeDlkNmFRUG84MUJkSWdEMFd0MnJwMitRQ3FBYVVxM2MzVzdRTGU5QkNiNnpnLzk4czVMMy9qQ3FkK0lvMVJMVmJDVmd0VzVmYkM2OXdKSW1pMGJVQ3dBbUJoTmJXZUlOaG5Lc01wVEx3dmxGQUtRNm5aZzdzUmgyTEZ5UERoNTBSWFZIN3RsNHlOWGZtTDVadk1GZVpIOWNKNXdkSm5vdEFlU0FaTXlZTnB2d0VUN0ZuM3Y2MzY4ZGQ1Vmw4KzlaZDlzOUl6S1p0Rm9XSm5iRDJ0N25tSUJpdElHdmlndkFZNHFFZUtiQlUyUW1QaUgrdVVUSlZJRzBnQ2FYWHdFNWxZV1NxT3g0a2FEMG1nODBhZS9tMmFyMFNRYkZ3clJHYXVKemdnZ0ZjRFVOSXowRk4wT1VIS2JDSVZjM2JWdjNuM0ZpNS9SdUV4aklaNEVVTzJaM2JDNjUzem9UKzNRZ0ZLakhKVE1VaE9DUnZsSFYzbVFZeWx3SFBiSkY3bXFiNnpDanNWSFlhWjljaUlBMFpqK2J6N1ErOExsSHpyNUtlUEs4clVianBsa0l6RlNWeExXWnd5UUNvQWl0N2JMNkNacU8zU3IwWHRYWGpyOXpOOTkxZXh2N3A2T25qYnA5M2ViTTdDNmN6OXNhS2FDV3MxbnFjcllVVnRtb3lxSEZOa0hCZ09ZMHN5elkza0JtdDMyeE45S3N6MW9vUDRIYjE3UG4yeEZrVmxldGtvcitScEF3VHpSR1Fja0E2YllBT2hjQTZiZHVXNmFhYWo0NDcrKzY5VXYvWkhtYTJ0UjZ2NG0yaExOUk9zenUyQjl4ejdvem1xOHhuRUdwanhiUGpHd3RpZlRuUU5uRk9MVEV4blhsbUI2OVRoTXQrVkYwVU1iVFY2a09ZYS8vQmRMWDJqM1VoYks5UkNGOXhTbFVXaTNxa0ZVV3ZZNEk0SGtpUEI5Qmt6N1RJU1h1cmFmZVdaajEzdXZtSHZEeGVmVkx0MnN5Wk1vaGcwZDdYVTBzRHF6dTJGWWIycVhwMkVVRlVzdGhYTE1ab21KZWFxbHRmUk1rajJGTWU1M29iVjJFbG9hT0ZNNitvcVNUWmUxa0tiTy85dFByVno5dC9mMzhoWFZoeWJsa2cvck9jNko2ck1PU0FYZFZEZXU3aHpUNW5KMm9tUGU4cEtaaTM3cnBkT3Z2MkJYL1B5dC9zaCtyUW5kcVZuZGRrQ3ZOUXVEaHNadExSNEpkS1c0S0U4Sm1rUjRtSEZlbnRHTVUrdXVRNk96QmsydGU1b2JhNVdTaDJVYnJRcENpM204LzhiMnZRVVlFd3V0R0FhaWxzN1BueVRSZUVZRHlYRjFNMGFJazd2YlkvNDlFdDcvN3VVeno3M3kwcG5YbjdjemV1NTJlcDYrWnFsK2ZTb3R4MUFqMWtwcWRSakdkY0NvcGx1a1JYMlU3dE9Pb3BDY0hoWk0rMlFBOGJBUDBhQ2ZzazNOdEhwL1E3ZnVkbDVtdXNqVkIyOXVmL0pQdnRJdUxuaVdyL1c1YU1MNmRHNStGVmQyVmdLcHdFNE53MGdIVElwZ3Awa1RqREx2Yi8zNW1lZjh4b3VtTDN2V3Z2aUZTajJteWFESGZDTTVSV3MyZnVSYjYxOTQ3OWZheFdwQVlzTDZmUExpTWZPNnQ5bHl4MmtEcE8zYXB0OTZKRGJhYVpjQjB6NGp6QnRGNWZLYUY3VE8rZTJmbi9tRkg3Mmc5clBObXBvN213QkVhNXZmZG5qd2pmZDhyZjNsNjc3Zk9lcW9zUjZNNStJdkdEZTJzZFZ4Uk51MW5UWkFNbUJTSmlVd2JkemN2b0s3c3dDMVp5YXF2L1BWczVlODRubk5sMXl3TzM1K05FRWU2blRhYUlBalBiTGpTM2QyYjN6bi8xdjc5bUxiZXZabkRxRGNqUjAzZXhMWGcrMnEzSjkxUUhJQTFTZ0FhcTlKRlV5YnYxdkY1aGM4cFQ3N3RwZk4vTlNMbjFuLzZmTjN4cy9Wb0txZDV1QVpQTG84UFBqTisvdC9kOVZYMi8vdy9VZjZybjlKRElEV1RVaC9vZ0NnM3VrRW9OTWFTQXlnWm96TDIyUDI5TzltVVpUbjI5UDJ4QzBkOFYzOHM4K3EvK2d6OXRVdW5tdXA4MDZIMzBMUGdIM2crT0NPYjl6WHYwMUhYbmM4dERqa0ZpMGpOOVdGOGNLZmkyYmZQbDBCZEVZQXlRRlUzVERTbkFFVHRWa2p5dXNnREluNWlRdnJjNzkwU2V2Wmx6eTEvcHdMZHNWUDJ6Y2JYVGpkVUx0UDVmV3U5L0RrOGJYazBDUEx3NGR1ZmFoLzl6WGY3dHp6blVOOXFYeFA3Tk0zSW5vTnhzdnNyUmdHNnAvT0FEcWpnTVJvcUtaaHBaMm03VEJDdldYZUQ0NnpJbGY0OHVjMnpuLzJnZHFCcCs2Tzl4L1lFZTNYNEpxYnJxdlpWaDEwVTdOVSs0dVVxdFhNQ0FWYVpDRkJIRkJ0cTlQSHRVNGYxdGIxWG9ObTVkaHFzdkR3eWVIQ1BjY0d4NzV5c1BjbzQ2bzQ4QXdNZURhTWlGNDJyVzFZYVhBbUFPaU1CSklEcXNpNHZaWUIxUTdEVmpsTE5ReFR4UUNQZTdvQWpkdnFHKzJUczg4S2pKL3QwVEh1S3prVDdhR216cnYwYklpY1l3T2NwbUdtSEZqVDV0ODVxR3JtMk9nVWdnc040d3dONitUZzJUQ3VLZ2ZPaG1HZW5qbjJqTjVxY0hac1EyT1lEWE9YMXcxNGNzYWFNcUJxRmRpcUNLcDhIeFZBbGdOTkZRQ1M3M093SkFYUUZNR1RzMDdIZ0djalp4elQrZ0NRd0ZtMDFlRHMyeEp6cDNjTGJGVXJNRkt0QUxLR3cxWTFCMVRLQVJJNjRCazRyRk5zeGZjR1p3UHJQTkdBeExIVkVPeG5hT1FzVkd4cWs0eUVoZThZRnRqcENiWDlmd0VHQUZqQXdNd25nTlhKQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDlsZXnpLrnlKjmiLfnmoTkuIvms6jph5Hpop0g5Lul5Y+KIOWllumHkemHkeminSDlvZPnhLbov5jmnInlgJLorqHml7ZcbiAgICBkaXYuYm9udXMtYmFyXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJldFxuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5mb3J6ZW5cbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93XG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cImJldE51bVwiLHYtaHRtbD1cImxvY2ttb25leVwiKVxuICAgICAgICBkaXYuYm9udXMtaXRlbS5jb3VudC1kb3duXG4gICAgICAgICAgICBkaXYuY291bnQtZG93bi1iYWNrXG4gICAgICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tc2hvd1xuICAgICAgICAgICAgICAgICAgICBkaXYuY291bnQtZG93bi1udW0odi1iaW5kOnN0eWxlPVwie2ZvbnRTaXplOjQwKnpvb21SYXRlLngrJ3B4J31cIix2LWh0bWw9XCJjb3VudERvd24gfCB0aW1lXCIpXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJvbnVzXG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmJhbGFuY2VcbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93KEB0b3VjaGVuZD1cInNob3dNZXNzYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cImJldE51bVwiIHYtaHRtbD1cInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi4vanMvcmVxdWVzdC1saXN0J1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2JldHMnLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcbiAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5nZXRDb3VudCh0aGlzLmNvdW50KHRoaXMuY291bnREb3duKSlcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBiZXROdW0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMyAqIDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8v5q+P5qyh5byA5aWW6YO96YeN5paw6I635Y+WIOWAkuiuoeaXtlxuICAgICAgICBnZXRDb3VudChmbikge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRDb3VudCgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoYXQuY291bnREb3duID0gcmVzLmRhdGEuY291bnREb3duXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudE51bSA9IHJlcy5kYXRhLmNvdW50TnVtXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LmlkbnVtID0gcmVzLmRhdGEuaWRudW0gKyAxIC8v5byA5aWW5pyf5pWwXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbiA/IGZuKCkgOiBudWxsXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyDkubDlrprnprvmiYtcbiAgICAgICAgY3JlYXRlVXNlckJldHMoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJybXNnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnc2hvd1RpcCcsIHJlcy5kYXRhLmVycm1zZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzTnVtKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcbiAgICAgICAgICAgICAgICB0aGF0LmdldENvdW50KHRoYXQuY291bnQpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duID0gdGhpcy5jb3VudE51bVxuICAgICAgICB9LFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpXG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50KCkge1xuICAgICAgICAgICAgLy8g6Led56a75byA5aWW5pe26Ze0MzDnp5Lml7Yg5Lmw5a6a56a75omLXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPT09IDMwICYmIHRoaXMuYmV0cyAmJiB0aGlzLmJldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5YCS6K6h5pe25LiN5piv5pWw5a2X5pe25LiN6L+b6KGM5YCS6K6h5pe2XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd1RpcCcsICflgJLorqHml7bor7vlj5bplJnor68s6K+35Yi35paw6aG16Z2iJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY291bnREb3duKVxuICAgICAgICAgICAgdGhpcy5jb3VudERvd24tLVxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5jb3VudERvd24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWAkuiuoeaXtuWwj+S6jjAg5pe2IOiOt+WPluiOt+Wllue7k+aenFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdldEJvbnVzTnVtKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5pbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LmZvcnplbiB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiA4MCU7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5iYWxhbmNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDgwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuLmJvbnVzLWJhciB7XG4gICAgaGVpZ2h0OiAyMCU7XG59XG5cbmRpdi5pdGVtLWJhY2sge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuZGl2Lml0ZW0tc2hvdyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG5kaXYuaXRlbS1zaG93IGRpdiB7XG4gICAgLypoZWlnaHQ6IDMwJTsqL1xufVxuXG5kaXYuYm9udXMtaXRlbSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuYmV0LW51bSB7XG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XG4gICAgY29sb3I6IHdoaXRlO1xufVxuXG5kaXYuYmV0LFxuZGl2LmJvbnVzIHtcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xuICAgIHBhZGRpbmc6IDAgLjVlbTtcbn1cblxuZGl2LmNvdW50LWRvd24ge1xuICAgIHdpZHRoOiBjYWxjKDMwJSAtIDFlbSk7XG4gICAgcGFkZGluZzogMCAuNWVtO1xufVxuXG5kaXYuY291bnQtZG93bi1udW0ge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAyZW07XG59XG5cbmRpdi5jb3VudC1kb3duLWJhY2sge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5jb3VudC1kb3duLXNob3cge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgIGhlaWdodDogOTIlO1xuICAgIHdpZHRoOiA5MiU7XG4gICAgbWFyZ2luOiA0JTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBCZXRBbmRCb251cy52dWU/MTdmNTY4YmZcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IFZ1ZVJlc291cmNlIGZyb20gJ3Z1ZS1yZXNvdXJjZSdcclxuVnVlLnVzZShWdWVSZXNvdXJjZSlcclxuICAgIC8vIOiOt+WPluW8gOWlluiusOW9lVxyXG5tb2R1bGUuZXhwb3J0cy5nZXRCb251c1JlY29yZCA9ICgpID0+IFZ1ZS5odHRwLmdldCgnZ2V0Qm9udXNSZWNvcmQnKVxyXG4gICAgLy8g6I635Y+W5Li76YWN572u5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldE1haW5Db25maWcgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldE1haW5Db25maWcnLCB7IHBhcmFtczogeyB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF0gfSB9KVxyXG4gICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XHJcbm1vZHVsZS5leHBvcnRzLmdldENvdW50ID0gKCkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRDb3VudCcpXHJcbiAgICAvLyDojrflj5blvIDlpZbnu5PmnpxcclxubW9kdWxlLmV4cG9ydHMuZ2V0Qm9udXNOdW0gPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5nZXQoJ2dldEJvbnVzTnVtJywgcGFyYW1zKVxyXG4gICAgLy8g5Lmw5a6a56a75omLXHJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVVzZXJCZXRzID0gKHBhcmFtcykgPT4gVnVlLmh0dHAucG9zdCgnY3JlYXRlVXNlckJldHMnLCBwYXJhbXMpXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5nZXR1c2VyQ29kZUZyb21OZXQgPSAoY29kZSkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRVc2VyQ29kZScsIHsgcGFyYW1zOiB7IGNvZGU6IGNvZGUgfSB9KVxyXG4gICAgLy8g6I635Y+W55So5oi35L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldHVzZXJpbmZvID0gKHVzZXJpbmZvKSA9PiBWdWUuaHR0cC5wb3N0KCdnZXR1c2VyaW5mbycsIHVzZXJpbmZvKVxyXG4gICAgLy8g6I635Y+W5YWs5ZGK5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldExhc3ROb3RpY2UgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldExhc3ROb3RpY2UnKVxyXG4gICAgLy8g6I635Y+W5b6u5L+h55So5oi3Y29kZSDnlKjmnaXlkI7lj7Dojrflj5bnlKjmiLdvcGVuaWRcclxubW9kdWxlLmV4cG9ydHMuZ2V0Q29kZSA9IGZ1bmN0aW9uKCkgeyAvLyDojrflj5bnlKjmiLdjb2Rl5YC8XHJcbiAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXnwmKVwiICsgJ2NvZGUnICsgXCI9KFteJl0qKSgmfCQpXCIsIFwiaVwiKTtcclxuICAgICAgICB2YXIgciA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLm1hdGNoKHJlZyk7XHJcbiAgICAgICAgaWYgKHIgIT0gbnVsbCkgcmV0dXJuIHVuZXNjYXBlKHJbMl0pO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqKirlkI7lj7DnrqHnkIbnlKgqKiovXHJcbm1vZHVsZS5leHBvcnRzLnVwZGF0ZXVzZXJpbmZvID0gKHBhcmFtcykgPT4gVnVlLmh0dHAucG9zdCgndXBkYXRldXNlcmluZm8nLCBwYXJhbXMpXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3JlcXVlc3QtbGlzdC5qc1xuICoqLyIsIi8qIVxuICogdnVlLXJlc291cmNlIHYwLjkuM1xuICogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yZXNvdXJjZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm9taXNlcy9BKyBwb2x5ZmlsbCB2MS4xLjQgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vcHJvbWlzKVxuICovXG5cbnZhciBSRVNPTFZFRCA9IDA7XG52YXIgUkVKRUNURUQgPSAxO1xudmFyIFBFTkRJTkcgPSAyO1xuXG5mdW5jdGlvbiBQcm9taXNlJDIoZXhlY3V0b3IpIHtcblxuICAgIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cblxuUHJvbWlzZSQyLnJlamVjdCA9IGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3Qocik7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDIucmVzb2x2ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXNvbHZlKHgpO1xuICAgIH0pO1xufTtcblxuUHJvbWlzZSQyLmFsbCA9IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQyKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChpdGVyYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHg7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZSQyLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblByb21pc2UkMi5yYWNlID0gZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQyKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZSQyLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxudmFyIHAkMSA9IFByb21pc2UkMi5wcm90b3R5cGU7XG5cbnAkMS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHggPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB4ICYmIHhbJ3RoZW4nXTtcblxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5yZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gcmVhc29uO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICAgICAgd2hpbGUgKHByb21pc2UuZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcHJvbWlzZS5kZWZlcnJlZC5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICBvblJlc29sdmVkID0gZGVmZXJyZWRbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSBkZWZlcnJlZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGRlZmVycmVkWzJdLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBkZWZlcnJlZFszXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlc29sdmVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZC5jYWxsKHVuZGVmaW5lZCwgcHJvbWlzZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnAkMS50aGVuID0gZnVuY3Rpb24gdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9taXNlLmRlZmVycmVkLnB1c2goW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH0pO1xufTtcblxucCQxLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59O1xuXG52YXIgUHJvbWlzZU9iaiA9IHdpbmRvdy5Qcm9taXNlIHx8IFByb21pc2UkMjtcblxuZnVuY3Rpb24gUHJvbWlzZSQxKGV4ZWN1dG9yLCBjb250ZXh0KSB7XG5cbiAgICBpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBQcm9taXNlT2JqKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IGV4ZWN1dG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlT2JqKGV4ZWN1dG9yLmJpbmQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblByb21pc2UkMS5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLmFsbChpdGVyYWJsZSksIGNvbnRleHQpO1xufTtcblxuUHJvbWlzZSQxLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLnJlc29sdmUodmFsdWUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2UkMS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoUHJvbWlzZU9iai5yZWplY3QocmVhc29uKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmoucmFjZShpdGVyYWJsZSksIGNvbnRleHQpO1xufTtcblxudmFyIHAgPSBQcm9taXNlJDEucHJvdG90eXBlO1xuXG5wLmJpbmQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgaWYgKGZ1bGZpbGxlZCAmJiBmdWxmaWxsZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgZnVsZmlsbGVkID0gZnVsZmlsbGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEodGhpcy5wcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmNhdGNoID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEodGhpcy5wcm9taXNlLmNhdGNoKHJlamVjdGVkKSwgdGhpcy5jb250ZXh0KTtcbn07XG5cbnAuZmluYWxseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VPYmoucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG59O1xuXG52YXIgZGVidWcgPSBmYWxzZTtcbnZhciB1dGlsID0ge307XG52YXIgYXJyYXkgPSBbXTtcbmZ1bmN0aW9uIFV0aWwgKFZ1ZSkge1xuICAgIHV0aWwgPSBWdWUudXRpbDtcbiAgICBkZWJ1ZyA9IFZ1ZS5jb25maWcuZGVidWcgfHwgIVZ1ZS5jb25maWcuc2lsZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbVnVlUmVzb3VyY2Ugd2Fybl06ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayhjYiwgY3R4KSB7XG4gICAgcmV0dXJuIHV0aWwubmV4dFRpY2soY2IsIGN0eCk7XG59XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBpc09iamVjdChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybURhdGEob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodmFsdWUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbnMoZm4sIG9iaiwgb3B0cykge1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBvcHRzID0gb3B0cy5jYWxsKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlKGZuLmJpbmQoeyAkdm06IG9iaiwgJG9wdGlvbnM6IG9wdHMgfSksIGZuLCB7ICRvcHRpb25zOiBvcHRzIH0pO1xufVxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IpIHtcblxuICAgIHZhciBpLCBrZXk7XG5cbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtrZXldLCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IF9hc3NpZ247XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcnJheS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzaWduKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcnJheS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX21lcmdlKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoZGVlcCAmJiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIWlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgZGVlcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcm9vdCAob3B0aW9ucywgbmV4dCkge1xuXG4gICAgdmFyIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICBpZiAoaXNTdHJpbmcob3B0aW9ucy5yb290KSAmJiAhdXJsLm1hdGNoKC9eKGh0dHBzPzopP1xcLy8pKSB7XG4gICAgICAgIHVybCA9IG9wdGlvbnMucm9vdCArICcvJyArIHVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBxdWVyeSAob3B0aW9ucywgbmV4dCkge1xuXG4gICAgdmFyIHVybFBhcmFtcyA9IE9iamVjdC5rZXlzKFVybC5vcHRpb25zLnBhcmFtcyksXG4gICAgICAgIHF1ZXJ5ID0ge30sXG4gICAgICAgIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICBlYWNoKG9wdGlvbnMucGFyYW1zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodXJsUGFyYW1zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcXVlcnkgPSBVcmwucGFyYW1zKHF1ZXJ5KTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT0gLTEgPyAnPycgOiAnJicpICsgcXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBVUkwgVGVtcGxhdGUgdjIuMC42IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3VybC10ZW1wbGF0ZSlcbiAqL1xuXG5mdW5jdGlvbiBleHBhbmQodXJsLCBwYXJhbXMsIHZhcmlhYmxlcykge1xuXG4gICAgdmFyIHRtcGwgPSBwYXJzZSh1cmwpLFxuICAgICAgICBleHBhbmRlZCA9IHRtcGwuZXhwYW5kKHBhcmFtcyk7XG5cbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhcmlhYmxlcy5wdXNoLmFwcGx5KHZhcmlhYmxlcywgdG1wbC52YXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlKSB7XG5cbiAgICB2YXIgb3BlcmF0b3JzID0gWycrJywgJyMnLCAnLicsICcvJywgJzsnLCAnPycsICcmJ10sXG4gICAgICAgIHZhcmlhYmxlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFyczogdmFyaWFibGVzLFxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7KFteXFx7XFx9XSspXFx9fChbXlxce1xcfV0rKS9nLCBmdW5jdGlvbiAoXywgZXhwcmVzc2lvbiwgbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5zcGxpdCgvLC9nKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCB0bXBbMV0sIHRtcFsyXSB8fCB0bXBbM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHRtcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciAmJiBvcGVyYXRvciAhPT0gJysnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gJyYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmxlbmd0aCAhPT0gMCA/IG9wZXJhdG9yIDogJycpICsgdmFsdWVzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc7Jykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyAmJiAob3BlcmF0b3IgPT09ICcmJyB8fCBvcGVyYXRvciA9PT0gJz8nKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IgPT09ICc7JyB8fCBvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPyc7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG5cbiAgICB2YWx1ZSA9IG9wZXJhdG9yID09PSAnKycgfHwgb3BlcmF0b3IgPT09ICcjJyA/IGVuY29kZVJlc2VydmVkKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVJlc2VydmVkKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlIChvcHRpb25zKSB7XG5cbiAgICB2YXIgdmFyaWFibGVzID0gW10sXG4gICAgICAgIHVybCA9IGV4cGFuZChvcHRpb25zLnVybCwgb3B0aW9ucy5wYXJhbXMsIHZhcmlhYmxlcyk7XG5cbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtc1trZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBVUkwgdGVtcGxhdGluZy5cbiAqL1xuXG52YXIgaWUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbmZ1bmN0aW9uIFVybCh1cmwsIHBhcmFtcykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICBvcHRpb25zID0gdXJsLFxuICAgICAgICB0cmFuc2Zvcm07XG5cbiAgICBpZiAoaXNTdHJpbmcodXJsKSkge1xuICAgICAgICBvcHRpb25zID0geyB1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gbWVyZ2Uoe30sIFVybC5vcHRpb25zLCBzZWxmLiRvcHRpb25zLCBvcHRpb25zKTtcblxuICAgIFVybC50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdHJhbnNmb3JtID0gZmFjdG9yeShoYW5kbGVyLCB0cmFuc2Zvcm0sIHNlbGYuJHZtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm0ob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXJsIG9wdGlvbnMuXG4gKi9cblxuVXJsLm9wdGlvbnMgPSB7XG4gICAgdXJsOiAnJyxcbiAgICByb290OiBudWxsLFxuICAgIHBhcmFtczoge31cbn07XG5cbi8qKlxuICogVXJsIHRyYW5zZm9ybXMuXG4gKi9cblxuVXJsLnRyYW5zZm9ybXMgPSBbdGVtcGxhdGUsIHF1ZXJ5LCByb290XTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cblVybC5wYXJhbXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBVUkwgYW5kIHJldHVybiBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKi9cblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuXG4gICAgaWYgKGllKSB7XG4gICAgICAgIGVsLmhyZWYgPSB1cmw7XG4gICAgICAgIHVybCA9IGVsLmhyZWY7XG4gICAgfVxuXG4gICAgZWwuaHJlZiA9IHVybDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IGVsLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiBlbC5wcm90b2NvbCA/IGVsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIHBvcnQ6IGVsLnBvcnQsXG4gICAgICAgIGhvc3Q6IGVsLmhvc3QsXG4gICAgICAgIGhvc3RuYW1lOiBlbC5ob3N0bmFtZSxcbiAgICAgICAgcGF0aG5hbWU6IGVsLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gZWwucGF0aG5hbWUgOiAnLycgKyBlbC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiBlbC5zZWFyY2ggPyBlbC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiBlbC5oYXNoID8gZWwuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGZhY3RvcnkoaGFuZGxlciwgbmV4dCwgdm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh2bSwgb3B0aW9ucywgbmV4dCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKHBhcmFtcywgb2JqLCBzY29wZSkge1xuXG4gICAgdmFyIGFycmF5ID0gaXNBcnJheShvYmopLFxuICAgICAgICBwbGFpbiA9IGlzUGxhaW5PYmplY3Qob2JqKSxcbiAgICAgICAgaGFzaDtcblxuICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXG4gICAgICAgIGhhc2ggPSBpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICBrZXkgPSBzY29wZSArICdbJyArIChwbGFpbiB8fCBoYXNoID8ga2V5IDogJycpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY29wZSAmJiBhcnJheSkge1xuICAgICAgICAgICAgcGFyYW1zLmFkZCh2YWx1ZS5uYW1lLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzaCkge1xuICAgICAgICAgICAgc2VyaWFsaXplKHBhcmFtcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHhkckNsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbmRXaXRoKHhkci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhkci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGRyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHhkci5hYm9ydCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhkci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmdldFVybCgpLCB0cnVlKTtcbiAgICAgICAgeGRyLnRpbWVvdXQgPSAwO1xuICAgICAgICB4ZHIub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHhkci5zZW5kKHJlcXVlc3QuZ2V0Qm9keSgpKTtcbiAgICB9KTtcbn1cblxudmFyIE9SSUdJTl9VUkwgPSBVcmwucGFyc2UobG9jYXRpb24uaHJlZik7XG52YXIgU1VQUE9SVFNfQ09SUyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5mdW5jdGlvbiBjb3JzIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoIWlzQm9vbGVhbihyZXF1ZXN0LmNyb3NzT3JpZ2luKSAmJiBjcm9zc09yaWdpbihyZXF1ZXN0KSkge1xuICAgICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5jcm9zc09yaWdpbikge1xuXG4gICAgICAgIGlmICghU1VQUE9SVFNfQ09SUykge1xuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnQgPSB4ZHJDbGllbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgcmVxdWVzdC5lbXVsYXRlSFRUUDtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGNyb3NzT3JpZ2luKHJlcXVlc3QpIHtcblxuICAgIHZhciByZXF1ZXN0VXJsID0gVXJsLnBhcnNlKFVybChyZXF1ZXN0KSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdFVybC5wcm90b2NvbCAhPT0gT1JJR0lOX1VSTC5wcm90b2NvbCB8fCByZXF1ZXN0VXJsLmhvc3QgIT09IE9SSUdJTl9VUkwuaG9zdDtcbn1cblxuZnVuY3Rpb24gYm9keSAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QuZW11bGF0ZUpTT04gJiYgaXNQbGFpbk9iamVjdChyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IFVybC5wYXJhbXMocmVxdWVzdC5ib2R5KTtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgIH1cblxuICAgIGlmIChpc0Zvcm1EYXRhKHJlcXVlc3QuYm9keSkpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdC5ib2R5KSkge1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpO1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnRlbnRUeXBlKSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDApIHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBqc29ucENsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIG5hbWUgPSByZXF1ZXN0Lmpzb25wIHx8ICdjYWxsYmFjaycsXG4gICAgICAgICAgICBjYWxsYmFjayA9ICdfanNvbnAnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpLFxuICAgICAgICAgICAgYm9keSA9IG51bGwsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgc2NyaXB0O1xuXG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDA7XG5cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnbG9hZCcgJiYgYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDQwNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbmRXaXRoKGJvZHksIHsgc3RhdHVzOiBzdGF0dXMgfSkpO1xuXG4gICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LnBhcmFtc1tuYW1lXSA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHdpbmRvd1tjYWxsYmFja10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBqc29ucCAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnQgPSBqc29ucENsaWVudDtcbiAgICB9XG5cbiAgICBuZXh0KGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PSAnSlNPTlAnKSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZSAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ocmVxdWVzdC5iZWZvcmUpKSB7XG4gICAgICAgIHJlcXVlc3QuYmVmb3JlLmNhbGwodGhpcywgcmVxdWVzdCk7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xufVxuXG4vKipcbiAqIEhUVFAgbWV0aG9kIG92ZXJyaWRlIEludGVyY2VwdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1ldGhvZCAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QuZW11bGF0ZUhUVFAgJiYgL14oUFVUfFBBVENIfERFTEVURSkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJ10gPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSAnUE9TVCc7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBoZWFkZXIgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHJlcXVlc3QubWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXF1ZXN0LmhlYWRlcnMgPSBhc3NpZ24oe30sIEh0dHAuaGVhZGVycy5jb21tb24sICFyZXF1ZXN0LmNyb3NzT3JpZ2luID8gSHR0cC5oZWFkZXJzLmN1c3RvbSA6IHt9LCBIdHRwLmhlYWRlcnNbcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKV0sIHJlcXVlc3QuaGVhZGVycyk7XG5cbiAgICBuZXh0KCk7XG59XG5cbi8qKlxuICogVGltZW91dCBJbnRlcmNlcHRvci5cbiAqL1xuXG5mdW5jdGlvbiB0aW1lb3V0IChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICB2YXIgdGltZW91dDtcblxuICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9LCByZXF1ZXN0LnRpbWVvdXQpO1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB4aHJDbGllbnQgKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aCgncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzLCAvLyBJRTkgc3RhdHVzIGJ1Z1xuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiB0cmltKHhoci5zdGF0dXNUZXh0KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyLmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICB4aHIudGltZW91dCA9IDA7XG4gICAgICAgIHhoci5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICB4aHIub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZXF1ZXN0LnByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaChyZXF1ZXN0LmhlYWRlcnMgfHwge30sIGZ1bmN0aW9uICh2YWx1ZSwgaGVhZGVyKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeGhyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoc3RyKSB7XG5cbiAgICB2YXIgaGVhZGVycyA9IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaTtcblxuICAgIGVhY2godHJpbShzdHIpLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gKHJvdykge1xuXG4gICAgICAgIGkgPSByb3cuaW5kZXhPZignOicpO1xuICAgICAgICBuYW1lID0gdHJpbShyb3cuc2xpY2UoMCwgaSkpO1xuICAgICAgICB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGkgKyAxKSk7XG5cbiAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0pIHtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaGVhZGVyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdID0gW2hlYWRlcnNbbmFtZV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuZnVuY3Rpb24gQ2xpZW50IChjb250ZXh0KSB7XG5cbiAgICB2YXIgcmVxSGFuZGxlcnMgPSBbc2VuZFJlcXVlc3RdLFxuICAgICAgICByZXNIYW5kbGVycyA9IFtdLFxuICAgICAgICBoYW5kbGVyO1xuXG4gICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xuICAgICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDbGllbnQocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjKCkge1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHJlcUhhbmRsZXJzLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKGNvbnRleHQsIHJlcXVlc3QsIG5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgaW50ZXJjZXB0b3Igb2YgdHlwZSAnICsgdHlwZW9mIGhhbmRsZXIgKyAnLCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbmV4dChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzcG9uc2UpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzSGFuZGxlcnMudW5zaGlmdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZXNwb25zZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXNIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHdoZW4ocmVzcG9uc2UsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UpIHx8IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoZW4ocmVzcG9uc2UsIHJlc29sdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgQ2xpZW50LnVzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJlcUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59XG5cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIHJlc29sdmUpIHtcblxuICAgIHZhciBjbGllbnQgPSByZXF1ZXN0LmNsaWVudCB8fCB4aHJDbGllbnQ7XG5cbiAgICByZXNvbHZlKGNsaWVudChyZXF1ZXN0KSk7XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEhUVFAgUmVzcG9uc2UuXG4gKi9cblxudmFyIFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHksIF9yZWYpIHtcbiAgICAgICAgdmFyIHVybCA9IF9yZWYudXJsO1xuICAgICAgICB2YXIgaGVhZGVycyA9IF9yZWYuaGVhZGVycztcbiAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYuc3RhdHVzO1xuICAgICAgICB2YXIgc3RhdHVzVGV4dCA9IF9yZWYuc3RhdHVzVGV4dDtcbiAgICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2UpO1xuXG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzIHx8IDA7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJyc7XG4gICAgICAgIHRoaXMub2sgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgICB9XG5cbiAgICBSZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHk7XG4gICAgfTtcblxuICAgIFJlc3BvbnNlLnByb3RvdHlwZS5ibG9iID0gZnVuY3Rpb24gYmxvYigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt0aGlzLmJvZHldKTtcbiAgICB9O1xuXG4gICAgUmVzcG9uc2UucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiBqc29uKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVzcG9uc2U7XG59KCk7XG5cbnZhciBSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZXF1ZXN0KTtcblxuXG4gICAgICAgIHRoaXMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuXG4gICAgICAgIGFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5nZXRVcmwgPSBmdW5jdGlvbiBnZXRVcmwoKSB7XG4gICAgICAgIHJldHVybiBVcmwodGhpcyk7XG4gICAgfTtcblxuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5O1xuICAgIH07XG5cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kV2l0aCA9IGZ1bmN0aW9uIHJlc3BvbmRXaXRoKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHRoaXMuZ2V0VXJsKCkgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBzZW5kaW5nIG5ldHdvcmsgcmVxdWVzdHMuXG4gKi9cblxudmFyIENVU1RPTV9IRUFERVJTID0geyAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcgfTtcbnZhciBDT01NT05fSEVBREVSUyA9IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonIH07XG52YXIgSlNPTl9DT05URU5UX1RZUEUgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04JyB9O1xuXG5mdW5jdGlvbiBIdHRwKG9wdGlvbnMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSxcbiAgICAgICAgY2xpZW50ID0gQ2xpZW50KHNlbGYuJHZtKTtcblxuICAgIGRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHNlbGYuJG9wdGlvbnMsIEh0dHAub3B0aW9ucyk7XG5cbiAgICBIdHRwLmludGVyY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGNsaWVudC51c2UoaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xpZW50KG5ldyBSZXF1ZXN0KG9wdGlvbnMpKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5vayA/IHJlc3BvbnNlIDogUHJvbWlzZSQxLnJlamVjdChyZXNwb25zZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cblxuSHR0cC5vcHRpb25zID0ge307XG5cbkh0dHAuaGVhZGVycyA9IHtcbiAgICBwdXQ6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBvc3Q6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBhdGNoOiBKU09OX0NPTlRFTlRfVFlQRSxcbiAgICBkZWxldGU6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGN1c3RvbTogQ1VTVE9NX0hFQURFUlMsXG4gICAgY29tbW9uOiBDT01NT05fSEVBREVSU1xufTtcblxuSHR0cC5pbnRlcmNlcHRvcnMgPSBbYmVmb3JlLCB0aW1lb3V0LCBtZXRob2QsIGJvZHksIGpzb25wLCBoZWFkZXIsIGNvcnNdO1xuXG5bJ2dldCcsICdkZWxldGUnLCAnaGVhZCcsICdqc29ucCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgSHR0cFttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcyhhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHVybCwgbWV0aG9kOiBtZXRob2QgfSkpO1xuICAgIH07XG59KTtcblxuWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgSHR0cFttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcyhhc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyB1cmw6IHVybCwgbWV0aG9kOiBtZXRob2QsIGJvZHk6IGJvZHkgfSkpO1xuICAgIH07XG59KTtcblxuZnVuY3Rpb24gUmVzb3VyY2UodXJsLCBwYXJhbXMsIGFjdGlvbnMsIG9wdGlvbnMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSxcbiAgICAgICAgcmVzb3VyY2UgPSB7fTtcblxuICAgIGFjdGlvbnMgPSBhc3NpZ24oe30sIFJlc291cmNlLmFjdGlvbnMsIGFjdGlvbnMpO1xuXG4gICAgZWFjaChhY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uLCBuYW1lKSB7XG5cbiAgICAgICAgYWN0aW9uID0gbWVyZ2UoeyB1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXMgfHwge30gfSwgb3B0aW9ucywgYWN0aW9uKTtcblxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsZi4kaHR0cCB8fCBIdHRwKShvcHRzKGFjdGlvbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIG9wdHMoYWN0aW9uLCBhcmdzKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgYWN0aW9uKSxcbiAgICAgICAgcGFyYW1zID0ge30sXG4gICAgICAgIGJvZHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3NbMV07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgICAgaWYgKC9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB1cCB0byA0IGFyZ3VtZW50cyBbcGFyYW1zLCBib2R5XSwgZ290ICcgKyBhcmdzLmxlbmd0aCArICcgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgIG9wdGlvbnMucGFyYW1zID0gYXNzaWduKHt9LCBvcHRpb25zLnBhcmFtcywgcGFyYW1zKTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG5SZXNvdXJjZS5hY3Rpb25zID0ge1xuXG4gICAgZ2V0OiB7IG1ldGhvZDogJ0dFVCcgfSxcbiAgICBzYXZlOiB7IG1ldGhvZDogJ1BPU1QnIH0sXG4gICAgcXVlcnk6IHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgIHVwZGF0ZTogeyBtZXRob2Q6ICdQVVQnIH0sXG4gICAgcmVtb3ZlOiB7IG1ldGhvZDogJ0RFTEVURScgfSxcbiAgICBkZWxldGU6IHsgbWV0aG9kOiAnREVMRVRFJyB9XG5cbn07XG5cbmZ1bmN0aW9uIHBsdWdpbihWdWUpIHtcblxuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBVdGlsKFZ1ZSk7XG5cbiAgICBWdWUudXJsID0gVXJsO1xuICAgIFZ1ZS5odHRwID0gSHR0cDtcbiAgICBWdWUucmVzb3VyY2UgPSBSZXNvdXJjZTtcbiAgICBWdWUuUHJvbWlzZSA9IFByb21pc2UkMTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyhWdWUudXJsLCB0aGlzLCB0aGlzLiRvcHRpb25zLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJGh0dHA6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS5odHRwLCB0aGlzLCB0aGlzLiRvcHRpb25zLmh0dHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRyZXNvdXJjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5yZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRwcm9taXNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZ1ZS5Qcm9taXNlKGV4ZWN1dG9yLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYm9udXMtYmFyXFxcIj48ZGl2IGNsYXNzPVxcXCJib251cy1pdGVtIGJldFxcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1iYWNrIGZvcnplblxcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1zaG93XFxcIj48ZGl2IGNsYXNzPVxcXCJiZXQtbnVtXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJldE51bVxcXCIgdi1odG1sPVxcXCJsb2NrbW9uZXlcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gY291bnQtZG93blxcXCI+PGRpdiBjbGFzcz1cXFwiY291bnQtZG93bi1iYWNrXFxcIj48ZGl2IGNsYXNzPVxcXCJjb3VudC1kb3duLXNob3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvdW50LWRvd24tbnVtXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIntmb250U2l6ZTo0MCp6b29tUmF0ZS54KydweCd9XFxcIiB2LWh0bWw9XFxcImNvdW50RG93biB8IHRpbWVcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gYm9udXNcXFwiPjxkaXYgY2xhc3M9XFxcIml0ZW0tYmFjayBiYWxhbmNlXFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLXNob3dcXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiPjxkaXYgY2xhc3M9XFxcImJldC1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcInVzZXJpbmZvLm1vbmV5LWxvY2ttb25leVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxQbGF5UGFuZWwudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNWZlYmQwYjAvUGxheVBhbmVsLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ucGxheXBhbmVsIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZykgNTAlIDUwJTsqL1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGhlaWdodDogNTAlO1xcbn1cXG5cXG5pbWcuY2hpcCB7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi50YWJsZS1wYW5lbCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDUwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmRpc3BsYXk6IG5vbmU7Ki9cXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIC4zKTtcXG59XFxuXFxuZGl2LnNpbmdsZSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LmRvdWJsZSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcXG4gICAgbWFyZ2luOiAzJSAwJSAwJSA4NiU7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LmJpZyB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5zbWFsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2Lm51bSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbn1cXG5cXG5kaXYuYm9udWRudW0ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9kZmMyNDA0YVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK05BO0lBQ0Esc0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtJQUNBLGtCQUFBO0lBQ0EsZ0NBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO0lBQ0EsZ0NBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO0lBQ0EscUJBQUE7SUFDQSwrQkFBQTtDQUNBOztBQUVBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLDRCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGtDQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiUGxheVBhbmVsLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOS4u+a4uOaIj+WMulxcbiAgICBkaXYucGxheXBhbmVsXFxuICAgICAgICBkaXYudGFibGUtcGFuZWwodi1lbDpwYW5lbCx2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5zaW5nbGUodi1iaW5kOnN0eWxlPVxcXCJzaW5nbGVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NpbmdsZScpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmRvdWJsZSh2LWJpbmQ6c3R5bGU9XFxcImRvdWJsZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnZG91YmxlJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uemVybyh2LWJpbmQ6c3R5bGU9XFxcInplcm9cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5vbmUodi1iaW5kOnN0eWxlPVxcXCJvbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50d28odi1iaW5kOnN0eWxlPVxcXCJ0d29cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMilcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50aHJlZSh2LWJpbmQ6c3R5bGU9XFxcInRocmVlXFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDMpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uZm91cih2LWJpbmQ6c3R5bGU9XFxcImZvdXJcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5maXZlKHYtYmluZDpzdHlsZT1cXFwiZml2ZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg1KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNpeCh2LWJpbmQ6c3R5bGU9XFxcInNpeFxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg2KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNldmVuKHYtYmluZDpzdHlsZT1cXFwic2V2ZW5cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5laWdodCh2LWJpbmQ6c3R5bGU9XFxcImVpZ2h0XFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDgpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0ubmluZSh2LWJpbmQ6c3R5bGU9XFxcIm5pbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoOSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5iaWcodi1iaW5kOnN0eWxlPVxcXCJiaWdcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2JpZycpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNtYWxsKHYtYmluZDpzdHlsZT1cXFwic21hbGxcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NtYWxsJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5mb3JtdWxhKHYtYmluZDpzdHlsZT1cXFwiZm9ybXVsYVxcXCIsdi1odG1sPVxcXCJib251c051bVxcXCIpIFxcbiAgICAgICAgICAgIGRpdi5udW0uYm9udWRudW0odi1iaW5kOnN0eWxlPVxcXCJib251ZG51bVxcXCIpXFxuICAgICAgICAgICAgICAgIHRhYmxlXFxuICAgICAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkKHYtaHRtbD1cXFwidXNlckJldC5iZXRudW1cXFwiKVxcbiAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcInRhYmxlUGFuZWxJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICdiZXRzJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHRhYmxlUGFuZWxJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcnKSxcXG4gICAgICAgICAgICBjaGlwSW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nJyksXFxuICAgICAgICAgICAgaW1nU2l6ZToge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUyOFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIC8vIFRPRE8g6YeN5paw6K6+5a6a5Lit5aWW6KeE5YiZXFxuICAgICAgICBib251c051bSgpIHtcXG4gICAgICAgICAgICB2YXIgbnVtcyA9IHRoaXMubG90dGVyeW51bS5sb3R0ZXJ5bnVtcy5zcGxpdCgnLCcpXFxuICAgICAgICAgICAgdmFyIHN1bSA9IHBhcnNlSW50KG51bXNbMF0pICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKVxcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1zWzBdKSArICcrJyArIHBhcnNlSW50KG51bXNbbnVtcy5sZW5ndGggLSAxXSkgKyAnPScgKyAoTWF0aC5mbG9vcihzdW0gLyAxMCkgPyBNYXRoLmZsb29yKHN1bSAvIDEwKSA6ICcnKSArICcoJyArIHN1bSAlIDEwICsgJyknXFxuICAgICAgICB9LFxcbiAgICAgICAgc2luZ2xlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZG91YmxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB6ZXJvKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB0d28oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdGhyZWUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZm91cigpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmaXZlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2l4KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V2ZW4oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBlaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG5pbmUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBiaWcoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgOCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc21hbGwoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JtdWxhKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDIyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gVE9ETyDpgY3ljobkuIrmnJ/kuIvms6jorrDlvZXvvIzorqHnrpfnrZvpgInmmK/lkKbmnInkuK3lpZblj7fnoIFcXG4gICAgICAgIGJvbnVkbnVtKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgYmV0KGV2ZW50KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hlaWdodCcgKyBldmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0KVxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXaWR0aCcgKyBldmVudC50YXJnZXQub2Zmc2V0V2lkdGgpXFxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgLy8g55So5oi35LiL5rOoXFxuICAgICAgICBkb2JldChudW0pIHtcXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyaW5mby5tb25leSAtIHRoaXMudXNlckJldC5iZXRtb25leSAtIHRoaXMubG9ja21vbmV5IDwgMCkgcmV0dXJuXFxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnREb3duIDwgMTApIHJldHVybiAvLyDlgJLorqHml7blsI/kuo4xMOenkuaXtuemgeatouS4i+azqFxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnTlVNQkVSJ1xcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcXG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpZyc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmJldHMucHVzaChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVzZXJCZXQpKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIGNhbmNlbEJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuYmV0cyA9IFtdXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5wbGF5cGFuZWwge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA1MCU7XFxufVxcblxcbmltZy5jaGlwIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LnRhYmxlLXBhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpO1xcbn1cXG5cXG5kaXYuc2luZ2xlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuZG91YmxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuYmlnIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LnNtYWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYubnVtIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XFxufVxcblxcbmRpdi5ib251ZG51bSB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFZ0FBQUJKQ0FZQUFBQ2VzV0RpQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGUlVFNVJUazROek5HTlVReE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZSVUU1UlRrNE9ETkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVkZRVGxGT1RnMU0wWTFSREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tWRlFUbEZPVGcyTTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrVXYySElBQUFCRHhKUkVGVWVOcnNuTEdPRkRFTWh1UE02QkRGRmJSWDh3UjB4eXZ3S0R3UGo4SnJVQ05FVFVkMUJUcHBKeUdadFhQL2VEUEw1SVRBSUVmS0p1ek1MY21YMzQ1M0ZROTkrSnhES2V1TGwyMTVmLytXWW5tNWNSUzc1U2FXbDF2bnNGdHVLNkFYem1HM3ZKaDc3LzU0OXpwTVJHdWRTNDNjajlDbmNsL2tscmkxVktwVHpUbXZiZUoyS1czaUt2MFQ5MnQ5K2ZIcnhlZDBBUW1ZS2NZK0pJSERmWUZrQ2xDRlVzYVV1RjloMURFTG5NaHd5c1ZBS2UxK3ppNmdDbWRtS0ZnUkZLb25HZ01rcW1tZ1JEVzhvQXZmdDQ2NnpEWHZRT29DUWpCelQwVU1abUlvMGFLSk1aUXkwTE5pZUp5aUh1SWFDcGcxeGluWDhsRkFVVXdNL0JDcUJ4V0VjS3lZV1ZVTlFrTFRhcW9Ca05JdUl5WVdGWnllaVVWbFhtUklQV0ptQW9mQXBCWjFiK1k1THlNS21qbzdsL2dta1dzRWN5TkxnTGpXc1luUEVYKzVzSytSZXlZR2xIYlV2d3NvZGt4SzRDQzRDS1psQVZLRzcwMFo0Wnh0cnpua1NadzU3TXBEdTFoVTdVVy9ZMkpXZHJMRXZpWnBRQXhKTnBmTS9RVHZIUUpFb0NKQ3RmU3FDaFF0S0VqTWhoaVNWcGRVd3BndTV6RVRrMGxqMU55RFl6R2F4dmduOEZhdkFTVlFqNGhnVEVIZ1c1b3B5ZnZTMTF1OUFVaXJNaUE0akF4Sm5IWm1WVWxNdE1LQlhlNFlJTmlWTmhEQTVNam85ekdTYlI2M2VGWjdoc1VWZU1Sd2FGUkJCRTQ0ZFB3TFFpRkR3V0lXTlRBa1V2NkZPcjZXcnZpZ2VHaFZRRkVYZ2FHeFNKcDJ4aGJWSEk2T2RYNk9oTHV0a1doYWRpZFJrcGhWZnViWVl2RGlnQnlRQTNKQURzZ0JPU0FINU1VQk9TQUg1SUFja0FOeVFBN0lpd055UUE3SUFUa2dCK1NBSEpBRGNnUU95QUU1SUFma2dQN1pNbncrS0hmYTlmd05uK2F5a052WlVoRjJ4dnpiRlNSNVYzaEN0UDJIZkEwSFpnWU9qQzJwT1J3ZDY3eW5Fc214eW5CVUxYZnV3YU8yWkFVU0xpcEE2czFobmFPNjU5ZUFlT0x0QStSSWJYZzZSaXVuU1RkSGJZMGNBdzRxMDdBdE50ZWtyMTlaMkYwRlNhWmV3SlNpOEhRSU12RkE4S2d0WFZtSnY2V2d4RWwwTXFlazNRUmNQd3lvMFpZRU5FZ3AydVE5ZEk3YW1sQVF1Z21CcEtya3NLTEN4aFFrZVo3YzN4eWhWZmVLcDQ5R2RyR1d6SUlxNmtGU3dBNERFdFZnZXhZTU8rU3d6Y25DbmNKVU9wUlNrT1NzTHFvdjdaQ0pKZldIYTZaZVRVYUxzVG5CSERvNVdWWjhVTS9FZUE0SlVzRlJVVU9BRmxhREpIcEl1dUthak1hbTFCSkR4Q1VaQXRRenNVVzFHdFNZaWRVL0RHR1R3N0RtWWlrL0pRNjhtYUN4U0JvaExRclNTZjE3U0VFbm1iUUNGT0JyeFFSK3FxVThHbEtSTE53aURqbUU3aE1YVHFNS2FrOGtXR21sYzlESVFCS2taMkw4WS9yQkFxQWdWTktpSUUwakprYnNrTE55Zkp0Y0swaEdNL2xvQ2doNEV6anNDeFdWdVM2amdNUWhCNldlOW5BVE1LMXIrVlpXb3VrakR6YzViR0w0RkpUTU85anluLzdlTThIRzR6K1krUytLRHVpUEZ3cXY3dTlLKzZiVU84ZXhLZDlLL1ZTZDlHT3AzNTNIUmFsTUhpdWdoMUsvQkgvWW15NVZPQTgvQlJnQTNWMk10bFduUitzQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmdcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g5Li75ri45oiP5Yy6XG4gICAgZGl2LnBsYXlwYW5lbFxuICAgICAgICBkaXYudGFibGUtcGFuZWwodi1lbDpwYW5lbCx2LWJpbmQ6c3R5bGU9XCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc2luZ2xlKHYtYmluZDpzdHlsZT1cInNpbmdsZVwiLEB0b3VjaGVuZD1cImRvYmV0KCdzaW5nbGUnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzaW5nbGUnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmRvdWJsZSh2LWJpbmQ6c3R5bGU9XCJkb3VibGVcIixAdG91Y2hlbmQ9XCJkb2JldCgnZG91YmxlJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnZG91YmxlJyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS56ZXJvKHYtYmluZDpzdHlsZT1cInplcm9cIixAdG91Y2hlbmQ9XCJkb2JldCgwKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0ub25lKHYtYmluZDpzdHlsZT1cIm9uZVwiLEB0b3VjaGVuZD1cImRvYmV0KDEpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMSBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS50d28odi1iaW5kOnN0eWxlPVwidHdvXCIsQHRvdWNoZW5kPVwiZG9iZXQoMilcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAyIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnRocmVlKHYtYmluZDpzdHlsZT1cInRocmVlXCIsQHRvdWNoZW5kPVwiZG9iZXQoMylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmZvdXIodi1iaW5kOnN0eWxlPVwiZm91clwiLEB0b3VjaGVuZD1cImRvYmV0KDQpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNCBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5maXZlKHYtYmluZDpzdHlsZT1cImZpdmVcIixAdG91Y2hlbmQ9XCJkb2JldCg1KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDUgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc2l4KHYtYmluZDpzdHlsZT1cInNpeFwiLEB0b3VjaGVuZD1cImRvYmV0KDYpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5zZXZlbih2LWJpbmQ6c3R5bGU9XCJzZXZlblwiLEB0b3VjaGVuZD1cImRvYmV0KDcpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5laWdodCh2LWJpbmQ6c3R5bGU9XCJlaWdodFwiLEB0b3VjaGVuZD1cImRvYmV0KDgpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOCBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5uaW5lKHYtYmluZDpzdHlsZT1cIm5pbmVcIixAdG91Y2hlbmQ9XCJkb2JldCg5KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uYmlnKHYtYmluZDpzdHlsZT1cImJpZ1wiLEB0b3VjaGVuZD1cImRvYmV0KCdiaWcnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdiaWcnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnNtYWxsKHYtYmluZDpzdHlsZT1cInNtYWxsXCIsQHRvdWNoZW5kPVwiZG9iZXQoJ3NtYWxsJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc21hbGwnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmZvcm11bGEodi1iaW5kOnN0eWxlPVwiZm9ybXVsYVwiLHYtaHRtbD1cImJvbnVzTnVtXCIpIFxuICAgICAgICAgICAgZGl2Lm51bS5ib251ZG51bSh2LWJpbmQ6c3R5bGU9XCJib251ZG51bVwiKVxuICAgICAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZCh2LWh0bWw9XCJ1c2VyQmV0LmJldG51bVwiKVxuICAgICAgICBpbWcodi1iaW5kOnNyYz1cInRhYmxlUGFuZWxJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ2JldHMnLCAndXNlckJldCcsICdjb3VudERvd24nLCAnY291bnROdW0nLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFibGVQYW5lbEltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZycpLFxuICAgICAgICAgICAgY2hpcEltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZycpLFxuICAgICAgICAgICAgaW1nU2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MjhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgLy8gVE9ETyDph43mlrDorr7lrprkuK3lpZbop4TliJlcbiAgICAgICAgYm9udXNOdW0oKSB7XG4gICAgICAgICAgICB2YXIgbnVtcyA9IHRoaXMubG90dGVyeW51bS5sb3R0ZXJ5bnVtcy5zcGxpdCgnLCcpXG4gICAgICAgICAgICB2YXIgc3VtID0gcGFyc2VJbnQobnVtc1swXSkgKyBwYXJzZUludChudW1zW251bXMubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtc1swXSkgKyAnKycgKyBwYXJzZUludChudW1zW251bXMubGVuZ3RoIC0gMV0pICsgJz0nICsgKE1hdGguZmxvb3Ioc3VtIC8gMTApID8gTWF0aC5mbG9vcihzdW0gLyAxMCkgOiAnJykgKyAnKCcgKyBzdW0gJSAxMCArICcpJ1xuICAgICAgICB9LFxuICAgICAgICBzaW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHdvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDMpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiA0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZml2ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2l4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXZlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5pbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogNCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJpZygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDQyNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtdWxhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMjEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDIyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETyDpgY3ljobkuIrmnJ/kuIvms6jorrDlvZXvvIzorqHnrpfnrZvpgInmmK/lkKbmnInkuK3lpZblj7fnoIFcbiAgICAgICAgYm9udWRudW0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNDAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYmV0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGVpZ2h0JyArIGV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2lkdGgnICsgZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoKVxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOeUqOaIt+S4i+azqFxuICAgICAgICBkb2JldChudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJpbmZvLm1vbmV5IC0gdGhpcy51c2VyQmV0LmJldG1vbmV5IC0gdGhpcy5sb2NrbW9uZXkgPCAwKSByZXR1cm5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA8IDEwKSByZXR1cm4gLy8g5YCS6K6h5pe25bCP5LqOMTDnp5Lml7bnpoHmraLkuIvms6hcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdOVU1CRVInXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdTSU5HTEVfT1JfRE9VQkxFJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmV0cy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudXNlckJldCkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBjYW5jZWxCZXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYmV0cyA9IFtdXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5wbGF5cGFuZWwge1xuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcpIDUwJSA1MCU7Ki9cbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDUwJTtcbn1cblxuaW1nLmNoaXAge1xuICAgIHdpZHRoOiA1MCU7XG4gICAgaGVpZ2h0OiA1MCU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG5kaXYudGFibGUtcGFuZWwge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNTAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAvKmRpc3BsYXk6IG5vbmU7Ki9cbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpO1xufVxuXG5kaXYuc2luZ2xlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LmRvdWJsZSB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xuICAgIG1hcmdpbjogMyUgMCUgMCUgODYlO1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LmJpZyB7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LnNtYWxsIHtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxZW07XG59XG5cbmRpdi5udW0ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XG59XG5cbmRpdi5ib251ZG51bSB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aYvuekui3nuqIucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFBsYXlQYW5lbC52dWU/ZGZjMjQwNGFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFvQUFBQUlRQ0FZQUFBQVJxOTlnQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGUlVFNVJUazRNek5HTlVReE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZSVUU1UlRrNE5ETkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVkZRVGxGT1RneE0wWTFSREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tWRlFUbEZPVGd5TTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrdmNsaEpRQUFYU05KUkVGVWVOcnMzWG1VSE9WOTcvK25laFpwdEk1Mk5FS0kwVWhDRWdJRXdrSmd6Q0lqZ3NFbUFYT0liY0RZTitjZUhBZHdFbzdqRGZzUFg4ZEo3S1BjWHdBbjVwZGpZNExCdVZ4c3gyQXdObVlUQWduRll3a2hKTFJydEl6UU9qUFNqR2J0N3R2ZnA2cDZ1bnQ2cWVxMXV1cjk0alNqMlh1cWEvblVzM3dmUTAyNnZFWXBGVkltUXdFQUFNQ1BvdGJiaUJFTGdHTmkvNmkxUWlBQkVBQUF3TDhCTUJKN0RFa0FuQmI3UjcwVkFtdllOZ0FBQUw0VWx2QVhld3hJQUd5Si9VTmFBVWNSQUFFQUFId2RBUHRqanpPMVZ2aWJFSHMwS0xNVkVBQUFBUDRqclgrOXlncDhvNnp3SjBHd2ptMERBQURnUzRQVzIzNTczRit0RmY3cTJUWUFBQUMrcGJPZjhZUDNvMUcyQlFBQVFMQlNvUHJKNzk1bVN3QUFBQVRBNTY2L0xGNEFHZ0FBQUFGQkFBUUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDaVIybXlmdlBPSzg5aEN4VXpiTlRWc0JBQUFNb2lFNnRnSVJmVFQxOS9KTHdDSzcveWZWOWlDUmZLdHo2eFNxNS8vQXhzQ0FJQTAvdVlUbDZ2dnZyS0hEVkVFWDE4NU4rdm42UUlHQUFBSUdBSWdBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBR1l6WjF5OXVtLzVPYTYvNThuUExGTVBYdDJpL3cwQUFBQ2xhcjMrQkcrYU8xbDlaa1d6dW1KaGt4bzd1azQ5dS9VRDFkWTk0T2g3NzcyeVJhMWFPa2MvN3IvcElyWCsvY05xdys2ajZxWDNqNmkzajNUejZnTUFnS0s0WSs0NE5XbDBqWm85c1M3cDR3ZTZCdFVqVzdzSWdFNUpxOTNLSmJQVWtqbFRSNFM2TDcrNExlZjNTNHZmYlZmTVMvcllpb1V6OWVQK201VDZ4T3JmRVFJQkFFRGNqVTBOT3NUWmRuWU9xQTBuQnpKKzdkVnp4cXBsczhlcUpVMWpzLzdjZXk2ZnJyN3ltNFBxaGZaZUFtQTIwdW9uTFhacE4vaXlPWTRDb0FSRmFURk01L0ZYdGhIK0FBQUlzT1dUNjlXcWM4ZXFEODBlcDFxbWpsYlR4cWZQREh1UDk2bEgzanFxbnR4ajVvWjdGMDlVZDF3eVJUWEh2c2NwK2RrL3ZyMVovWStuOTNvbUJIcHlET0R6ZTA2cXZVZlNONWRPbXpoR3R3NW1jOW1NY1NOYS8ydzlmWVBxa2JXNzJmTUJBQWlnYjF3eVNmMys5am5xMmMvT1UvZGROVk90YUI2Zk1md0pDWHFyYno1SGY1K1FMbDQzNFMvUlAzM3NiTTlzQjg5T0FubnVEL3N5ZnU0dlBybzQ2NlNPK3o5NlhzYld2eCs5dk5YeEdFSUFBT0FmY3hwcTFQOVlNVDFubDIwNkVoYWwxZkRuMjAvbC9mc2xhTnBCa2dDWXdST3RCM1JyWFRvUzdyNjJhbUhhejBucm4wejZTT2RZMXhuMW5kZHAvUU1BSUlqYWVzTnEzWjdUZVgvLy9jdW42akdCVzlwNzh2NFoxODZiUUFETStpSjFENmhuM3RvMTR1TVNDbVVNM3orODlINXlxaDlYcis1YWNwWmFNRzJjL3J6TStKWEFsK2huYTNleTl3TUFFR0MvMlpGL0M5N2xjOGZydDYvdXl2OW41TnQ5WEd5ZUxnTWprejJ1T3I5Sk5jK1lxTi9mMG5aYzdXanZWRTJUeDZqSDdsNmhQNTZwcXplZFJiTWE5ZmhCeXNBQUFCQk1NcG5qcTZjSHM0Nzd5MlJzdlRsRCtLZmJUdW11WlB2OVk3R2Z0M2IzS2JWMmY0OWFlN2hYdHpUdS91SjU4YytuK3hrRVFJdk0vSjA4cGw2dDJYY3lQa1pQQ2o4ZjZUZ1RENEJTRWlhMUxJd2J3elVCelRENTJPczcxQk5iUHVCb0FBQWdRQ1NzM2JKMFN2ejluZ0d6YS9oUTE0RGFmS1JQWFhuTzJLVFBwN0s3a2krYU5WYjk1OGJqNnUvLzJESGlhMlQyY0Q1akRRTVhBQi80MkpKNHVKTVp3SGJvS3hYNVhhcy9PMVY5ZU4wdTlZVmZidVpvQUFBZ0lCN2IzS0VEbnJUY3BRdHdGODdJM1UzNzBJYmphc1BKOW95Zm56RSsvV1RWUXNZUCtpNEF5c1NOeEphOVVvZS9STGRlUGsrTmI2aFRkenpWeWhFQkFFQUF5RVNPaDljY1R0dHlKODZiM3BBenZHVXFFQzFrdG5DbUx1YnUvb2dudG9FbkpvRjgvb3E1RmYzOTBpMzgvUnNXY1VRQUFCQVFtY0tmaERlcERaak96cU45em5MTmhabEx2V3cvNm8xQzBKNW9BZnpJNHFhaS9KeVhOcldwOXBQSk0zK1h0VXpURTBWeXRTcEs0V2duSzR3QUFBRC8rdVI1bWN1MHZPY2dBRXF0d2VzWE4yYjhmQ0YxQkgwVkFHWHloNnp1a1kyVWM5bTA5NWphZHFoVGZlTFNjek9HT2ZuOHlEcC9acWlUYnVhSDdyd3M0L2RLU0pSSkp3OXYyTS9lRHdCQUFFbDR1KzNpOUpNL1pLTElJMXU3Y3Y2TU94ZE55RGpUVjhZY1p1czZEbFFBdkdiQmpJeWZreGE5cDlidjFVdkQyYVNVUzZZUU43RWg4K29nVXZibC9wKytyWjU3NFBxTVgzUE81TEhzL1FBQUJDRG9DWm5ObStpTFN5ZGxERysvMjlycDZPZEtlWmhNWHRqYTRabHRVUEVBS0YyMG1kaGxXK0xwdTI5UW5la2Z6UHF6dm4rRFVsMjlBNnJ0UkkvYWNhdzdxZDZmL0Z0Q1phYVZRczVyYXVTb0FBREE1NlNWVG9MYWo5Y2ZqWThGbExGL2QxK1dPYnpKek9GY3NnVklhVUg4MTAwRXdEZzNNMzZsbXpaYjRlZlVPb0gvNjVrL2pDajRuRHBHTU5HNGhqcU9DZ0FBZk81RHM4ZnBvQ2JyKzM3cTRxbTZGRXkySmRwKy8zNW56cTdiWEFIeW1ZMG5SclE0QmpvQXVsbkp3NjNPTXlOZnJNMEhPOWp6QVFBSXNNUlp2bEt1UllKZ0p0SnlKelgvYlBjdW5xaXVtejlCL2ZlQmJyMGlpQjNxL3VYR3M3UCtEQysxL2xVOEFNcmF2UUFBQU9VaUFjNk5kdytkU1dyOVczSE9XQjBnNVNIQmNmM2UwNnE3UDV4MWpWK3Z0ZjVWUEFEbUlpdUNySG12ZmNRNFFhZkx3YVZiNXUzQ3N5ZXg5d01BRUZBUzRGeDlmU3pvZmZEWGkzWFErN05mSGRETHY2VitQaHVaK2Z1VmRjYzl0eDBxR2dBbG9LM084bmtaSHlnQmNPVVAxaVI5L09qM2JzMzRQWSsvc2szdFA5bVRka2F2Rkh1V2VuK1pkUGNPY21RQUFPQmpxUUhPS1NuZ2ZHTlRROFlWUHJMNXQydG1xRlA5WWIzT2NFZGZXTDNRWHZsaTBCVnZBWlFhZjlucUFONjkwZ3h0MGhyWXV2dVkvcGpNQnM0MmRsREcvc25qd2F0YmRHbVlwc2xqMU5MbWFUbnJEVzV2NytUSUFBREF4Lzd4MWNQcXE5Zk9kQjNrRG5RTnFxdm51QStQOG50azNlRlVEenk3WHoyNXB6dTRBZkNGMWpZZDhyS1JzSmM2d3pkYllNeUhoTXBIMXU3bXlBQUF3TWNrZEhYMEhWUS92cjNaMWZkdCtLQlgzWEhKbEtJK2owcXErRnJBc3Z5YXRPNVYyai8vK2gzVjFqM0FrUUVBZ0k5SnNlWnZycHpwNm52c0ZUelc3RDZsLzEyb0xlMDlGZDhPSVMrOEdMYy8rb2JhMGxhNUFaSVBQZjhPUzhBQkFCQUFQL3JFMlZsbjdPNDlQbks5MzkzV3gyUXl4OGVmMnFQTHVoUmlwNE0xaFV2TkU3T0FwZVZOSm5ySW1MMVBYemsvNTFpOVlwSFF1Zm8zVzVLV21nTUFBUDdWZXFCSExXbEtQNWJQbnVrcjdwZzdUbDA0WTdTYU1LcEdIVHcxM0VQNEw5YzNaVnp0dzZuRW54Zm9BR2o3enV1NzlVUHFBMzU0L25TMW9LblJjY2tYSjJTY256Mlo1Sm1OQjBhc0VnSUFBUHhOV3ZGbVRheFgxeTFNWHY1Vld2Nis5THYyK1BzeVJpOTFuTjVQYjJqS1d2WkZXZ2EvOWVJaEhSelBtOTZnV3FhT1RqdlpaT01IdEFDbUplVmhFbXY0WFRaam5Gb3diWnorOTV3cFkvWE0zbXlUUGFRVWpMRFhCQlpyOXAxa2pCOEFBRkIzdnRpdS9tdFVUVHpNU1hEN1g2OGN6bHFzV1ZvRVUwTmpLZ2wvNllLamZPK2swVFZxOWtRekRGSUd4aUZwcWZ1Z1owQmRkZTVrSzlCbEh6eVpXamhhNmdtbUt4c2pRVkVtb1FBQWdHQ1IxcjcvL09RY05YMUNuYnJ2di9ibkRHVVM2dTQ5M3BkeC9PRGpieC9OT0xPMzBqTitQUjhBcFZDek9LK3BVWTFycU5PaFRjS2JXOFhzTmdZQUFQNGpyWDJmK25tYitrVHpPTWN0Y3ZMMUVocFRRK0R2MysvMDVHb2ZWUk1BcGVXdW5PRk5Da1FEQU9BcjBXakMyMmpzamZuV01HcVVDb1hZUGlraDhKR3RYYTYrL2tzdkhGUS8rMVJ6ZkNLSWpCMlVMdVZxRStnOVllYWtzZXo5QUlEcUZ3bXJTRiszQ3ZkMHFzaVpVN0ZIbDRyMHh0NzJubGJSMk1lamZUMHFHaDdRUVJDRmtYcUEwbVVzNHdZbC9FbXJZRFh5VkF2ZzRZNGV1bThCQUhBcEtzRXVHbFdHOVo3OHc3RGVHdzZKRWJOVjBERFlZQVdTTHVOSkx4NVNhdy8zWnAwNFFnQjBxUDNrbWFMOEhGbGZXSmFZeTJiendRNTE4Z3l6Z2dFQTFjOHdRc3FvcVZXSm1jOUlDb2lTL2NJcUdnbkh2bzV1NEdMdzRzU09xZzJBd2w0UnBMdDNVRzF2NzlUL1Rpem5JcUZOQ2pmZnQvd2M5YzNiTGszN000NTBubUYyTHdBZ1NBbFFxVmdBTktLUldQREwwTTBiaWFob2VFaXBVQzJ0Z1BCV0FEUkRtN1BnMWhrTGduWlkzQkVMaXFkamdkRU9panVPVWVBWkFCQ29CT2dnSXhxNkJURDJ2OWc3Tld3eUFtQjFTaTBXRFFBQU1zZkRhQ3dBR3BHb2JnV1VMbU5hQVlPTmdRQUFBQVFwQ1VhR0ZMT0JRUUFFQU1BMzZTNXp0RFBzcjRqSVpKQUltNHNBQ0FBQS9KRC9jcmJyR1ZaeEdHa0ZqTklLU0FBRUFBRFZud0FkVGdaUjRTRmRGZ1lFUUFBQTRJY01tT3ZUMGdvb000SHBCaVlBQWdBQW42ZS9wQzgxOUZoQVhSSUdCRUFBQUZERitjOElPZnN5K1lkMEEwZm9CaVlBQWdDQUtnNkFzVXQ2VFozRHJ6WE1GVU1JZ0FSQUFBRGdpeVRvTUFOYTNjQ0VRQUlnQUFBSVNFVFVBZEJhSHhnRVFBQUFFS0FnS0JOQnFBbElBQVFBQU5VYjZhTG02RDVuWDYwWENZNFNBQW1BQUFDZ2l2T2Y0Mm93aVRVQm94RzZnUW1BQUFDZ3lsT2dDOUw2SitNQVBWSVRzQ1prOEJJU0FQMWpWRjB0R3dFQTRMMjRxTHVCSTU0SWdPRllHRzBjemZXU0FPZ2pFOGVOVVlOaHB0b0RBRHdVL3F3RUtLTUc5V3pnQ284RjdEb3pvRnFtak9HRklRRDZSMHZURkhXcWQ2QzYvd2c5VU5oYVA1SzZVUURnelVobjVIbHA5OERTY0h1UG5WSVhOWTAzV3lWUlVyU3psdU53ak8zSkZ6YzNxYmJZanUzNWpEYzBHRHNKREZsNXo3NFRqQ3B6U2xsME9BakszMVZiRjd1RnFJbjlmU0g5RmdCUThRdU9Vald4ODNIVWVaZ3o0dmY0RWIwMG5GSEI4L21XL1Irb1M4NmRxaTZaTlVHMUhqekY2MGtBckc3THo1dWpwb3h2VU05djJ1dmRKeW5GUUlmNnpRRG84S1FSSFl6b2swM1VpSVZBT2VGSUVJdzlqQnAyS3dDb1lBbzBnNkNiM2x3OUd6aHFyZzBzTi9rVmFvSTcyZFd0M3RsL1FsMDNmNG82Y1daUTdUdlp5OHRaSW5RQmwxaEwwMVIxM2RKNXNSMzZtRHArMm9NN3N0enhEUTJveUVDdmZxc3JTRW1JQzRWVUtPT2pScjgxckJPR0NnL0d3bUFzUE1yUHNCK3hqd0VBS25ScWo3ckxmMVpzMU4zQTBRb1A4Vm56N201MXNLTkgvZmxGWjZsTHo1NUFkM0NKMEZSVHF2dXYyQjU3NllKejFLcFkrRHZVY1ZxOXR2V0E1ODRPVXZkSnQvaEpXSXU5YjlpaFR0ODk1ajVWNkx0Ris2NHhmc2FKNkRDbzVPZldEc1VlOVJYdFRnQ0FBRjZCOHZvT2ZUNjNsNGFyWUU5T09QWWNmclh1UGZXUkMxclVxZ1ZUZEhmd3h2YlRhcytKTTZxamQwaEZLRnBOQVBTYXVycGFOV25jR0QzaFE4YjhTYmZ2dXdlT3ExZGo0UzhjOGNnT0syRk51bmlIQnVMZHZUcjBXZUhQbkEzbU9PWEczeHJ5NXhtSlFUQnFCa0c1azVRUUtDY1Rnd1pud0l1azlkK2MyR1dZNDNybHBpM0U4VnJWK1U4bnVyeGFMNGJIRDFid25DMGg4TFYzZHFwMzloNVdGNXg3bGxvV0M0RWZuVGRaaFdnT0xFOEFETlhVcUc5OVpoVmJ5WVhCY0VTZDZ1M1hFejVrekorbnVuMTFkKytnTmRFanJJL3p4T0NYejMyamtmQ1BxTmwycVA4Zk5heWxoYVE3UWJxRVl3SFEwSzJCdFlyMmZNQmI0VStPMFhqNWo5aEZQeHF5eHZYR2psY2RCamxtcXpRRjV2TWRoamtaSkR5a3o5bVYxbkdxVzYzWnZFdXQ0UVYxN1lHYkxzMC9BSXJWei8rQnJlaW5FLzFndjNtUWh3eXo1Uy9QNEpjckRKb3hVRmVXR2c2ZTBzSlFVeCtmUFF5ZzB2ZUU0WVJ6UXNnS2dWRTlobGVQNDVVYk5nbUNjZ1BIelp1dncxL2l0eG9SY3g5UUhnaUFLQjI2Z0lNa0VqRmI2S1RWenhyblY2clR1V0gvVDNjUGgzUkpHZjBZN0RQTEROU1BNaThvQUNwNFRnaVBPQ2ZJVGR2d3VGNEppRVBtTW1FU0JuUVFES25TblRuZ2hSQW9EUU5ScXdlSG0zVUNJUHh3T3BCdUhSbmI0V2FjWHhGT1FWRzdwZEVlR3lpdEMvMFJhMnhnSFdPTmdJcWRGR1Q4cnhFZk1oWS9hbzJVU1Y3U2lpL2R4SExUVnNlWVhyL0hSbk15U0ZUMzNCajFCRUMvNGdnTzJNbStuT0V2OFlSaVdIZVZNb0JYbDVDeExpaVJ3VDVXRlFFcWRyRzNadjFuT0Y3Tmgxa1dTcmY4UmMweHZaR0JQaytzRzRzYzUvdENUOXl5S0FDdk13RVFLRW9RdEdjYzI1TlBkQTNDUGwyU0JrQzVyd0FoRmMzU2ttZkU3eHV0bXpmN0JsS08yLzR6NXJLUThHYjRLNkNWMXA3TXAxRnloUUFJN2dpTEhRVHR3dEtHMUNPVUVCZ21CQUxsUFJoRGpvWmdKTjY4MmNldHRBNUYrbnM0YnIxOXkxM1F0K3Z1WUc3T0NZRHd5d25CUTZjbXUzdEpqemNKczRJSVVBMW5FT3U0RFJuV1VJNitXQWlVMWtDNkNqMG5xdklyQlpqMEUxd3NEd29DSUx4OHQrK3hnZHVKdFFqdGNZRzZLQzJBTWgyRU5hN09DMGJTY1JzeTZ3YnJMdUZleHZQNkxPenJ3SzhuN3ZHNkVnQlI1YTkyU0VWcjY3T08rYW5ZaWNZZUZ5Z25HK2tPbGxWRUFKUmVUYTB1L0p6ZmNXc2tkd25MRFJ4ZGh0NjZ3eTd3Ky9XUGtPb1JUdHNTcGJXUWNZTlZnVEl3Z1F1QlV0ZzFZamJySys4Y3BIYlhraDZQRkxIV0U1WjZaTFdqS0Q0TGxKcFY5eStmbFlDaTF2cmhJUlV4QzB0TFMyRDlhTFBFRTZvL1ErcjhOeGk3U2FnMXkvK00zSG5NYzdaTUNKTHgzTmFTZ2tuMUltdFlVWVlBQ0crYzYwTjFPZ1FhWVJkM2RaVUtnYkVMazFFM21oTUhVTklid3hwci9kZG9Yc2R0VkU4WWtBdCt4Rno1UjhyRTFFVTlzWlFZOGEzQThLZUdhMEVtaFQ3NW1JUys4SkE1ZGx1My9LbjROU1VhVGxocFFGYWhNcXk1eGJXMVZ2MVg2Z3NTQUZHQmM0S2hvald4RTNPa1R4L1luanRkV2JNTkkzS0NrZkdBRWdMclIxTjRGaWpaZ1NmSGxqekNCUnkzMXMrSldNcy9TbzFQZlFNM2l1MWJxWk5wTWRmNDFFc0QxcGdyaEVpZ2s4Q255d0JGVlh3bCtGQnlYVWt6RDFyTEMxb2xnNklENFZnWUhORDdpdXdiWmxGeGJ2QUpnQ2pyQ1Q4cXpmSWU2d29lYmxHSXR5ZVlkNWR5dmlBRUFpVmpMZjVXVUdhdzF4bFhVWVp5K0NVQjJqOUJ1bloxN2Nkb05ENHIySWd2TGhDeVh0NkVWcitvZldOZ0RTK3dXZ2VqOFVBbzViOGlldnlwVVZ0UEVDUUFvcXhDZGJHREw2SkxzSGc1Qk1vemkwZ0lIQXlaSVJCQTBXOEk5ZmpneUdEQkEvZ1p5bEZCTWdaVGh6T3I4N1pZaGJwMWxRWTFYQTVHcngxdGZUd2g5Qm5wa21QU0o0MzRPdE9HdlQ2OGpDK1VhMUJ0blRsa2dLNWhBaURLY2RJMzlLeGdOZFJ2aFVEdjNiOUdyWlVIZEd1Z2RBZkwrM1FwQVVVL0Y1ajFYSXAzN0NhRlFLdTBrejUyYWNVdkR1bG10OGR4Mit1c3l3eHNDWDNHY1BDU21kckZ1VWVROEJZYWZvWFRoYjVzKzBQaXZoWVBsVllJdEliN1NCQTA3RFhpdVZrZ0FLTDBkLzR5dTB0T0pvWUhwKzRuaGtCRHVnMFN4eFZ4Z2dDS0ZDYWllakIvTVhzQzBvN25sUS9WTjdDOW5iOHc4WmZFSEhNWFRoNVRKNjlaL0x4dGRlSEhnM3hVMTJrczJtdHBuWXVkaGo2blA4OTh2c01CVnNZSXF0b0k1M2dDSU1yQ0NvREZ2Z0FVT3dUcVZrQTVTVWlYa200SnJGZGVXdDBFOEVVUUxPSkZkOFJRamlGeklvRlJXOGV4bTJuNzY3ZG1TUjFsdGZEcGorcndGMG42V25NTW5yV3Q3YkNYRk5LS3U0MkwvWW9OOXhJYlZxZDF5R29OdE1hTzBtSk1BRVNwRTViTUNxNHpUeWdlTGVJYXY1QWt0aWJZdGFVQUZPVThVSW9XbDR5dCtETDhKT2d0UEhaNUZYdGloWlJVc1lOZ1pDaHBQS2FSdUszc2xqUERTQXBScFE1c3BUNi9HMWEzc0htalB6QThkalJFQ0NRQW9vUkhvRGtyMk93S2puajZKR0czQk9vN1lnSWdVSlFnVXNyMVhwT08zVWhpaVpqNkFMWHdST05kczFHN2ZFbzRiTlhRaThhN2R1ME5acFpWQ1kxb0pVdjRncW9LZVU3MkVaV3duK2lKNUxyY1RGU0ZaTmdBSVpBQWlCS1NNRldrbVlBbHYxUFViUWtBaXBOTlNyOThWL3pZalU4TUNVQTNuejFleng1anFjZTVoZE8zN2hrSjNiaktHRmxXUmZrcjhPVSt4eXV6eHlkMlBZb09HdWJZVWNZRUVnQlJ1a052dUJYUWU2VmhrcDRwNXdHZ0tpL3VTUk5EN0JJeGZxdnhLZVZZNUswdWNSSVpIcjhYVFppb1lYZmoydHNrelluTkNQQitNcnpFb05TQ0hkTERmaGcyUUFCRVNZKzhrRGtlVU5lUUNudjM1QkMvdXdaUUtPbUcxRU0veW5CeFRab1lJa0ZReHZOS1YyYzFGNHVPejJLMUptMVlNNTdOaVhVSjQvZVM2dWNsQno1aVRicWJCYjNSSkZHcmlGMVV2STVhc0FSQWxFNUlabUxWbUJjRVFoYmdiN3BMTWx6V0FKTFV3aU05d3ZyaWJsUmZDNDgxZGxLM1VFbllDdy9FbzF4U0sxOTgvSjcveHU2VlkyZXhCLzNvWUIycU5WY05BUUVRSlRyaVlnZVpkRjE0dGl0WXIxekFCQkNnNEF3elpMWCtKVTQ0S0ZzSXRDL3V5dXdPbHVlZ2V5QzhIL3lrdFUrUFl3eUhFNVpHQ3lXMTd0SEtWN3liaGZnRW9vRmVaWXdlUjFjd0FSQ2xERmplN1FxTzNRdktpWmE3UUtEQUlHT05UNnZReFRUcDRxNWJ5encrRHRCZXVrekNxaTZaWmJmd2hhd3FPdGI2dTdUeWxXUS8wUk9JckpuVWJGMENJRXBKZHdYWFd1dEplcWNWVU1ZTktla3FBbERZc1NTRm1XWFNWMUtKa1FwZDNKV0h3MS9VWE01T2J5L3JmR2pvMEdja3JZZExKQ250ZmhLL1VkRUZ5OWttQkVDVTlwQ3JxVFh2dFhUSkJvODhKOTNOUWswb29HRDIyRDlQWEV3OU9OVEVYcU5XYXZWWlBTR0dWYTdGU0NpY1RSWXBiOE1FM2I4RVFKUXBjRVd0OFhaZTZBcVdsZ0s5ZGpHQXdvNGxYWUE0N0sxcnFaY21uVW1yMzJELzhCckd5dXppSGJFQ0I4cDRPWktoUC9VMEFCQUFVYjQ3cnByWWVibk9xZzlZeVJPME9UbUZ5UjlBNGVGR1NWMDFPWjdMUFBtak9qYlBrSW9PbU9QOENINGVlVTNrT2lUajBta0FJQUNpekdva2RNWHV2Q3JZRlN4ai82Sk0vQUFLUDVic3NXeGVhdjdUS3hGNW9HVkh6elR0MDEyK29ZVGdaOTJDb3B6N3FkNzJOV1lqQkpVZkNJQ29GS3ZyMVJpc3lGckI4YTVmbXY2QlFvOG1hK3lmTlpIQlErZVlpa2VzcUJRYzd0WERYV2oxcTJEbzA3MDlOV1kxQ3YzV0Evc0dBUkRCem9DeFMwYXQyUXBZOXE1ZzNmWEw3Z29VZklFZEhEQURvT2NHMGtlOXNXM0NRMWI0QzNsd1p1L0loWUdqNlQ1bnRaeEpyNGtPc3pMZXMycENYNDNWOHNka0R3SWd2RVZDV0UxRXIzRlpyZ0hiOGJFZm5BeUF3bzRsV2ExQ3h2NUpiUEJhNjErRlcvZjFNbTZ4ODFySU0rSFBNRXRlamRndWhobzVkZHZRUmJXVGdxRHVUamZpYXhKN0x1NWJMWHptYzYyUjltaENId0VRbnIrSWhPck1CZHoxT3BjbERvRjAvUUxGT25KMStETnIySG5zSW12T3RLanN4VCsrbWtkNWEvb2xqMjFMckNCdFZXQ0lieE1qZVhzNWZZWVZibGlOMnM5Zi95MDFLWDliS0g2ZUJ3RVExVUJDbWJUSVNkZENLVnNCN2ZCSDF5OVFjUGd6dTM2SHZEbXVMZW9pMEpRc2cxb0J0TWpoTDVvNGZzM3Uya3dJZWxHakp0NWFWN0p3WGM0d2EvOVNReVhWYkdVU0J3RVF2Z21CSVRPY1JRWkxGZ0tqOW5KMDNCMENoUjFMNGJDdWFSZXlsaXZ6Vk9rL095UlYrampYWGIvRlNWeEpyVjRKclh1VkdkdG1sT1Juam5qTjlQdTFDWCs3d2VRTkFpQjh5MW9yV0pXZ0s1aFp2MEN4RHFaSWZOeWZkOWZhOVVBQXRMb2xEZnRzSnM5SGhycm9HOXhvenZPVjd0NjB2MCtQYVZNK1hiVkllb0JxcklMOHFRR1E4elVCRU1GZ2R3WHJBdEdSNGswSzBTZlFRZ3QrUm9mUDJkNVo2d29vZS9pVGxqL2Q5V3N0b2VYSkk4RUxMVVh5SEdycnJkT0dFUStBNmFzZUpMU0FXU0V2YXJmMGVTMEVGVGxZbXkyMkRNMGhBQUs2bTdiZVhDY3pHclpDWUxTQWJtR3o1Uysvcmw4cjlNbEZUMW9sN2VkUVV4dTdPYThoQkNKZzRjOWF4emIyc0FzYWUvTUlzRmI0OFVBWHNIUmhqb3c3T1VLZjUxdTlpcjFkcGRkbndGcVRseFkvQWlDQ0xXVFdtMUxSV3F2TEpHS1dWTkN6NnR5RVFVT3Y5S0VEcGRPTGdmeHMrWDN5Yi9tZFVzVS9FZ3QvNGJCMThyWXVlcUVhOGgrQ2xmOGlZVDN4STc2YWhXZnppZUdORlVBeWhKMTRkN0NlckZHcnV6K3I3V1FTMWVmQmFMRittRzVSanNxaUFIWDEzRmdUQUlIaEdYUlJWYU5iM1hRWWxJdVFCREs3eElJZDJ0S0ZQMGYxL3V4V3ZxaDVhaDRhTkJlMXR3TmcvS2xZZCtsV1FOUnZtVXdDMXhlN2hCc01leXhZNHY0clk4YXNtbkZtbDZIeXhuNW1qL3VMSHd1c1pwSDNlUzEyVGpKbnNKWndwbTZwQTNiOGRyZzRtMFQvc01GK2ZjNDJXSjZUQUFpa0M0VFJtcEE1V1VTM0RJYk5sa0U3cUNXZWt1TGhMNVRoSWh5MWdtUlVCejVaeTlSSUdOc1h2OGhaWTRuaW56T2lLcUpiUW5wamUvc291b0xobkxRbUQvWHJNWFRSYURSaEtHbkMvaE9xaVhjTEdsYU5NeU4rRTJOVVp2eXBIQ015N2srSy8zcDUzSjkxQm9ncUQ4OFVOUXhyc2x0VjM4VWtwTGJpNUQvZC9hMnNCUUhpUzdXQkFBaGtPSkVtRFJ6V05RVERLbDRRTkxFK2xOM0NJaTB2MHNJbndVOFdyazlZZ3pnVUdpNGdhcVM4VGI1Uk5jd3U2ZkNRTG9VaEozUGRiVUU5S21TOVprWlVwTDhudm1SYXhpNVVQZHdoYWwxbXpaYm9hTWhxa2RhdGcyWkx0Q0ZMS01adlNrb1lDdlc0UHpPMHlqRmlWRVBMWDAwdEFhTGtOK09xdUlVYURITndqVDQvNnpIV2RXeG1BaURna0M2VFVKTjBJZFV0THZFSkhKR2s3bHNqUHZnNmUrQkxuejBsTEVhR0I4WExqTWpZQmRtOEtIUGh3Y2dRRmVucjBmdGVLR01MbW5sRjFXMHIwV2k4blNYZVphdy9GbzdQS05XdGlISTdJamNnVnBrUVBUa3BNUkFXSVJqcS9YdkFEbitoNm1qclppSkJlVUpnc1grYVlmYXc2SDFPenRFMWxPMGlBQUxPTGxYbXhWSzZaNlBtRWxYUmVPaXpMcHRXT0V2dXhuSlhxVjlmcGcwckJGbzF2WFRJSE96VFFUTTBxb0dURnRMc04xR3I1Uy9ibXJBSkJXL1Y4UGhXTXhUR0k2RVZCaTB5ZkNIeEtERE1HYkQyUG02MmtNZCt0NTRWNis3Q3JWdGpZdnUxRVRMaXk1bFZSZmpqSnF6MDU5cFN2WHpTczZON1Y0Ymk0d0YxYXlBOUxBUkFZQVFKZkxJZXFRNWlVVDJiTFBVZTFValR2VnZJUGV6d0d1bjJXQ09ybFNiMnV5TzkzV1pyWVAxb1hodFlRYXBmdDh6cElPVzJYY1ZJWHN0Vi96KzFoVEFsRkpvWFVQdTlmbk1pbGRXbFp0Z0JTWTZGMnJxTVI0RWVGenZZcXo4YnFxSkpIMmJ0UEFKZzZUYXdPV1phSnVNVmV6TWIxZzJNUGw5SHpNb1BaaENVc2FmbThuYUVRUUlnQW52eXNickM1S1F3TkRnOGhrKy9UV2pKeTlLdFcwandTM3V4dG1ackd0R1FmbTVSZTh4VTdPUVZHaldHMWdnVVBHTThZeWhNdkpsSkNJVkcybEE0YUxVbURxK1FZZDg0eGJ2YXJCWVhmZEVkNk5NL3grdVRQcEkyczk0UVRDQW81WDRjNlQ5amhyOVFhU2JheE0vYklldDhhcC8zaHlMbWpZeE0xcFA5VllZK01GdVlBSWdzRjUwMDRhZnEvZ3dadjJmTjlOVXpmdTJ1M3NSdVhUMDRYZzIvbjlMSFZ1b3RFTDl6dFN2OXk5MXI3SUlyZy83TkVFaVhjTkNQeFZKY0xnMjNvZEF3a2xzTncwUFcwNHZFZjJMVVhxNU1tZUhQcUtweUx3YmhyMFQ3cjEwQVhFK2VDNVYybjBnOG54clI0WEd4MGZod213R3pFVUJ1V0dycm1EQkNBRVR5QVdzdTE2UlA4REtHd2c1Sk5iWGVQa25xTVh0cWVKYXVESE5Qbk1DaFVzYnhwYlQ2bFN2d1piMFlKOXk5Um1MUFhRYi82eEJJdDBWZzZkaGxsSGsvekJnS3pmOGxqaXRNckVrWWpSMTNoclVQVjEzNG8zeEk4Y1gyaDhoZ24xa0NTSjkzamJMVWdUUlM5MkU3RE1yMXdiQ0czQXpaWGNRRDVsakIyanB1dGdtQWlJY3BhL1dNYU1MZHZUMldJbjdDMUFkMUJVK2NkcmV1THM5aXRmQlo0Uy94UkpCcEhGK2xBbC9PdTlmWWYzb3hFMTMrNDR3ZUU4aWRhbkFqWUNrSHpyc0xoZllxRGlvK2hpRXBGS3FVWVJUVmNycVQvNHdxTGF6c3lRMXF0L29OV3FXTFZQeW1vTnpuWFB0M21hMkNzcXNhT2dUR1d3WERabWt2ZWI2NmtVUEdZSFBEVFFBTTlBVW5kakswYTl0RkUrN3U1WkdRcXN3TFU2ak9ITk5oRjU0dDhYcVVlanhTeE94MjB0MEtkbUNOUnVQMW9NeHJrT0g1d0pmeGhHVlkyOWVxTnhnZDZGV3FMcHAxNEQxOFNvNm5TTFNpSVRCaklFd05oVlZ5akdVNjU5RUNXSXg3OHZCdzRXOVZ2bFkveC90dHZNeVJrVkNKSVdvK2IybEVrRjRqWFphTEZrRUNZRkFqWUdMSmlmaWdjUHRlV1EzWHhGUG1MTVhoUUdqT3BETVNXd25semkvZk95cTdqcGs5anMrYXhCRy9HTm8xK2RSd3QyNzhIRjVGb1MvakNTc1VHaDRYT05Cbi9uMjF0QVFHNjZ3WWU3MkhJZ2tyMW5oMFg2M3lHMTd2cnY5YlJlRlB6Lzd1MStkbyt4cGlsd0F5dkxpLzJzSFU3aDYyS3pMb0lWQ0RadmtqWFVxR2FFSUFERXo2czArS3c5MDV3MHVLR3NrRHd0WHdBTnQ0blRFNUNZUVREN0NRdVdpNWtkQmRiSzlacXNjM2haSUNuMWwvVDViMUNTZjlPOTZ0bXppdW8wcGIrZHk5Rk5iaTlOWlNZRHJvMGtVUm9PTXhaSlluaVIwSFJqVEs5aWgrYklrdm40Yzg2WEphNWpyb3N0SlJ2THZYNDBNQjBuWVAyeUhRWHExSmVweG9FU1FBQmlvQkdsbnU4TzFBbVBCKytqSVMxc2sxUGdOWG1lTnNySm0yMFpEVmNoZGZxMVNaczdQQ1lhdExOekw4ZE96UWFQKytsT2RwK1B2VlNBaUJZZk1rUzNkVnNFaExoQjRPTU1TMktIcjhzOGN6Y3p6bEZaN2xSbDFQOUJpS0wxT1l2V0M1ZDRQZ2lMSmMrayswQ3ZYTGlrMDFkY25YS3hBQWZSdzduSDgyTVJRbXpoaFUwVFJkeDFIelBldGFwZ05mL0h3UzFkK29JMTRvRkE5NmhxRktWbyt2cWtLZ1hlaytSTGRFc0E3SGtGN2oxR3dGakxBOWlucXpTNHQ2WHF5YjBmaEVEM3ZtZDVWTkFFcDNyazB1STJNTXJ3TXYxNnJhc05raXlFMDRBUkRaUXFFMU9EemRiTUhoT2hMSlMxUHBHbEdoK1BlVXN4NWZkWVRBa05rdEx0MFNsSzBJRmowZVNWcGNCdWdLTHBLb2RiR25hOC9kVmh2UjZsY2xYYjZ1cjJYMitNWEVRdjNXR0VjWm0ydXUzODYrUXdCRTdsQ1lwb1NFL24vU3hTd1kzYm9GTlZoSTk3azFPMWpQdkVad0xyM1M4cXR2QUJJbVFxSEFZNG9MdU9QOXo1b2xhN2I2RGZtbTFTL1hOU3l4VVAvdyt1Mzk1dnQxbzlpSENJQisyK3VOa2gxTUkwNHFQcHk4VWRwQUxmODNCeW5IWjFzak1NZWxYcGRYdW9JVDZsMmlnUE1jM2I4T2twODFsdHZIclg2T3JsdnhsYUtzeWd3eVd6aDJMSWJxR3dpQkJFQmYzdnVVNytDQ3U1ZkZyRnZBQmd6YzZ5K3pnaVVFRGxyakFRbUJCUVZBTHR6WlJhd1pzVkx1S3hvT1JLdGYxbXVWUGFUSlhyRnBhRkJGWW05WnRyTndiRDN2M2ZQQWs2K093ZkMvSUt1cFZkSGF1bGdRcEFVNFg5THpFR1VjYlk3d0Y5WXJFVVVIenVpYmpaQXNFQkRROERjeUNKcXpuZldDQ2RheW5mWUNCU0FBQW1XSTVyVCtCUGRzR1F1Qk5mV0V3RUtPcEJDZFR1blRzYm1VbXhscWhzeUN6cUZRRmE3eFhOcnpzTmtEYm9aQUNjaVJ2dTdoOG1VZ0FGYjlIVEtib1JwU0lBSjd4cXhSMGRwUlprc1duSi9iN0lPSUxydVJJdWI2NDFGWmd6eTJwU1RjaEVLMCttVThGU2VzYzZ6TFNNdnlwTXpTend1M1l3UU1PRDNybEhqTlpWVEx2aENLaGNCNnBjS0cyVnJEeGNmeERTNFNONGdaWHVLeld4TW1lckNsSEZ3dTQ2czFEVkNubFFCWTdYdDBqUmt3d2pSbmU1Sk1BcUQ3Q3FraE1GSnIxb2lrWUhUTzdhVnFXRk03VGxyOTlBemZRYk5yTTJRRVpvWnZVVU9nWGFkVnl1WFVzTG9NQWJCcTkyWnJmRXpVMjR2UUIvSkdYYnI5NUxXaEJRT3BseURaTnd4aitMalZnOUpaUXpqOStZMXU4M2lybjlUMWt4bStTdEhxVitBaGFIVUVVNkdCQUZqbDVHSVN0UXJQY2dIeHhObEZCdnpMd0gvZDNRQ2szVTFDWmt1RWJzV1BtSmNqSFFidEc3bG9vQU5oVkc4UnJzeDZLYmZCQVhObEdhWGlwVjFvOVNzby81SDZDSUIrQ29HMSttN0drSUd0cU95RlMwcC82SVhJQ1g5d2NqVXk5RkFPSGZXc01EaThNMFdHdjBiQ29Jd2RERXBMdi96TkFSK2ZwZGUxbGJwK0VhdlZ6N0NMT2hOZkNyOW1oc3o5aXg2YXlnVEEvKyt6MTdJbEFRQUF5dUN2LytOVmJ3UkE4VDhmL2dXdmlJLzkrMzIzcW50K3ZwVU40V09QZm5JeHh6SEhNVGlPVVFYSGNUSFF0d1VBQUJBd0JFQUFBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQUNJQUFBQUFpQVNIVFQzTW42QVFBQVVLMXEyUVRwWFRaam5GbytaN0k2Wi9KWXRheGxtbXFlTVZHTkhWMlg5RFU5ZllOcTc1RXV0YU85VTcxM3FGTnRhRHVwM2o3U3pjWURBQUFFd0dvaExYdWZ1T2hzZGZGY00vRGxJb0Z3eVp5cCtuR3I5VEVKaEJ2M0hGUFB2WE5RUGIvbkpCc1ZBQUFRQUwxbXpyaDZkZStWTGVyR1pYUFV0SWxqQ3Y1NUVoemxjZXZsODNRWWZPNFArOVFUclFkVVcvY0FleHNBcERzUE45U29MeTZkbFBQck5oL3BHL0d4Si9mUTYrTDFhK3hqZDY5UXJidVBxYzBITzlRVFd6NWdveEFBdlJIOGJydGkzb2l1M1dLUklIai9UUmVwdi9qb1l2WE1XN3ZVSTJ0M0V3U0JQTWlRakgrNDdaS2tqOGtGSlozOUozdFU1NW1SeHhrWEh1KzZjbWFEdXZ1eTZYbDk3K3FVOTdlMDk4VC92Zk5vbnpyVkgwNEtqenM3QjlTR2s1eUh5K1hteFdmRmU4ckV0L3NHMWJ2N2pxdnQ3WjNxdFIxSHN2YVUzYlhrTERWbnlsZzFzYUZlbmRmVXFNWTExT25yZGE0ZXVpMXR4K1AvUHR6Um85cFBuakgzZ1ZnQTNYR3NtNkZhUVE2QUQxN2Rva05acVlKZkt2azlkNjljcEZzWmYvalNWdlh3aHYzc2VZQUxDNmFOaTE5QWJLbnZ1dzBLcVJjSzBkMDdxQzlNaWVTaWtXak52cFBjeUJYWmhUTkdGKzFuTFdrYW0vYmZxWG9Hd21ydmNUTVV0aDdvaVlmRWpyNndlcUc5bHhlbFNNNmYxVGppZXJoaTRVejlrT3VpaktWLzYvMTJ0ZTJRZWR3dGluMzl2Sm1Oam9aaFpkd0hFczRObWM0VDY5OC9ySS8xWnpZZUNHd2dERlFBdEp1aTNWNDRpa1c2bUw5NTI2VnExWkpaNnI2blc3bUlBRTREd3RtVFN2SnowNTBMNU1Ma1JxYldobHl0R3hoMjN2U0dzdi9Pc2ZVMThZQ1lMaWphQWZHRFU0UHFVTmNBNFRCUE1xWStWd1BKcXFWejlLT2NFa1BvUzV2YTFGUHI5d2J1ZUExTUFKUUpIbzk4N3NObGEvWEx0ZU85OEtXVjZ1OSt0b0VMQk9CQTArUXhubjF1bVZvYlVsc09rVm5MMU5HZWUwNTJRRnpTTlBKekVneVBuQjVVZi9hckE3eDRPUlRTa2xjdWRnRDl4YnBkNmg5ZWVqOHdqVE9CcUFNb1hiNlBmZUVhVDRRL203UUdTaUNscGlDUTI4eEpZOWtJUGpadGZGMVZQZC9tV0dCZDBUeWVGeTRIR2NOWFRXVHk1dFAzZkNRdzEyWGZCMEFKZnpJUnc0c2trQklDQVgrMElxUTZlWVloSGs3Y01YZGNWVDd2eE1rbVNLOVVRemRLZmE0SnluWFoxMTNBOGdJV0d2NTZFbVlzSmM0dWJCeFRyNHRFeTh5a0M4NmRtbmZyb2gwQzFVL2VwRHNZU0VQRzducXA5ZDRwam1lSElXSEc2S3A4M2pMREdObko5YkVhMmRmbDR6OTQxZGNUUkh3YkFPV2lvWU5WSG81MW5WRnZiRzEzVmN6WkxpTDlrY1ZOcnVzSnlzNzJyVnN1VmxzZWZZT0pJVUNLcTg2bGhkelBaazJzcjhybmJaZVhRV2JTT0ZLdDVMcjgwSjJYcWN0V3YremIxOGUzWGNBeTI5ZHRxNEVFdjRlZWYwZWQvL2N2cWkvOGNyT3JPM2o1V3ZrZStWNzVHZkt6M0pCbTUrL2VmQUZuRENCRk5YWWpTYzhCblBIaUJCQW4waFdseGpDcDNWbU5MZmVwMStYdjM3REl0NitSTDFzQTVRVnpXK3JsOFZlMnFTKy91SzBvdi84N3IrL1dEM2tlTXNYY0tabUZkTmZtUXhTc0JSS01iNmkraTRpc0FnUm5Ibm5ycURxM3NVNU5HRldUOUhGNWYvNzA1SENZcmE1ZnViRUNTWGJMNTB3dStURzI2M0NuT3QwN3FDZHZsSXBjdy8xYUs5QjNBVkM2Zm1WMUQ2ZWtwYTVVNVZna1VFb3RzTzk5ZXJuamJ1R3YvdW5TV0FCOGtiTUhZRGw0c2tlWFoxaVFNcDVvUnVPWW9pemZpT29NVXNzbjE2djVqV2IzOGFUUk5XcjJSUE5HUWJxVXo1cGcvbHRtNjBvNWwySTdkcG9XM2x4a2pId3AzVzRObWJwditUbnFWZ2RmTDYzeStiWkkzbmJ4YlBWMmtScUlDSUFsSk11N09YMlI1UTdpOWhLUHU1Tmd1ZVZmWHRGVHk1M01aSlFMbXN4Y2xoWkVBTXJWc1pCYWRzSmVSaXJSc3BacEpRK1NzcUlJU2t1V2MzT3pwSnM5MjlodWJVeHNZWFRic3JqN09OMi91YVFlWjA2dnlVNnVrN0tLaDMzZFhqSFAyZSs1OXlkdjZyY1BmR3lKNng1Q1djWHJ5d1JBYjNQVCtpY3RmN2VYYWRLRi9BNzVYVkw4MmNtRjV0Tlh6aWNBQW5sd05ueGlXODd6U09yRWs5UnhpUGE2cERhNWFDWGVlS1l1SjRmS2M5TFNlR05UZzI1TnRHY20yNjJKTThiWEo5VXEzSDZVMVVCeWNWcTZTVmJTZVdYTElmVkU2d0gxdFZVTEhYM2ZodDFINC85ZTJwdzdBRXJybjkzTDkvd1Axcmd1RHlmWGJabm82YmVaL2I0S2dHNWEvNlRidDV3emJ1VjN5ZStVZ3RST2RqWmFBWUhLa0dOMVJKQmtYRzRnMk11OFpRcUxkcmZ6MnNNRXdHeWNUZ0NSSmRqdWVLbzEvbjZ1WmVQaU4zcXRCK0sveDBtamlxdzFuTWkrdHJvSmdkY3NtT0c3QU9pcldjRFNUT3VFVFBpb3hBc3B2MU4rdHhNcmw4emlMQUlBSGlKZHpoSU8yM29wQVpQTmdtbk9pbnZiNjJiYlljNXQ5KytxaFRNYy9aNXRoMGEyeUVzSWRIbzlGdFZhMHpBUUFWQ2FaNTNjQ1VqWGJ5WDc4dVYzT3lrUkkyTVU1SUFBQUtDYU9DM2RsTGhldHRNd2w5ajl1MmlXczFEMjB2dEhDcm9laXhtVC9EZmh6RGNCVUlvd08vR3p0VHNyL2x5ZFBnZVplUVFBUURWcG11d3NMSzNaTjl3VHQ3eGx1cVB2c2J0L3hieVp1UU9nQkx4c0pWeWNYbytyY1RuS3dBUkFKMk1IWkNDb0Y4YlZ5WE53VWlnMm4xbFVBQUJVMHN4SnptWlZKNDdEZDdKcWlNd1N0cjlISm1zNUNXV2I5aDdMZVQxMnltKzljcjZZQk9KMFIwZ2RDRnBKOGx5azhITTJicWVxbzBUN1YwT051bkptUTlhdnlYYzkwNitzTzg0R0J1QXJUcTdITXZ2WEprTzRuRXdhMmJobk9NdzVYU0l5M2ZpL2RNSFN5WE9Xc1kxK0tnanRpd0I0OCtLekhIM2QrbDNIUFBPYzVibmtDb0JDNnBxeE1raHhnbHRxU0R0dmVvTWFOeXE1RWJ6Y0t3MFFBSUhDMktWYlJHSkJhTnV5MmVtUGFiZkgrZ1BQN21mMUQ0ZmNGbHkrZUxhek1ZUHZKWVE1cCtNTU54N295UGsxUnpyTytMS0xOeEFCMEduRjhZYzM3UGZNYzVibjhzM2JMczM1ZFhvbkp3Q09DSFdaS3YrbjF1c0NVSDNzY2l1SngzbmlEVnNsbG9TVEcwZ0NZRzdTbXVkRTYrN2hCaG1ua3ptZTNUcDhMWFF5S3pleC9sODJVcmR6eGNLWmdic2UreUlBT3RrUkVwdWJ2VUtlVTY1dVhqOU9QUytFaEwvVk41L2pxOVlMdS9ZWUVHVC9kczBNZGYzaXhwSXMzWWJ5bVR5bTN2WDNPSm5Na1RqK1Q5L3NPNWlWeTVyYzJmbGlFb2lUSFdHSEJ5dnpPM2xPZnB4NlhvaWRuUU8rK252c3Jpc2c2R1JaTmkrSFAybUJSRzZ5L0tKYlRycGZFOGYvT2YyZXhGWkcrRFFBT3RrUlRudHdiVTRuenltSTR4S3ljYlAyWnpXUWRVa0J4Rzd1am5wN2ZkM1U4Y0pJTDNYdDdVenNHb0RTWmV5a0tzYkJrejN4ZjZldStaMUpWKytBcStjU05MVkIrVU85K0FJSGRhY3IxTEhUZzc0WjV5Y0wwZ05RNmxTL3QxZlhhSjQ2bWhlcEJHU00zdlBmZWs2WFdKRmkwREllVUxxRVV4cy9uRXptU05WMm9vY05UQUNFbnh3NVBjQkVEOEJuRG5RTmV2cjVNVGF4dEtTOFNtS0pGU252SmhVK1pKS24xTVJObk13aGxUSFdmUHZYdWhTTVRNeVF6NmNiVDA4RkRRS2c1c1haTzA2bnNTTlpkMy9FTjMrTExsRkJLUmhBZGZSNWYzMWRKbTNsNW5RVmtGeGt3c2R3NVk1dGFUK3ZBNTYrcnB1ZmwrN2theGJNMEpNbnh6WFFTQkNJQU9oa05tMnhkc3BpR3U5Z0IvWGk3T1ZLMjM2MFY2MW9IcytHQUh4azdXSHZCeXNtYmVYbWRCV1FVdERkeVE3S3ZzRGtpMUd0aHp0eTkvTTdtV1plYms2V3IzUHl0NkY2U2QxQ0FFcTE5WHEvQlREZkZYOEFML0pGQzJEN3lUTTV2MFlHbE1xWWdzUTZRcFhrZFBrNkozOWIwR3crVXRyWmdqTEpSTVlacG1vOTBGUFI1d1g0M2Q3amZRVk50dGpTM3BQMW1KV0pKdnM2MDQ4MWxCSlRmcXN5VUFuZHZZTnNCQUpnR1FPQnc5bTBNcURVSzZ1Qk9GMis3clVkUjloTFhlb1pDT3NMU2FhTFFHSlFrM0ZIak9rQnZIUHNaanFXcFV5TVBWUFlQb1k1ZnIzSDZhb2ErZFFMTEpXZ2pzZjNSUUNVZ2FDckhYemRpbm5UUEJNQTVibmtQQms2WE1ZbWFHU3MwT052SCtWQ0FQak1QNjg5cXNmWnlURmVEVjNDeUovVDVkOUFBTXhwL2Z1SGM5NTFyRm82UjgxNTl0Mktkd05MOTY4OGwxemUzY2NFa0hUa3d2QVZaczRDdnNOTlhIQXNiWjdtbWVjaVpXU0N5RGVsemJjN1hPcnQzaXRiS3Y1Y25UNkhEYnVQY3BZQUFGUU5wME95cGswY294Njh1dkxYWTJtUXlWVkZ4TzNmUmdBc3MyYzJIbkQwZGJkZE1VKy80SlhjMmVRNTVDTGR2MCswSGxBQUFGU0xOZnVjRDF2Nmk0OHVydWoxV055MWJIWkovallDWUJsSkJYSHBCczVsN09nNjlkMmJMNmpZODVUZkxjOGhsN2ZlYi9mTWpHVUF6bS93WkozU3hBY1FKSExkT3RibHJIcUZYQXVmdnVjamVobTRTaDJ2bjc1eXZxT3ZsYi9KYjlka1g2MEU4bjgzN0hVMCswakczOTIzNjFqWko0VGN0L3djUjJQL3hGUHI5M0ltQVVwTVZnNllQR1prQzBTNldZSHBWaGR3MG5XMFkvWHZrcGE0Z3JjdG4xeXY1amM2YjVXaWZNeEltL1llYzN5dGszSm8vL2xYMTZwbjN0cWxIbG03dTZ3aDYrSGJsK211YUtkL2s5LzRLZ0RLYk9DdnhsSzZreGYwYno5K2tkcHp2THRzczJ6bFFpTy8wd2xaL1lQWnZ3Z3lhUkZZTUcyNFZhQXhGdEprVGRCc3NpMy9KQmNaSnkzdnBTQi9Cd0d3K09ZMDFLZ3JaemJFM3orM3NVNU5HRFc4VW9mOGUvNzBrVFVGcGZoNk1kY1NsOXFEMXozZHhndVNZUDB1NXdGUXlMRjU5OHBGZW5qVWJ6ZTJxVGQzSGkzcE9yN1NNbi92bjV6dnFCYXZiZHVoVHQrOVRyNWJDL2dmZjdWSnJmN3NGWTUydUVjKzkyR2xmdkpteWNPV2hELzVYVTR2UUkrOXZvTXpDQUx0dG90bjZ3dUNIelNPWWJVWHQ0RXVjY1dOODZZM3FIR2p6TkZLVWlSNmJEM0xzWG1kOUs1OVlkVml4NjFyaWRmbFd5K2ZweCtycmNhUUhlMmQ2blR2WUh3Q2hvekRjOU5LS04yOFY1MDdXYmZxeS9LcnNnS1htK0JuOCtPWWZOOEZRTGxyK0x5RHRZRVRRK0RGTDI5VjMzbDlkMG1lajh4eWtvR3VUc1BmUzV2YVNucm5BMVNEL1NmOXN3UmlycGJMb1ByR0paUFV0Zk1tVkgyb0syVGxFajk3b2JXdDRKczR1WTdudXBidlBkS2xKMDJtKzk1aWtma0ZmaHlUWCt2SEhlOXJ6L3hSanlsd0VycmthKzYvNlNLMXZHVzZ1dS9wMXFLOXlITFhJZU1Mbkl4SnRNbE8vUFZuMytYTWdjRHJQTU9ZS3IrVEx0b2xUZFVmam1tUlRFL0c4OTI0Ykk3clZrRFhBVHlQMWp5M1pINkJINFg4K0VmSmVKc2Z2YnpWMWZkSVVIdnQ3LzVFZmYrR1JRWE5TSkx2bFo4aFA4dE4rQlAvL090M21Qa0x4SnowVVFBTWFwSFpYUHkwZHJaMFh5T1pYTXRrU0ZhMWsyNW92L2JLMWZwMTU1TXVYVmxxSnArQnFQS1FKbDhweFB6UyswZHlEdUNXMExkcTRRemRpdWcyOU5rZWYyV2JaNWFwQXlxTlNWQ29Kakoyc1cwUEUzMVNTWENhOC93N3VwZXRHa212blBRbytsV3RuM2UrTzU1cVZhOU1HcHZYV0FBSmN2SzQveWF6L3MvdXcxMGpWaHVSV1ljdE15Y1czTVF0NC82Ky9PSTJ6aGFBRDVXamk2b2F5WHEvOEQ5N2ZIMDFoa0RwU2ZUekRQNWF2Kzk4bjM5OHZTNDBXY2hKV0FLZVBQSnQzY3NWL2lTb0FraTJ4ZUZrTHErclZQa1pyNU0xdmYxQ1ppMC9TUXRnMWhEWTFUdVkxOHpnU25ubytYZEtOam5VSzBKKzMvRmtITUpscTEvV1FjdHJmckZ1RitFUENJQktyWFRnZFQwRFlUWkNRTWdRcHh2LzVSVTkzQ25kckYydmtCNi9CLzdqTGQrSFAxRWJsSjFQZ3RiM1Q1N3hSRzB4MmZsL1ZNTFNNNEFmSE83bzhXd0xvTFJPSnJKcmxkbWtqRTNpVEdZS1FhZTM5M2lmTDJZQ3o1cElyVWNucEVGR2hqdkpER0ZaZzdlUWNmT2x1QzVYWWpVU0FtQ1p5STczMm80ajZsdTNYRnl4Y1RseTRaQkJwVndRZ096YVQ1NHA2UHZsVHY1SVovcWZrUnJZTWdVMzRiYndMTHhMVnUxSVorZlJQbldxMzFscjVJR3VRZFhSbC95MXFlOGpkeERVRFNDeGg1Uk11M254V2VyOFdZMXFRVk5qV1cvNnBJYmdyc09kZXVXU0lFN0NyQTNhSHl5ekM1OWYvYkl1MEN5TFFKZHJQSUpjakg3NDBsWm0rZ0lPUGJQeFFMejZmem9VVEs5K3JRZDZYTFVBU291aDNXMzh3YWxCZGFocklHTXdrMGttZmhwbjZPY3dhRjRYaDYrTjlsS1FpV3R5RjFKT0tmR0d6ejZuY1A0SVlBQzB5ZDJIUEVvZEJPVU80N2svN0tPN0YzQkpXc2xwS2ZjL3UxVXVNZEFsaGprbVZ3VDQyRThLYVZUS0lBQ1dLQWpLZXIyZldkR3NsalpQS3pnTVNtdmZHMXZiMVhQdkhLU2VHUUJrOEpWMXg1VmFkNXdOQVJBQUswZDNEVnRoVGNMZ05RdG02RHAvRjV3N05XY1poOFE2Z1RMR2tOQUhBQUFJZ0ZVY0JvVU1VcjNxM01sSjR4RzZlZ2RVMjRrZUJvZ0RBQUFDb0I5SndOTURSaGswQ2dBQWZDREVKZ0FBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQkFBQVFBQUFBQkVBQUFBQVJBQUFBQUVBQUJBQUJRWExWNWYyYzBxcUtSb2RoYk5pSUFBRUFnQW1BMEVsYlIvbDVGQWdRQUFBaElBSlFXUUlQd0J3QUFFSndBYUJpR1VpR0dFQUlBQUFRbUFNWVNvQmtDQVFBQVVGVUthTUl6RXY0UEFBQUEvd2RBa2g4QUFFREFBaUFKRUFBQW9Db1ZOQVl3bWhBRC8vMitXOW1hUHZmb0p4ZXpFWHlPNDVqakdCekhJQUE2U1lIS3JnTjR6OCszc2pWOWZ0SDRudy8vZ2czaDg0c0d4ekhITWFyL09QN0JHM3ZZRUQ3MlZ4K1pXNVNmVTNBZEZ5b0JBZ0FBVkpjQ0F5RGpBQUVBQUlJVkFNbC9BQUFBQVF1QUFBQUFDRm9BcEFrUUFBQ2cyaFEyQzdpMlRxa3dJUkFBQUNBNEFUQlVxNklHdmNnQUFBRFZwUEQwUmdBRUFBQUlXQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFBQUVRQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBQUlBQUlBQUNBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQkFrTld5Q1VwblRrT051bkptUTE3ZjI5RVhWaSswOTdJUkFRQ0JkczhGamVwdzk1QjZzLzJNT3RFZllZTVFBQXV6ZkhLOW10OVluL1N4QzJlTUh2RjFFMGJWcVBuVFI2ZjlHYzFUUjZ1eDlUVWxlWDViMm52VUMwKzNzWWRXS3J5UHExZFhuVHRaUGJIbEF6WkdsYnF4cVlHYktLREt0VXlvVTUrOFlMTCs5NzJ4eDRIT2ZyWDFTSi82b0h0UXJUL2NxM2FmR21RakVRQk4zN2hra2pwN1F2MkkwTGFrYVN5dk5uSzZhZTVrOVprVnplcUtoVTM2L1RYN2ZxdmF1Z2ZZTUZYb256NTJ0bnA0VkVpdDIzTmFyZC9mb3g3WjJzVkdBYXJNZFhPU3I5MnpHMGZwaDdnNzlqalJNNlQyZC9TclBiSEhNenRPMFVJWTVBQjQ3YndKdmdoN004YlhzM2VXMFlOWHQ2aFBYSHF1YXA0eE1lbmpkeTJicmI3eittNDJVSlc1ZC9GRU5XMThuWGtCV2Rpb0gzOXp6Vm1FUWFES0xKK2QvWG8rWld5dGZseDg5bGoxKzdZZUFtQ1FBK0RPbzMyK0NJRDJ4UXVsYzltTWNlcnpWOHhWZjNMeEhEVjJkUHJ0L2VrcjV4TUFxN0hWWVA2RUVSK1Q0UnAyR0x6bjh1bHE3ZTVUNnJrZHArZ21EcWo3bHArajloenZWcy92T2NuRzhDanAvclZiKzNMWmVMQ0g3dUNnQjhCVC9XRmVWV1Fsclgwcmw4eFNTK1pNelIzRUo0N1JYMDhJcktJV2c4bjFha1h6K0p3M1dMY3NuYUlmeDA0UHFvOC90VWUxOVhMdUNJcnYzN0JJM2IxeWtlcnBpd1dHbjd4SkNQVHFqZHdjNTQwNW00OXdJK2NXWldBODdJNjU0OWdJSmJCb1ZxT2o4R2VUVmtCVWowK2VOOEhWMSs4KzNrZjRDNUFuUDdOTWh6OGhMZitQZk83RGV1d3ZQSGd6Tjl0NUFIeHhYemNiTE9nQmNQT1JQbDVWWkQ5UmJEN2s2dXZ0VmtCVWh4c1hUM0wxOWIvZmVZcU5GZ0F5cy8vdEJ6NnFWaTJkay9SeENZSGZ1dVZpL1hsNGg5dnVYOGIrRVFCOVpkTG9HalpDQ1VocGwyTmRaMXg5ajdRQ2NvR29ndkRYMU9CcS9LeDAvekloeFAra2hlK0ZMNjBjTWNuTEpoOS83TzRWYkNnUG9mdVhBT2phems3L2xPeVlQWkdKSUtYeXM3VTdYWDI5dEFKK2JkVkNOcHpIZldLQnUrN2ZGN1oyc05FOHJCZzNYVExaUTdwNTVSak9Sb2FGU1Bjd3ZNRk45Ky9LbHZIcWdXVlRkTUZvZWR6Y1BFNWQyOVRBUnN6QmQ1TkFOcHdzYndCOC9PMmoxaDFJN3E1bkNhZmxmbjVJVHlaMVNLdGVyb3RDb2xzdm42ZWVlK2NnQThZOTdNb1dkd0h3NTl2cC92V3loMjlmcGk0NGQ2cmFlNlJMdGU0K3B2YWY3RkhQYnYzQWNXMU9lN0tIVTlJOS9PQ2hUaVo5VlpBRXR3VlRSam51L2hXSnRRRVRmVTBsMXdtVU1qSE1GUFp4QUJTeWlvYnRnOWlMZmFocitHUWhzNFQzZFE3dkFLbExydjNUNVZQVjNaZE5kL1I3MXU4OXJiNnk3amg3VVpXU1ZzRDdiN3JJMWZmSVdLRnIzbXNmOGZHbXlXUFV6RW51eWcrOXN1VVFGNW9pY3R2OUs4ZHZLVy9JN05XR1pJVWhDWnJjL0xranJYOHJGczdVLzViV09YdmkxamRqRHhuQ3NXbnZNZFYrOG96YWZMQWo3WW85ZHkwNXkxWDRzOGs1WWVPQkRtNzB5bURLcUpENmNOTVlOWC95S0hYdXBIcDEzdlRpdDlvbDFnbVVGVVVrRUw2MjV4UmgwSzhCOExvQ2xsQzd5a1VMd244ZllOYVJsMG1kdndYVHpKblVjNmFNVlJNYjZ2TU9hellaSzVScEhKRmIwcUtCNG5IYi9Wdm84V3V2OVMxamRXVzRocjFzcEJSeFR3Mmkwa05BQUhSSGlyQm5JaTMzaVpNNVZzY2VuLy9oYTBtaFRVTGhoYTlzeXlzRWZ1L1R5OVdXZjNtRlZZQktHUGd1alFVeUNXWmxmdzZ4M3lsQlVCNXJZemVCVDc3WEdkZ2dXTXN1bVh6SEx1djdPdlhUYlhRZlZlemlFTHU3VHd4MXkxcW02YmN5bzY5WUFhM1VKSWlpZUphZTdUelU5d3lFMWQvL01mdjRQMmxSbEhCM2JxTVo3dXlBSndXbDNad25CQk82OGpnZnQweDMvbnIyRGFadHNmdnlpOXYwY1pZNjh6Y1hDWmpTL1h6emo5ZnhRaFJJWnZQS2hJNGxNeHBLMHNKWGlDdWJ4K3ZIejk4OXFSNTl0NU1BR0dSdTZvZEo5eEcxd3lybjgxY3ZjRlhMejR2eWJZVkU0VGR2ZTQvMzZUcWIwajByN0hBblNyR1NFQk82M0Vucy9uWGl0eHN6OS9yYzhWU3JlbnRtbytzYlEvbjlNb1pRUWlUY3V5TjJQWlhKR1c3RzhsWHMybi9CWkRWalhKMzY5cnBnOWNvUUFCTzQ2ZjdkZnBScDUwQ2wyYTEwZHBCelNrTGU2cHNKNEY2VnJmczNIWm1jbGMzdGo3NmhYdnU3UDhtNDVHTW10MTB4VDcyMjR3ampBZlBRTW5sVVZZUS9tN1FFM3RNOUdLaVdRQUtnZmNmWjRLNWI1MERYWU5xVk9wanBXeDQ3Mmp1cnZnV3cycDkvcVgzamtrbnEybm5KTjJYcHh0ZFZBNjkxZlhtZG0rNWZtUkNTSzZESldMNXZQZjNmYXZWbnIzRDFQT3dpMGMrdmZwa1h4YVVqM2RVM3JrNWFBb00wT1lRQWFMbHprYnNCNUE5ZVB5djdTZW4wb0Y1aVNnYWF2N1N2aDFCWVpLZDdtY3J2ZHgrYVBhNGszYkdWTUc0VU5mY2QzNHk3N1A1OVkydTdvNi9MZDFLSWRCM1RGWnpIVGZxSi9xcDgzbmVjM3hpWXJtRE9Tc3BjYy9makxwZVB5a1ZhS1dSQit2dXVtcW1lL2V3ODlWOS9PcHUxZll0STZvSDVBV3VRWnVhbllSYlNjZ2xuaXQzOW0waEMzSlkyOTZXN0pEUnlyTHJ6YW50MUhyL0x6ZzdPMEpCQXRnREt1S0dyNTR4VnkyYVBMVnNMZzRSQmVYeSt2VWQ5L2ZlSGFSRXNVT2NaZjJ5L3lXTUlCa0ZRamQzV2xWTHM3dDlVbjM5OGZWN2pBZWtLZHU5QVozOUp4Z0ZLTGI5UC8yci9pSS9Mak9Oenh0V3E4YU5xMU16WTI3bVRSdW42ZjI0MDFJWFVzcW1qVk92eGZ0Ky9Qb0VKZ0JMNnBFNllyQlJReVpPeEJNNmZmYXBaL1hqOTBaeGxLSkRaam1QK3FNRW9wV3lRbnBQVmRlQXZwZXIrVFpUdmVFQzZndDFyNnhnb1NRRGNscUYzUU1idXBZN2ZrOXFEZjNYSkZEM0p3NmtKOWNIb0hQVjFBUFJLNkVzbGRjU2thMWdRQXZQejloSHZCVUJwalRqU2VZWVhCMm5KRUpBbjkxQThQaHUzM2I5djdqeWExKytSOFlBZlhyZExMKy9vaG5RRk15dllPU2NUUVdTb3g1WWp2YTdxQkc3NndIbjM4b24raUI3VDk2dXp4K3JXUFFRZ0FQNys5am1lSDBBdUlYRGpCMzFKUzlIQlhlQnlzNVp2S2xsZlZBckkybEpYNXBCeGhxbGR6ZEx5Nk1YdzZVZHJEMWYzY1NHMUJxWGdkT3VCSGwvOFBlWGd0dmh6dWlYZ25QcUhsOTVYSDFuYzVQb2M4c0RIbHFqbmY3Q0dGOHVCZEJOQmVnY2pxdlZnanc1eGI3YWYwUUZOL0dwaG82T2ZLZC8vN043U25vTlBEVVFJZ05WTTFnQmUwdVQ5NS9sUEh6dGJ2ZmZVSG9wSzUzTjMyWmtjQUJNRFhXS1lrN1ZDRSsvOFVSMnE0Wml3MXgyM1E1NTBXMU1LS244WG5PdThOTkpiNzdjWHRuOTFENmkvKzlrRzlkZ1hybkgxZlZLK2lhNWdaelpiQVZER0FtNk5IUnV2dFhXbkhWc25ZKzZjdHM2OWY4VDlqWlIwQXp2OStUSytNQWpqLzN3ZEFKL2EzS0d1YzNoSFVVblNOZjNGcFpQVVY5WWQ1MnpoMHVyZmJORnY2WTd4TDJsRmM3dnNXakYvdDdUZ2RmZEg0ak9TN1hHSmRPVVczMzNMejNFMU1XUDlyc0pMZGNpNTQvRThTc05JZ2VoSDF1NW1yZUJjWVNwMjdQemxydy9rckt0MzZVem5kVEkzNXhFQWJ6alhlUVdPYlFGYTVNRzNBVkM2VmFVV1h6WE12cnZ0NGlucVh6ZDEwQXFZeDhrYi9pWUJySmprbkhEa3RIblJsbDZDUTEzbXY2V3dlMGRmbUhCWFFTdm1UWE8rWC9RTnFvYzM3Qy9LNzVXV3ZLdk9iM0sxVkp3RTFlL2VmSUZlWmc3Wk9TbXF2SHkyOCtGYUwrNXpmM3hlT01ONXdIUXp2cEFBNkdGcmQ1OVN0eXlkNHZubktaTkNwQkExRTBLSzc3SVo0OG8yWnErY3Z5c29zZzNsa081WGFSMlU0OGVKbS85akYxMnpIcmEwMlhrQUxMVDdOOVVqdjMzUDlhemdWVXZucUp2VzcrVkd0RURTUGV0MHByQzB4TnRqQnQxWTZEQUFsbU44SVFHd1RKN2JVYndBS0MwUjYvYWNqcmNZMkYxQnNnNnB2ZEM3MUJWMGMwRktKS3NlS0FKZ1VVbmgxa2MrOTJGMXRPdU0rdll2TjViMFJQM2taNWJwQzhKTG05clUxNTk5bDY2aElubG93M0gxbTloeExCTW8wcldRdTVuc1Jmano5ckhxWmpMR3RrUEZYYTgxMzFuQlRBZ3BuSnZ1MlMxNWRQOWUyOVJRMHZHRkJFQ1BLbVkzc0lTL08xL01jZGRwamVPN2QvRkVkY2NsVTF5TlhXcXAwRGdudjVKNll0Lzc5SExkVmRNOGVxSWU2UDJMMkFsZVp2NFZPNXpaNGM5dUZaZzNzN0hrZ1RNb0pMUVZJN2pKZUQ1NDF6VUxacmdMYkswSGl2NGM4cGtWTEJOQ0hyeTZSWDNuOWQyOGlIbHkwejByNi9TNmRjbE01Ni9uNW9BRlFOOFh4WkZ1NEdKWXY5LzVqdmZJMWk3MXFaKzN1YnJvc0ZKQWNUMTl6MGRHbk1qbDd2NkZMNjFVZHkwNXEyZ2hNekg4MldRc2tiUThGdXYzSU1zRjJHSHJYN0hIRXFLNFpBeWU0M1B4KzRkTDBzSXVQL09ITDIxMS9YMmZ2bksrUGhjZ1AwNjdaMlYycnBQeGhLa1d6M0RldUxMK01BSFFWNlFiT0IxcEdYVDFjMXlPQzVEdXFsOXZwVXUzRWlTVVpSclFMYUZReHZyODhKWUxDenBweS9kS3lFd05melpwZVpUZkk2MERxTHp1L2dnYndhTms3S3liQ1JqYjJ6dEw5bHhrWW9uYnRZTGxuSEx2bFJ6bitYRFRQZnVIZys1Yi85eU1MNVJTTmZrRVRBS2doMGszc04wU0o2MEF2OXgwUWc4R2Y4RkZPSlBCNXZuTTBQM3B0bE1jNFdVbWdTdFRLRXNrcllHeUhxaVVuc2czL0RtNWFOMS8wMFdFd0JLWjArQjhyTzMyb3hSaDlxcFZDOTExL3o2ejhVQkpuOC9YbnZtajYrK1JzakMwQXJybnBudjJqNGZkcjdMa1puemgxZ0F1UFJtSWRWR2tKZTdoTllkVnk3OXVWMy81MmhFOXBtaVppMm5uZHBGWHR5anJVbDR5a0Z3Q2wxUFNTdmZOMnk3VkxSQnVmb2QwSTd0cHNTQUVsc2FWTG1xSHdidmNyUDRoeGQ1TFBkTmVmcjdVQm5SRHppVmZXN1dRRjlNbHA5MnpNanYzMVR4V3pHcVo3SHdkNG53Q0pnR3dDa2g1bGRRU0syNldpWHU5clljajFlUHNTUjl1eVluZXpRWGxXN2Rjbk5meWM0UkFJRDAzcTM5czNIT3NMTTlKaWp6TFVwTnVTSytDbTV2Sm9IUFRQWnZ2N054RjA1M2ZKTDRhd0NWWkE3a3lzaXpLN3BTTUZTekhXcjF1eHlRaTJjTzNMM01kekdRd3VkdmxuRzUvOUEzWFk0UUlnVUI2TWxIS3plb2ZiKzQ4V3BibmxlK0VFTGZkMlVIbXBudDJjNTdMdjAwWjY2elFTVkNIaUFReUFGN29ZbGJRTzRmeWIvMXpFelR0MVFuZ25xekx1V0xoVEhlQk8zWjNmOS9UN3F2NHk0Vmg1US9XNkhwLytZWkE2VVpHZVUwWVZjTkc4S0FQejNmZS9TdXJmNVJ6TFc4M0UwTGt1VDMwL0R1VWczSEJUZmRzUHJOelA5emt2RUZneXhFQ1lHQmMxVExCOGRjV3NpNmdGSWwyYXVkUjZwVGxRN3BjWkFDMlcvLzRxMDBGbFpLUUphRGNqaE95U1lrWXVvckthLzUwNm14NjBjVnpuYS8rOGU2KzhxK1gvdGpyT3h5RnYzdC84aWJoejZWbFp6c2JocFh2N055WjQ1eVhPVDdjUFVRQURBS1pPZWltUUhNaE0zblBkM0hST2RYUGhKRjhQSFRuWmE2NmtJUUV0MkswSkVqM3NkejF1eVhQVjU0M3N3YkxwNWxDNjk0N0Y4ZjJmemVUcVRic1BscjI1eWpuaVd5dC9USXA1WnJ2L1phaTcyN0QzOVJSanN1LzVEczdkNG1MQXRPbkEzcjlEVndBL0VTejg1WVhLUjlUeUV6ZXBXYzduMml5K1FndGdHNUoxNitiQzRoOXduWTc3aThidWV2UEp3VEs4NWJGNUpHL25aM09XM0JsZVVaWm9RZmVjZGV5MmE2Ky9xWDNqMVRtSnZQbDdlbWZUeXdZeXBoZ2xuMTA3MUlYTS9qem5aMDdkYXp6aG9ITkovcXpmbDdHRXhJQWZjQk5xOXltZy9tUC8zUGIwdmprbm03T0NpN0lPTHE3Vnk1eS9YMnlSRnV4NVJzQ3BWNWhQblVJWVhLN1JKd3N6MWdPY3V4TDJQenBEVTJ1eGdFSHphSlpqYTV1M0VwZC9pV1RkR1ZoNUgwWkJrTDR5NC9UMXJsOHk3L28wRGJXZVJkd3B2R0NFdnp1dWFCUmZXN0pKRisrRHJWQjIvSGN0TXF0M1o5L0FMeHprZk54aHF4VDZwNlVZM0ZMVHRxbDZxcXh4Lys0cVVNby92YmpGNmtOYlNjcmRuR3JkbkxzT0wzUmtxK1RVSlp6VFcrWFlVL3FFY3JFc2xrVDYvV2Ezb25QNTFEWEFEZDNtYzdGemM3SC81V3IvRXNtVWhiR0htdjh6NzkrUjA4UVFmN09jMWllNWYweVRjNzQwMFVUMVhzbnpMR0dMUlBxMVBsVFJxbWxaelhvY1lyU1ZTM2pFQW1BVmE2Y3JYSWZtdTM4enQ5dWFieXhxU0ZwNG9oMGNibHQ1UWlDZkxwK1pkWnZNYnQraXhVQ1pUemdQOXgyaVo1WkRQZmsySEZ6VEYrM3NGR3RpMzM5azM4OG9kZnNkc0krTHM5dHJOT3ppU1hvblJXN1NNanZsYTdsYkhUQitYWEhlYUZTU0F1K203Sk41U3Iva29tMDlEM3oxaTcxMm80ampQY3IwTTNOcFMzL2tnK3BSL2h2SDUrZDlmUFNHbmpDWjB0S0Jpb0F1aDMvSjkwMzlray85ZTVsWElZeEFVNHVDcWx1V1RwRlAxSTkvdlpSdFlHTHg0Z0xSejVkdnpMcnR4d2tCRTVzcUhmMUhKZk1tYXIvTGk0czdyMTN0RS9kNHZKNzVCaDk4UHBaNm0rdU9Vc2Y1eklEWHlaaDJjRk9CL1A2bXFKTUhKa3hub2srNlZ5endGMjl2SEtXZjhtazFEZVFRVEcveE9WZlNrWHFGajY1M1YvTHUvb3VBQzZmWEsvbU41b24zZFR3NW1iNU56bjVyNzY1c3VPenpwdk9VbGVwSHZqWUV0ZmZJNE8xeTNrQmtRdEYwK1F4anRZa0ZqSitrUENYSDJuRmt5RG45cWJMRG5teUlwQ2JWWUhjbWphK1R2YzhzQ3hreXJtdHlmbjRQeW5ZRHY5d3V2eGJ2dVZmRXIvZjZVb2pUcmlwVzBnQXJJQi91bnlxdXZ1eTZiNzVlOGFOQ2lrTWs2NWZhUzF6UTJwMGZmM1pkOHYrWEdXQStOc3pHN04yVmN0eis5SExXNmtmVnFCbk5wN3c5SEV2WXdUYkdBZVl4TTN5Yjl2Yk85bGdQaUhqNjV5R3NxMEZWc2FRN3k5bUFGemt3d1laWHlVTXY5WFNvL3NvbVF6RWR0c2FJT04yS2pWVFQwcEVTTWpMRlA0b0hsc2MvN3FwUS9VTWVQZllkN1B5VUJDNFhmNU54dDNCSDFhNEtQK3k4MlJoRXkvK2EyZHh1MnRsVm5ITGhEcGZ2UjYrQ29EN092MjFucTUwSDJHWUJMbWJmN3hPeitiTkZLd1NGYnZtWHo3UFYwSmVwdkJIdDIrUnRuTnZXUDN2MXo3dzdQT1RzWVZJSmpkeU1qRXJGL2thamhQL2NOT04rdXpld2xyTnBmdjR0OXU3aXZyOHI1c3oxbGV2UnkyN0pLcU5oRHBwRlpCU01ObTZXQi81N1hzVmY2NXk4WkxBYWs4S2tWQks4ZGppazdHQVV1TXozV1NxaWwvMFdJVWtpWXpIdGNma3lwS0l5K2RNVnVmUGFsUUxtaHBIRFBIWXRQY1lHOHhIbkhhamJqOWFuTWtmcTF0UHFMSDFJWFZsOC9paS9MeTVrL3cxRHRCWEFWREt0cXoyMlFFak01R3BJNVkrV0QyLyttWDF3MXN1VkxkZVBpOXRDNE1YWmc3YWdWVUd2YytZTklid1YwSi8rZG9STlg1MGpTNzE0aVVzUTVlWjFMODBhMkFPMTlXVEdmRXlTMWdtVXEzZlJRRDBDK2srZFZxY2VVc1J5Nzk4ZTkweGRVLzNvUHJrQlpNTC9sbEhlL3kxWmpBdGdLaHFYL2psWmwwajdLdC91alNwcnRqZlAvK3VwNTduZlUrMzZyZUV2OUtTSXMvMzd1L0plMlp3c2EzZmU3cG9yUm1CdXJtajI5ZDMzSXovKzBPUnk3ODgrbTZuK24xYmo3cmovTVo0Y1djblpDVVNLVVl0OVFoZjNOZE5IVUN2YzdNeVFEV1FBZVMwQUdZbkxYMXI5cjJpSHI1OW1WcXhjS1l1KytLMWxUVUlmdVVqM2NIUDdlMVdYMXc2U2QxMjhaU3lCVUU1OSt5T1BXVDFEMW5ibStNV0dDWTE5Q1JFWFRobGxGb1FlOGh5Y09sS25Vbm9hajFlL0pVM1pFeWd0QVlxZFV4ZDI5U2duME02M1FNUjFYNTZVTzN2SGlxb0RBMEJzQUxLTVJ0d1MzdjZKZUs2WTNjSFR1NzJaYmF5MHdrcmJoYThEeko3Z3NpRFY3ZW9KMW9Qc0VHQ3ZqLzBodFZYMWgzWEQxbVhWOFlIeWpLUWhkNGNTc2lUYzR4ZFBGcUNYa2RmV0wzUVRpc2ZrSXUwb01uYXZucDkzM2ZOOGo1MkdKUHhkUXRqb2JBY3k3L0ZuMFBBK1M0QWRtZHBvclZQM3JiV0E4bEJibk5LM1NGTzdOV0hzaXBJcFpkOFMxajJUY2JWaW16bFdWSnYwbWpOQThvVHhxWlEvNVlBbUsvLy83K1BxLy83YmdjQkRrQmFkcGdqMUFIZTQ3ZHhkZ1RBTWlMd0FRQUFaRWRiS3dBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQVFIV29MZFlQZXZTVGk5bWFQdmZ2OTkzS1J2QTVqbU9PWTFTL3YvcklYRFlDeWhNQS8vby9YcTNPdno0OHBJendnREtpa1lKL1ZOUUlLUldxVWRHYWVxVU1nejBMQUFENE93QldyWnBhRmRWQnNMQVFHSTBGUHhXcWk0Vy9XdllvQUFCQUFQUitDSXlGdDJqc0VaWW9HSFVYL0tTbHo2aFIwVnBwOVdNNEpRQUFJQUJXQ2NQc3RvMUdsUkVKT3d5QmhobitwQVd4cGs2L0R3QUFRQUNzcWd4b1dFRk84bDlFR2RGc3JZR3hydzJGeks4UHNma0FBQUFCc0hySkJJN1l3d2dQeFRMZ1VFSVFUTXArc2EreFd2M284Z1VBQUFSQWY5QVRPZVFoSVZCM0NWdkp6ekRmNmdrZmhEOEFBRUFBOUNGcDZhT0xGd0FBK0RIbXNBa0FBQUFJZ0FBQUFQQ3huSDJjRDl4MEtWdkpoWEFrb3JyT0RLaTl4N3JVdXdlT3F4T25lOWtvQUFDZ3VnTGdkMTQ3d0ZaeXVqRkRobXBzcUZVdGswYXBwVTFUMUNYTk05UzcrNCtwVjdjZVVFUGhDQnNJQUFDSHBveHZVRXZPbnF6T25UcEJUV3lvVnpVaE9pM2RpSVREaFFWQU9EY1VpYXJqUFlQNnNlRlFkeXdFVGxEWHo1dXVHc2VPVnIvWXNFT0ZJMUUyRWdBQVdkU0VESFhOb3RucXduT21xR05kUGFwMXh3RzE2NE1UcXF1bmo4WVVGeDc4ODVVRXdFcVFFb0liRDUxU0hXY0cxYWN1bWg3Ym1jOVJMNy9YeG9ZQkFDQkwrTHYxUS9OVlUrTVk5V0xyRHRXNjYxRHNla3JqU1NuUW5scGkrenA2MWU5M2RhZ0xtMmZvNW13QUFKRGVOWXRueDhMZldQV3oxemVwUCt3OFNQZ2pBRmEzMWtPbjFQRXpZYlhrbk9sc0RBQUEwcEJHa292T21hWis5OGZ0YXUrUkRqWUlBYkQ2eVEzTXB2YlRxbm42SkRZR0FBQnBYREI3cWpwK3FrZTE3bTVuWXhBQS9XUDNpVE5xNHBoUmJBZ0FBTkpvbmpaUmJZeUZQN3A5Q1lDKzB0azNwRUloZ3cwQkFFQWEwa2l5cy8wWUc0SUE2QzltQ1JnQ0lBQUE2Y2dNNE03dVBqWUVBUkFBQUFTSnJLWUZBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQkFBQVFBQUFBQjBJMmYzdENrYm14cTRGVUVBQUFsZGRtTWNiNzZlMnFyOVlsLzQ1Sko2cnFGamZweDdQU2dXcnY3bEhwdXh5bjFRbnN2ZXlrQUFDaUttK1pPVnQrNjVXSTFmZUlZZGU5UDNsVFA3emxKQUt5a2p5K2VGUC8zdFBGMTZwYWxVL1RERG9QLytQWngxZFliWnM4RkFBQjUrZjROaTlSdFY4eFRZMGZYNmZjbENHNTU5QTNWMWoxUTlYOWJWWFlCUzdkdjg5VFJhVDhuWWZES2xnbUVQd0FBa0pjNTQrclZLMzkxbGJwNzVhSjQrQlBOTXlhcTc5NThnUy8reHFvTWdKKzVjRkxXejcrd3RZTzlGd0FBNU9XRkw2MVVTK1pNVGZ1NVZVdm5xUHVXbjBNQUxIc3FiNmpSNC80eTZSa0lxMy9kUkFBRUFBRDUrZG5hblZrLy83Y2Z2MGkzRWxhenFoc0QrTVdsMlZ2LzNqMTBSbDA1czBIZDJWaW5Kb3lxeWZuekRuUU5xa2UyZHJHM0F3QUE3VHV2NzFhTFpqWHExcjUwcEZ2NGE2c1dxaS84Y2pNQk1GL0xKOWVyK1kxbWlyNXd4dkM0UGdsdjg2Y1B2eisydmlianVMOUVLNXJINjRkVFc5cDdDSUFBQUNESjE1OTlWMTJ4c0NscERHQ2lXeStmcHg1N2E0OTYrMGczQVRBZjM3MXVwbHJTTkxaaXYxK0NKUUFBUUNLWjZmdlB2MzVIZmZPMlN6Tit6ZjBmUFUvZDhWVHJpSTlMOTdBOVdVU0NwQmRuRFFkK0pSQW5yWW9BQUNCNEh0NndYMjFwTzU3eDg5SkNtRG9XVU41LytwNlA2TzVqZWNpL3ZUaGVzT0lCY09mUlB2WXdBQUJRVms1WDluanM5UjBaUHlmZHcvZGUyUkovWDRwR3l3eGlLUmRqazM5N01RUldQQUNlNnE5OHZiNDc1bzdqU0FBQUlFQWV1dk15ZGZSN3QrcDZmeis4NVVKZDJpVmRLSHhpeXdkWld3RnZYR1pPRkpIdmYrUnpIMWJUSm80WjhUVjJDQ1FBZWl3QUFnQ0E0SkNnWjdmU1NiMC9tZEFoWS8yZWUrQjZ2ZnBIcW15dGdCTDQ3bHB5bGxveGIxckdDU04yQ0h6eU04czhzdzBxUGdsa1grZGd3VC9qOSs5M3FrTmRJd2RZYmo3aXJIdDVaK2NBUndNQUFBR3hhdUdNakovYmY3Sm54TWVrRmZDclhXZlN0dTZKR3k2Y3BTZURQS2xVeHRJeHl2cmM5MCtlVVY5K2NSc0JVTUxYNDI4ZlRSdmE1SE1iVGc2b2RYZk96VGhaUXdvLzMvbGlPM3N6QUFCd1JHcjhaU0lUUDlLUjR0RDMzM1JSMnM4dGJaNm0zem9KZ2JLODNPYURIVHBVQmpvQVNzRGJzQzVMMzNxV2RYL0ZNeHRQc0NjREFBREg3TUNXS3R0WXZ5ZGFEMlFNZ05JeUtOM0tVaE5RUXVDem8rdlZpb1V6TS82c2I5LytJYlZtMzI4cldoN0c4MlZnY3EzNysvUHRwOWlUQVFDQUl4TFVNblhsdHU0K2x2SDdKS3p0UFpKNTRZZ0YwNFlua056M2RHdldyNVd4Z28vZHZhS2kyOEhUQVZEVy9iMThidVpWUFdUc243UWdBZ0FBT0pGdC9KOTB6V2F6Y1UvbWdIamgyWk9Td3VMOVAzMWI5ZlNsbitjZ0gxLzlteTBFd0V4azNkOXNLM1g4WmdldGZ3QUF3TG16SjJkZWZTelh1THpUdlprbnJvNXZTSjRCTE4zQnNwSklLbWtaL05RUFhsWFA3emxKQU16a3hzV1p1MytQblI1VVQrN3BaazhHQUFDT0xXaEtQd0VrMi9nL1c3WVd3blEvVnlhVS9HTGRydmo3TDIxcVU3Yy8rb1luMWcrdTllb0xKTVdacDQzUFhFL25QemNlWnk4R0FBQ3VTTjIvZEhhMGQ1Yms5MzNobDV2VnhYT25xVFh2dFh1aS9Jdm5BK0RIRmt6SSt2bFBYVHhWblQyaFhqMjJ1WU54Z0FBQUlLZHN5NzhkVEZQL0w1VjBFYS9PNC9kS3ExOGxaL3hXVFFCY1BybGVYYmV3TWV2WFNPdmdMVXVuNk1mZTQzMXF6ZTVUZWtZd1lSQUFBS1NUT0ZNM1ZkdUpub0orZHFhV1JmMnp1NzJYVFR3WkFEOTUzZ1JYWHk5MUF1Vng5MlhUOWRqQXRiRXcrTjdSUHZYSTFpNzJkZ0FBb0NYTzFFMVY2Y0xNQkVDVmZmSkhMdkdXd2RpL0g3eCtsdHJTM3FOMnhzS2dCTUlOSC9UU1FnZ0FRRUExVFU1Zi95OWJ6VDRDWUpuY3UzaGkxc2tmYmkxcEdxc2Z0MWp2eTlKeDBtVXNvZkJVZjFndlBkZlJGMVl2dFBkeVpBQUE0R01QdmJ4ZGJUdlVxVXZCeU1TTTVoa1R6V3pRTjBnQXJMUS9XOUpZMHA4dmRRWHRVR2lUYnVNWGZyU1RJd01BQUIrVDhpdXBKVmp1V25LVzQrOS84T3FXako4NzFuV0dBSmd2bWZ5UkdNeEdiTnhZVUJzektwUzFPSFErM2puVXcxRUJBRUFBcFk3OSsvNE5pOVQra3oycTg0dzVaR3pOUHJOZzgxM0xacXUvK09qaWpEL25TQ2NCTUcrZno3SHVyOVQrKy9zL2RxaHZYREpKWFR0dlF0YXc2TWFoTHNZRkFnQUFwWmExVEZOM3IxemsrdnNPZDFSWFk1Sm5BcUNzKzN2OTRzemR2ekoyVDhLZmtMZnlrQlpEbVRGOFZjc0VQUXM0WDYrMzBRSUlBQUR5SjJNTENZQjV1SFBSaEt4ZHU3L2JPbkxEeW96ZURldU9LeFY3U0lDVW43Rm9lb082Zk81NFY5M0VUQUFCQUFDaWRmZXhyRFg5MHBGSkpFKzBIaUFBNXVQak9VcS9QTGZqVk5iUHQvWGFMWVJtSytHTlRRM3E0ck5HNjBEWVl0VUpURWZLeEFBQUFPVHJtYmQyZWJMWXMrY0RvSFRsWnV2Q2xiSXRibHZwNU92Tjd4bGV1RmxDNGR6R2VqVjdZcDA2THhZTXg0MEtxZFlEQkVBQUFHRGFmOUpkTG5ocFU1dW4xdml0cWdBb1hibVhQYnBkZCtGK2FQWTR0YUo1Zk5MblpabTNZdENCa081ZUFBQ1FnVDM3TnhjcCsvTERsN2FxaHpmc3I4cS8wek5kd1BFdTNEU1RPMlNOWHdBQWdGS1RzaStQdjJLMjZNbU00RlE3Mmp2VmU0YzZxemI0ZVM0QUprcWMzQ0Zoa09YYkFBQkFPY2hZdnVFdTNXMisvVHREWG4rQ2hEOEFBSUNBQlVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQTFhWTIxeGQ4ZmVWY3RsSVJQWERUcFd3RUFBRFNlUERQVjdJUnZCQUEvK09Ocld3aEFBQUFuNkVMR0FBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQ0FZakIrOEg0MHltWUFBQUFJVUFCVWt5Ni9MUFoyVXV3eE52YW9aNU1BQUFENDBrRHMwUk43ZE5URy9oZU9QWVppajBHMkN3QUFnRzhOV3BrdkxBR3dQL2JvdFQ1Unk3WUJBQUR3cFNFcjgvVkxGM0JMN0I5allvOVJzVWNOMndZQUFNQ1hwTmRYR3Y3T1NBQ2Nwc3l4ZjdVRVFBQUFBRjhIUUdrRkhKQUFPTVlLZjFJU3htRGJBQUFBK0pKVWZvbElDSlFBV0tPRzZ3RVNBQUVBQVB3YkFFWGsvd2t3QUNRbVNtTU5mT1F1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQWxDQVlBQUFBcVhFczlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVSa015UkRrNU56TkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNVJrTXlSRGs1T0ROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2preU4wSkZRa0UyTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxHUXpKRU9UazJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtFVndjR1FBQURldEpSRUZVZU5xY1dHbHdYTldaUFcvdGZWRjNTeTIzSkcveUppOVlYbkVNamdOTUlFT3dJV1Jxb0dxV0tnZmI0MUNWZUFLa1pxb3lxY0daTUtsVWpSTThnY2tVV1VqK0pBWFlDVEFzSnNaT2pHMkNqWTBzZVpHRVpPMnRyZmZYeTl2Zm0rODl0YWR3aGdCSnk3ZTYzZEs3OTl6emZkLzV6cjJNc0RXR1ArWDE3ei83WjM1WUdkNTVYL3dMNnphSE45K2ltbXFIbC9VR0dEQ1FMZGtJQ0lIZW83blh6NzJhZi9Wc2g3L2ptTWlJT2MzVW9ObmFqUlBaYzI4SGRuLy9ocS81VHdyazhaODhzbnBhbjlsenNYTHhDOTF5ZDl2TjBTMklCQ0xRcWhwVVc2WDViU1NFQkZnUHUvVmk3ZUxXQzdVTERrQXB4c1YrbFJTU3owYjR5RnVLcFVDM2RUamcvOWlMK1RpR3Z2dnNONWhSZGZUSkVXM2txeFc3QXBpQVdsWEIwYzlQMXY0VTdiRjJRSEZtb3VFQlRreWV3R05YSDBXTWo0SHhNYkI0Q3o3NDBjYTMvcUxkMy80WXgzQlRWYk1LeG1ZK2xDR09hL1A5VVRBSGZ2cm81cDVxejdFaFkrZ2UwelRCMXdUd0pnYy82MGRaS09PTWRnWWV4Z09UTVRHdFQrTzEzS3Q0T3ZNVVJFNkUzL2FETlZod0dnZUxmcDloTW1zS1d1R2hFQk1haWZMUks5ZERlUExsZHo0WlE0Lys5NTR2dmxKNDViRE4yVmhrTDRLdUd1QkVEbnlJZzJSTFlHc3NNYVhCdG0ya3hCUk0yOFFNZ2ZKemZwY3B6YThoekllQktuMnVhZkI2dlpqbFpwSFRjdGdlM3Y2dm5jSE9iNVdNRWg3Zi9iMlBaNGpBN0x3aVgvbjEvY243MFlKV3ZGL29SeVFSUVpFdndpNEJTOVZsNExNOGhLS0F1SmJBZkxZTkNTc0JzZUtCVnRBUlZzSll5QzFFUlNrakkyWVFpOGFRTCthUjRsTjRzUFZCVENnVHQrVzBmTG5GMC9MNzM3eDA4cU9UK3A4T1BkenlRdjY1bHg1dGV3eDdGdThGS0czdVpYWmlvRENBRGRwR2VNdGVzSlF3NnhMcjBCSnV3WUxRQXNSOWNUZFJpMW9SWStVeHBLVTB4bkpqYU5LU2FBdzFvbGU1Q2lrczRXRGJRV3hLYllaVUx1Ryt5L2NkRE1CL2laWTg5bEdBbUdFTXZjSFFralBWR1VoVkNmMXFId3FGQXRZV094RTBnNWdYbjRmTk5PbWRDKzhFQkhyQ29BcldiVGQwTE05aWk3Z0ZzSUMzeDk3R3FZbFRHSnNkd3lwbERTNzR6K09jZGc0cmxaVzRrTDhBMVZCbzd2ZGYrdG9UZTVMZi84YVB5aCthUXcvLzRHLzM5Mmc5VC9vTlAwcVZFcExKSkNaS0UxaFZXZzNCRU5BNXZ4UDcxdTl6SzZva2xXaGRxMTdDYkgwR3l5MS9wNEtpd2FnTCtNaVZJM2k5NzNVRXhTQk9lMDZocmFrVjJaa2NQSUlIbHQvR0VyNzl1Wi90LzlXRC95K0hObTVmSzVoTHRPT2FwZkdRZ1VBNGdCRjVCQjNWbFFnWUFXeGJ2QTI3TnV4Q3JWSkRXWmJBc0F3dDNRREw5THIxYnRPd0xDOXMxZ2VXMVNDckZiY1ExczFmaDZnbmlxNnBMamNmdTdWdU5NVWF3Y29zV0k2aGpLaXN2dWV6ZHo1Lzl0akY3QTJBL3ZLcjIvZFAydW5QQzZyZ2lxZ1pNcEdVbWhFdFI5SFp1aGE3TnU2Q1ZKU2dtVElZcmdHbTVxZGQ5c0lmZWdOZTRWWDYvQlk4dm10Z0xCdWF1cERDNTZjd2xxSElLbGEwckVCQkxtQWtNNEtVdHhWVDRpUkVRd1JqTUZCNEdhVDAwWjdmOVAvNmc0QzR4WGVrL3JQS1ZGTzhRZFhqRTVHVGNsaXFMVVBFRzhGRE4rMkdhSWxRREtwaExnYURGZ2tGZndoZStUYXMyUmVoei9iQXlIVlRBUndIYjc4QlR6QURwYktXUWticFlGY0p2RVhKdkFsWGkxZVJ6V2VRTmJNSU40UnBIc05sMnJLdCthdmFPbjdZZC9HYTZnWi85UmNYTCtzMWV6ZVVha1dZQmtteHgwS2IzWVpDS1kvMTg5YWpzYUVSSmFWRUQvdElVemlFZkUrQUxSMUFkWkFqRnY0Q1l2UXVlQnZ1Sk9ZK2k5cDRBbmIrYWZxYlIyRFVhdlJka0RZaXUrV3pKckhHemEvMXZnMG9Ha1d3Tmd1RHdqcUVvZWcxdS85ejF4bGl2cnpqb1FjK3ZlVFd1MVZaeDZBOEFObVcwY210UTV5UFkydkxWbGY0bkVrdEpncWYrQkxwelJPb2pYV2lZZlVkRUpwallIVVNBbGFBa0d5Q3QzRUo1QkZpV1h3VFhDQU94ZHdDamxHb0VvRkdYd0lUbFRSbXE3TklXMm5VMkJwc0N2SGR6WGRqRTd0bCtzM2Z2ZldHd3hDMzk5TjdOdTFMZmhrLzcvdzUvbTdSMzJOYW1zRnNjUmFOZ1Vhc2JGZ0pTYU1rZGxxRXBvUFhEa09mOWlBOG4wTEM2ekFuU3NUU05HeG1HbnBhSWhtb0lqUi9CZFNKSklYd0JaanFKSUVOb1diVWlPa21KQUlKRE9XSFlPb21vdDRvRG5VY3dvSDUzOEkvYk4yN2piQUlEaURCMHMydHMvS3NtOXhmWC9SMWZDcjBLVnd1WEVMRUUwYkFGNEJ1MGZhNEVPM21DdFNaYnJCTU95eFZRclgvUEd4dUdKV2h5NmdPOTRFVlJ5R1B2Z2NsTnduQnZ4U1FCaUVLbDZpdGlIUE5sN0xCTC9nUkZhTXdMQU5mYWZzS05pWTNvYUFVVUpRS1RVNjVPb0JFbHVXYUhUM0pLQmxhR0xndGVodXlhcGFhcE1lZHlCRTlSMnBzSlExa3JnR0VqMlYxNklVc2pFd3Z0WXN5dEd3UlZxRVB5dXdNaGNpQWJSS2J4U3hZWlpxYWI5My9XSmpUTGZxM3pMY01HME1iS2M4TUFrZC95d2tCaHh4SHFVbStiR0hPTTludWcwNG45dkJleUU0eVduVUZaV3dZOW53WWVYb3ZFVXZrYmFod29ZMUl4RFBuNWtKdG9BYk9ReG9qalVPZUduZDhDdFJZR0VLY3BpRTF2NzY1c2w2R3ovYTVNbnJkcTdFc0l6cnA0d0RpTE10MkdvQW42VTI2cmVDMTdHdFkxYkFLRW9VbFg4bURaM2dLVVFsc3d4b1lnWTB3cDA1QktoRWNnY3haeFFUbmlDUXR4dEppdkRlTkVySEVtcE9Rd3d1Z1IrNkFSNWNwV25PTGx5a2ZUUXBYajlTRDg5SjU3SnkzRTF5SmN5ek1IQzVuODRGUW9KZ01KVkdqSFgyNzk5L1FyL2RoVVd3UnBzcFQ2QzMwSWlKR1lKb3FmQ1JaY3ROK1VHK2trRWhRaWliVWZCV0dicmxNMXVpelhORElGV29nbFlDYzNBOC9NV1RReGh4Yk1wNGZwd3JMWUdsOEdaVTNpLys2OWpST2pwMUUzQnRISkJ4UnJwZDlVUE5WN3hqd3ZML2d5YkZET0RaMXpIV0JUbU5WeW9wYkZaMHRuZFF1S3JSckRXeHFBN0taUEt3cnArRHh5dUNDRFdSaktaOUlNc1Jna0ZncVFwNm9vclR3cnhIY2RoQ0NWb0p1YUlpSDR6ZytlaHlueDgvUU15eXNnSVY4SVVmUmVCMlRUQnBkWFYyWkU2Zk8vTmdCNURzOThkdWJMa1Y3TmdqTlBCcjBHR2tZanlsakdzdTl5NUdwekdKRnBBUEpRRFBLRkRZdjlSOSs4YjBvYUQ1STZWNVVNeFFlV1lPbDZGUXBOYklnQkhEbHc0aC83a2NJY0NvQkxjRlBqZFd5VEJ3Wk9FTGxYMFczMlkyd0dDTDk5U0xVRU1TNTlEbjg4b1huenJNRjd4RUhrQ2NjRGtibkpadDJKT2Nub2RkMFZ5UDhZUzlLTkZsQUMySzhObzd0QzdkVG1Heklpb1NBd0NCeTArMHcydjRHRlRKbmRxUU5adU42S0sxL2hkRHRoNURhOWdBOHBEdHFwVUJaS3JnRzdabnVaekNZSFVUTlYwUEZUN3BHanRPMkxRVGpBV2pET3BScnhtRzFhSjUyQUhGYXhWSjRuN1V6M0J3SythSmVhQlVOSWdsaGpzMGhpQkEwWW1CWUdzYTJoZHVvVndrb093bFNxeUlhYTBEVFRiZkEyN0VEd1ZVN2tWcTdEWkZRR0hvcEExMVRxT242RUkvRzhXTGZpM2huL0IyWWdvbExkby9iQVp5VzRRbVIyS29tSnQrYjBnclhhdDh4Vlh2TWJSMlVTejZXUjVEM3NsdGlpOGhTR0piYitCUk9BUjFwMEVMV1U2UC9uOCtjeDhhbWpVaUVFNVFYQnJGVmhrbjlpbFdwWjFGQkdOVUtOS1ZDTWlDZ0tkeEVrL3J3VE04ek9ETjJCaVpyNG9SK0hJSkhnRnFtNXV3SlVmL3pJdE9id2ZTbDJUY3JVOFpod3BGeEFEbEt3NnNsczhBSStqM2VpTmNmYUE0aVY4N2g3dGpuc1cvRlBwd3Nub1JHaVNsWGE3aVV2K1FLNkR6L1BLU2lLUVNGSUlVdzRJNmdoL2owRTZPNmhxT2pSL0h5OE11NFBITVpCbStneSs3Q1A2NzRHcjZVK2hMU3RVbWtTUjZzb28zeHN4TW9EcW4vWW1yMklPRW84blZkcWpqb3FsUEdmNlRmbS95TzFXQWoxaGpITjFkOEUzeWNKKzBvWTgvRlBiakxmNWQ3aXBnWW1NQkFkb0FTUFVuSkdRYlB6amxoNStSUjAydXUvZTNQOTFNenRtQjZEUHhlZXdlTElvdXdPN1ViaUFEajVnUk85SitBZUZaRVpVWjlWcXVZdy9TNDVFeHgzUStaamg3cFZVdmpCRHRtVkxUbDNoWXZ3b0V3UkZuRTgwUFB1K3F0K2xYUW9SR3RvVllVMVFMZW5Ya1hFNlRLdmJrKzlPWDdNRmdjZE1OYW9xTUphUnZJRGlQbnpTSHBTVUtTSk1oazdsVDZPWnc1aktFelE2aU95TjJGUWZVSHRMWURLTzgwbHc5NmFzZUxMcUN4UExIYzkzaWcxYmN1Y1VzQy9vQWZsWHdGWVN0RWVXQkI5SXNvbWFRdE92VWZpeWRSTk54VEtwa3NTQ1NXQVUrQVNDUWFlUVl4b2NHdFd0dWdwa1FrVm9Oa2F3MGRoZk1GMk1NWW43cFNmb1RXRzZCeHJSNmxHODVsNXR3WmdnNm9PZU9xSUdLaGtwVmJ4S0NJWkNwSmxwU0JTWWx0YXFiYmh4dzc0ZVRNcnZaZDJOR3lBN2MwM1lJR2Z3TzZ5bDEwdXVVUnRrTXdGTU5OQ0RFa0lCQ25BMlNCYURpWEkwZWdqT2F2S1FjczAzYVlHWEU2eXZYcmh6ODhLT3Ixd1RtZ2VHcGk4a3gxaFVrbDZpVTU4Q1g4NE1peFZQV0tDK3hneC9kdzc0SjdzVmhZakhaZk8yNU4za3E2RmNEUnFhTUllWU5rWlQzd05WQVRwZGJpVk5QRStRbFVaK1MzYzMzcWR3bk1LSzB6UkNOWEorTkRUNjRPU3BXR2MvQm1sSUl4eHJEc3FGeXNwaXFaU3RScEQ0NGp5QWs1N0YyNkYvZW43a2U2bElha1N5anBKUmlhZ1p2ak4yT0VHOEZWcFJkY2hVTmh0RUJsUFkzcys3bU1VclNlS3c2cXY2UzUwM1V3bVRvQkgza2Q0NFF0VzBldGxkT3FXazdqVWxUQjdiV3N2SlVQY0V2elFoN05EelNUZWpsNndic2VoMkhJaWxpMGp4QjVIWGtabm5yekthU3NGR21PTmtGOStWeGhVUG1mZWlVNVlNWWNadHB1aldyanA0dWY2SDdJcUdlOWc1NHlGUE9LdzhvcjlQN2I0RHl4UXpiMUplLzJYRmorbWZiYllyS2lCRVJCOERpQURNUFE4NlY4N1hkbjN5cnBnM1ovMmFNTlMrTktGejFYcTg4M1RXT0tSb25BR0gvTy9aRHJLT0dxQnhwcEpPcWZmZlh2K2ZyTjBBZHZvS3c2dTg1bTVEb3IyWHA0SERvVS9KL3Qrek11ckQ0QXpKR0ZJSTB3M01BZ01IZEY1WUppNjZDc09ydGFuZGx5SFZDNURzVDh1SVdZUC9HT2thMERFT2VzN3cxZ3JoZUZYUWVsMTRIcEg4WElINzcrVjRBQkFBbUgxM0ZXY2QyVEFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicGxheXBhbmVsXFxcIj48ZGl2IGNsYXNzPVxcXCJ0YWJsZS1wYW5lbFxcXCIgdi1lbDpwYW5lbD1cXFwidi1lbDpwYW5lbFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cXFwiPjxkaXYgY2xhc3M9XFxcIm51bSBzaW5nbGVcXFwiIHYtYmluZDpzdHlsZT1cXFwic2luZ2xlXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdzaW5nbGUnKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGRvdWJsZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJkb3VibGVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2RvdWJsZScpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gemVyb1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ6ZXJvXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDApXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBvbmVcXFwiIHYtYmluZDpzdHlsZT1cXFwib25lXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDEpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB0d29cXFwiIHYtYmluZDpzdHlsZT1cXFwidHdvXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDIpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB0aHJlZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ0aHJlZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCgzKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gZm91clxcXCIgdi1iaW5kOnN0eWxlPVxcXCJmb3VyXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDQpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmaXZlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZpdmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNpeFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJzaXhcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNilcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNldmVuXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNldmVuXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDcpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBlaWdodFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJlaWdodFxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg4KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gbmluZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJuaW5lXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDkpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBiaWdcXFwiIHYtYmluZDpzdHlsZT1cXFwiYmlnXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdiaWcnKVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHNtYWxsXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNtYWxsXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KCdzbWFsbCcpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmb3JtdWxhXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvcm11bGFcXFwiIHYtaHRtbD1cXFwiYm9udXNOdW1cXFwiPiA8L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gYm9udWRudW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYm9udWRudW1cXFwiPjx0YWJsZT48dHI+PHRkIHYtaHRtbD1cXFwidXNlckJldC5iZXRudW1cXFwiPjwvdGQ+PC90cj48L3RhYmxlPjwvZGl2PjwvZGl2PjxpbWcgdi1iaW5kOnNyYz1cXFwidGFibGVQYW5lbEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cXFwiLz48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcU3RhdGUudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wY2U3NDE5MS9TdGF0ZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vU3RhdGUudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5zdGF0ZSB7XFxuICAgIGhlaWdodDogMTclO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYm90dG9tOiAxZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxudGFibGUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuc3RhdGUtaXRlbSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMuMzMzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2Lm1vbmV5LXN0YXRlIHtcXG4gICAgcGFkZGluZzogMCAxZW07XFxufVxcblxcbmRpdi5wb3J0cmFpdCB7XFxuICAgIHBhZGRpbmc6IDA7XFxufVxcblxcbmRpdi5wb3J0cmFpdC1pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL3RoLmpwZ1wiKSArIFwiKSA1MCUgNTAlIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYucG9seWdvbiB7XFxuICAgIC8qY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwLCAxMDAlIDI3JSwgMTAwJSA3MyUsIDUwJSAxMDAlLCAwJSA3MyUsIDAgMjclKTsqL1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAvKiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5aS05YOPMS5wbmcpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cXG4gICAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG5kaXYuYnV0dG9uLnVuZG8ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBoZWlnaHQ6IDQwJTtcXG4gICAgcGFkZGluZzogNSU7XFxufVxcblxcbmRpdi5idXR0b24gc3BhbiB7XFxuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cXG59XFxuXFxuXFxuLypkaXYuc3RhcnMtYnV0dG9ue1xcbiAgICBwYWRkaW5nOiAuOGVtO1xcbn0qL1xcblxcbi5tb25leS1pY29uIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xcbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICAvKmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7Ki9cXG59XFxuXFxuc3Bhbi5tb25leS1pY29uIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblxcbi5tb25leS1udW0ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWU/NDZhOTFmNjhcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzRkE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxnQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsNERBQUE7SUFDQSx5QkFBQTtDQUNBOztBQUVBO0lBQ0EsMkVBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBOytCQUNBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0Esa0RBQUE7SUFDQSw2QkFBQTtJQUNBLHlCQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0Esc0JBQUE7Q0FDQTs7O0FBR0E7O0dBRUE7O0FBRUE7SUFDQSxvREFBQTtJQUNBLDZCQUFBO0lBQ0EsaUNBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLCtDQUFBO0lBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiU3RhdGUudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g54q25oCB5Yy6IO+8jOWxleekuueUqOaIt+eahOS4gOS6m+eKtuaAgVxcbiAgICBkaXYuc3RhdGVcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLm1vbmV5LnRhYmxlXFxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVcXG4gICAgICAgICAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5tb25leS1udW0oY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIixAa2V5dXA9XFxcImNoZWNrRGF0YVxcXCIsQGJsdXI9XFxcImNoYW5nZURhdGFcXFwiLHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjM0Knpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD1cXFwidXNlckJldC5iZXRtb25leVxcXCIpXFxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5wb3J0cmFpdFxcbiAgICAgICAgICAgIGRpdi5wb2x5Z29uKEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiLHYtYmluZDpzdHlsZT1cXFwiaGVhZHN0eWxlXFxcIilcXG4gICAgICAgICAgICAgICAgc3ZnKHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIsdmVyc2lvbj1cXFwiMS4xXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoKydweCdcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodCsncHgnXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGRlZnNcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuKGlkPVxcXCJpbWFnZVxcXCIseD1cXFwiMFxcXCIseT1cXFwiMFxcXCIscGF0dGVyblVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCIsdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIsdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uodi1lbDppbWFnZSx4PVxcXCIwXFxcIix5PVxcXCIwXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbih2LWJpbmQ6cG9pbnRzPVxcXCJoZWFkYm9yZGVyXFxcIixmaWxsPVxcXCJ1cmwoI2ltYWdlKVxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZSh4PVxcXCIwXFxcIix5PVxcXCIwXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiLHYtYmluZDp4bGluazpocmVmPVxcXCJoZWFkYm9yZGVyaW1nXFxcIilcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnN0YXJzLnRhYmxlXFxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvbi51bmRvKEBjbGljaz1cXFwiY2FuY2VsYmV0XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyQmV0JywgJ3VzZXJpbmZvJ10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgY29uc29sZS5sb2codGhpcy56b29tUmF0ZSlcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuJGVscy5pbWFnZSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaGVhZHpvb206IDEuMixcXG4gICAgICAgICAgICBoZWFkYm9yZGVyaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZycpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHdhdGNoOiB7XFxuICAgICAgICAndXNlcmluZm8uaGVhZGltZ3VybCc6IGZ1bmN0aW9uKG5ld3ZhbCkge1xcbiAgICAgICAgICAgIHRoaXMuJGVscy5pbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICd4bGluazpocmVmJywgbmV3dmFsKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgaGVhZHNpemUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE0MiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLngsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTY1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBoZWFkYm9yZGVyKCkge1xcbiAgICAgICAgICAgIHJldHVybiA3MCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxNSAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTI4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDExMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyA3MSAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxNDYgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDQ4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxcbiAgICAgICAgfSxcXG4gICAgICAgIGhlYWRzdHlsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwcHggJyArICg2NDAgLyAzICogdGhpcy56b29tUmF0ZS54IC0gdGhpcy5oZWFkc2l6ZS53aWR0aCkgLyAyICsgJ3B4JyAvL1xcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnKSdcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJywnICsgdGhpcy5oZWFkc2l6ZS5oZWlnaHQgLyAoMTAwOCAqIDAuMTcpICsgJyknXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KSAvLyA15Luj6KGo6IOM5pmv5pWw57uE55qE5pyA5ZCO5LiA5Liq77yM5Y2z5pi+56S65YWF5YC855qE6IOM5pmvXFxuICAgICAgICB9LFxcbiAgICAgICAgY2FuY2VsYmV0KCkge1xcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjYW5jZWxiZXQnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNoZWNrRGF0YShldmVudCkge1xcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKC9cXFxcZCsvLnRlc3QoZXZlbnQudGFyZ2V0LmlubmVySFRNTCkpXFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxcXEQrL2csICcnKVxcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXFxuICAgICAgICB9LFxcbiAgICAgICAgY2hhbmdlRGF0YShldmVudCkge1xcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcXFxEKy9nLCAnJylcXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5pbm5lckhUTUwpIHtcXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IDEgLy/mnIDlsI/lgLzkuLogMVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bW9uZXkgPSBwYXJzZUludChldmVudC50YXJnZXQuaW5uZXJIVE1MKVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4uc3RhdGUge1xcbiAgICBoZWlnaHQ6IDE3JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvdHRvbTogMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbnRhYmxlIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnN0YXRlLWl0ZW0ge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgd2lkdGg6IDMzLjMzMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5tb25leS1zdGF0ZSB7XFxuICAgIHBhZGRpbmc6IDAgMWVtO1xcbn1cXG5cXG5kaXYucG9ydHJhaXQge1xcbiAgICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5kaXYucG9ydHJhaXQtaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy90aC5qcGcpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbmRpdi5wb2x5Z29uIHtcXG4gICAgLypjbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAsIDEwMCUgMjclLCAxMDAlIDczJSwgNTAlIDEwMCUsIDAlIDczJSwgMCAyNyUpOyovXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICBtYXJnaW46IGF1dG87XFxufVxcblxcbmRpdi5idXR0b24udW5kbyB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aSpOmUgC5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA0MCU7XFxuICAgIHBhZGRpbmc6IDUlO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHNwYW4ge1xcbiAgICAvKmZvbnQtc2l6ZTogMS41cmVtOyovXFxufVxcblxcblxcbi8qZGl2LnN0YXJzLWJ1dHRvbntcXG4gICAgcGFkZGluZzogLjhlbTtcXG59Ki9cXG5cXG4ubW9uZXktaWNvbiB7XFxuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcpIDUwJSA1MCU7Ki9cXG4gICAgLypiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cXG4gICAgLypiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyovXFxufVxcblxcbnNwYW4ubW9uZXktaWNvbiB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG5cXG4ubW9uZXktbnVtIHtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5O1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBWUFCZ0FBRC8yd0JEQUFvSEJ3a0hCZ29KQ0FrTEN3b01EeGtRRHc0T0R4NFdGeElaSkNBbUpTTWdJeUlvTFRrd0tDbzJLeUlqTWtReU5qczlRRUJBSmpCR1MwVStTamsvUUQzLzJ3QkRBUXNMQ3c4TkR4MFFFQjA5S1NNcFBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDMvd0FBUkNBRXNBU3dEQVNJQUFoRUJBeEVCLzhRQUh3QUFBUVVCQVFFQkFRRUFBQUFBQUFBQUFBRUNBd1FGQmdjSUNRb0wvOFFBdFJBQUFnRURBd0lFQXdVRkJBUUFBQUY5QVFJREFBUVJCUkloTVVFR0UxRmhCeUp4RkRLQmthRUlJMEt4d1JWUzBmQWtNMkp5Z2drS0ZoY1lHUm9sSmljb0tTbzBOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFEaElXR2g0aUppcEtUbEpXV2w1aVptcUtqcEtXbXA2aXBxckt6dExXMnQ3aTV1c0xEeE1YR3g4akp5dExUMU5YVzE5aloydUhpNCtUbDV1Zm82ZXJ4OHZQMDlmYjMrUG42LzhRQUh3RUFBd0VCQVFFQkFRRUJBUUFBQUFBQUFBRUNBd1FGQmdjSUNRb0wvOFFBdFJFQUFnRUNCQVFEQkFjRkJBUUFBUUozQUFFQ0F4RUVCU0V4QmhKQlVRZGhjUk1pTW9FSUZFS1JvYkhCQ1NNelV2QVZZbkxSQ2hZa05PRWw4UmNZR1JvbUp5Z3BLalUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2Z29PRWhZYUhpSW1La3BPVWxaYVhtSm1hb3FPa3BhYW5xS21xc3JPMHRiYTN1TG02d3NQRXhjYkh5TW5LMHRQVTFkYlgyTm5hNHVQazVlYm42T25xOHZQMDlmYjMrUG42LzlvQURBTUJBQUlSQXhFQVB3RDF4alRkMURVbEFDNW96U1VsQURzMFpwdEZBRHMwWnB0RkFEczBacHRGQURzMFpwTVVZb0FYTkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYVRGR0tBRnpSbWt4UmlnQmMwWnBNVVlvQVhOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05QRFZIaW5DZ0JEU1VwcHRBQzBVVVVBRkZGRkFCUlJSUUFZb0hwUjBySzhSNjdGNGYwdDdrNGFadmtoVFAzbVA5QlFCWDhTZUtyUHc3R0ZjR2E4WVpTQUhISHFUMkZZT2ovRXlLV1FSNnJiaUFrLzY2TEpVZW1SMUZlZjNWMU5lM2NsemRTTkpOSWNzN2RUVVdLcXhOejN5R2FLNWhXYUNSWkluRzVYVTVCRlNZcnhydzE0bnV2RDEwQXBNbG81L2VRRS9xUFExNjdZM3NPbzJVVjFiU0I0cEJrTU9Qd0k3R2swTk1zVVVVVWhoUlJSUUFVVVVVQUZGRkZBQzBsRlkzaWJ4SkI0Y3NQTWJFbHpKa1F4Wis4ZlUrd29BczZ0cmRsb3NBbXZaMVJUOXhCeXpuMkZjVlA4QUUrZjdjalc5Z2kyZ09HRHQ4N0QxejBGY1pxT28zT3EzejNWN00wMHJIcWVBQjZBZGhWY0NxU0piUGN0SDFpMDF5eVc1czVBdzZNcCs4aDlDS3ZFMTRsb0d1VDZCcWFYY09UR2VKWSt6clhzOW5jeFgxcEZkVzdCNHBWREt3OURTYUdtVFVVVVVoaFJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQUFaTmVXZUxicWZ4SDR3VFQ3VEpXSi9JangwM2Z4Ti9uMHIwalViNlBUN0tlWnlBMGNEeXFQb1A4U0s0RDRiV1p1OVl2TlJseXp3cmdFLzMzNi9vRCtkTkNaMlVYaFhUVTBSZEtlM1dTRUx5eDRabS92WjlhOHg4VGVHN2p3N2RBTXhsdEpEKzVteHdmWStocjBmVXZFUXRaZFl0MUlFdGxaaVZUNnNjOGYrZzFQWjJjR3RlRXJTRzhVU1JTMjZiaWV1Y2RSNzVvVEJvOFk0SXJvdkIvaWQ5QnZqRmNzVFlUa2VaMzh0dXpEK3RadXU2TE5vV3B2YVQ1SSs5SElCdzY5aldkM0djNDlxcmNrOS9WbFpReUVNckRJSVBVVXRlZmVBZkZRVlYwZS9mSDhOdEkzL0FLQWY2VjZDRHg3MUxSYVlVVVlvcEFGRkZGQUIwb29xT1dXT0NKNVpuQ1JvQ1daamdBQ2dDdHErcXdhTnA4MTVkRWVYR3ZDanE1UFFDdkdOVTFXNDFpL2t1N3BqdmM4SjJRRG9BUFN0THhkNGtmeERmZ1JFcll3a2lGZlgxWS9Xc0ROVWtRMkxnSHZpdWo4TGVFSnZFRW5uVE8wRmlEdDh6SHpTSHVGL3hyUDhQYUxMcjJzUTJjWkt4bjVwWC91b090ZXBhcThla3BvMFZzQkhDTHhJbFJlZ1Vxd29iQkl3UEVuZ0t6WFJ6THBDTkhQYnJ1S0Z0eGxIZjhhYjhNdFg4eTN1TkxrYk93K2JGbjBKNUg1OC9qWFpXTi9GZmlkb3lOc016eE43bFRYblRRRHd2OFNvdkxHMjNsa0JIcHNmajlDYVc0ejAraW80SmttajNJMjRCaXBQdURnL3lxV2tVSlJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQndQeEl2M3RybTJoVW5iUGF5UmtmVmxQL3N0WGZobkVGOFAzTXVSbVM0SS9JQVZsZkZPUC9TOU5rL2hNY2k1SHJrZjQwbmhiVy83SDhJQzV3V2lnMUFMT282N0hYcitCNS9DbjBKNm1KNHN1NVU4V2FzRmNnU2Z1bUhxTUQvQ3ZRdkF0MnQzNFR0Qm41b3QwUkgwUCtHSzg0OFdNa25paTlsaGNTUlNzc2lPdlFnZ0d0MzRjYXVMWFVadE9tK1ZMckR4RS8zd09uNGorVk5nanJmRm1nSnIra3VpQWZhNHN2QzNmUDhBZC9HdkhTcktTcmdxdzRJUFVHdmZoZy9TdktmaUZwYWFmNGg4K01ZanZGOHpBNkJodzMrUDQwa3dhT1d4am5uUFhnNE5lZ2VHZmlFa2NLMnV0TStVR0V1QU03aC90RHJuM3J6K2s2VlRRa3oxSzUrSmVsUnNSQkJkVEQxQ0JSK3RaNy9GRmMvdXRMSi8zcHNmeUZlZlVuV2xZTG5mSDRwemY5QXlQL3YrZjhLa2orS1M1L2U2VzRIcWsyZjVpdlBzVVlvc0Z6MU8xK0pXa1NuOThsekJnZFNtNytWY2w0cThZemVJRyt6MjZ0RFlML0FmdlNIc1cvd3JtTVpwYUxCY0tROGZXbHJhOEthSTJ1YTVGRTQvMGFJK1pNZTIwZHZ4UEZNRHZ2QU9pZjJab2EzVXlZdWJ2RG5QVlUvaEg5ZnhxaDhSZFQreFM2U2tmTHh5bTR4OU9uOWE3WmlrU1pKVkkxR1NTY0FBVjR4NHExa2E1cnM5eEhrUUwrN2gvd0IwZC94T1RVb1ozSHcxbGFiUjd3eUVsamRNeEo3a2dHcUh4T3QvS24wMi9qNnF4ajQ5UWR3cUx3cnFRMFR3UmMzQXcwOXhjbUszVHUwaEFBL0FWcmZFRzNQL0FBaUVSYzVhR1dQSlBjNHdhT29kQ3o0RXZHdmRBYVZ6OHh1WlNRZmM1L3JYUzVya3Zod29IaGNrbkJlNGNnZlFDdXNwTXBDMFVVVUFGRkZGQUJSUlJRQVU0VTJuQ2dCRFRhY2FiUUF0RkZGQUJSUlJRQVpvNTdkY1VacE9sQUhsWGl1NzgrTzRzSnorL3dCUHZYS1ovaWpmbjlEK2hGVXZEVXd1TFBWTklkZ0Rld2xvYy84QVBST1ZIMVBOYkh4SzBvd2FwRnFLQStWY0RZK096ai9FWS9LdU1qZG9aRmtqWXF5RU1yRHFDT2hxaUJxdG5CSko0OWVsYitpeVdPcEpEWTN0eDlpdklEbXp2VjZBOVFqL0FJOURXRkpKNXNydVFNc2NuSHJUUHlwZ2U3MlRYS1dDSFVQSkVxajU1STIrUi84QWE1Nlpyelh4L3JsdnEycFFRV2JMSkZhZ3FaRjVETWV1RDZWeTV1WnpFSW1ubE1ZNkp2T0IrR2FqUE5KSWJZVVVVVXlRb29vb0FLS0tLQUNpaWlnQUdNODV4N1YzUGcveFJvdWphY0xhZEpvcDVHM1N6RlF3WTl1bklBK2xjTlJtZ1o3THFGL28ycmFSSTgycFJteEEzVENPVGFXSDkwOS93NzE1UHE5N0RmNmpKTmJRSkJhajVJWWxHTnFEcCtQZXFPTXJnOWFYdGowcEpBMmRGNFNqTi9xOXNicVlKWTZhR3VHTGNJdk9mMWJINVYxbmlUVWwxandCZVhpcHRnZVZSQnU2c29ZRGQrSnpYbjJsMnQxcVU4ZW1XcGYvQUVseGtEcGtkejdBWnIwZnhyYnBZZUI0N0MyUWtlWkZER3FqazRQWWZoUXhvei9BVTVsdWJXMVFueXJLMmVTVWpwNWtqZFB3VVYzWkdUV0Y0UDBIK3dkSTJ5LzhmVTU4eWJIT1BSZndyZXBNWVVVVVVoaFJSUlFBVVVVVUFGT0ZOcHdvQVEwMm5HbTBBTFJSUlFBVVVVVUFGSFdsNlZUMUc1dW9MZkZoYW00dVc0VldPMVFmVmo2ZTFBRlB4TkxwUzZOTkZyRXFKREtNQWZ4azlpbzdtdkdKTmdkaEV6TkdEOHBaY0Vqc2NWMGZpVFRaWWJ0NTlkMWVPVytma1c4STNsZlFkZ29ybXVoSXhWSWhoUlJSVEVGRkZGQUJSU1V0QUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQVNXOXpQWnlyTmJUUEZLdjNYUmlDSzdQUmZpRHZsZ1RYWUJPSWptTzRqVGxEakdTdmM4OVJYRVVnd0RrZ242VVdIYzk3czd5MXY3ZFo3U1pKWVdHUXlISXFVMTVINGIxR0N5dWcxcHFFdW0zRGtCbG5IbVFTK3pZd1I5YTlXczVKcDdkWG1pVkpDT2RqaDFiM1U5eFV0RkprOUZGRklZVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUNaL0t1TDhRK0xMdTRhYXg4T3h5U2VXQ0o3eFI4cVk2Z0hvUHJYWVhNY1VsdklzNXhFVk80azRHUGMrbGVWZUsvRkkxSS93Qm5hV29nMHVJNENvTm9sSTdrRHQ2Q21oTTV0eXp5TVpHM09TU1dKeVNmclRUeFIxb3FpQW9vb29BbjAreG4xSzlqdGJWQTBzaHdvTEFmcWE2KzIrRjk4NmY2VGV3UlAzVlZMNC9sWFBhUG9VbXFZZFp4Q0ZPY2lKNUcvSlFjVjNHbncrSnJLSEZucVVHb29vLzFOekc4Ylk5aXcvclNZMFpjM3d0dkZHWXRTaFkrakl3SDlhNTdXdkMycDZDaXlYa2FHSmpnU0kyVno2SHVLN1VmRU5iS2MyK3RhVmNXY3kvZUNuY1BxQWNjVnN3MzJsK01kSHVyYTJrODFHWGE0WlNySVR5RGcrNEZLN0haSGpGQjRxVzZ0M3M3bVczbUdKWW5LTjlRYWlxaVJhQ2FRYzFaMCt3azFQVVlMT0Faa21jS1BZZHorQW9BbHNORTFMVkZMV05sTk9vT0N5cngrZlN0QStDdGZBei9BR2MvL2ZhLzQxNjFwMWhEcGxqRGFXeWhZb2wycjcrcC9HcHBwb3JhTXlUekpIR09ydVFCK1pxYmxXUEVicncvcTlraGU1MDY1UlIzTVpJL1NxQjQ2akI5RFhzMDEvYWEwaGdzdFhualhveldxbm4vQUlGamo4RFhQYWg4TVlwVWVTejFHYnptNS8wZ0FoajdrZEtkd3NlZENpcldvNmJkYVJmdmFYc1JqbFhzT1FSMklQY1ZIYVF4WEU0U2E0UzNVZy9PNkZnRDJISE5Na2dBelMwNTFXT1Fxckk0QjRaU1NEV3RkV1Z2YzJJdmJMUzc2Mmo1SG1Cdk5pSkhYdGxmMW9BcWFiZVcxcEx0dmJLSzd0M1B6S2NxNC8zV0hTdlVQQ2NWcWxzc3VqNmhKTnByY0cybjVhQnZRSHQ5T2hyeUlIUHA2MTNYZzN5TG1ZWE9reWZaTlNqWDkvYUZ2M1Z5bnFNL2RQOEFJMG1OSG8xR2FSYzlUMzlUUzRxU3dvb29vQUtLS0tBQ25DbTA0VUFJYWJUalRhQUZvb29vQUtLS0tBTWJ4TmJHOTA1NHA3dzJ1bnFDOTFJbytkMUhSUjlmV3ZINzJXQ2E1SnM0UEl0MU9JMHprNDlXUGNtdlEvaUROZFhrUnNMUlQ5bmdqKzBYa21jS0IvQXVmVW50OUs4MDZjWUF4VklsaFIxeDJ6VXR0SEhMTUJOT0lFN3R0TEg4QU90ZFBwZDU0WDA1Y3l0ZFhManFKYlZDR1BwemsweEhKaXJXbldFMnFhaERaMjIzenBTUXU0NEZHb1g3YWhldlA1VU1BSitXT0pBcW9QVGlqUzc1dE0xYTF2RkdURElISTlSMy9TZ1I2VnB0enIzaHZTMGd2Tk5TOWdoWEFrczNHOEQzWHY4QVdzNjcrS0k0RmpweEo3bWFUSDZDdTMrMnExaXQxYUo5b2paUklvalBMS2ZRZC9wWGp1dkpaUWVJcEpiVnZNdEpKUE44dkJWbDV5eUZUeURuTlNpaTdyZmpEL2hJYlR5YjdUb1JNbk1jeU1jb2Z4NmoycXA0VDFoOUc4UVFTNUl0NUQ1VXdKNDJudjhBZ2NHdEZQRE50SGVycUF1OVBuMGZKbFBtVGJXMjlkcFVjN3E1WnNiMjJqYXJNY0QwSGFtSTZQeC9aL1ovRmM3Z0RFNkpLTWU0d2Y1VnpXSzMvRTE2TlN0ZEd1eWYzcHRURkovdkt4RllOTkFGZHY4QURHd1dXL3VyNGovVUlFUW4rODNYOUIrdGNSWHFQdzBpVlBEa3JnZ3M5dzJmYkFGSmdqZTEzV3JmUWRNa3ZMajVtR0ZqakJ3WFk5QlhrMXg0Z2wxUFZWdTlhVjdxRkRrVzZ2dFFlZ0hvUFd1MStJVWtVU3dTTXBublJDWTBiL1Z4WlBMdDZrOEFENjF4bWlhWGI2M0hjMjV1b1lMN2NKSVRNY0xJT2R5NTdkcUVOblN4ZkV1UzBTT050RldLSGFOaXE1WEk5Z1JqRmJGbjR4dTljakthTHBNcnlqaG51SEN4Um4zUGY2VnkrdDZXMWhvdHBwazEydW9hdkxNdmxSeHVXRUtZeHRCNjhrMTZEb0drcm91alcxaUNwa2pYTWhIZHp5eC9Pa3hvOHg4WDZYckZwZUxlYTFKRkk5eGtLMGJmS01mdzQ3QVZoVzF3MXJjeFRSSEVrYkIxUHVEbXUzK0tGNnIzbGxaZ2d0RWhsYkhZdHdQNVZ3dU0vZDYxU0pON3hJUmN1dHlsenAxeXJjczFzbmx1TTltWHY5Um1uZUdMZ3hwY0NXNjFhM3RsSHl2WkVrSzNmY3YwcTlxTzF2RE9uVGFsbzRNUmdBanY3ZVRFaW50dkdNZm4rZFpQaHJVN2pSdFdTN2lXZDRFTzJmeTFKeWg5ZjUwZ0k5WWlna25hNXRMOWJzSDcrNkx5cEIvdkwwUDFGYS9ndXhUVVJLYk9UN1ByRm13bWdjbjVaVVBCVmg2ZHZ4cS9xdW8rSE5makpTN1dHWHFyWFZ0dDUvMzE1SDQ1ckEwYTVsOE4rSmJhNGxJOHNQdFprWU1qUnR3U0dIQkhmOEtBUFkwZG5pUm1YWXhBSlgrNzdVNmpyemtFSG9SUjFxU3dvb29vQUtLS0tBQ25DbTA0VUFJYWJUalRhQUZvb29vQVVVaG96bWtIWEdjVUFjUjhTOVJFR253YWRIZ05jdjVzbVA3cTlNL1Uvd0FxODRVRmlGVUZpVGdBREpOYkhpM1Uvd0MxL0VWek1yWmlRK1ZIL3VyeC9QTlZOSzBtNjFPWW1CbGhpai8xazhyYlk0eDd0NisxVWlHYm1rYUxwbHFxeTY1Y1dzVG41dkprbDNFRDNSZWZ6UDRWVDhVNmxaWE4wbHRwTWNFZG5DbythS1BiNXJkeWUrUFN1djB6d3RwV2thUExxRWNaMUc0U010RzhrWnd6ZGdpbnJ6M3J6N1U3SjdHOE1OeTRlNzZ6cXZJalk4N2MrdnI2VUlHTTA3VHJyVkwyTzFzNFdrbWMvZEhRZTVQWVZOcm1reWFIcWt0bE5JSkpFVldKVVlCeU04ZTFkUjRUbGVDWk5OMFVKOXJtRysrdm1YY0lWSDhLZzljZnorbGJQanJ3NGRSMG1POHRRMGwxYUQ1cy9la1R2OVQzL09pNFdPWjhJK0xMN1I0emJQYlRYZGlEeXFLUzBXZlErbnRYYVNXV2dlTUUzUEF4bEErK1VhS1FmajMvQUZyeWl6dnJteG1XZTB1SklaRjZORzJEWFZXUGp6VVhBVy8xVXhvT3ZsMmF1eC9ISUZEUTdteEo4TDdCbkxSYWhjeGowS0sxVWRWK0dyVzFsSlBZM3JUeVJydU1jcUFiZ091Q0t2V2ZqZno1QmFhUFpYdW9YTDlYdUhBSDFPT2dINFZQNGs4WkpwT21tMGl1SXJqVkhUYTVpSHl4RTlmeTdDbHFHaDVnWExJRTNaVlNjRDB6U1VZNEdjWjlhS29rSzc3NFlhaUZrdnRQYitJQ1pCbjA0UDhBU3VCR053SkdSNlZ2YUt4MFRWOVAxYUlzOWs4bmx0Si9kend5TjZFWno3aWhqUjNYaWZRcmp4SHFWcGFMTDVGckdobW1sQXlTZWlqK2YwcUFmRFRSdGdEUzNwT09mM2c1L1N1cW5mQTJRbU5wMlVtSlc2UGpuRlk4SGllTy90bkZpa1p2NG0vZTJNNzdKT09vQlBCUHAyK2xUY29tMGp3dnBHaG56TE8zeE9SanpwRzNQajJQYjhLcDY3NHowL1NJbmpoSXU3MDhMRkh5QWY4QWFQOEFrMVN1dkd0dXNoakU4MWhjcjkrMnZiVWxmekhJck5uK0pEMjRJWFRyR1poMGRIWUQ5UURSWURpdFF1THE4dkpicThEbWFZN3lXR00vVDJxYlJkR3VOYzFHTzF0VlBQTHlkbzE3a21yRFJhdDRyMVo3bExhU2Q1VzVLakNLQjBHZWdGZW0rR05CazBTdzJ6dEVKWEh6SkN1Rlg4ZXJIM1A0VTJ5VWcxRFJyaUxURmkwaVJUNWNRak5yUDgwTXlnZFBWVDc1cnpIVE5YazhQK0lQdE1FYnhSb3hTU0JpU2R2ZFQ5UDZWNlpxR3V6ZUg3K05kU0htYWRjTnRpdXdPWWovQUhYQTZqMElybFBpRm84UzZoYWFyQ3lMQmVIWkpJT1ZEZG00OVIvS2toblRhMXBHaGFqWXJkVFdNcnBJZ2NUMnNmekFIbkp4L2dhOC93QlI4UFJyRTgyalg4ZW9XeVpMb3B4TEVQZFA2aXZRUEJjbHhiNkpKWTNpTjU5ayt6YXZPNUQ4eWtIdU1IaXFlcjZkb25pT2NpMnVvN0xXRVBESDkzSVQ2TXB4bjYwSmhZMHZCdXEvMnI0YnQzWnQwMFA3bVQxK1hvZnl4VzdYbkhndWU1MEx4VGM2UnFLZVcxd081NDNqa0VleEdhOUh5RHlLR05CUlJSU0dGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGWTNpelZoby9oKzVuVmdKWEhsUmY3ekRyK0hXdGs0QTkvU3ZLL2lEcmlhanFvc29XekRhZkx4ME1oKzkrWFNta0pzNVRra0t2SlBUM05kNzRkMGUwMDFvRTFRdGU2aVJ2aXNJdm1FSCswNDZBKzU2VnllZzZiZDZycTBWdnA1eEtQbU1uYU1mM2ovbnJYcHRtMmcrRDdNd05ld3JNZVpaR2JkSklmZkdUK0ZOc1NScmFqZWpUdEt1YnlWUURCQ1pNZGVjY0N2REpKV25sZVJpV2VSaXpFOVNUWHFIaXJWMDFEd1pleTI4TndJWkNpckxKSHM4ekxEN282bjhxODB2N1UyTjQxdVQ4NkFDVDJZakpINGRLRURQUVBCelduaHJ3aE5xMThRdjJoaWY5cGdPRlVmVTVOZFBvTTk1ZldYMjYrWHl6Y0RkRkFEeEduYlBxU09UWEFSS2ZFR3M2TG9neWJTemhReUFkQ2NibUovbFhhK0l0WWF3RnJwdGpnWDE2d2lpQTZSTDBML2dPbEpqUm42LzRCc05WbGE0czNGbmN0eXhVWlJ6OU8zNFZ3T3ErSEpkSmxlT2E5c1hkZjRVbU83OHNWN0Q1c05sR0lNL0pERDVqTVQ5MVIzUDE1L1dxRjFCWmFsb3NWeHExcERNWlFHQ3V2SUxINVFEMTdpaE1UUjQydHhOSEcwVWNyb2pmZVZISURmWDFxSUQ4NjZieHI0Wmk4UDNzTFd1NzdOY0E3Vkp6c1lkUm51T2E1cnBWQ0NpaWlnUWd4MzZWdWFMT3RpRDlwQm0waTgvY1hRWHJFZXg5bUI1Qjdpc1RGYWVrM0RhZTVubWg4L1RaejVGMG5VRWYwWWRRZmFnWjY0TlBhNzBTRzJtbUprRWE3TGhEOHdJKzY0UHIwTmVUZUlicTdtMUY0dFRoUVg4RGJIblFiVElCMEpIUThZd2E5TzhNK2JhV3AweVNVVFJRS0pMU2YvbnBBMzNmeEI0UDRWeS94TjBuWkxiYW1pNDMvdVpzZW81VS9sa1ZLR2NoYVJTYXBNc1Z4cU1jSlg3clhUdHQvUEJycU5JOEJYVXN5M0VHc1dXMUR5OElFdVA2Vkw0VThCdzMxbEhxR3FNNWlsK2FPQlRna2RpVDcrbGVnV3RwQll3TEJhd3h4Uko5MVVYQUZEWUpFV25XTDJGdjVVMTFQZE54bHBRb0g0QUFZcHVvdmVXOFJtc1lsbktETFFFNExqdnRQWnZyMXEzSUNVYnk4ZVpqNWQzVFB2VkRTdFpoMVV6UWJURmVXNUszRnU1K1pEL1VlaG9LSzZUNmY0dzBLYUdKaVVkU2pvd3c4TGRzanNRYTRLS2VkL0MrcTZCZjh5NmNSTENUMUFWc01QMXorTmJIaVZwZkNIaW1EV2JJRVcxNWtUeEwwWWo3dy9FY2ozckw4YmxMWFg0OVF0U0REcU5wbkk3NVhCL3BRaVdkYjRDMUQ3ZjRhaTM0TTFzZkpZOXlvKzduOERXanEybGFWNGdWb0xzUnlTeERobFlDV00rM2YrbGNSOFBkWnROSlMrVFVibExkWkFqUm1USURIbk9LNkxXTGJ3LzRxVlREcVVFZDZuRWM4TWdERDJQcUtHTTVQeFJwT3JhQzl0Sk5NOTFid09QczEyMzNvK2NoVzcvaFhvMmk2cEZyT2syOTdFUVBOWDVsSDhMZHgrZGNMYzNQaUx3M2J2YmF0RC9hZWx5Zkt4ZjUxWmZaeHlEOWFyZUQvRWR2b21xeVdwa2IreTdsc3FaT3NUZGlmNUg4NkhxSkhxV0tLRllGUVZPUVJrRWRLRHpTS0NpaWlnQXB3cHRPRkFDR20wNDAyZ0JhS0tLQU9lOFU2dGYyZG0wT2wyTnpQY1NqYUpVakpXTWV1ZTVyeXA5TTFCQ1RMWlhXVDF6QzMrRmU3TUN5RlFjWkhVZHE1TFc5SzhWcHViUzlaZWFNL3dETE50c2JqOGNZUDZVMHlXamdiYisycmF3ZTJ0WUxxQ0dRNWxaSXlyUDZaYjA5cWdzTlRsMGk0THhXMXE4d1BEVHhieXY2NHEzcVZsNGtrZkdwUWFqS0FlamJtSDZjVlZqak9uc0pOUTB0NUZKK1ZaaTZBL2xqTlVJNjd3OWY2MzR5MU9GTDExT20yOGl5U2hZd3FzeThxdjU5dmF1TjFTUXphcmVPeDVhZVEvOEFqeHIwWHducWVzYW9zWmdzTFBUOUxqNERxaHkvc296K3ByZ1BFTnFiTHhCZlFIQjJ6TXdLbkl3VGtmenBJYk9tK0djWSszNmhlU0VmdVlSbGoyQk9UL0twUEMxMC9pUDRnVDZqSm5iRWpOR3A2S3YzVi9RbXNUUmI4V1BoVFhBcllsbU1VSTljSGRuOUFhMVBoNUl0dEZyVjEzaHRnUitwL3BRd1JzZUlOUjNlSDcyVlR6cU40TFNMQi81WnFkdkg1TitkYUhpVzVFZW8rSDlPSEN5M2Fzd0hvZzRINS95cmtmRUU1Z3N2QzlvVDl5TmJoaDdzdy84QXIxcGVMTDNiOFJOSVUvZGhNZjhBNDgxSUN0OFQ3c3ZxVm5aanBGRVpEOVdPUDVDdUlGZFA4UkdKOFd5ais1R2cvU3VYelRRaFRTZldsNjQvcldycDMyZTI1azFOSUdQYUsyODEvd0F5TVV4R1lrY2ovY2pkdjkxU2ExdkQ5MmxqcUhrYWpFMzJDN0FoblYxS2pCNk45UWVjMTFOaGVaQUNhcjRsY2Y4QVRPekFYK1ZkQmF6RnlGazFDNmRPbXkrc1FBZnh3S1Z4MklmQ3lTYWJOZDZKY25mTFluZmJ5SCtPRituNjFjOFlXSXYvQUF2ZkovR3FlYXYxWG4rbFRYZHNWMVhUcjlCbGh1dDVOdkFLTU1qOG1BL09yVjNJcXFrVWdHTGhqQ00rcFUvNFVpaXZvRDU4TTZlLy9UcWgvd0RIYXNRM2YyalRVdWxVa05HSk1LTW5wbmdWbDZkYy93Qm0yZWgyRW5XVzNkVG50dFRJcGZCdHcxeDRWdEhKNVhjby9CalFCclEzTVZ4Ykpjd3lLMExMdVZ3ZUNQV3VMOGNSejZMcTFsNGlzRHRmY0lwY2NoL1RQcUNPS210TDQrR1BHTXVsM0IvNGwyb041c083cEd6ZFFQWW5JL0tvOVdKT25heDRldVNXYUNIN1ZaTVQxakJ6dC80RHlQcFFnWlk4WFN4YTk0Q1cvZ0dVVXBNUFVjNFlmcVIrRmNMZjNadXZEV2xJVDg5dEpMRU05ZHZERCtkYkhoKy9hVHdMcjFpeDVpakVxQStqSG45Uit0YzlwVnMrcDZsYVdDWi9mVEFFRHQweWZ5Rk5FbnBsbnBPbXplRHRNczlXVkZCZ0JWeWNNaFBQRGR1dGNENGs4SjNuaCtiY3krZlpzZjNjNC9rMk9ocnQvRk9zYXA0Y2VPU09HM3ZOSmxIbCtYS21DaHg5MGtkdlRpdVp1OWJraHRHdjlBdW5pc3kyeTRzSmdKRmhKNllCejhwb1F6bmJiVnRRc0FSYTMwOElQOEt1Y2ZsMHE5YWFScS9pT1lQRGFsODlaU2dqWDZrNEdhc2FkNHBlQng1T2k2WkxLeDZwYkhPZnpydXRKdVBFMnE3WHYwZzB5MUg4S1I1bFllZ3lUajhhR0pGL3czbzF4b1dtTGIzVjdMY3R4Z2Z3Uit5OTYyS2FCaFFQU2xxU3dvb29vQUtjS2JUaFFBaHB0T05Ob0FXaWlpZ0FGUTNmMm55R05vWUJML0Q1MmR2NlZOU1l6UUJ4T3FIeDArNFFyYnJHZTlxeTUvTmptdWZpOExlSjdtOEU4OWo1MDJjNzd1VU1QMU5lcjlldFZ0VG4reTZWZHpqckhBN0Q2aFRpbmNWanlHODF2WEw2NEZrOTlLNUQrVUVoWUtoT2NBREdPS3QrSm9OR3NiSzFzTE56THFOdmtYRXFjcXhQTEFudVFlbGM0a2trYjdsWmxjYzdoMXpUYW9ra0RrUnRIbjVXSUpIcVIwL25YUWVHWnZKMFB4R3ZjMllJL1BIOWE1c210RFNya1F3NmxHeDRuc3BFeDc4RWZ5b0F2K01KZitKeGJScjkyQ3poVUQvZ0lQOEFXazhYWC8ybnhGOXJqLzU1UXVwSHJ0Qi9uVkxYcHZPMWVSMVAvTE9OZnlSUldlenRKamNjNEFIUG9PQlFCMEhqVzRGOXJNVjZuM0xtMWlrSDVjL3FEWFBWTEpjUExERkc1eUlsS3I3REpPUDFOUmswQVQyY3R0RklIdXJaN2xWNklKTmdQMU9NL2xXL2ErT0pkT0FYVDlJMDIyWDJqTE4rZWMxekpOQm9zRnp0WS9paHFRUDcyeXRYSCt6dVgrdGErbi9FNnluWUMrdDU3Zkp3WFg5NHYrTmVaNXBwNjByQmM5L2pkSjRrbFFoa2NCa1BxT3hybi9GdDU5am0wVmM4dnFDSDhCeC9XdGJSVC94STdBdC96N1IveXJnL0dlcEM5OGFXRm5Hdzh1MWRBM3B2TEFuOGhpa2lpLzR4MVlXSGk3VEJrQkxXR1JteDZzQ1A2Q3Rqd0NoWHdkWmh2NGk3Yys3R3VIbHRwUEczak81K3o3aEFaT1pEMFNKZU0vVTQ0K3RlcVcxdkJwOXBGYndLSTRZbENxTTlCUXdSeC94TnNmTTA2enZsR0hnbDh2STY0WVovbVAxckkxL1VHdk5HMFRYRi93QmVGZTFuQS9pNHdRZnJ6K2RkajQwZ1c0OEpYK2VxS0hIMUJGZWJXODVsOEczOXV4NGd1NHBWOXR3S24rVkNFelBzTHcybHRmUktUdHVJUEwvOGVCL3BYUytDclZkTnVvTlJ2bGFKTDB0YldzL1pIOVNQZm9EWEg4OVFjVjB0cHFEM3ZnTy9zcFhKYXhram1oUGNBdGpBL0grZE1TTnJWOVlPbzZaY1IzYXFzaXViSzlRZEZjWk1jb0gxR1B4cmtmRGsva2VJTE1NcVBGSktzY2tiRElkU1FPUit0R3FhaTF4cU41S3A0dTFYZW8vdllVL3pGYk5scE9kVDhMVFJyajdXb1p6N294NS9JQ2dEMUdHMHRyY0h5SUlvcy8zRUMveXFYclFmUTBBVkpZVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJXYjRqVm04TmFrRjZtM2YrVmFOUjNVSDJxem5nSjRsalpEK0l4UUI0eHF0aWJIUzlJRGNTWEVUWERuNm5BSDVBZm5XVlhiL0VPd0tYbWpRUmpyQ0lGSTlRUUIvT3VZMTJ6WFQ5Y3U3UlB1UXliQitBRldpR1VLVUhCcEtLQkRwWkRKSVhQZkg4cWFLS1RGQUMwVVVVQUZGRkZBQUtEMEo5cUtrZ2RJN2lONWtMeHF3WmxCeGtEdFFCNjdxT3N4ZUdmQzFzOG0weitRaVF4OTJmYVAwSGV2S2JTMXZkYTFSWTROMHQxTTVZdG52bkpKUGFyc2t1cWVNTllHRk1zNzhLbzRTSmY2Q3ZUdkRmaHEyOFBXbUVLeTNVZy9lelk1YjJIb0tuWXJjbDhQNkJiK0h0T0Z2RUEwcmN6U2tjdTMrQTdVenhWY05aK0hMdTVqKy9Ec2tIMURxYTFETW1aUG01akdXOWhXRDQ3bUNlRDd3OGZQc1VmaXdvUXkzNGdsV2J3bHFFbys3SmFsaDlDdVJYa050TjVlbTMwWC9QVHl2MGJOZWk2cmVCUGhmRzdINXBiV09NZlU0RmVYazhZQjROTkNZbmFyTnJkZVJhWGNRYi9Yb0V4OUdCL3BWY0NsOGx6RVpRaFpBNFRJL3ZZemltU1g3clNqQm9lblh5Wkp1bmtRLzd5a1kvVCtWZXNXR2hyYlJhTnVBM1dFREorTEtNL3dCYXAyM2huZHAzaCszbVViTEVtYVZmN3pFY0Q4eitsZElhbHNwSUtLS0tSUVVVVVVBRkZGRkFCVGhUYWNLQUVOTnB4cHRBQzBVVVVBRkZGRkFCUlJSUUJoK0pkTiszUzZWT0Z5Ylc5Um0vM1NlZjF4WENlUE5QMmVNU1FNQzg4dGdmYzRVL3lyMWNqanRYSytPOUxOMVlXbW94cnVsc1pWWmdPdmxralA1VTB4TkhsazhMVzl4TEMrUThibFNEN0hGUm11bThlNmI5ZzhSdmNLUDNGNFBOVnNjWi9pSDU4L2pYTTV6VkVpMFVVVUNFTmJtaTZaWjNXaGF2ZTN1Ly9SVVh5OWg1M2s4RDhheERXM3BiaHRMaHNjLzhmT3BSZ2oxVlFQOEFHZ1kvVS9CMnBhWmF3VHplUzZ6bFZWVWI1dHpkRjI5elZPNThPYXZabEJjNmZOR1pIQ0lNZmVZOUFLOURta0dxZkVhTzNQOEFxTkxnTWdYc1pELyt2OUtmWXlIWFBHMXhjTVNiVFNWOG1NWjRNcCs4MzRkS1Z4MlBQaDRVMTF6eHBWeitLNHJUMDM0ZTZ2ZHpMOXNSTFMzejh6T3daaVBZRCt0ZWlXZXFMcUdzMzF0QWN3V1FDTTM5NlE5UitBSDYxb2tZNEZLNFdLT2o2Slk2RlppR3ppVkFSODdubG5QdWY2VmVIV3M3V0xveGkwdEUvd0JmZHpCQUIxQ2o1blA1RDlhMHV2STQ3VWlqQ04xL3hOTmZpSjRndFl6bi9nRFZ6Zmo3VU4zaGJTYmNuTDNLcEs0ejJWUDhUUStvK1phZU1iMVRuenBFdFl6Nm5sZjYxemZpTytUVk5iaWpELzZQYnBIYktlMkY0WS9ubXFTSmJOZnhkZG0zOE1hSHBQOEFHSUZta0hweHdQMU5jYmpGWDlhMU50WDFXYTY1RWJZU05mUkY0VVV1aWFMZDY3ZnBhMm93T3NraCs2aTl5ZjZDbWhGUmJhWnJTVzVFWjhtSXFyUDJ5ZWcrdGVnYUI0VVlXK2tSM01lQXJOZlRnOTJJQWpYK3RhMG5oaTIvNGxtbHhSa1dGbTMyaWNucksvUlFmVW5rbjZWMG82NS9LcGJHa0hTaWlrQXpTS0Zvb29vQUtLS0tBQ2lpaWdBcHdwdE9GQUNHbTA0MDJnQmFLS0tBQ2lpaWdBb29vb0FLYTZMSWpJNmhsWUZTRDNCNmluVVVBWW5pYnc5SHJtaEcxakFFOFB6VzVQWWdZeG4wTmNQQjRjZlcvQy9tV3NSajFYVDNhQ2FJOVpBT1J4L2V3Znh4WHFkVkZzSTR0Umt2WWZrZVZBc3dIUjhkQ2ZjZXROTVRSNFVReWtxNmtNRGdnakZGZW5lTXZCbzFKVzFIVEUyM2dHWklsNlMvL1pmenJ6RWdobVZnUVFjRUVZcWt5V2dxMXA5MTltdjdPUnZ1eFRySWZ6R2FxMGg0RkFqMHJ3NWNBZUx2RkZ5M0pUTEErd0ovd3BmQ3Q3L1puZ1MrMVJqbVo1SlpjbnUzUVZ5M2gzVTJFMnNOSzM3eTVzWlB4WUQvQVBYVndYbVBoV1loMUY0SXo5TTdxVFJWenB2aHhHMy9BQWo4MXc1M1BQY096TWVwNlYxcDQ1SkFBNUpOYzE4UFIveFNGdjhBOWRKUDUweng1ckwyT2tyWlcyZnRWOGZMVURxRjR5Zng2ZmpTNmo2QzZCTyt2K0lMN1dDTTJzSCtpMm1laEhWMkgxclU4UjZxdWo2SmRYVEVCd3UyUDNjOEQvSDhLazBUVEUwalJyV3lURzZKTXQ3c1JrL3Jtdk9QSHZpRWF2cVF0TFovOUV0U1JsZWp2M1A0ZFB6b0F6THE1TUhoYXpzZ3hNbHpNOTNMNjQrNm44aWF5TW5PN1BOT2VWNUNESTJTQUZIc0IwclMwSHcvZWVJYnZ5YlZkc1NrZVpNUjhxRCtwOXFva2owWFJidlhyMWJlMGo5M2tQM1l4NmsxN0JvbWkydWhhZWxyYkx4MWVROVpENm1uYVBvMXBvZGl0clpwaFJ5N0g3em4xSnE5VXRsSkJnWkpwYVNpa01LS0tLQUNpaWlnQW9vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQTF5SGpEd1lOVVY3M1RVQ1h3R1hqSEFtL3diK2RkZURtajYwYkJ1ZUFNclJ1VWtVcTZraGxZWUlOTk5lcitMdkIwZXVvMTNaS0V2MUhUdE1QUSsvditkZVdUUXkyOHpRM0NHT1ZEaGtZWUlOV21RME5qa2FKOTZFaHNFWjlqd2F0dzMyM1I3cXhKK1NTYU9WUHFNZy9vZjBxbjFvb0VlcS9EZVRkNFdBLzU1enVQendmNjFqVzgzL0NUZkVzU01kMXZaRTdSMklUcCtiR28vQWVxZlk5RTF4VDk2Q1B6MTUvMlNQNWdVendKY1I2VG8ycjZ6Y2NsQXNhZzlXYnJqOFNSVWxHNTQrOFROcGRwL1o5aytMdTRYNW1VOHhwNi9VODE1YU9CejE5YXNYdDdMcU43TGRYRGw1cFdMTWY2ZlN1aThKZURadGNkYnE4RHhXQVBYb1pmWWUzdlQyRVUvREhoUzY4UTNJYkpoc2tPSkpjZGY5bGZVMTYzcCtuMjJtV1NXdG5Fc2NTRGdkY24xUHFha2dnaXRZRWd0NDFqaWpHMVZVWUFGU0NrMlVrRkZGRklZVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCVGhUYWNLQUVOTnB4cHRBQzBVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBQ3ViOFcrRVl0ZWdOemJCWTlRUWNPZWtnL3VuK2hycEtQb2FOZ1BBcG9aTGFaNExoREhNaHc2TU1FR21acjFueGo0VWoxMkQ3VGFxRjFDTVpIL1RWUi9DZmYwTmVUTWpSdVVrVXE2a2hsSXdRYXBNaG90Mk4rMWw5cENnbGJpRm9YSHFEMy9BNHFXZlVHR2dXbW5JU0VFanp5NC9pWThMK1FINjFuMTAzZzd3d2RmdVRQYzVXeGhJM2Y5TkcvdWordE1DeDROOEdIVjJTOTFCQ3RrcCtWRHdaai9SZjUxNmdpTEdvU05RaUtBRlZSZ0FEdFFxckhHc2NZQ29vQVZWR0FCU2lwYkxTRm9vb3BBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGT0ZOcHdvQVEwMm5HbTBBTFJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFuc1JYQWZFTHcydXc2MVpKaHNnWENqdU9nZjhBb2E5QUZNbGhTYUo0WlFHaWRTcktSMUI3VTA3QTBlRzZUcGsrc2FwQlpXNE8rVThuKzZPNS9DdmJkUHNJTk1zSWJTMmpDUlJLRkh2Nm44NjVmd1Y0YmJScjdVNVplU3N4Z2hZaitBYzUvSEkvS3V3b2JFa0ZGRkZJWVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGT0ZOcHdvQVRGSmluNG94UUF5aW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMERGTFMwVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTklwMUxSUUIvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy90aC5qcGdcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTFFBQUFCVENBWUFBQUEyakMwSUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwQ05rTkJOa0pDT0ROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGTmtKRFJEZEdNak5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa0kyUTBFMlFrSTJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rSTJRMEUyUWtJM00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzBZMWxMUUFBSGY5SlJFRlVlTnJzblFsOFZOWFZ3TTk3Yi9ZdGU4aE9nRUJJU0lLQWlJQ3lxVmgzckh1clZkdGk3VmQvVlZ2MTkzMUZhMjIxN3JXZldqK3JyVm8zQk5GaXJidXlDc2dta0FBU0lHUlBTQ2JiSkpuSmJPKzk3NTQ3azBuZU1wTUVnM1hpdTNCK00zbHo1NzdsL3UrNTU1eTdEQ091WFFBbk1TVVFtVXZrVkNMVGlFd2drazBra1lnTnREU1dVeStSTGlKTlJJNFJPVUJrRjVGdFJGeWpkUkxtT3Fma2J4MklvMzRqT1VTdUl2SjlJbk9JY0ZyZGZpZVRMU3pJdzJtRGp2TkV0aE41bThpYlJPcEc4NlE2R0QyaVVkWGZTZVE4RFdJdHhVakl4cnl3UEV6a0F5S1BFZGs0R29Xem8xREdJaUtid2hkMG9RYXpsa1lJTnpLekljelFvcSt0b2NVVFY5Q1pnZ2lQc1F6OFlLaU1kYzRnN0RubWg4Tk5BYWhyNDZHeFBRaGRiZ0U4UGxHcjBqR1lMRVlHRXEwc1pLZm9JQytWZ3lsWmVwZ3gwUUI1YWJwWVh6dVR5SHJDMU91RXFUdkkrK1lUc3FtRnQ4OFk4WmQ0QWE3a1dIZ3U3UFNwcHFyalFmajN6ajVZWCtHRjQxMjhWc3RhZ294RURoYVhtdUNDVTgxUWtCa1RiaGRoN0NiQzJPb2hUWXpyMjBjRzlIMUhuNDI4djdmZ1pnTnBRWDhpTGVnWGFubFIyMityOU1HTG4vVkNSVzBnY3R4Z1RvQ1VyRkpJVEM4RWEySTJXT3pqNkRGT1p3U1cwMnMxUFlhU3dBZUFEL3JBMytjQ1QwOEx1THNhb2F1MUV0cWJLdWl4L2xRNlhnODNMTEhCdktsR1lKZ29aWW53RjhMYXI0MVhiZmYxSC9PdG1qTUUwRy9GQnZwM1lhQi9WM0N6blFDN2xweDhpVnErUTQwQmVHeHROK3l2QzRHc045a2hlL0ppeUp5MEFCTFNKdUdwdE5yK1RpY1JYTTRxYUs3YUJJMUgxa1BBMjBPUGx1VHA0WTVsRHBpYXJhN1lDSE9iQ1hQTGpGZHY3NkJBdnlFRCtnWUYwUE5qWHNhOVI1NkYreWJmbkVZSy9wQVVQRlArdVQ4b3dqTWY5TUxxTFI1c1VXQzBKRUYrNlRMSUxWcEtOTEJKcTBjdEtVMVdvc0ViRDM4R3gvYStCVDVQQnhBdERKZlBzOEF0NTl2QW9HUFVvQzRuN0oxdHZIcUgwL2ZHYVRLZ082UkE4ME1BalhZeUFYVURPZWtwOGcvcWlZTjM5MnRkY0tRcENBekx3ZmlTaTJEU2pLdUEwMnNnYTJrWVlBZThVTFZuRmRUdWZ4ZEVnWWZKV1RxNC80ZUprSnZLcVprZit3aURDMEUyS01NcGdGNHpMOVk1RGNRNC80Z1k1NHB3Q3BvV2Q3emtnbTZQQUphRVRDaGJjZ2ZZVXlacXRhU2xFYWVlOW1xb1dQOEVzYmZyd1dGaDRiRWJFcWdwb2hLTTJFQllQQmNOZ3dqUU4zWks4bkQzWHBrYks1cnhOQ25nY3ZueGJaVit1SlBBN1BhSmtEYitOSmh4N2oxZ3NxVnJOYU9sRTBvR2N5SmtFWC9MM2RVQW5XME44TWxlSDB3aE5yVmNVeE1OblUrWVRDT3Y3L1VmKy8wN1hta2VHcHBRa1Q2ZmNEWEhpRGZMangrbzg4T0tWMTNnRFlpUVBYVXBsSjExRitqMEZxMVd0UFMxRXBxcFpXZmRTWmxDdHBBeFpFM09IekpKMkx3bWNreVdHUDdOdVlxREhXNHhOOG5DVkJCRFhCSm5ibWpuWWZrelhlQWlaa2JPMUhPaGNONU5XazFvYWRSVDVkYm5vT0hRUjhUOFlPRDVueWNwTkRYaDJOWGxFY3VTckV3ZDkrTXVhY1A0N1JVNWtnTzZuN2lZKzVhWlhpR21SdG5nNDRHZ0NMZS8xQU5OblFLazVzMkdvak52QVMwVXA2V1RrWkp6WmtCdlJ3MTB0amRCZVcwUXpwOWhBRlk2U2NORXpJNEM0M0xYRy9Mdkt1Wnl0RC90T051Z2c0dmt4NS81MEVPakdkYUViQ2hlY0dzc2EwVVRUYjZXSUZ2SUdMS0d6Q0Y3Q3J1Yk1Ocnh0R09wQ3RCWVFraUlkbWJOZXZqRDRHTW9sWTBCZUd1N2w0Ym1paGJjQml4bkpDY1dOZEhrcEFreWhxd2hjOGdlTWlqbjBxU0grK1JLbVIyY3ArNHgrMWtHRHVZTVBpWUtBSS8veXdNQ2VjMHV1Z0NzaWVNMUxhTEpOeUxJV2s3UmhaUzlQNzNyb1N3T1poTlpyWDdFZHJiRVpCYkRucUorZVEvcitvdnRUcm5qdUsweUFBY2JnbUF3SjBGZTZXVWdpdG9NT1MxOWN5bTM5UHZRY213VEhLanZwT0hpdVlYUytIU3lsYzdNK3hUSFhpUTI5SWUvc3VTWTlZeGluc1lybTBKeHZ0eVNTN1doYkMxOTgrRTh3bHhlNmZmcCs1YzNlUldmSTdQSWJrUkQ5OGZ5aWpPWkh6RWdjb01Yc0ZTMThMQy9qbWhub3gzR1RWcWthV2N0L1VkUytzU0ZVTGR2TlJ5bzY0R2p6VUVveUJnSTR6R0VlV1NYdkwyZmFtaEVWSDlUcjk1aFppNFJaV2IzUi91SUljNHdrRHJoVEdLY0d6UzdUcFAvaUNCN3lDQ3lpRXpLT1VWMkVlUElTT0dqVnhqU3pUcHhwcnlrVHl0Q1ErWnA0OC9RUEc5Ti9xT1NPajQwaVc3ZC9vQ0NlR1FYR1E2WkhJVHhKVlBaQlF3alNzSWYxYTBDdEhXTG9EYzV3SkkwL2p0bGJwUVdEUXlRZWp4QnFLcDFLL0xZckRxWWtHZVZISE8yZWVHNDA2ZlpDQ2NoV1pQeWFXREMyZDBKOWUwODVLWU00RW9VTjRzTWs3Y3JkWWFmZWJpamZ6VFBraS8rcnFnTExadHlwRThqTUkrTkVjRUx6czZFc3hkbVM0NjkrUG9SS1AvS05XaFlWWVFicjVrODBMRHJ1dUhKNXlzVm82S25UaytDaTc4M1huTHM3NjlWUW5PcmQ5Z2pxTGN1TDVRKzg0T2RzRzVMNjRqdmE3VEsrWFluaHJCWURHMjFXMkJ2TlFFNldUb21tR0JtWnBPWDFiaXdTMi9TaTlQayt2ZHdNMCtyeFpaY0FHTkJONHVpQUlJUVZCd1BDZ0g0SlFHQ0daUnZjTXBNdDhBdmYwbytENjhUZXZmakJqaFMwd09UOHFYYXViT3JEM2J1T3c0R2d4bFlabWlnSitTWklEL1BMam0yZFdjekNPVDhES05jakY4MnFOZHdEK28xZUhKUDhuSU9WM1ZHeWxreVB4MHM1Z0VuYXNNMkovUzZnM0dxcFNkQ093SDZhQXVQdzREU3NYQzlXSVFzNDFHRFVjZmt5YW10YXd0VnJOR1dDYUlRbjBpWEZTZEFYclkxRENvUEUyVVFoclIyRG1SbDJLT1dZVElSMDJLOFl5Qk1aQlFoTFltRmFWTlRwZVpHZXpkY2ZFNFdlYUltOUdKQ3o3RFJEZVVIMVRZSkVpRTVRUWx0d1FRcnBDYWJDSWdEQVBiMUJlSFR6UzJ3ZVA0NHlYWGN1bUlIMVZwK3Z6S1VGUWg2SVJnTUFzZHlzR0R1T0VoTU1FWStlK2ZEZW1EWitOeHB3bWpMb0svMXlLWU1TY293SFJFblZCdFlNVTJlb2RVVkJ0cWFIcGYyTTE1emJwWUp6bG1VSFROZlZvWmpST1ZtWnhwZzhrUmx3NWd5YVJ5Vndlbmo5WFd3ZDM5blJMdjNKOVNxeVluS1ZjK256VlJlYTNXdEN6NGc1ZFEyZEVpQUxpbTBRc1VoTndRQ2ZzVjNjS0dxd0FmQmFtRWtNQit0YmdOL3dBZEdnd25pY1dLWjBScDZ2czJkZ21McXFJR0Y5SDROcmVNNDBTNUh0cnN2WkcxenhnU0lSMytRRjNpaXBmeWpYdTU1WnhjTU95K2VINitEWTNVeTRBUW9MRWdlVmhsb0pubDlmWERrV0Fzc21wOGZPVDUzZGhyVjVCV1Z2U3I2WDZUck94ZlBTNWMxRGljRUNld0cwUnlmZ3l5RVJXU1NXSGYwSGlXZmNZQmFScWVqZ3pFTW1PUWF1czhmYXNQOUU1SGlEbWlpb1hoK2VFQ3ZYcnNGbGl3b0pkMjlWRnYvL3RFM0pYOFhGZWJDRlJlZlBvSnI4TlByWUFlWkVFOC9OR2RFOXlHUUJzRVRDTC80c2dHV1h6ZnczWktpZENwUC82MUh6YUtCdno2bTNJU3p4ZGtkbXA4VHB4RXJaQkdaOVBwQllYSVFoczJVWllqTXVJdmVkY2RqRWdRQmV0eGVPSFNrTVRURGlxVFUxQVFGdEhVTlRsajE3aDQ0L2RRcEFES2x1V0Y3UGFRbDIyRFZjN0VYTWh3NlhLL2lsTFAwL0hnZC9jK1FGNkk3WTd2M0hvV3FtdVBTSWtnWlBoOUh6WU5ldHdqMWpXMlFteTIxM1lNcWpWYnUyUGFuTHl0YVNabTJNUktDVmIwSDJoY3lzVzR3ZnUrZGdiYy9PQUl2ck5wTTdFWXZ2ZjliYmpnRHJsd21YZVgreXVxdE1MdHNFdVRscENsS1dMZm1WekhQNE9uendiOC8yZ1ZQdmJSWllTY2I5Q1pJZEdSQUVwSCtaK2p6OVVVdDYvM1B5dUd6cmRXU2N0Q3BzMXRUSU5FK2pqcWI2ellmZ2d1V2xra2FaU0RnVXpHM2dsQjV0RGtFdGhnYVQvdGs0MEdvYi9aQ2tqMEJ4Z0xQVVpobGRORmhqMjhOalVBYjlHYXdXWktwM1lpMktNc3FWeEl2bWw4TVgreHFISGFwYUo3OCtZWDFJWFZBVEFrRUY4L0JrYzd1bE9KMGNOaENUaGhHRW54K1BkVFVpNUZuaU5kUmVRUkRjMUpON1d6cmdhMjduUVMyY2RJSUJJSGJhTENRc3ZXMGpEZmZPd3gvWDdXRm1qRm9RNXFOZGpBWmJYRG5MVW9OL1YvL3N6clVrT2wxTW1BeEp4QkhOSnRxL1RHaG9hUGNnaTdhcC8yYUltN3RMVkp4RnFPRFFvMFZqQTRheHhrVStlYlBtUXhmN0c0YWZqTWg1VjY0ZURwOVpZZys4UHBZT0ZyanA0N2ZpdHZQQXJOcHdBSGMvNVVUbm56K2tPUVozdnJidGVEdWMwa2Fub2xBaTlyY2FrbVUyTnRZQjNnZTFOVG5uWk1GWlNVemlmVVVESmNuaHVMVktqSHZSZk9uUW1sUjdrQzkwbkk0VXJZT0h2M0xnYmdHZXFBSEU2TURIZXNHaFRqVzBMaHZuaUc4ZHg3TGVNRm1OVWVOSkF3bm9ZbkJFY2ZrTjdkTFY2amQrL0JPQWlNcmdSblR3VW9ualhMMHg2V3hoN2p1c3ROSVBtYlFWWWF1VThlWnFDYVdoOU04ZlVINFlGMGptTTA2bUR3eGRWalhtVUxzZmhUVnlBdlB4MjBjZWppV2crNUV2eGlQRDJEVzlCelZ6ekRHKytZNzJ3bllzYU1paDQrMXdSZDdPdUc4czBzSmxBUG15NXlaeWFUaEszZFkzYmI3R0RFUFRBUWdYZGdtMXNPY1dST2dZRUx5c0srN3Fyb0wvdlZ4TlNsbmRPYUlvQm1DWnN4WVRicWhQTCt4TWljcE84TUV5VW5LQVJFRU9UY3JFYTY0WkhqaHRJZWYvQVIyNzYyR00wNmZFam0yK013OGFHanNra1ZQMnFDNnZoc1M3T2JJTXd4RlBJU1JSV3VJdlkyREo3d3dPc1BWQVdKNkdjYkNQaXBpVEpORHJjTWVTeHBhaE5MaWxDaGExd2w2M2ZBckdNMkdQUlYxRXFCUlcwK2VKSTJTSERqVVNDTVRhQk1QT0lWK3VvZmJpSzRjQjRoNHYyb2x2ZkhQemZERTM5WkgvZTVMVDl3SVJWTnlGVDFWWE52UVF5aGFIUXdSNWhnTFFPUGdSTkhrSk5YUE9OYWdDTGtOMVRqZVcxY05QN25XQnhhek1XcXV2ZnViaUYwY0tydi9HYUtHcnE1RHV6cTBnamt0SlFGU1U2Ung4YmIyYm5DMnV5TFZWOWZRRmRMc3FvNnZEc3pFOFZXN2ZqbzVDUmpWK2h6RGNlZ1lKa2NreWhIL3Q0NWhyaW1UMHFKb1hOMkk3aEh6Nm5WbTJMWG5HQ3lZVnhRMTMrYzdXeURSa1NtYmVzdkFFODl2aHg1M080WDZ0cDhzaEtzdmxlN1AvZW1tY3ZqejN6ZUduRVZ5YlJpSFJsRnRqTVJCVFVuTVVZM2UrQU45RVdkVWZ2MXhYYWY5alZjY2NaU0RpV2lWZUUrRmt5eGdOdXVIM2RvM2ZGNEI2ejgvUU4vZjk5OVhLOEpHT3AyUmFPREdxRUR2M251TWFHY2pEWlZKbng4TFJtSy9pcFpRR0pGbGRLcGExMnBLcERDemJDZy9yUXVWT2xvMHZ4Q21UOHRYblc2S1RtcE9wbDNGaEJIR1JKMUdZMVkzdEswUzd5cGFoTExpNUJINUZpVkY0eUVqUFNsS3AwWWVHakZUM2x0WEF6KzlUdDNzT0ZiYlJxRm5RRHFJZ2JGcWl6a0pURVk3Y2M1OHFwb1ZqeVhZTXlMbVNxZ0hVVGM1VXBLdFZFWUt3bGl3b1U4Z3lqRTJUQTdVUmxPbnBJN0lGRU83Vm03YkRtNEE2QmlpSTdselR4VXNuRmVzeVBQWjVtb0NyNVUrUStuelkySGxYNzhYODNvdnUyZ21sZjUwdExvTDduNXcyNmdHQjhhR0NSMURRNHN4bkVKQmlPKzd0MXJFcVBaemJIYzR1b1pqZ0FNOVo0SzlGUTBLb05HcHEybm9nd1NiUS9Ic2hCTUl2WVdpSEx4cUJWSUhzaTM2cnd5UHowdFg5Q0E0VUJidmRScUwyYWh6T2VKOTZMcy9uVG85K1FSYWVteHpXNlNtZ1I2Mjdqb090LzVNK3ZHTzNWVTBYTWNNQ3RmMUoxK2diK1E5akJnazlyWlB0Zm8rMmJBUEhuOSt2WG8wZy94NzVYOXZnS0xDUEJVTlBRYUd2c1VSbXh4am9WY1NZRUtlWThUZk8xaFpCL3YyMTlEMzExeTJRRDNDUU15TzdsNGxTQ1hGZWNSK3JxRU9uYkszNDAvb0hxSjlEKzFySzdISldWYnBDdUdxRmJVb3h4aXEzQmhSampGcWNzeVprUVJubkQ1K3hONXlxOU1GaDQ2MHFLb0J1aHFFUEJPYy9EU3JORlB4ZVY1T0N1VG5PS0M1UlZSOEg3ODMvNkxId2VNTm1RbDMzWHdXYVRBTEpYbFd2clVSSG5uMnM0Z1RhYk9rRWtsUnJVQ1dPS2NPS3pxUXlnZ09odTBZWUZYcjh6dHBja0NjUnpud3VpZU10NEhaYkJqeGR4ZWRVVW9sbW1hZ2tRTHlkbFpacG1xV2hYT3pZT1UvNnhVK09UWUNnOTRhN3ZZRnlXTFlnUzZWQTVQQlRrTnhPSWtJWTk1TUZFMTd4U1d6cUh5WG9oeERPVDlSVFk2aGhoaS8vZEVObmtoQWNxeTJ2aFhHNTZaL1BhY3cvRXh3SkM0L1QvMlhvV2Vka2dtdnJxbFZ6R3JER1hVTzZ6Z1F6RHpkUG9GampTcW1qQkVTSFRtZ3c3bmJUR2drTTNZZk92SWJpR2VlbWVHWkhMSERYdkdZZ254UUVsVm9hM2ZCMXUxZktZRStBYWN3Tk1tSWg4TEo2ci84bFp1ZENIWXJRSTliL3V6WXlMd1Jqamg2MFRTMFVXZWxjZXpJdlpDOG8wV2hNRllHVm1Da1RtR2NSemx3Uk96ampVZWcvT0FScXFsM2xUZkI5VmZPSGY2VGlXRzc0VE1wbmVvQVN3eHpac21aR2JEMmcrT3h1LzZvUFlEVUxJaVc5K0FoM0NhaE91bzVsaTQrQlZKVEVsU3ZQejRybGFkYzZsZ2xzOFF0Q0VhQURncWlsMlNTYlA1czFvdlFGMkNJdDB3MENXZU14L2dPSEt2elFIbGxPNTE2aVYyNHcyNGIxbGRmWDdNUkhucm1FL3ErZk4zOXFsRFBLSlVPMW5nOFByQllCcDVUU1ZFcXZQMStVMVQ3Vnh6S3JCbEdYb3pFUFBiY3BxaVRrRTRwbmFBQ05NVHRUbGhpZUU2NDJhQzhpNkFBM2dqUS9nQjRkQVlwMEE3eWw1ZVlvRUtnbTlpQ3FYRjQrK2lBMldCUldRYmNlTTBNYW4zbDVpUU95MXZHYm4veDZVVnc4L1VMRlo5Tm1aUUNsMTgwSGFZVVNKL0oydmUvZ0I5Y1BwQi9SbGtPUEh5UEdWNWJjeGpLditvYXRyTjl3ZElTWW10YjZMVFREVnVib2FiQkhUVXZReHFwMVp3UzJmZGpkdGs0U0hDWXdxWkZFTkpURThlVVV5Z0UzYlRwV2czS1Zoa01BZ2I1Ulh3U290c1BIVVFqUzBZZzBtd0N0UFp3d0h2YmdUSEVIOUNvR1hVNkV5UWxKQkJiZDl6SW1nSnh4TkpUeGtGUllZNEtFSUlDWmt6dmZib2Y1czhwa3Rqb1V3cFN3R2J0bjgvQktEUmxUNjl5RlFxYU1aZGVPSlcrUDN5c0U2cnJlME4xSjZwZEp3S2RTdWQ5NERtV1h6ZGY5ZG9HL0lqdXVCNzY1cjF0OURYVktpZ2FwZHZQWUN5VWJxRXJkSHZGRnZrdkRHVW5oUndIdnE4bFR2Y1VEdGxaOGtpSFBOWFdkeWtlVHJURnAvMmFUdzJVd3pWdUtEOVFwM1JPaVVPSEVSZTFhenhZR1h1SFVOeW9adkMrSGtxUG42VURQQmdKWVZWR0p1V3BwczRaMldnbUhvWHZDejJ2RUp0U1hudDhJam9zQW1wb3ZxV2JxWjZZTEVvMnJKaVlFZ2JhVXhmWG04M0VXaWU0OHEzUENZZ3V5TXRKa0t2aDBFaWJMT0VpMllhbWRza3huSXovMUhPZmdKR1lOMnZlcllDNXN5ZEw3Rlk4UDE2SFl1U1FQTktkNWEzdzJGUHZ3dm5ubEVrRFUvUS9CNTJ1N2toajZPbjFrZ1pRSDlrMGgyNWtRNDcxVnpaZERTTkdueXVDTnY2cmIrNk1hMGVmOXpUUTEwbXB5czBhQ2NNMStMZ1pzQmVsL0htWjc2YnJad2YvT0RoRFhRY0x0NjJ4QWFPemdhVjRCY1RqNW42b1RkMTk3ZUJ5TjRQZkg5cCt0blJLT2t6TVM0VWQrK3JCMVlNamNXazBYN2VuaGViQmVSZ1dZcGVPUzdaQXlWU2JaSEhxN29vVzZIQUpkSGZQUUxBdnRQY2ZUZ2sxSlZIeEJ6elE2Mm1EQU8rbGpjSmdzRUtDTlpQYXVmTGhhWnl2N1BXNW9OdmRBajUvcjJLdElhNzd3MUZBTEJmellybTlmYzVRQ0ErZEg1MFJiT1kwT3BLSWM2LzlBVGNVVDhiOU40STBwQ2hQdXl1YW9jZGpvWEZ3SEt5SngwQ2Q1NnNIUVNRKzNkTlg5VUpXZ3ZSNS9XT243amUzclRVK2gwODU4T291L2E0ZnpRb0t6S0N4MGp5aTFsTXNJblI0ZWtuTGFBVFduQjJYc1Vyc2pnMDZhMmkvQzNMZ2NJMEhLcXZyNk9RaXN6R0JWaTVxdC80OG1COEJRWEEvMmxSSDRlM1huTGpIQndyQzJiL2xBT1kxR3hOSk9WYnFUT0krZEZ3dzVMWFFyUW53dDJsVXRDSVRqa2xiVE1tZ1k0MktWZU5ZYm1pK05OMWhrSlpsTmlRQ3J3djFIR2hxNERHSXpMbG1TU04xMGthaVhJRWV1bmFMeVU0WEVNU2poaGI2R2dtcDNkUit6bkpJTlRSMnFDdjM2SFloeXdpMGYxY0RlL3g0RDFSbE9zVEpnd3M1bzhBUC95bzNBdCs1QnhoVFZoeTJhb1pDWXlkYVNhVHI4a1NxdlZBYmh1WTBoN1lZWUJrOXNGWWR6Uk1hY3RhRjgrZ2lxNjJwazRtMktuNEdBczJMck5GR3dCa29LUGlldGVoRE95UFJIN3RoS2F5aGVkR2lxbE9IalFITkZibUdabWpqb2p1MVVmZ3hEMTV2Zno1Nm5lU2MvWXNJOE53bW80TTJCSG5raGw0N3VVWTlaMWFkQlJnWDVrYlhYdm82ZjFKQTRTRWY3MkdxdHRkeWFFUDdxWVltMHJ1bmtkMldZUTlLZ0Y3UUQzVFhIdURTenlFMW9JKy80QjJCd2pDb3V3K3QvaEFwQ1AxVEVSRThnOHdrd0VxbkdsSWN0UHZRb08rb1IxWTQ5ZTVjakQ1NFRSc0NGMzE3bEg3NGFNT0xzc0NJenRIR2JjbElMNkhuTE1xUXlLQnJqMHY3bVRqMmZPZVhFU2JsOTdDbmtjTVZFTDFVUTNmOHZvZFAvcTNkL2N3V3c0Zm5UZ2xleXc0eU8vS1RlQ2djRjRUS0ZnOEVTWUZzMGh5SS84UU9ERENJc2JVNzZkaGxVSDdiUTE1c1ZOdnIyMy90TVhnbTdJbThoN0tJVEE1dXJ6aDVFTm5GeUIwcWNsMzQwNzR0TmR5eDJrNW0vNFJrWWJETERaZE45OEtESDl0QWFGc1BqT01VOHN3TW9DVXRmWE0wKzBQc2hWbVU5ejYxbmV4K1pCY1pEalhwME9lWXMvMzFML1ZyNWI5cU9DTW5BQVZweENZTTl0Q0N0YVNsYjVUbjl2V1VQV1FRV1pUelNaa2w3SVlaeGwrU0ZhSDlQaGZhMGE3SE54azNON2lZS2hFRy91RzNmanJQUTJ3NFluOTFiUVBSMjZUOUVLUW0zNHdnYTUzYktIdklJSUFvK1llc0lyUElidGdYREd2b2tKWkdvN3JsbGQyR05mSldNREU1Q09kTzlkTFpUa0xUYWpwSlJQdkpYazFPcWhER2hPYlZsRGxrRHhtVWMvbmFsL28xeUd5WTNYNHZJa0kwUnV5ZGoyNDBicWgwc3Z2azM3NzJWRGRNd0VJRDdTQWV4M0o0VUp4QkUwMUdSZmdRWS81MnloeXlKOCtEakQ2OHdiUUJtUTJ6Q3hJTjNYNXZGd1k0dTRrMDNmbWUrVVVmemw0YVZJYWVHQ2UzTGV3Qm0wRUV4bDBKMFBxK3BrVTBPU21DYkNGanlCb3loK3dOWmhIWlJFYVIxVEN6a1NBK2Q5ZlNnVG5DajJ3MG85b1Y2cnRZSnNFa3d1emM0TXpCQnJyTktNQzB6QUJzcVRZQzM5ZEVqWFhSVWhDWHcrSmErbGE2Z01BNC93MU05eTR3NmtSWXNkUUZlVW5LK1NsLzNXNTYrZVhkeG5YazdiRXcwS0lxMEhjdDhvb0VhalN1bWZWVitwNEZFNFBaT1FtQ1pHT0haSXNBK2FRYjJGRm5CTUhiVExxRkZoRE5reU0vMTZJbExaMW9lSTV0ZlF1WTNuTFFjeUxjdnFnYnBtVW9KNGg5VWFmYnN2d3Q2eXZrN2VHdy9Td2hucnZySE9uZWFBUm9WTjg0UlkxOTc1Q2hlVm14cnlUUkpKMHJuZW5nb1RBOUNMdnJqUkRBK2RMdWd5Q2E4a0RrYkZyRmFHbkVpU0ZLa1QzK0tqRGVXckFTTStQT0pTNG95MUxPa3F6cllvOWQvQS9Iazc0Z2N3ai83QS9WeFJ4YWF2dHRoeGdlZGFsM2VabWpQM3pEL25TYm0yMlc1NXVXNFljSHp1K2cycG9KZEFEWDlEZGdPMGt2SUFhMUd0TFM4QkpoQlpuaG1wNG5ERGtwUzhnVXNxWGdrakQ0ZzVYMnA1QkpaQk1aRGJNcWJSek9SOVJYTHFmOUlRVW5idUJTaitLU2pPRDBWZGYwM0padUV4UXpsQUk4QXl2MzJPSERTa3ZJcU9mc0lEam1nbUFuNWplajF5cE5TeW9nQjREdDNRZXNhd3N3ZkRkZFM3RjBpZ2QrT0xPSG1odHFNRi94dXYySi9jZDE1ZVJQM09lNHhYbFBleURNNmZDQURtZkdxV0lJY1ZGdW9sRDQ5clhkdjhoUDRpZXA1YTN1ME1PTE94eHd0QzBFc2NoYVFMQ1dBazlFTkdScWxhZ2xZbG8wQStldUFKWUlJM2pvc1lMVUFOeDRXamRNU0ZaZldWVGZ4VlpmdGRMeHpKRTI3aXZ5NTBHTWJCQ1lmWU1ZbFFPZEZ2TWkwdjZRaXBOdWNUSjBJYkdsSjc1OFZmZlZjL01DODFVYkhwRzlqVVo0Wjc4TkRqc0g1bnlJbkJWRVl6NEl4bXdROVNrZzZwSW84TUFZeHZiK2E5OUo3WXR6bGYwVVdDYllTVXlKZG1COWpjRDRhb2cyZGtleVRVbnp3eVVsdlhCS3RpOXFqR3hiblg3cmoxWTVWblo1R1l4bVZCSnBkTjdUNXBYeEtRUDY0YlFocnpIdGZnbzFxbG1jWHBwMzl4TDNtVCtmNDczU3dJbW1hTitwNzlMQnhpb0w3S2cza1M2RDB5cGFTNUJpNFdGT25oY1dUT3FEdk1Ub2F6MzlQSGovYjd0NTlmM3JySnZEOWpKR05KcWRkN2Q1VmRnY09kRGhMNkw1Z1prbkVzbWZuaGtjLy9qNXZaZVMxeGxEZmJlNVd3ZGZ0UnFnaHBnbHgzczRjUGJxb05mUGdEZklBaTlvRlQyV0VrYzZYSk5Pb0lNaXFUWWVNdTFCNHV3Rm9DamRENW1Pb1FNRys1cDFlMy85dnUxdDhscEwvcXlCVUt6WlNXRDJSZUZTQnZSRHc5K2lJTzJCTkRTUWNiTUgvSzJ3Q1VUU2w4L3VLL241bkw3emN4UDRmSzA2dFhTaXFkN0YxVHk3dy96QmN6dk1GZVJQWE41ZEhkYk9YYzRWemtBTUpxVkF0ejQwc2owMzBoOUlRNlBYR282QTVJV2R4c1FmbjlwWC9PTlpmWXNtcC9KVEdXM29VRXZETWJmSmYrTHNIWHBodDNuREM3dk02UERoamp3NG5JMHhaaHcwY2JldWNBcEQ4UGoxZ0E0WGdzQ2l0c2IxK2hsaHB4Rkxkc3pPQ1dUY09LdHZ4dWw1Z1pKc2g1RExSRjFHb2FYdktNUkNZemRiLzBXZGZ2K0x1ODE3ZGpib2NTMGdEbC9qSktOR0l2ZzNuUTVLWUJhSHdhSWM2SlFUdnJqMEI5SVJWbU1ZN0xRdzNGZ2cvcDZZT1NlQnR5OHI5azJZbVJYSXlVL2lNMUlzUXJKRkwxcE5PakRyT2RIQU1xQjVpMk13Q1NMd0FaN3hlNFBRNXdrdzduWVAyMUhUeVIzL3NrbmZzUGFnc2JyQnhmVkFhSVVKdnJhSElYYUdRZmExcm1nVlJzQ2dET2dIVTc3MkRhVC9NUUsyTFd4alk2SDQwNjM0ZXhDNGF0UVExdWc0NFlNTkN3T2FhVEtHRlRFVklTem9EYUlkN0ErRGpCcTVNd3d6bWhtOUZPVGZ0QW9ud0o0VWFMQVhqZWFOTUdGb01aeG5DWXN0TEpid2NUbllXaHFEU2xvR01vYmJQR0Z3ZThQdlBlSGpRUmpGRFZGMUo2RmxCc0tDM1FrWEJsalQwSnFHN3RmUStNcWZyQlAvdndBREFDRURJeURMT01YckFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZ1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUJUQ0FZQUFBQTJqQzBJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBDTmtOQk5rSkNORE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcENOa05CTmtKQ05UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rSTJRMEUyUWtJeU0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tJMlEwRTJRa0l6TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrK0xwenFRQUFFdkZKUkVGVWVOcnNuUXQwVlBXZHgzLzN6cjJUbWNsa2twQk1TQWdKNFNsSVZKNmlJRWl0cGFmcVZtcDliWFZkcGJVOUh0MnVhN1ZuejRyYjQ2dGRGVzI3cTJ5cloyVVBYY1Yzc2NwS1d4Y0JEeUNVcDRBbElBVHlKcFBIUERMUCs5cmY3ODVOeU54NVpjS2swUEQvY243TVpPWi83OXprZnU3di9uNi8vMy8rZjA1YnZ3UkdVTVZvVjZMTlE1dUpOaEd0R3EwRXpRbE1vMWw5YUY2ME5yUVRhSWZSZHFQdFFQUGw2ME80di9Nay9DeUFsdmRmWkR6YWJXZzNvUzFBczdCemUwSEthUmp4Y1BtZzF4VzBuV2p2b2IyTjFwVFBEeFVnZjBTVHEzOEU3UnNNWXFZTUlqWVdHdllNMmtkb3E5QzI1R1BuZkI3MnNSUnRxM0ZBTnpDWW1YS0VtNWpaYkRDMDlLdzl0RFo4QjEybGFyQ0s1K0E3MlJvMmVXVFlkeUlHUjlza2FPcFNvTFZiQm05UWhWQlVZNmQwRk1wUndFRkpJUS9WWlFMVWxsdGcyamdSWmsreVFxMWJ5TFRaWXJSUGtLblhrYW1IOFhuN3NHSnE5YjJyY3Q1SVVlRldDdzh2RzBsZlNoM3ZrT0hEUDRYaGs0TVI2UEFxN0N3elFXV0pCYjV5aVEydW4yZUhLVlVaNGZZaFk5OUh4dDdLR21MOGZYZHVRUDlqK01XQjU3KzBQMkRGSytnRnZJTHVUOVdXdlAyT2hpaXMrYjgrT0hoS0duaGRMQ3dHMThSNmNJNmZDalozTmRoS3hvSlE2QUplTEFCZUVObVpIa1ZTWlFsVUtRcHkwQThSNzJtSWVGcWhyK1VZK0JzUGdSUThVOXk0WklJSWQxL2poSVhUQzREajB1eExnNWVRdFI4VjNMWXoydjlhOU0wRldZQitOd3ZRa1RqUXY3UTlVSVRBcnNjUHZ5WlZ1eU90RXF4YTc0ZERUWEdRQlVjUmxGOTJOWlJmdWhnS3F5WkIycU5tdWpDRThBVGJUMERYNTU5QzE0RXRJSWNDK3N2MXRTSTh2TndGMDZ2RmRKdDlpdWdzTDdoOVo0OE85QnNtb085T0FucFJ4dVA0WWZnbCtIZjcvVzdjOFViYzhSenorekZaZzlVZjljRmIyMEowUllGWVZBcFZDNzhKRlhPWEFXOHRZQ2VTS2Ruem9nZjM3TnNFN1ovK0ZtS0JIa0F2RERjdmRNQUQxem5CS25DcG9QNGMyYnUyNFBaZG51Z2JsNXVBN2trRVdza0NOTVhKQ09wbS9OQlo1amVhTWNGYitab1hqclhKd1BFV0dIdmxEVkI5OVMwSXNvMmROYWJzWU1jaTBMcmxiVGo5MlllZ0tRcE1IU2ZBVTNlVVFFMjVKVlg0Y1FBWnZCcE1uVEtXSktEZldaanBNNjBZblA4ZWcvT2tjZ3FGRmcvL3R3LzhJUlZzWlZVdytlYUh3RkUxa1owbHBwd1Y2amdKSjk3OUJZUTlMZUJ5OExEcTdtSTlGRWxSak5pTUxINmRBb01Cb08vcFRXaGorY210TlptcUdTL2lEbTQydjc2aklRYVBJTXpCcUFZbDArZkQxRHRYZ3JYRXpjNE0wN0FrT2t1Z2ZOWlNIV2hmZXd2OGNYOFVwbUZNYmZiVTZLSHJrRWszUG03b2YrMko5eU1tRC8zMmxTay9KQnpUYnJkYnVYWG0xdzgzUy9BUHIvZ2dJbW5nbnZzMXFMMytYZ3czY3V1ZlVmSCtFWlpVTkVXUHdTWDhXVlkwdmM5UzAxaHQrcTlKSEFhM0ZQVUtGZzVFSkkxaVlMdG9RZU9CNTNNckJHaXFDazBiWGdIUG5qK0NUZVRnUCs0dGhwazFZaW8ydjlQUHBtV0ZOenZRUFVHdHB0VEJIY1JqVGFnenQzUXJjTzlxTC9nd3pIRFBXNmJEbk5PdEphYUNQeUxyanlvRGQxU0xSM2djVmg1Y05rRi96RVU2MUx2L2dPRUhCNi9jVjVya3FSRWRuemVrWFZwYXlEV1pnUmJNSGxINHJvOEwvYnI0SmR5c2VQQmJFbnJTbGVzQzRBdkh3NHlhNjc0NzVBTU1Jc0E5UVFsaWlwWndaVE9OWG1uR2VRL0dZbUJGNzExV0tBNFpiR0pMNnVzRmI4TnVlT3lOQUx6OEF4ZUlpZFdQWW9jVncrRVYzaHZCTkJncDZSTzZYM1JkYXhYZ2I4eXZyOTRZMHFzWjl2SnFxRnYrUTMxVEFqNlRFY0J0dmhoMCtHTUpNRE5kV0tKejM0NE1FQXYwUEJzM3hCWXhScXdSYzhSZVVyVUNHZTE1MGJVczZjNFFCenh1NkoxNXV3aFBEbjZOcktGVmduZDNSdlRTM0lTYkhnVE9hak8xU0xhK3FBS3QzaWpHMnFvZVl6RmpSaXdRRThSR05uNklNWjAxWkk3WUl3Yk5yV3dpUEc1Mnl2emdOazJyaXI1cXRjQ0N3YTlwS3NEenZ3dGhJZ2ZnWG5BOTJNZE95SHBGOW9ZazhQUkp3TUprcHFSUUJKa2dOb2lSYkNMVzNGZmNvTFAzd2djaG5jWEJiQktyamM4NnIwMEFtbUpvTXVGN2ZyN1lyajNTLzNPL1VZbnVpeFpaN3dHc1hISnoxb09nV05rWFpvT1JtREtMR09rT1pvZTZjdkczZGZZT044czZpMlkreHhUcUkvUDRwQmg2NDBPTzhYYVJTeHFuOFp1dDhUcGZ4YUtiZ0JOdEdXTWZ1dW9DZUR1aGZJOFpzMnhHb1FjeGs0a3BZbzdZSTYzZEdrbjI0c2dzc1RzbzVJaHZlWEVWZHhjSG1tWHczbWdJNktFbTlNNk9JaGd6Nnl0WlNuSUsrQ1BNTXpQbEptSW1HTXZNRGJGSERCNUdGcjlzbHhPSUoyYUozVE1oQi80bmZyOVBkTm01RzgyQitlOFBTUHFsVkhMSkV1QXNZcEs3N3pmcUdPa055eXp4WVRZczh5STd4RkE2dm9nOVlwQllKQ2JObkJLN2hQR0FoMzd1Rm11RlhkRG1tUDM5eHdmalhlYkY5VmRsekVpOXhtMUQ3elZpeGl4SEkzWjBoakl3Vmp3elBzeDUweUVwS1M0aGRvbGh2UitGbWw4em5WL0NjVnBDK2FPeFU0VXV2NllQeExkWHBoOTBSS1VZcWkyeWZoS21zNjFWRTBzMk1YWG5pNzFxSWdqT1V2RDRlNkc1VzRHYU1uNVFKeDN3eERBK1hjZGJmeEN5Rk51NXVlWkw0bUJUUEs0cG5GQVBlcVNTb2Q3TWJwdk04bUdaNjlNY0ZOYk4xSm5jMzZna05VQ0c1K016QzJFdTJrUnRKZzBOR3Z6dmFIc2NWTWU0S1dtdnFpaGVVYkxLaXMxTStSR3hSRXlsazZOeWtzN2tsNmNWTVBPS0RNOGdsdW1iaXRZQ2dhczFUOC9SMUJYZnNWaFduYmFESkNLcjdDd3c1VlhFbEZWSUhYYUlZOGJwajgzRXBvbEpuV0c5Unh6YldYbk5iVzdRNlRPQUxoMmJjaW9heWo1aitPRXNkbWJLYXl3dHgwZGlwaHE4Sm82cDFCL2JlMVV3ZTFrckR4WDlIbHF3V0xRaU03VCtjRHphRmdwVHoxUWdHNE9OR005TWVRODlrQzB4eFhjTGRSYVJTVzhZUURPNVdZc0ZDcWtKQVczQmJXMW1OeHlPR2NHNjNqdVk3S09wYnNpR2dES05oSWl0VkRNZ0VZdjZJS2NZSklVYzlMMENuV1VZR0hHWFd1bmlaL3JXQ2NPWmFTU2txdG9RQnJhbGJNQVQwTnh3dnZiRWlodE1Jd2IwRU5oS3d5d25wSWNkTXI2bGQwa3lGODAwQXRLN3ZJZmxvUFdld3RUdkRpVStaand6L2FWMWhrc3RQZENaUW81MGI3R0VrR2xrdmZTd1FnNFFoaG1yc0hDRGFjVERqdUZJeUhZNWFDemNZRG9YUUEvVGhRdnAzdU9HdW1NbXByOGcwRnlXa0VRWUxyWXM1R0E2SDVGUEgzSVl4TEtra09tOFNncjd1ZE55cm5Kd21aTkM5amRuT29kSllUcG0wMVk1c2dHYjYwUjhURXk1U0ZXSDUwZ3pWRGs0bGhReW5YZEpZZWFZeFBEUVdzYkJTZW11Rk9haG1jNWh5SkU1S1V5ZjlLVk5DdG5mbk9rY0pJVUR4UWd0NTVBanMxaVZnK2w4SkQ1N3lKRVdhUFkzWlRwM01YVE9JVWMyMTgvQ0RxYVJoRm5UaGtkODJwQ0R3Y3AwUG9vYldzaVJlN1pKZFVKYUtJYUpLZDlTRkcwSVZZNWNrMEl1Y3gxYVpZa2gwd2hKVFJjaHEzSjhKZ0krbVZsYVNHMEFhRm5WSXRnb1lmbFh1MGhMcjNINmFwLzBiVnV6SkZrRm04Q3p2ejVUM2tWc3BmS3hXalErUDdUZHFpVzVXdHdrTWdCMFRJS1FZRTBFMm1XamlSaHhzNUFmdU9JVVFQZlB5OEdjTkZNK0UwTHRERnZKUUlmMEdMclFtaHc2eURMUVRETDZqS05hTUFZOTVqbDUzYzc0ekVtSzczVGFDZlJpYkNvd3BueDc1LzRGV0ZNWXNVZ3FMMVNUNXBCR2huMzlRS3YraUhiYXZIbDFxUUcwdHlQdGgwZGx0c0lWczN5dmxKVitOdjkrRnVOc0p2SWFpR3IwcGtwQUs2ZjlYS1A1Y3BoVVpnQjkrbmphbWRVSmFEYjdLRk8rcE04K0txdHBlVk04Si9WMms4dlZKUGVORE5PYktzWFFjb09IKytLS3VrUXdwMWRTUm1rRHVhM0J5RGxUQjh2QnFBSWxkb0dkRGFhelZ0Q1lIenBkb1U1dU82SW5iVFBIeVVsMWtDT2QzQmZFTXBFby9jOXVjZmRkYzJXVlprTHZiMUNMYnIzTW9VRVBKb1dLcHduNDh0VHJFOUlpOUE3TU9ndFl4WVBwTEVTZU9aeGhibWkxcXdtSjkrcng4emhYNG5TNjZMelZkZnVFM2NReVVSamIzY0ozZEFUZ3VObVBYelVsdnNhS2ZPeXpqQWZqQzhzRE15a3hZNWFyRVR2RVVNWnc1TXVkK3VPaXlja3J5aEs3TzA5WktJYU9FZERVb205Zks3L0RITE1zR1FCNkIvNFh5eGo3ZUxNY0VCTlRPaEU3R1hNeFpFOCt1bDEvU2t5YU9TVjJpV0hkUS9jOEVhQzBNcmg2bTNXanF1cWROQVB3MTVVcWNORlk5TDZSUHBDT2JzdTRTbEVJYnhlMDZDWkwxWm5sWXNRTXNaT0pMWjA5WkpCWUpDWUh2MG5NRXJ2RU1OVXcrcWZTRFc4N2FUbHhxcGM3Wk43ZHR5K0w2Sjh0NzkyQWU0NW1EVDJDRVFVNFd1S05HYk1zUnF4a0N6V0lPV0tQR0NRV3pYd1NzOFF1TVV6TmVTTzRwcGJkcis4VjE1c3ZqOW5qSlpqaVJpOGQ4b0swNTRPTXk5aVM5WVJrOExQbGtabGxNV0tFV01uR2s3VDNBNTA5WXBCWU5QT3BNNHZzR2d6VFNySWFkRC91b3pqYTkveldnazliZk56eHdhc0wwVmJmV3hqU3YrVXRILzRZczgxVGFldUUvZFlibEtDcmp5M0d5U3oxSXB2RUJqR1NqU05pVFQ3MHNjNGVNUWltbGErSVZXS1cyRFZ5UWNORHg3MDBCZFduZjdQSCtrNVNKOHNZR2I0K0hTOEFWUUZwMDh1NGFTUnJvRTlyenJYNW9obExNVXdYbG9nRllvTFl5TjRISGdIcGsxZDA1b2c5WXRETTVXdDd4WGVJV1lOZGlBTjlobWdLa0QzUGJTblkzT0RoRDVpM3ZuTmVFQ2JpVGpWL0owaWIvd3V2b015QnZEN1dROUdnSFgrQnprQXN2bUlXeTRFdVNLTnpUd3dRQzdFTVl6VUdETm5TR2ZPZDFwa2o5c3l0aU5Gbk50czJFN01HdTVEZ29idC80aVZYNmtkcmUyU0RmVTJVUmk4TjJvZUl3Y21EVndmQWFjVURham9BeXZaMVdlT2ZmZ3RnOE4vY0d4MjRPbGxuK2VpWE51Z3VUZWVlR0JncUx6cGJ5Qml4UnN3UmU0TlpKRGFKVVdMVllIWWdETEQ4ZUpsejRDQ2UzV0tuZTRIYTdPVzVZcHNHODJ2a09ZTVAwbG1nd3N3cUNiWTFGb0RjZVFvZzVBT3VwbjdJWTBocEpCWDlrcFRaMHUxSDFzNTArTVNUQlk0bFRIOWxwdmZpSVlVMDhESks1emVtUUc4b25rTlJTUzdkVU5EVVY0RUs2dmJYUUczWUNnV0NCbzh1ODBGdGFYSVY1TmM3Yld2WDdpblloRTlQR0VBUGZBalh0YW95b1hINTQ2VTAycFQ2dVMvOThKN0FQMTFSS3k4eTczQmZpeFZlMk96Q2cwVUFKOHdDeTVJVnRNQXljMHRNdzVjVUJXWHJxNkNkMmdlaVJZT0hsdnBoOXZqa3pyelBtb1J0TjZ3cCtqaysvUnp0RkVVMGc5L25rL3g5UEZ1a2JzVEdPOVk1WHozVnd4MDN0NWxkSFlWLy9xb1BDaW44T0xVZmxQZWZBcTI3aVowVXB1R0ZKejB0b0h6d1V4MW1Zb3JZSXNiTTNEWDFjaWVJU1dMVFlGUXk3NHZyZW01czBnZVVQekdHdXNUTDBHWk1keXR6MXQ4VitIRjVvVnBsYnRmaHQ4QXZ0aGJEeVI1Qlh5R091MlFaOExPdXgwQkdaR2VKS2JzVUNkVDlHMEE3K0FmOSs0SjFtQUErdU1RSGxhN2tLa2hYa0c5ZnZyYm8yU01leTE3ODhjOVVlKzc2MXg0VldVMEUydk5zUmNyUGNqOVpSbFFTN1JmWFY4cVh2Zm0zZ1Fjcm5PcTQ1TGlZZzNYN2ltQmpneVB1NEIwbHdOZC9EYmlMRmdNSUJleWtNYVVjbTZFZDJ3N3F3WTBBd1Y0OUZsODJMUVIzekFubzRVWXFtRzk1dmVqbmh6b0VDak1PVTZuTzgxaTNaSEE2TktDTnhrUWtRVHlqcGtTOTZMMDcvZmZYbFNxVFU3VnQ3QkZoelM0WGZObGxlR2NiSnB1VEZ3QTNhUUg2K2hwZ00zMnd1Z2QwTjROMllpZkFjYlJJdkhROHBWeUNleTczdzhReFVzcXRtcjE4NDIzclhLdVBkVm5JSzlPWTV6YUVPVHFJVVRQUTdveUg0WDZ5bkxLOWFyU0xTbXphcExXMytXKy9zbFphbEs1VXM3KzFBTjQvNUlTakh1dVpOK3d1Z01wcHdMa25BaFJqNUZLRUIyRXJpbnR3M3NMTzlXaVNpdUdDakx4RkFnQ0JiZ0JmTzJnZURIazdqZ0tFL1FQTnBybGpjR045SDh6Q1dEbWRxOXZSSkc2LzYwM1hPbStFbzJwR0ExcXI1N0d1aUlsUEU5RFB1TE1lby9zcEhXcUtvYWVpMWE2OEpyajR2Z1dSVzYwV0xXMXBvOWtyd0piakR0alZiTU5iQm9PV0NXL1VEZ1VXMUVaZ3llUXcxSlpJYWR2RkZJajg1MDc3VzA5dEtxUnU3V1kwdkJxZzNiT3lLNUtDemR5Qk5qYWs4SU1hVDBLcnU2eEtudkQ4ZFgzZndzZloyYlp0OXd2dzUwNHJKbzhpZEFRczRPa1RvQy9HUVVUbVFXRTk0Nk5LRmg1dnZvS3FkNHFVT3hXb0txSmtUNElaRlRHb2NtVWZNMytnWGRqL28vOTF2b2VQVkpJN0NmRmFzd2RoanFiaDBnVDB2NVVQK1dEZFQ3c3BRQzVCbzZBWTR3ZW91SGQrdVA2K0JlSHJhb3FWT25ZNm1ZYXJacC9sNUs5MjJUOTZlWmY5SVA3WUNmSFNISGxucitkUmo1U0J5VVNnTzNNQW1sVHh0SnRLZW9WR0JhVFdTQnBMVnN3TFg3eGlibmpwMUhKbE9zY3lRS2FocFlrYUpudEhYdDFqMy96cWJqc2xmRjZJZDJkVHB3WU5PZ3AyUHVwUnMvQjRka0FiT3lGZ3lWc1hvMVVhU1NQdDJUVi92RlI1ejl6dzdDdHFwZnBxbDFyREFiQnZ6eklOaGxodDlmUE5ueldKaDlic3NlLzdVNHRJSFNTVUxkSWdvMWFJZDVqb3cwRVJabTBJTEpxQkxodjJ3VlU4WFVHd0ZoaGd1dzI0YVlkRlZOc1lYNndVTGI4NE9uSE9PR2w4WGFsU1dlWlF4emhFcmRBbWdGMjBhRmFlQTVZdGpzWkNod2FLcEhDeGlBemhrTVFGdTBOOHo4bGVTOGZlTnJGbC9SY0ZqUzArU3dEaTN6Q2h4MjREWW84QmNyVHowVTQxQndaTlFQK3M3S3gvZ1lxZkRvRHROR0pzMm1rcGVXd0NHODFxZUhTYU5vRTNySDkwSWRPb2RNUzZxWVpSTmtoeGNNd0FtVHh5cndFemhSbDlPc2ovMHFrT2c3MUVvS0ZvUmo1L0VjNkFsc3A1RHNPY2hqbU0xODFnTTQxQ0oyMENtY3B0SVFQY1B1TjV5SGhkaGp5dUhpaU13SlVwR1VhM0U0c0JNUFBRekVQM2UyaDZWRWJxZy85ZmdBRUFGSTRjUFRGOEdqb0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aKleazqOmHkeminS5wbmdcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g54q25oCB5Yy6IO+8jOWxleekuueUqOaIt+eahOS4gOS6m+eKtuaAgVxuICAgIGRpdi5zdGF0ZVxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5tb25leS50YWJsZVxuICAgICAgICAgICAgZGl2Lm1vbmV5LXN0YXRlLnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4ubW9uZXktbnVtKGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIixAa2V5dXA9XCJjaGVja0RhdGFcIixAYmx1cj1cImNoYW5nZURhdGFcIix2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD1cInVzZXJCZXQuYmV0bW9uZXlcIilcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0ucG9ydHJhaXRcbiAgICAgICAgICAgIGRpdi5wb2x5Z29uKEB0b3VjaGVuZD1cInNob3dNZXNzYWdlXCIsdi1iaW5kOnN0eWxlPVwiaGVhZHN0eWxlXCIpXG4gICAgICAgICAgICAgICAgc3ZnKHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uPVwiMS4xXCIsdi1iaW5kOndpZHRoPVwiaGVhZHNpemUud2lkdGgrJ3B4J1wiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHQrJ3B4J1wiKVxuICAgICAgICAgICAgICAgICAgICBkZWZzXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuKGlkPVwiaW1hZ2VcIix4PVwiMFwiLHk9XCIwXCIscGF0dGVyblVuaXRzPVwidXNlclNwYWNlT25Vc2VcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSh2LWVsOmltYWdlLHg9XCIwXCIseT1cIjBcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbih2LWJpbmQ6cG9pbnRzPVwiaGVhZGJvcmRlclwiLGZpbGw9XCJ1cmwoI2ltYWdlKVwiKVxuICAgICAgICAgICAgICAgICAgICBpbWFnZSh4PVwiMFwiLHk9XCIwXCIsdi1iaW5kOndpZHRoPVwiaGVhZHNpemUud2lkdGhcIix2LWJpbmQ6aGVpZ2h0PVwiaGVhZHNpemUuaGVpZ2h0XCIsdi1iaW5kOnhsaW5rOmhyZWY9XCJoZWFkYm9yZGVyaW1nXCIpXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnN0YXJzLnRhYmxlXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGRpdi5idXR0b24udW5kbyhAY2xpY2s9XCJjYW5jZWxiZXRcIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJCZXQnLCAndXNlcmluZm8nXSxcbiAgICByZWFkeSgpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy56b29tUmF0ZSlcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4kZWxzLmltYWdlKVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWR6b29tOiAxLjIsXG4gICAgICAgICAgICBoZWFkYm9yZGVyaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZycpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgICd1c2VyaW5mby5oZWFkaW1ndXJsJzogZnVuY3Rpb24obmV3dmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRlbHMuaW1hZ2Uuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAneGxpbms6aHJlZicsIG5ld3ZhbClcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaGVhZHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxNDIgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTY1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoZWFkYm9yZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIDcwICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDcxICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE0NiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRzdHlsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCAnICsgKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggLSB0aGlzLmhlYWRzaXplLndpZHRoKSAvIDIgKyAncHgnIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJyknXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3NjYWxlKCcgKyB0aGlzLmhlYWRzaXplLndpZHRoIC8gKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLngpICsgJywnICsgdGhpcy5oZWFkc2l6ZS5oZWlnaHQgLyAoMTAwOCAqIDAuMTcpICsgJyknXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvd01lc3NhZ2UoKSB7XG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KSAvLyA15Luj6KGo6IOM5pmv5pWw57uE55qE5pyA5ZCO5LiA5Liq77yM5Y2z5pi+56S65YWF5YC855qE6IOM5pmvXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGJldCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdjYW5jZWxiZXQnKVxuICAgICAgICB9LFxuICAgICAgICBjaGVja0RhdGEoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKC9cXGQrLy50ZXN0KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpKVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxEKy9nLCAnJylcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURhdGEoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcRCsvZywgJycpXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bW9uZXkgPSBwYXJzZUludChldmVudC50YXJnZXQuaW5uZXJIVE1MKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4uc3RhdGUge1xuICAgIGhlaWdodDogMTclO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJvdHRvbTogMWVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cblxudGFibGUge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LnN0YXRlLWl0ZW0ge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIHdpZHRoOiAzMy4zMzMzJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbmRpdi5tb25leS1zdGF0ZSB7XG4gICAgcGFkZGluZzogMCAxZW07XG59XG5cbmRpdi5wb3J0cmFpdCB7XG4gICAgcGFkZGluZzogMDtcbn1cblxuZGl2LnBvcnRyYWl0LWltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMvdGguanBnKSA1MCUgNTAlIG5vLXJlcGVhdDtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG59XG5cbmRpdi5wb2x5Z29uIHtcbiAgICAvKmNsaXAtcGF0aDogcG9seWdvbig1MCUgMCwgMTAwJSAyNyUsIDEwMCUgNzMlLCA1MCUgMTAwJSwgMCUgNzMlLCAwIDI3JSk7Ki9cbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLyogICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nKSA1MCUgNTAlIG5vLXJlcGVhdDtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47Ki9cbiAgICBtYXJnaW46IGF1dG87XG59XG5cbmRpdi5idXR0b24udW5kbyB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbn1cblxuZGl2LmJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDQwJTtcbiAgICBwYWRkaW5nOiA1JTtcbn1cblxuZGl2LmJ1dHRvbiBzcGFuIHtcbiAgICAvKmZvbnQtc2l6ZTogMS41cmVtOyovXG59XG5cblxuLypkaXYuc3RhcnMtYnV0dG9ue1xuICAgIHBhZGRpbmc6IC44ZW07XG59Ki9cblxuLm1vbmV5LWljb24ge1xuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcpIDUwJSA1MCU7Ki9cbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xuICAgIC8qYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsqL1xufVxuXG5zcGFuLm1vbmV5LWljb24ge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIGZvbnQtc2l6ZTogMS41ZW07XG59XG5cbi5tb25leS1udW0ge1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5O1xuICAgIGZvbnQtc2l6ZTogMS41ZW07XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogU3RhdGUudnVlPzQ2YTkxZjY4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSTRBQUFDbENBWUFBQUNLbHNYOUFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBQjNSSlRVVUg0QWNNRHdVTVhmc3QyUUFBSUFCSlJFRlVlTnJ0blhsNEhOV1o3bjlWM1MycGQrMXFMUmJla0MxWmxySEJMTWFZUUNBQmt3bEp5RGczRE55RU80SEJJVU15bVJtSW53bHo3d1ZtSUROM2NpY2JEZ1RHU1NESlhCSW1KS3dockFhTVdlSkZscnpJTnBZbFc3dlVlN2Q2cVRyM0Q3WDI3cTZTRFZocTFmYzgva055ZFZmVnFWZmZlZC8zKzg0cDZiN2RBaU1tUlJQd044QjY0QTNnL3dMTnVYcXozenJuMUQ1blB0MFRQOXZTbXhNRHVMR3h3Z3c4QU53ODRkZExnUzhEUHdHKytXeExieWozZ0ZOeFpvQ1RJNkQ1SnZBVm9GNEk2UEJHT0RZUVlWR3BqZG9pRzVMRXpjQVZHeHNySG5tMnBmZWZjdW5lSlZlREFaeFRBTXduZ2I4RnJnUVlETWRwN1FvU2lpVUJhTzBLY253d1NuMmxrekpIM2lMZzNvMk5GVmNDRHo3YjB2dXIrVHgyNW5rS21CcmdPOEQxQU5HRXdvSHVJRDJCMkxSalE3RWs3N1o3S1hQa1VWL3B4SkZ2dmhTNGRHTmp4ZlhBdmMrMjlMNXRBT2NVUWpDM3lQVTFqWjU3Z051QUlrVVZIT2tQYzJ3d2pLSm12NCsrVUl6K0l6RnFpMnpVVlRqSU04bWZBajYxc2JIaXA4QWR6N1QwOUJ2QXljRzRwdEh6UmVCMjRFS0FMdjh3QjN1Q1JCT0svajhTQWNlSEluVDVoMWxhWm1kaGlRMVprcjRNWEhWTm8rZmhaMXA2N2pLQW96TTZkcjh4cTI5dzg0MmZid0x1QmY0TUlCQk5zTDg3eUdBNGZzcmZtVWlxSE9nTzBqRVlZWG1sRTQrcndBTjgrNXBHenhYQVExc2YvYzAyQXpoek5EYmYrUGxKOGpxZVZHbnJDOUV4RkVGb3pLNmhnVzRDL1NkeGxGVGlMS3RDa3FTMHg0WGpDbjg2N3FQRW5rZERwUk9YMVhJaGNPSG1HeisvQ2JoLzY2Ty9lYzBBenR3Q3pUZUFXOGJrOVZDRVE3MUJFb3FhOVhQRElUKytrOGVJUjhNQStMcU9FUnJzcHJCcUlUWjNTY2JQRFlaanZIRWtSazJSaldVZUovbG0rU3JncXMwM2Z2Nlh3TGUyUHZxYlRnTTRzeHN3bndEK2JxSzhidW55RXh4T1p2MmNFby9oNjI0bjRoMlk5bi9KMkRBRHh3NlM3M0JUV0wySVBLczlnMGdZOFgrNi9GR1dsRGxZWEdySEpFdlhBOWR2dnZIelA5NzY2RzgyRzhDWjVDQkpaeDR3TjF4WERmekxSSG05dnl0QXQzODRPOWxWVllMOUp3bjBuMFNvYXRaN2lZVUQ5TGJ0eFY1Y2pydWlGcE1sTCsxeFNVVndxR2VjLzFRWFdnRnUzWHpqNXk4QUh0NzYyQk1QR01DWkRWbm1odXZ1QWI0S0ZJL0k2eER2OTJ2TDY0aHZBRi8zY1pSRWJFYm5Ddy8xRWZFTjRpcXZ4bGxhaFNUTGFZK0xKaFIyZC9ob0h3alRVT1dteUdaWkRmeG84dzNYZlFiNDd0YkhubmplQU02WkFjd1hnYjhHTGdMbzhrVTUwQjNRbE5meGFCaGZkenV4VU9EVXZTdFZ3ZC9UUVdpd2w4TEtXbXlGcFJtUDlVYml2SG1rbitwQ0s4c3JYVmd0cGl1Qkt6ZmZjTjJ2Z1c5dmZleUp0cms0L3RMcFZzZTNiYXI3U0MvNHBzZmJtb0I3Z0UrUHl1dVc3Z0NEb2V5WlEwMG1DZlIyRWhycVJWTld6VER5YkU3Y2xXZVJiM2RtUGM0a1N5d3VkYkMwM0lGWkhwc1dId1MrdG0xVFhmSk1BS0N0eDV6YndMbnA4YlpwOHZwUWI1RGpnK0hzT0JDQzBGQXZnZDRUcUlxT1p5TUVwczQvWVQ2NlhWSnExOTZTWEhUUmc4ajZCdGZxS3NaZFdZczVyeURyY1FVV0U4czhUaFlVMjBqQjV3RHc4TFpOZGQ4MWdQUEJndWJyd0YrTnl1dmpnMkVPOW1qTDYxaklqNityblVRc3F1czhzcmNEYzh0VGtqVFVnWUNSaDJvckl0bHd0VkNxbTBaL282RVZKQndsSHB6bDFjaW03QS9GYmJXd29zcEZpU04vOUZjdkF6L1l0cW51U1FNNHB3ZVlLNEcvSDVYWEE2RVlMU2Y5QklZVFdUK1hqQThUNk9rZ0d2RHFHNFRoSU9iV1p5VDV4QjZFcXFLb0trS29TSktFTEp1UUpRbFJmQmJKbFo4U2FsR3RQaENhekxncWFyQVhsV3NxejBxM2xZWktGL2I4c1lmNEpQQS90MjJxYXphQU16UEFWQUgvT2lhdjR3cXRYWDY2ZkZGTjBob2M2Q1kwMElNUXF2YUpsQVRtbzY5TDVzT3ZvQ2FHVVpVUjBLaXFpaEJpQkRpU2hHd3lZWkpsSkZsR3JUbUhaTVBWUWxnTDlhbVBmQ3R1VHkwRkRuZDJvRWtTaThyczFGVTRzWmpHbE5vandKWnRtK3I2RGVCb2crWWVZRE5Rb3FpQ0kzMUJqdlNGTk9WMTFEOUlvS2NESlpuUWx4RzZXekMzUGlzUkdrQlZWUlJWUVZWVVZDRVFFMGlUSkVtcHpDTmprbVZrazR4c3prZFpjZ25Kc3k4VG1QTjBuUy9mNGNidHFjV2NiODFPdE0weXl6MHV6aXF4anlhcW5oVC91Y3NBVG5yQWZCSDRHckJ1VkY2M2R2bUl4clBMNjBRMGpMKzdnM2hVWDFlbkZPekYzUHlrSlBVZlJSVUNWVkVtWlpsczNHVWsrOGlZWkJPeUxJUFZoVkozaFZBV25nK1NyT1BrRXZhaU1sMzh4NUZ2cHI3S1RhVjdER2c3Z1llMmJhcmJaZ0JuWEY3ZkRWd0w0SThtYURuaFkwQlRYaWNJOXA4azRodlFkNlB4TUtZREwwaHkrMDdFR0ZnVVZGVkZWZldQd2JUc0k4bmc4cEJzL0pSUUs1YnA1RDhtN0NXVjJJdkxrVFFBVitySXA3R21FTGZWTXZxcjU0SDd0MjJxZTIxZUFpZWR2RDdZSGFCOU1KUlZYZ3NoaUhqN0NBMTBvU282ZW1tRWlxbjliVXdIWHBCRUxEUUNGbVdVQUl1c1dVYUxrOGdwOEpoa0U1SXNJU3FXazJ6OGxCQk9mUTNnSmtzZXp2SWFySzdpN0E4SldGQmlwNzdTUllIRk5QcnJYd0xmMnJhcHJuUGVBT2VteDl0dUIyNGRsZGZ0Z3lFT2R2dUpKN1hrZFlCQWJ3Zkp1TDR5Z1R4d0ZQUGVKeVVDUFNrZW82SXF5alFlYzhydTZWVCtJOHRJSmhQcXdndFI2ajhoUko1ZDEvZFlySGJjRlF1d1dMTWZiNVlsenE1d3NhVGNpV25jUVB6eHRrMTFtM01hT0RjOTNuWUZjTWVZdkE3R2FEN2hKUkROVG1pVmVJeEFieWV4c0w0eWdSUWV4Tnp5dENSMTcwT29Ba1ZWVUJSdEhuTzZBQnFadmtiNGo1eG5JN25zNC9jcml5NitFNU8raDFQZ0tzSlpWcDJ4Z0RwbU5PYVpXRkZkU0UyUmJmUlh1MU1FK29HY0FzNU5qN2RWQXY5bm9yeHVPZW5qcERlU25jY29DdUhCSGlMZVBuMFBQQm5EZlBnVnlYUmtPMm9pTnA1bFZCV2hxaDk2ZC9SVStTN0w4b2lCdUdLalVHdk8wV2tneXRpTHk3R1hlRElXVUVlajJKNUhZMDBSeGZZeG9QMFIrTzYyVFhYUHozbmdwT1QxclVDcG9nb085d1k0M0J2UUlhK0hDQTUwbytxUzF3SzVjdy9tbHFja292NnhLZWwwZWN4cEFXaU1RS2NNeEpLRktDcy9MZFRpcy9STnMyWUx6dEpLck81aXpXTnJpbXlzcUM3RW1qY0dnbDhEMzk2MnFhNXR6Z0VuSmE5dkF5NEdPT21OMEhMQ1J5U2V2VjZVR0E0VDdEdEpZamlpN3dhOEhaaWJmeWRKZysyb1FwMW00cDJwa0FCSmxwQWxlWktCS0dwV2sxeHhqUkEyL1FhaXM2eWFQSnNqTzlHV0paWldPS256dUdkVVFKMDF3RW5KNi84TmZHWkVYc2RwN3ZReUVCeldJYSs3R0E3NjlGMzRjQURUL3VjbHVlTWRoREtCK0tvakp0NXNpWXdHNHRKTFNkWmRKakRuNnpNUTdTNGNaWlc2Q3FnTlZZWFVsanAwRlZEUE9IRFN5ZXY5WFQ2T0RRUjF5T3QrSWtOOUkxMTRXcUVxbUk2Ky9tdnp3UmMycVlub3RBd2p4T3hjNTVYZVFIU2pMTDlTS0FzdjFHMGdXdDNGMkVzcU5BM0VRbHNlSzJ1S0tIT09BUzF0QWZXTUF1ZW14OXYrbXBFeVFiMFFjS3cveVA0dW43YThEdnNKRFhTakpQUXRWWkc3V3pIdis3MUVzUDlEa2RjZlBmOUpHWWh1RDhtVm54WnF4WEo5M3lHYnNCZVhZM1dYWmx5Qk1ScFZSVFlhYTRwd1pDaWduaW5nZkJ5NGMxUmU5d2VIYWU0Y3doL0pEb1JrUEVab29KdDRSR2VaSU5DTGVkL3ZKS24zQUtxcXYwd3dteU85Z1ZoUGN1VzFRcmowRzRpT1VnLzVkcGZtdVphVU8xbGVWVGl4Z1BvVDRKdGJOalNFUGtyZ2VJQi9HNVhYa1hpU2ZTZThuQmdLYTVpNEN1SEJQcUtCSVgxZGVJa281b012U1BLUjdZZ1VmMUZPb1V3d203TlBXZ054MFRxVWhxdG1aQ0E2U2lzeDUyZm5QL2xtRS9WVmhTd3VjNHhtcW1QQUkxczJOUHpUUndHY2V4aHBxaXBUVkVGYmo1OUQzWDROZVMySUJyeEV2TDA2eXdRQzA3R2RtUFkvSzRuaDBBaFF6cUM4L3FnQU5NMUFyTC95UFdYSituUDFkaUFXT0l1d0YydnpINWZWUXRPQ1lpckdDNml2QVE5dTJkRHdxdzhET0Y5a1pEWEIraEY1SGFhNVkwaGJYa2ZEaElaNlNjYUc5YVh3L2lPWW01K1U4SjVBRmVxWTR6dVhwNlhUTWhEdHhTTUYxQVdyOVJtSXNveXRzQlNydTBTVC8xUzRyVFF0S01FMVhrQjlHcmgzeTRhR3R6OEk0RXlXMTVFNGV6b0c2UTlveSt2d1VLLytNa0hFTzlLMjJibnJJeWtUekIwQ1BjRkFYUFZaL1FhaXlZeXRxSndDWjZIbXVSYVhPV21vS1NUZlBGWkEvU2x3eDVZTkRmMm5BcHdwOGxxaDlZU1g5L3VEV1Ira0VJS29iNUNvZjFEZkExY1NtQSs5S0puYVhrWk54aWJMNjQrZ1REQnJ3WlBKUUZ5d2htVGpud2xoSzlKbklPWVZZQzhweDFKZ3k4NlRUREwxMVVVc3JYQWhqMlNxSHVEaExSc2E3cG9KY0w2V21wYnFoUkM4M3g5ay93a3ZzYVNpSWE4RGhMMzlNeWdUN01hODd5bUo4TkFJOGMxaEh2T0JHNGgxSHlPNTdBcmRCbUtlelltOXFFeXpnT29vc0xCeVFUSFZSV1BFZkNmdzBKWU5EZHV5QWVkeTRGdGo4am9RWmMveFFYdzY1SFhFMjZlL1RPQTdnWG52YnlXcDcvQ3NLaFBNRGY0enhVQnN1RW9vaXk3U2J5QTZpMGI0ajBZQnRjeGw1WnphWWdydFk4QjhIcmgveTRhRzF5WUNwd0w0N2tSNTNkd3hTT2RnU0ZOZVIzeUQrc3NFc1RDbWxxY2t1ZjJ0V1YwbW1Ic0dZaVhKcHM4STFWT3YyMEMwRlpaUTRIUm5KZHdTc0xETVNlT0Nrb2tOWkQvZHNxSGhKdW0rM2FJUmVBa29WMVRCb1M0ZkI3cThtdko2T09nbkdoalVYeVk0OGhybS9YK1ExSGc0TlMzTi9qTEJuRE1RUFEwa1YzMVdDSmRIdDRGb0t5elQ1RDltazB4OVZTRjFsWVdqRFdUcnpjQldvUHpFVUlnOXh3ZUl4TFNxMXhFaXZnSDlaWUtlQTVqMy9sYkMzNDB5UjhzRXN6RlVJUkNwVEszS1lpUURkYlZpNlQwb3FZdlhvNnpZS0VTK1hVT1h4QW4ybjhSU1lNTldXSnBsQnc2RmZaMkRTQklzcnlvQ3VNUTg2c3ZzYU92SmZwSmtncWh2Y0d6VElTMVBRUXIxWTk3emhDUjF0K1JNbVdDMnhXaTJGa0tncXVvSWVJUkFQcktkdkk3M3BHVERWVUpaZWluSUpvMWtFTVhmMDBtKzNZblZYWUpzTW1tcnRZa1hrZjdpVklhRFBvWkQvcEV5Z1pZSGxZaGkzdis4SkI5K0ZaRk1qbWVaZVM2dlB5b0F5YW82SXQvVkVLWTkveVdaRHI5S3N1bGFvZGF1MGZ4amowV0N4S05oQ3B5RjVEdmMwd3pFaVJBeEF3cGdraVJwR25qaWtSRFJ3TkNFTW9HVTdlb3h0ZS9FdE85cGlhanZqSGZoelZjQUtVS2twcThVZ1E0TlluNXJteVFPdjRaeXp1ZUVXckpJOHp1aUFTOUNDS3l1b3F3Wkp3eTRUSkpFWWdvaERudjFyVHlWQjQ5aDN2VzR4RkRIdkNzVHpGWUFxWXFDRU9wNEJ1by9pdm1sZjVORTdYa2ttNjdWTmhCRjlqcTBlZEtSVXljU2pXbEppdm93NzNsU2tqcmVHMXVzYjhqcldRSWVRS2dDSWFtVE05RHhkOGc3dVZkU2xsMU9zdjRUbVExRWFUb2UxSEVGbmFkUmRwVXkwWEZNaDE3NnRmbkFTQmVlTWtlNjhPWTcveEdxaWl4a1RLcEFibjJldkdNN3BlVGFHNFJhMmFEcjJTZkhaeVNyZWVvSnBub0Y2VUJnZWU0ZWlkQkFpdmlPRkNNTndNd2wvcE9TNytFaDVMN0RrcWhzRU9rNDYvVG5LZEpOVlduWkN6RGQ0QlBCL3JHNmtzRmo1aUNBRkNXVmZVeVlFc01aWmhaSnB4d25EY0l5ZkRhcEpGRVVKU2U2OE9acnFFS0FxaUNyU3Rybm5BNFBVK1c0QnNlWi9xMHFNcXFhTkVaL3ptZWYwY2xuNWhsSG5pYXFSSHFCTlRsUDVSbWpQbStrV1hvOG1JRTRqR3hUSjlMS2Nja1l3RndPU1VxN1I2RVFhcHAza1lsSkdTY0NZSlpsWXhDTjBCM215Uk9lbU5FOFowVE9wSjNNSkdoQ0tPUGJBMC93Y2RMUkdnTTM4eHMzVTM1V3hvR1VuejNqU0RMbzJmYlZpQnhFampRZEQrbmtlTWFNWTJTZDNJN0VjSG9mUnlJTE5kWXFjbVpFam9HbTNOTGNFdm9tcTB3bEI3MUdzTWxpalBkOHdGT1dsSk4xcXBJeWFIeTlteUVhTVVjWVRycG5MR2w0d0VBTXdDUkpIL2g3bkl5WXl4a25leWVYR1JnZUF3NEdPNTZmaXVwMHErUHBrcE5rVU9QNXFNYlQ0U0V4dmtXTlRZTWNHeGxuM2lJbkRja1I0MjAwRnUyZVk0UDI1RGlYVVRXa2xkWlVsYlpVbFVGVkdWa29keUlSeS9nR3Z5ekdNVVpKM0loVGlxeFRsWlNKNDFnS2pKSExLVTBscGZsOU9wNlN6am5PMVBXWFRsVkp4bFNWTXhRbkV4dEJhRHJIVVFDVFNVNHZ4NDFhMWJ4VVZZTHBIYUZpU2dkZ0FoamQ5MDMzZVF6b0dCd25zNnd5cHFSNWtuRDA5ZU1reC9lQWRKaTFLSTRSODVqL1RQbDV3akk2a3dZNWxvd3BLZGREU1daUVZka3p5V250Vm1GRUxnQW5rVVgvblBMYWNXa0djNklSdWFTcVRtL3RlS1orREl2VkdPdjV3RyttclIzWG0zR2tHZitIRWJtU2NIVEk4UkNBSmMxT2sxbXBzZEV4bUVPNGtVNEpPTW80RnpLQVlFUVdxcUo3bTVOTUpOaVlxWEpybXBMMExRRk9qQnVBcnF5dG81S0JrbmxPa0RQV3FpUnRPVzQwY3VWMkpPTVpuckhRYVFCbVdNaHBRQ1RIUTFYSTJGV2haMEhlVEtwVmtyR1h6cnlackRMOXJFMk8wNlV4czlFQm1EdXFTWnhTSldCU3hwbTJ6ekhDS0hQT0UyR1ZMdGNJRGVjNEFHQXhtek5wTldOazV5VjB0RE9PeVBwUlExUVp1Sm5PZUNTTlBRQU41TXpyeVdxcUFaZ1kyOXZhcWJsZmlkRkJNUTlnYzRwRlRnMDViaUFucHlNZXpUS3JmTkE3Y2htUkcybzgyME9mMlk1YzAydFZhVGRyTXJia3p5bjBaRnpra0dWZGxZNDkyZEkwTWh0N0FNNERjcXpkT2lveXFpckpJTWZ6bGh6TGFHN2xGZ0RJc3hnR29KRnhacFp4UHVqdk5DSVhjSk1tMlV3b09aaXlHb0RadDhBd0luZHdvMjhKOEFRRDBKRzFQOEo0MStaOFVGV245b3pOV2ZOVHRuNVVJM0lqRXRFTW5zdHBHSUNTTU9oTXppZWNiSlJWbndFNHZWbGRaTW80eGxadXVhL0hKZW5VRGNDTWUyN0xKbU93YzF4VTZlRTRDcVMySDAzM2FrWEoyRnA5WG1ZY1djNjZJRThHZ2dCbXMrbER4cWdSdVJSWlZkVklyN29Ca3R4UE9QcGVkS2FLc1pXY2VjWTZGeU4wUjNMOExjQzJyQXZ5aENvTTV6alhJOE5XYm5yMk9jNk1uRXhHam9HYm5BbVJqSjJTa2FOakt6Y0RKZk5Ua00ra09qNnR5Q25TcS9GOHV6QVFsUnNodThvelY1V3liTzEzU205bE5kYzBJbG5kaUlqUEdQbTVtbU1zK1ZqWC9ZV3dYdkRuTThoQ0V3QUhKQUZrYVNMUEdlYzdraVJOKzJkWmNnSEZteDhWMWdzMjNTK1o4NDJuTU1lbXBmd1ZINmY0MXA4TCsvb2JrUzBGYVoreExNdHA4REQ1WFE1aFNPMEJtUDZZOUtjdmNPQzRZdk9keFp0L0x2SlhmTnlZdWVaQW1EMW5VL2lsN3d2WFo3NHRaRmU1RHVhY0VUY2FCaURhQnFESlhZSDdzM2VKeFBuWEVYcmhoMUxpNUg3akNjMDJIbU1yeEhINUxhSmcxZFc2Mm1SVVJTRWE4RTdEZzZLT0dZRDVXZC9sRUEzNkVFSlE0SFFqU2RtOVFrdDFBMFUzL1VnTXQ3NU0rT1dISk1YZmF6eXhNejBwbVN4WTEzN3VjZnY2Ry85Y0tuRG95RENDNFhDQWFNQ0hTUE91emdrR1lIN1cxbEVoQk5HQWwxZzRnTlZWUXI3ZHFUbC9GcXk0Z3Z4bGw0akl6c2VKN1BpRkpPSlI0d21lZ2NoYmNqN09UL3kxTUpYVTZqbytIZzBUOVEraUpCUDZwajA5QjZtS1F0amJSeXpzeDFaWWdpWGZxc25ZSFpmY2lHMzFSaEhhL2pNcHV2dHBHRTl6Um55SVlTcXV3WFhWMTBYZWt2TjFIYThrNG9SOWd5U0dJMW1QYzlnS3VIQmwzZWlQYjBqMzdSYnJnZGNUU1lYZGg0N1IzTlkrTVNXbFI3UFZqcTJ3RkpOWjM4SzhaSDg3d1QvK1NJb2ZmZHQ0c2gvV3RGVGd3SEhKbDRSMTdlZDBMWmdVcWtvME1FUTA1TSsrZnNva3M2cHVJYXVYTDhac2toR3FHcEJrK1dMcHZ0MkNaRHoySzNOZS9uOERDRVdHMmJtdmpTT2QzUnBYS21GMUZtSnpGZXZlRXpCMjVHMkNmL3lSbE94dk41NzBCNFlZR2V1cXEzRisvQlloMjR0MGZXUTRGQ0RpRzBEVm1BVVdWVmR3OGFybE9Hd2pIWi85SGUrLzJicjl4Yi85dzBQLy9yWjAzMjdCbGcwTnJrMy9jUDlmTGx4MTdsZUtQTlVOQUwyRFBuYnNQVVR2WUhhVFQ1Wk5XTjNGV0oyRitocmJWWVhJcnQ4VGV2VVJTWTM0alFkL0dtRlowSWpyNm04S2krZHNYY2NuWWxIQ1EzMGs0N0dzeHhXNUhGeXlwcDZxc21JQUJrOTJ0TDMzOUJNdnYvcUxuendIdkFQMGpBTEhEaXdGR3ErNzg5N1BMcnZ3a2d1ZEpXWFZBRWM2dW5tMzlURCtVUFk1MEdUSncxNVVScDdOb2VzbXhIQ0kwUGFmL1NueXpoUG5DU1Zob0dBbVBNWmRnZk9LVzBWQm96Ny9URTBtQ0hzSGlJVURXWS9MdDFnNGYrWFoxQzllZ0N4SmhIMURmWWZmMi9IVy83djdqbWVBUHVCOTRCZ1FHZ1dPR1NnQkZnRzFRTWxmL2ZDeEd4WTJyVmtIb0tvcSs0NTBzR3YvVVdLSjdBL1pVbUREVVZ5T09VK2ZvNno0ZXdtKytHTXAydklTeGo0ckdyT1NPUi83UlY4UWp2VTNJT1Zwdi9wcFJCVVBFZkVOcFpYWDQ2eERvbUh4QXRhdVdFcEIvc2hPSk1mMzdYcjdrVzkrNVpGRWJOZ1BuQVJPQUlPTXZEVmFrZTdiUGZLd3RteG9zQUFPb0F5b0FTclBXcm5tRjlmY2RzZTdDeHFhemdNWWpzVjV0L1V3QjQ1Mm9tb3M1Q3B3Rm1JdktrTTI2U3VISlU2MDR2L0Q5NlhFaVZZREllbkdzLzVTWEorOFhaamNGZnI0WkNSSWFMQVhWVU5lVjVVWHMyNVZQYVZGTGdENjJvOGVlT21uRDl6Yi9QSnpKcUFyQlpnK1JscU14NVp5amdFbkJSNEpzQUJ1d0FOVUE1N3pycmx1NVNWZitQTFY1UXVYMUFONEF5RjI3RGxJWjArL0JtK1RzUldXWUhPWDZHeEJGVVQzdlVUZ3hhMkdnVGlhd1QxbjQ3cnFkcEcvY0xVK0JSdVBFUnJzSVI3Vmt0ZFdMbXhheHRMYVNnRDhmVDBkemE4ODk5cXpQL3JYVjRIZUZHQzZBVDhRbnpvZFRBTE9CQURKUUQ1UWxBSlFEVkMyOGJhL3Y3Unh3NVVYRjFYV0xBYm83T2xueDU0RGVBT2g3SE95MllLOXVJSUNoMXNmLzBuR0NPMzRUMEp2UERwdkRVVFo1c1o1MlZlRS9keHJRY2R5cEZHdkxScjBhc2hyRTAxMWkxalRzQVJ6NmgxbDdjMjdkano0dFJ0K0RneWtBSE1TR0FLR2diUnpYRnJnVEFDUUNiQUN4VUJWQ2tBbGYzSFB2MSs3OU55TExpaHdPSXRWSVRod3RJTjNXdzh6SEl0cjhCOHJqcEpLTEFYNlhzMm9CQWNKdnZxSUZOazFqd3hFMllSOTdXY1dPeSsvNWFpc3Mwd1FEWGdKZS90UUZTMTU3V0hkNm5xY3RwSHhQM21vZGZmVFA3aHZUWHZ6cnVzbjhKaCtSZ3JmV2I4c0szQW1BTWdNMklIU0ZIaXFYR1VWcjEvL3YvN3ROMmV0WEhNQlFDeVJZRmZyRWZZZFBvNnFaamNROCswdW5LVVZtQ3o2dG9STDlyZmpmLzRIMHZDUm5UbU5tZndsNTFONDlkZUZ1V3locnVQajBUREIvbTVkOG5yOXVTdW9MaThabDlmUC9OY3JyejcyME03VWRIUUM2RW54bUxndW9xNEhPQk1BbEFjNGdmSlJBdDEwK2RYSnk3OTA2NWFLUldjM0F2aERZWGJ1UGNpeEV6MGEvcUdFMVYyQ283aGM5OHJRNFNNNzhULy9BeW5aZnl5bkFHTXVyc0gxaWR1RXRmNVNmWms0bVNEWTM2VkxYcTlkdVl5R3BiVWo4dHJ2N1R2ODdwc1Q1ZldKRkFIMkFyR1p5Tm9aQVdjQ2djNVBFZWpLRklES3Iveks3ZXRXZmZ5YVMwdXFGeXdGNk9vYlpNZWUvUXg0QXhxWjJZeWpwQnlicTFpM2dSaDY3M2NFWG41WVV1ZDRCNktVWjhXMTRiOEx4OFhYNnk0VGhMMzloTDBEMnZKNlNTMXJHK3NteWV2LytMdGJmaEdQUm5yVHllc1pYL3RNZ1RPRlFGdFRCTG82OWEvMEMvLzRMeHZQUG0vZFJmYkM0bkloQklmYVQvRE92b05Fb3RuVHFUbXZBR2RaRmZrMnA2N3pxOE1oZ3E5dEk3VHoxOUtjTXhBbENkdXFxM0ZmdVZtWW5LWDZzbTNRUjNDZ0d5V1pmU2FwS2l0aDNlb0dTb3ZjWS9MNjVaOXQzYnIzcFdkOVUrVjFuU2VaYk9zeG45b3RuQ3B3cGhCb2U4cEFyQUdxTGZrRnpyLzg3c00zbmJWeXpVVUFpV1NTM2Z1UDBuem9mWklhQkM3ZjdzUlpYb1U1VDkrT0dFbHZGNEVYZnl4RjlyMDRKMTVHbTdlZ2tjS3J2eTd5RmpUcTg3ZGlVWUs5SjRsSHc5cnlldFZ5bHA1VlBTYXY5NzM2aDllZStlRjNYa3Z4bDBueXVzNlRGQUJuRERqYk5vMlUydHQ2ekpZSi9LY2FxRnAyNFlaSFAzbnpOL1pXbnIyOENTQVVpYkp6NzBHT0hEK3AvUmZwTHNGWldxSGJRSXgzdHVCOTdudFN2TE5sVmdMRzVDekZmZVd0d243T1JwMWRlRW1DL2QxRS9FUFpNN1hKUk5PeXhheFpzVlNYdks3ekpDZk5jV2NjT0ttTGtJQzhDUVppRFZEeHNSdHV1ZUM4YXo1M1dVbDFiUjFBNzZDWEhidGE2UjMwWnVjL3NnbEhpUWRiVWFsbUIrS29OSTNzK3lPK0Z4NlFGSC9QN0ppVlRCYWNGMTh2WEpkK1dWZVpBQ0VJZS9zSkRmWm9WNjlyUEt4YnZRS24zYVlwcitzOHliUmZOaXVBTStGaVpLQWd4WCtxVWhtbzdMbzc3LzNrcEFMcThaUHMzSHVBVUNTN3lXZXk1T0VzcThMcTB0YzJJQkl4Z20vK2lzRDJuNTFSQTlIYThERUtQL2sxWVM2cDBYVjhMQndnMEhlU1pHeFlRMTQ3V1g5dUk5VVZwWnJ5dXM2VG5SVE5LdUJNdUNnVFlFdnhuMUVDUGFtQW1sUVVtZzhlWmZmK0l5U1N5ZXo4d0dySFZWRkRudFd1MDBBY3dQL2lRMUpvOXpNZnFZRm9LVjlFMGNadmlJS2xGK2pqYWZFWWdkNFRESWV5dDVuazUxbFl1M0k1RFdjdkhKWFgvWWZmZlhOSEpuazl5bVBtSEhBbVhGemFBdXFmM2I1bFYvV3lGYXNCSXRGaDNtayt5S0ZqblpxN25WcGR4YmpLcTNVYmlJbStZM2lmKzU0MGZQaXREOWYwTFhEaXZ1SVc0VHovT2wxbEFxR3FCQWU2Q0EvMVpiMW5TWktvWDNJVzV6Y3RueVN2dDkxeDZ5OWo0VkR2QkI0ekFFUXpUVXR6RGpnVCtNKzBBdXE2Ni83aTNBcy9lLzJWWmJXTGxnRU1lUDNzMk5WS1Y5K0FCbitXY1pSVTRDajE2TzVBSEc1N0MrOXozNU1TZlIrd2dTaWJjS3o5N0JXRlY5ejhSOWxXcU9zakVkOGd3YjZUbXMzaGxlVWxYTHltY1pLOGZ1WG5ELzUrejR0UHQwNlIxNkU2VDNMR3ZzU3NCODRVL2pOYVFCMDFFTXV1L1p1N0xxKy8rTEtMM2VXZVdvQmpKN3JadWFjVmZ6QzdERFdaTGJqS2E3QVY2dk5EVUJXQzcvNFczNHNQZlNBR1lzR2ljeW5hK0EyUlY3Vk1uL3FMaHZEM2RCS1BoclRsOVRrTkxEMnJacUs4M3Y3TUQ3L3phalo1bmJQQW1jSi9yRlA1ejVlK3MvVnppODlaZTJHZTFlWlVWWlY5aDk1blYyc2JzYmgyQTVuYlU2dGpDYytvZ1JqRS84cC9FSHpyOFZNeUVNMkZIb28yZmtQWVZseXVqMjhsRXdSNlR4RHhEV2pMNitWTFdMT2libXg3dlpuSTY1d0h6b1FMTjAvZ1A5VkFsV2R4M1M4L2QrYzk3eXlvWDdrV1VnMWt6UWM1Y0tSZFZ3T1oyMU9ET1Y5ZkJUNDUySW52eFlla2NQTUx1Z3hFS2MrSys5SXZDOWY2NjVFczJsMk9RZ2hDQXowRSs3c1FHc1hmUlFzcVdiZTZFYWZqMU9YMXZBSE9GUDdqQWlwUzA1Zm52R3V1YTVyVVFPWVBzbU5YQzUzZHZab0dvcU9vREZkRmpXNERNZGJad3REVDM1VmltUXhFU2NMZTlBbUtQbm1iTUJkNmRIMW5OT0RGMzlOSk1xNGhyOTFPMXAvYlJMV25MSjI4N2dFNjljcnJlUVdjS1FES0J3b24rRC9sMHhySXVudlpzYXNGcnorb3dWbE5PTXVxY1pSNDlIVWdDa0c0K1FXOGYvaWhsUFNORzRoNVZjc28rZlFkSXIrMlNaK0tpMFh4ZDNjd0hQSnB5dXZ6Vmk1blJkMWlaRWtpRXZEMXQ3M3p4bW5KNjNrSm5Da0VlclNCckpwTURXUkgybm0zK1lCbUE1azVyd0IzWmUyTURNVEFHNzhnK043dnBjTEwvb2R3blBzcDBPRmNxNHBDc084a3djR2VyTk9FanV2dkFBQUR4a2xFUVZUZW1MeGUxVEJKWHYvMHpzMi9IQTRGVDB0ZXoydmdUT0UvMlJ2STRnbDJ0UnhpMzZHajJnMWtEaGVGbFdkaDBXa2d6aVRDUTMzNGV6cFFOVXpNeXZJU0xqNnZpZEtpd2pGNS9lcGpEejI5KzRXbjluMFE4dG9BenVTYjAyNGdDNGJadWJ1Rlk1MWRtdDluTHk3SFhiRkF0NEdZbFJ1RkEvaTYydlZWcjFjM3NuVGh1THh1ZWUyRjE1Lyt3ZjJ2TU5JYzN2bEJ5T3M1QTV4bjluMDB4Y1EzYnJ0Y1h3Tlo3d0J2L21rZkE5N3MvRUtTVGJqTHEzR1dWdW8yRUNlcHNVUU1YM2VITG5tOXFuNHBxMWZVWVRHYk5lWDEraCs5clBJUnhodTNYWDZHZ05QeTBWYWgzL2pxNWZvYXlONC96dHQ3OXhPSlpsYzBKa3NlYms4dGp1SnlYZWNYcWtxd3Z3dC8zd2tkOHJxS2RXdFc0bktNVEkxZGJmdDNQL1g5ZjA0cnI5Yy84UElaNmNaLzQ2dnpCRGdUYmxoZkExbHJHM3NQSE5ac0lNdXoyaW1zV3BoMUNVL0VQNGl2cTEyN09kenRZdjE1VGRSNHlqWGw5Zm9IWG81ekJ1T01BZWZabGpPN2NPNzFyMTZtM1VBV2pyQnpkeXVIMnpzMXY4L21McUdvYWlIbS9QRU94SGcwalBma01WM1Y2L09hNm1sY3RpUWxyLzBEYmUrOC9tWW1lWDNKQTYrYzhaYkYxNzk2MmZ3RVR1cm05VFdRRFF6eDFxNFd1alVMcUJMT3NpcWNKUjRDL1YzNjVQWFNoVnh3em9wSjh2cm5XMjc3WGlUZ1Y2Zks2MHNlZUdYV0xCS2IxOENaTUFpNkdzaU9kWGJ4MXE1OStJT2gwejVuWlhrcDY4OWJSV254dUx4KzdaY1BQNzNyK2Q5Tms5ZVhQUERLck91cU40QXplVERTTnBCOStWOGV2RzdScW5QUEh5K2dIdVZQK3c1b0ZsQXp5dXMxS3psNzRZSXhlZDI2L2NYWG4vcitQNmVWMTdOaFdwcFZ3Tm42MkJQTTF1aDQ2SzVwRFdTZXhYVy9tRnhBamZIdTNnUHNQL3krWmdGMVhGNmZ6ZXJHWlpuazlhaGFHZ0tHYTIrNVIyVVdSOGREZHhuQXlUQXdFeHZJUmd1b0ZkTUxxQUYyL0ttWmpxNWVEWG5kaE11Wmt0ZUhEK3g1Nm52L3RIcUt2QjRBUXJXMzNETW5GcnVmT2VBOCtodm14QUQ5NUI5SEc4Z0tVd1ppMmdKcVIxY1BPOTVyeHVzUFRKYlhhMWRSVTFtaEthOXJiNzQ3emh5S2pwLzhvd0djR1FCSXM0QzZ2KzE5bWc4Y3BuSFpFaHFYTHgyVjE0TnQ3N3orUmlaNVhYdnozWE51U3pFRE9ETWZNTTBDNnNRNHZtL1gyNC8rdysxM2gzMUR6cW55dXZibXUrZnNIaXdHY0U1OTROSVdVTmR2K3RMZmxOU2N0V2p3eFBGak81Lzh6MWQzUGY5azgxUjVYWHZ6M1hOKzE4c3pCcHhjaUV3N2NLUThvZUVVVUNiSjYvdTI3eGM1Y3UrbjlEa3pScEFDd2ZDV0RRMXhJSlNhZ2lvWmFXVU5wakxORURCODMvYjlxakZpQm5DbUFrZ0Z3bHMyTkF3RHZsUVdpZ1BSKzdidlR4b2pOQjcvSDF0QXdncTdIUEE1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwic3RhdGVcXFwiPjxkaXYgY2xhc3M9XFxcInN0YXRlLWl0ZW0gbW9uZXkgdGFibGVcXFwiPjxkaXYgY2xhc3M9XFxcIm1vbmV5LXN0YXRlIHRhYmxlLWNlbGxcXFwiPjxkaXYgY2xhc3M9XFxcImJ1dHRvblxcXCI+PHRhYmxlPjx0cj48dGQ+PHNwYW4gY2xhc3M9XFxcIm1vbmV5LW51bVxcXCIgY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIiBAa2V5dXA9XFxcImNoZWNrRGF0YVxcXCIgQGJsdXI9XFxcImNoYW5nZURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjM0Knpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwidXNlckJldC5iZXRtb25leVxcXCI+PC9zcGFuPjwvdGQ+PC90cj48L3RhYmxlPjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcInN0YXRlLWl0ZW0gcG9ydHJhaXRcXFwiPjxkaXYgY2xhc3M9XFxcInBvbHlnb25cXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiaGVhZHN0eWxlXFxcIj48c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoKydweCdcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodCsncHgnXFxcIj48ZGVmcz48cGF0dGVybiBpZD1cXFwiaW1hZ2VcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCI+PGltYWdlIHYtZWw6aW1hZ2U9XFxcInYtZWw6aW1hZ2VcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCI+PC9pbWFnZT48L3BhdHRlcm4+PC9kZWZzPjxwb2x5Z29uIHYtYmluZDpwb2ludHM9XFxcImhlYWRib3JkZXJcXFwiIGZpbGw9XFxcInVybCgjaW1hZ2UpXFxcIj48L3BvbHlnb24+PGltYWdlIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiIHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIgdi1iaW5kOnhsaW5rOmhyZWY9XFxcImhlYWRib3JkZXJpbWdcXFwiPjwvaW1hZ2U+PC9zdmc+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBzdGFycyB0YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwibW9uZXktc3RhdGUgdGFibGUtY2VsbFxcXCI+PGRpdiBjbGFzcz1cXFwiYnV0dG9uIHVuZG9cXFwiIEBjbGljaz1cXFwiY2FuY2VsYmV0XFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxCZXRNdWx0aXBsZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LThmZjQwNjdlL0JldE11bHRpcGxlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRNdWx0aXBsZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLm11bHRpcGxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuNik7XFxuICAgIGhlaWdodDogMTIlO1xcbn1cXG5cXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi50ZW4ge1xcbiAgICB3aWR0aDogMzQlO1xcbn1cXG5cXG5hLmJ1dHRvbiB7XFxuICAgIC8qd2lkdGg6IDEwMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xcbiAgICBmb250LXNpemU6IDJlbTtcXG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XFxuICAgIHBhZGRpbmc6IC4xZW0gMWVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/MzgwMzk3OWJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0lBQ0EsaUNBQUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxnQkFBQTtJQUNBLGdCQUFBO0lBQ0EsZUFBQTtJQUNBLHFCQUFBO0lBQ0Esb0VBQUE7SUFDQSxrQkFBQTtJQUNBLG1CQUFBO0NBQ0FcIixcImZpbGVcIjpcIkJldE11bHRpcGxlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOmAieaLqeS4i+azqOmDqOWIhlxcbiAgICBkaXYubXVsdGlwbGVcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEub25lXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMVhcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEuZml2ZVxcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDVYXFxuICAgICAgICBkaXYuYmV0LWJ1dHRvbi1hcmVhLnRlblxcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDEwWFxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge31cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLm11bHRpcGxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuNik7XFxuICAgIGhlaWdodDogMTIlO1xcbn1cXG5cXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi50ZW4ge1xcbiAgICB3aWR0aDogMzQlO1xcbn1cXG5cXG5hLmJ1dHRvbiB7XFxuICAgIC8qd2lkdGg6IDEwMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xcbiAgICBmb250LXNpemU6IDJlbTtcXG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XFxuICAgIHBhZGRpbmc6IC4xZW0gMWVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g6YCJ5oup5LiL5rOo6YOo5YiGXG4gICAgZGl2Lm11bHRpcGxlXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEub25lXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDFYXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEuZml2ZVxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiA1WFxuICAgICAgICBkaXYuYmV0LWJ1dHRvbi1hcmVhLnRlblxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiAxMFhcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuLm11bHRpcGxlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcbiAgICBoZWlnaHQ6IDEyJTtcbn1cblxuZGl2LmJldC1idXR0b24tYXJlYSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbmRpdi50ZW4ge1xuICAgIHdpZHRoOiAzNCU7XG59XG5cbmEuYnV0dG9uIHtcbiAgICAvKndpZHRoOiAxMDAlOyovXG4gICAgLypoZWlnaHQ6IDUwJTsqL1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIC8qYmFja2dyb3VuZDogI0NDQzsqL1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDMxNWRlZywgI2ZlYWUzZCwgI2VmOGIxMSk7XG4gICAgcGFkZGluZzogLjFlbSAxZW07XG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEJldE11bHRpcGxlLnZ1ZT8zODAzOTc5YlxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtdWx0aXBsZVxcXCI+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIG9uZVxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+MVg8L2E+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIGZpdmVcXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLWNlbGxcXFwiPjxhIGNsYXNzPVxcXCJidXR0b25cXFwiPjVYPC9hPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImJldC1idXR0b24tYXJlYSB0ZW5cXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLWNlbGxcXFwiPjxhIGNsYXNzPVxcXCJidXR0b25cXFwiPjEwWDwvYT48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWVzc2FnZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcTWVzc2FnZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtMzNmZGI4MDcvTWVzc2FnZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuZGl2Lm1vZGVsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmdcIikgKyBcIik7XFxuICAgIHRvcDogMDtcXG4gICAgLypwYWRkaW5nOiAxMCUgNy41JTsqL1xcbn1cXG5cXG4ubWVzc2FnZS10cmFuc2l0aW9uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG59XFxuXFxuLm1lc3NhZ2UtZW50ZXIsXFxuLm1lc3NhZ2UtbGVhdmUge1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYudGl0bGUge1xcbiAgICBoZWlnaHQ6IDIwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbn1cXG5cXG5kaXYuY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi5jb250ZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjYpOyovXFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZT81ZDIzZDA1NlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0ZBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLGFBQUE7SUFDQSxtQ0FBQTtJQUNBLDBDQUFBO0lBQ0EsT0FBQTtJQUNBLHNCQUFBO0NBQ0E7O0FBRUE7SUFDQSxpQ0FBQTtJQUFBLHlCQUFBO0NBQ0E7O0FBRUE7O0lBRUEsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLHNCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxrQ0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJNZXNzYWdlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgZGl2Lm1vZGVsKHYtc2hvdz0nZGlhbG9nU2hvdycsdHJhbnNpdGlvbj1cXFwibWVzc2FnZVxcXCIpXFxuICAgICAgICBkaXYuZGlhbG9nKHYtYmluZDpzdHlsZT1cXFwiZGlhbG9nXFxcIilcXG4gICAgICAgICAgICBkaXYuY2xvc2Uodi1iaW5kOnN0eWxlPVxcXCJjbG9zZVxcXCIsQHRvdWNoZW5kPVxcXCJkaWFsb2dTaG93ID0gZmFsc2VcXFwiKVxcbiAgICAgICAgICAgIGRpdi5jb250ZW50KHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxuICAgICAgICAgICAgZGl2KHYtYmluZDppcz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVxcXCIsdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiKVxcbiAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVxcXCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS5iYWNrZ3JvdW5kXFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBkaWFsb2dTaG93OiBmYWxzZSxcXG4gICAgICAgICAgICBjdXJyZW50SW5kZXg6IDAsXFxuICAgICAgICAgICAgZGlhbG9nSW1nOiBbe1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmV0SW5mbycsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+aKleazqOiusOW9lS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvbnVzUmVjb3JkJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAncnVsZUludHJvZHVjZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWNoYXJnZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH1dXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBkaWFsb2coKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDU1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNzYwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNDAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0NSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY29udGVudCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNsb3NlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0MiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDg0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3VybCgnICsgdGhpcy5kaWFsb2dJbWdbdGhpcy5jdXJyZW50SW5kZXhdLmNsb3NlICsgJykgNTAlIDUwJSAvIGNvbnRhaW4gbm8tcmVwZWF0J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgZXZlbnRzOiB7XFxuICAgICAgICBzaG93TWVzc2FnZShldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nU2hvdyA9IHRydWVcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGV2ZW50XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgIGJldEluZm86IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZScpLFxcbiAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUnKSxcXG4gICAgICAgIGV4Y2hhbmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlJyksXFxuICAgICAgICBSZWNoYXJnZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZScpLFxcbiAgICAgICAgcnVsZUludHJvZHVjZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlJylcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuZGl2Lm1vZGVsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmcpO1xcbiAgICB0b3A6IDA7XFxuICAgIC8qcGFkZGluZzogMTAlIDcuNSU7Ki9cXG59XFxuXFxuLm1lc3NhZ2UtdHJhbnNpdGlvbiB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG59XFxuXFxuLm1lc3NhZ2UtZW50ZXIsXFxuLm1lc3NhZ2UtbGVhdmUge1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYudGl0bGUge1xcbiAgICBoZWlnaHQ6IDIwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbn1cXG5cXG5kaXYuY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbmRpdi5jb250ZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjYpOyovXFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRk1UWkVRek13UkROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGTVRaRVF6TXdSVE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1V4TmtSRE16QkNNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rVXhOa1JETXpCRE0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K1gyeW1hd0FBQUE5SlJFRlVlTnBpWUdCZ21Ba1FZQUFBbmdDYW9NWExDd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgZGl2Lm1vZGVsKHYtc2hvdz0nZGlhbG9nU2hvdycsdHJhbnNpdGlvbj1cIm1lc3NhZ2VcIilcbiAgICAgICAgZGl2LmRpYWxvZyh2LWJpbmQ6c3R5bGU9XCJkaWFsb2dcIilcbiAgICAgICAgICAgIGRpdi5jbG9zZSh2LWJpbmQ6c3R5bGU9XCJjbG9zZVwiLEB0b3VjaGVuZD1cImRpYWxvZ1Nob3cgPSBmYWxzZVwiKVxuICAgICAgICAgICAgZGl2LmNvbnRlbnQodi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxuICAgICAgICAgICAgZGl2KHYtYmluZDppcz1cImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLnR5cGVcIix2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIix2LWJpbmQ6dXNlcmluZm89XCJ1c2VyaW5mb1wiKVxuICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS5iYWNrZ3JvdW5kXCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWFsb2dTaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcbiAgICAgICAgICAgIGRpYWxvZ0ltZzogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmV0SW5mbycsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9udXNSZWNvcmQnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5byA5aWW6K6w5b2VL+W8gOWlluiusOW9lS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3J1bGVJbnRyb2R1Y2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdleGNoYW5nZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVjaGFyZ2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBkaWFsb2coKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA1NTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNzYwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE0MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDQ1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDg0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndXJsKCcgKyB0aGlzLmRpYWxvZ0ltZ1t0aGlzLmN1cnJlbnRJbmRleF0uY2xvc2UgKyAnKSA1MCUgNTAlIC8gY29udGFpbiBuby1yZXBlYXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBzaG93TWVzc2FnZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaWFsb2dTaG93ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBldmVudFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIGJldEluZm86IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZScpLFxuICAgICAgICBib251c1JlY29yZDogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZScpLFxuICAgICAgICBleGNoYW5nZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZScpLFxuICAgICAgICBSZWNoYXJnZTogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZScpLFxuICAgICAgICBydWxlSW50cm9kdWNlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWUnKVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuZGl2Lm1vZGVsIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHotaW5kZXg6IDk5OTtcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMTIsMjYsNTUsLjM1KTsqL1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+aal+iJsuaMoeadvy5wbmcpO1xuICAgIHRvcDogMDtcbiAgICAvKnBhZGRpbmc6IDEwJSA3LjUlOyovXG59XG5cbi5tZXNzYWdlLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcbn1cblxuLm1lc3NhZ2UtZW50ZXIsXG4ubWVzc2FnZS1sZWF2ZSB7XG4gICAgb3BhY2l0eTogMDtcbn1cblxuZGl2LnRpdGxlIHtcbiAgICBoZWlnaHQ6IDIwJTtcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXG59XG5cbmRpdi5jbG9zZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG5kaXYuY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBNZXNzYWdlLnZ1ZT81ZDIzZDA1NlxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWlZQUFBTDRDQVlBQUFCUCtqd1pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dNRFZETkRZME1qTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd01EVkRORFkwTXpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBd05VTTBOalF3TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakF3TlVNME5qUXhNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtJaTJOK1FBQUdMTkpSRUZVZU5yczNRdHNYZlY5d1BHL24zSHNCRmdTVmxoNGRVQlIyTUxRSUJWVWlCWmFKbEpWdEJzcUt4cTA2Nm9LV0I5YXAwMmFxZ2wxNjRRMlRZTkpCUW4yVkVjN3VqS21sVEhveWxaYVZBMVVZQ3BoRFFYS0tJOE1LQ1JRSER2MnRYMjk4N3ZZMmZHNTV6Nzh1T1lHZno3U1g1QnpyNitkWTBmbjYzUCs1Mzk3Wm5mZG1aYWdOeHM3c25GZU5zN014dHV5c1RVYkk5bFlsd0NBdFdJeUcyUFoySk9OeDdQeFlEYnV5Y1lEMmFnMi9LanRPMHMzOXkveWt4K1RqVTlrNDlleWNhenZCUUNzZWV2bXhxYklqV3hjUExmOTJXeDhPUnMzWk9PNWRsK3N0ODNuYlo1NzRTZXo4WHVpQkFCbzRkaTVabmh5cmlFMnIxU1lYSktOSDJUak43TXhhRDhEQUlzd09OY1EwUksvMnVySi9TMGUrMEkycml4N3NQcVQxMUpsOXhOcGVzL3phZWJsZmFrNnVqK2xxZWswT3ozdFd3QUFhMFJQZjVZTEEvMnBkK09HMUxkbFUrcmZlblFhUFBYazFIdjRZY1duYnNuR1Y3THhybXg4S2h1bHdkRFRZUExyY0RiK0lSdnZLejR3dmVlRlZObTFPMDA4OEQzZkRRQ2cxTkNPMDlQZ2FhZG1vWEpVMmNOM3BEaDdzbjNuZUR0aEVtZEtic3ZHUmNVSHh1KytOMDNjOTZDOURRQzBGeWhubjVtR0x6aTM3S0hiVTB5VTNiNXp1aGdoUmRjWG8yVDZtVDFwN092M3BKa1hmbXdQQXdCdGl4TWFVMDg5blVZdVBELzFIN2MxLzlCRmM4MnhZTXBJY2ZKclRFcTVJcjloNnNrZnBkRmIvbG1VQUFCTE12UENTN1dXaUtZb3VDSTljdGVsamNKazgxeTVIRFQ5OUhOcC8yMTNwdG5KU1hzVkFGaXlhSWxvaW1pTGd1dXpPRG15TEV6K0tMMCtZL2Fnc1grN0o4MU9UTmliQU1EeTR5UnJpcGdhVWhBTHMzMitHQ2JIWmVOaitXZkZSTmM0OVFJQXNGSm1YbndwalgvajI4WE52NUVldWV1NGZKaGNsWTJCK1VkamJSSjMzd0FBblRCeC8wTzExc2dabUd1UldwakV1Q3ovNk9URHUrMDFBS0JqU2xyanN2VElYYjN6N3hKOHpQelc2cXV2cGNrSEg3YkhBSURPaFVuV0d0RWNPZEVpT3lKTXpzOXZyVHo2aEwwRkFIUmNTWE9jRjJGeVJuNUw0Wm9QQUVCSGxEVEhtUkVtcCtTM3hCdnlBUUIwV2tsem5CSmhjblIrUzNYL21EMEZBSFJjU1hNY0hXR3lNYjlsZHJKaVR3RUFIVmZTSEJzalRBWVhiSnFac2FjQWdNNnJiNDdCWG5zRkFPZ1d3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQW5kWnZGMENILzVGdFB5T3R2L1NqQi84ODg4eFRhZnpHUDZ2OWY4OFJtMVAvcWFjdCtiVm45anlicWsvL3NPN3o5V3c4N09DZlowZGZTOU9QUE5UK2J5dkhuNVQ2dGg2N1lOdjA3bDFwOXRXOWkvNjdsamx3eTkvV3ZwNTF2M0paR2p6enJHWHYzL25YbTdkU3I5dlcvczk5THdGaEFvZUVpSVNCazA4cC93ZVlSY25HejN4MnlhODlmdnR0YWVMbWhXRVNZWkQvZkxNSERxUlhQbnhSeS9pWU4zald1V25kMmVmVWZaNlpKeDhyZlg0K1dwcjlYZWROekVWVHo4aUdsczl0eDBRdXdsYnlkUUZoQW04SzhSdDdIQnpuOVIzNWxnV1A5MjNla29ZdXZ6SUxpaHM3OHZtbkh2M3ZCUWZtbnZYcmF5R1NQN015ZU81NzB2QkZGN2Y5bXMyZU8zcmROV25xUCsveGpRZUVDWFNqdUl6UTdEZjIzazJiYXdmNlRvVko5Y1huNi8raG4vSnpxVks0NVBObUZXZDI0Z3hQSnd5ZDg2N2E5dzhRSnJCbVRPOTVOczJPajVmL2d6M211Tm9aa0tZZi85ajM2ei91WjA5S2xkV0lndXhyYnhVRjhaeWxCa1E3WVJCbmJ6cDFCbWRnMjg4TEV4QW1zTFljK09yTkRRK3NHNis1dnVYOGliaGtFL05LOGdFejlPNExVOC93aHRTNzVjamFueWZ1dUsxaEZNVEJ0L2c1SnUvN1RwcDU2Y1dtb1RIL3VZdHpYbFl5SU5vSmc0RjNuSmY2VHV6TUhKTzREQWNJRXppa3hKMGFlVDNEdzZtL01ORzBVNWNhNWswLzkweGRYT1FudEk0Mmk0TExyNno3Mk1yOTl4NHk4MGdpU2hZemZ3WVFKdkNtVnJ4OU5INkRMOTU1MDZuNUpmT0tFMkFCaEFuUVVOeVZVN24zM3p2MitwUC9jbXZwSlpsT2E3WXVTOW1hSzUwUSs3WFJyYzNMdGY2U3krdk9mZ0hDQkE1NWNhbGhKUTZlL2NlL3RlNVc0QkRyaW94KzlwUExYc0J0MFY5UGszVlp5dFpjV2F6WjhiR1d6NGw5MGFrQUducWZTMFFnVE9BUTEzdlUxb1lIdWJJekdyRlNhN3NHZitFWDAvVFQ3emw0d0k5SUdibml0eFk4Snk3cmRQclMwVklzSlpwNmhrZGE3KzhtaThjdCsyc2VIcTc3YzZ4MnU1aVZkUUZoQW0rb2dWTzNMK3I1elE1eXJjNFl4Sm1DNGkzRmNmRHN4akJaN3FxM0RXTnRrWXZITGV2dmtBVlFyTFE3S2t4ZzVYNlpzd3VnZy8vQXN0L2U0NnhHVVZ6V3FMNzhVdDMycVNlYVg5NlorTnBYVTNWZjgvZXNtWHI4MGJxRFozd2RxeUhPOXNUZllUcDNDM0duemF6aTV3SldJZmp0QXVpYytPMjlOREJ1dnJGMnQwNStiWkRac2YycDhzMjdtcjVlbkUxNTlZb1BMWGlqdnVLQmVmcnBwK3BpS0w2Ty9QeU9abSsyVjdaV1IwejZiRFMvSXY4bWV2SGZPSHRRZGlkU0owU2tWZGZJaXJZZ1RJRGxoOGtaYjIvNFdObDZHeU9YZm1UUm55UGVxeVovY0o3KzNnTXBGVjUzL1FYdnJkMmxjekNNN3JodFVYZnNOTHNUcGZnbWVzc1JDOFBGR2l4dFBYZDhySFlHcVN6NkZuUHBhdE90ZHkvNGM1enhpWW5EZ0RDQk41VzRmUEpHM0ZvYVp5MktLNy9HLytkRFpLSkw5MWxFeVhLaklDYlZidnpjbjlidCsvMS9lWDJxZk9OcnkzcnRlSVBHZUMra3ZNcUQ5NmZKZi9xU0gzZ1FKdERkR2wzR1dRMHh6NlJzYnN0YUVMZEs3Ny91bW5UNDU2OWRFR2NiUHA0Rno4Zi9QM3BhdlN0eVdZUVV6ekxGWEpwV2w5OEFZUUpkSWQ1d2JsVU94Q1czRjhjbGpvRzNiV3Y0aG4vVHUzZlZEc3lsUVhYV3VRdVdydzh4V2JmUnVpdnhXdDBtTG0zdHYvRzZaYzF6NlJuWjBQSnkxL2hmMzFBTElVQ1lRRmVMeVordDNtd3U1a0hFS3FWbGEyN0V3VDUvd0l2ZjNzdm1uNHpkOHNYUzI0dGoyeXNmdnFqMmRUUTZxOURvYkVIWkcrQkZsQndxNzVVekw3N2VzYU8ycHVFUFhOTHlIWm1YSW1MTitpVWdUS0RydGZNT3dBY0Q0U2V2cFBYWmIvWEYrUkJ4aVdEMGM3OWJDNGhtVWRKcWJrTWNuT1ByS2R1K0ZzVCtpVkcyNkZxck16M05scmFQczFTaUJJUUpISkxpTG85R29WSmJPajRMa09Ka3pmai8yRlo1Nkx1bGk0WEZiK3Z0VExpTTI0TEw1a1dzTlJFbHhUTkJjWnYxWWkvREZNOWtBY0lFRHIzZjJyOTFkOU16S00zaXBPeXVuc243dnRQMjdiRDlwKytvUDdqKzRQdHJhdi9IWFRvYnJ2ek1nc3M1RVl1dDltSEVUSEdPeXV2djkzT2pIMnJvSUN1L3dncUxCY2RpWW1tTVYzL25xclp1VVoyUGsxWm5NeUpLeHE3OWc3YS9sdnphSlFmRDVIL1cxb0prNnovMDYzVnpUTVp1K3ZPV0h4ZVh1NG9yOGNaNk1CRTZnRENCUTBiTVBhZ2QxTEt4bUZWSlc4Vko1ZUgvV2xTVXhBRzA3RXpOMUhlL3MyYStGM0VwYStqZEZ5N1lWbnM3Z0RhL0w3RVEzWUo5bWdWT2hBNGdUR0JONkR2MmhOUzNhVXZwWTNIN2J4eG8yelh3OW5QcW8ya0o4eXBXVTluN0J5MGxSdUp1cE1GZmVuOGEvdGduRnI3K3ZyMTFsMkppTWJwR0lpN2pMRlZlaEU2anU1MkFGZmlGd2k2QWxUZDArWlV0bnhOMzI4UmFHWG0xU3dVTmJtMk43WWRkL2NlMUEyWCtQWGFLdC9MR1hUaXhYSHVFVEYyWXpNMHZLUzdEM2twdHJrV0ROVUhhWGNJOXZ5eCtvK2ZIK2ltRGYzZjdvbTd2TFM2VUZ1OEIxR2hPejlnWGIzbzkyckt3bUo4TTIrcHpIYmp0eTNYcnVzVCtxSDdraXRvdDRmcytlSUVmZUJBbTBOM0s3cVFwaWxWRlc5MVdYSFpIVDluaVova0RjN1BYblBueGkyL1lQaWt1aTkvc2VaMFFRVGUvbjhyZXAyaGVSRjFlWFBhSmp5M3U5MWJyMUFCTDQxSU9yTExpaE1wR0lqaml6RUs4eDB1enl3M3RpdGRZcmVYVHkxYWpyWXVrVmJ4dE9TN2h4Sm1QdHI0L3V4K3AyeFlmdXhMZkE2QTFaMHhnRmNVRTFySjN4TTJMZVNDVDkzN3o0RG9sY1ZkUDlmbm4wdEQ3TDBrOXd5UDFFVEMyditYbmpkZk1MNS9lYmh5MVkrYVpwK28vM3lNUGxaNWxLSjZKbVBpUHI2ZDE3M2puaXA0bGFlZXlVbHoraXZBcjIxNjIrRng4cmE5KytxT3AvOVRUL0JCRGgvWE03cnB6TnI5aDN4OWVhNjhBQUt0aTA5Vy92ZURQTHVVQUFGMURtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQXJKRCtidjhDWjdPeHJ6SlZHNk5UTTZsU3JkYTJBUUN0OWZYMHBNSGVualRTMzVjMkRRN1VSbzh3V1pxSWthZkhKOUxFVE5WUEZnQXN3Y3pzYkRvd0U2T2FYcDZjU2tOOXZlbjQ0YUZhb0hTanJyeVVFMmRFSWtnZUd4MFhKUUN3Z3VLNEdzZlhPTTUyNHhXSXJneVRaN0tkOWI4SEp2MzBBRUNIeEhFMmpyZkNwSVc5bFNsUkFnQ3JGQ2R4M0JVbURjUXBwUitOVGZoSkFZQlZFc2ZkYnJxazAxVmhzbmR5cW5iWERRQ3dPdUs0RzVOaWhVbUpmVjEyT2drQTFvSlhLc0trMVA3cEdUOGRBTENHajc5ZEZTWlRzeTdqQU1CcTY2WnBGRjBWSmxWTHVnTEFxalA1RlFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRmlGd0FBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbWRnRUFJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoWWhjQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDcEF2MDlmVDRqZ0RBS3V1bW8yOVhoY2xBcnpBQmdOVTIyTnM5T2RCVllUTFMxK2VuQXdCVzJZYis3am4rZGxXWWJCb2M4Tk1CQUt2c3A3cm8rTnRWWWJKNTNVQlhuVTRDZ0RlN09PNXVGaWJsWW9iSkNTTkRma29BWUpYRWNiZWJwbmgyM2VtSnFMYWZXYi9PVHdvQWRGZ2NiemQzMlRTS3JyeHVjdHp3VURwcWFOQlBEQUIwU0J4bjQzamJiZnE3Y1dmRkdhVzNqcXhQaHczMHAyZkdKOUxFVE5WUEVBQ3NnS0crM2xxUWJPN1NHMDc2dTNubnhVNkxPM1gyVGs2bGZaV3B0SDk2SmxXcTFUVHI1d29BMnY1bFB5YTR4aTNCY1V5TkcwMjZlZFd3L2tOaGgyN0pkbUlNQU9ETnpiMjVBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFvRDVNS2d1MjlQWFpLd0JBNTlVM1J5WENaRFMvcFdmZG9CMEZBSFJjU1hPTVJwZzhuOS9TdTJIRW5nSUFPcTZrT1o2UE1Ia3N2NlZ2eXlaN0NnRG91SkxtZUN6QzVLSDhsdjZ0UjlsVEFFREg5Vzg5dXJqcHdRaVRlL0piQnJlOXpaNENBRHB1Y052SnhVMzNSSmg4Tnh2UHpXL3BQZUt3TkxUamRIc0xBT2lZYUkxb2pweG9rUWNpVEtyWitOS0Nnam50VkhzTUFPaVlrdGI0VXRxK3N6cS93Tm9OS2JlZVNjd3pHVHI3VEhzTkFGaHgwUmlGT2EyVnVSWTV1UEpybkQ3NXEvd3poaTg0Ti9XOTVVaDdEd0JZTVgwL3ZhWFdHQVYvazdidmZDNGZKdUhxYk96TlAydmt3dk5TejlDUXZRZ0FMRnMweGNqTzg0dWJvejErZi80UHZZVUhQcGwvWnYveHg2UU5GNzgzOVF3TzJKc0F3TktqWk4xZ3JTbWlMUW8rbmJidjNGc1dKdUVyMmJncHYySGd4QlBTeGt0LzJXVWRBR0JKb2lFMmZ1Z0R0YVlvK0lzc1N2NStRY0RNN3JxeitLUll1UDdXYkZ4VWZHRDg3bStuaWZzZXNvY0JnTFlNblgxR0dyN2duV1VQM1o2TkQyWmhVbWtWSm1FNEcvK1lqWjNGQjZiM3ZKQXF1M2FuaVFlK1oyOERBT1ZCc3VQMDJpM0JEVmFVLzlkc1hKSkZ5WGp4Z1VaaEVtSml5UmV5Y1VYWmc5VlhmNUlxai80d0M1WG4wOHpMKzFKMWRIK2FuY3lpcDFyMTNRQ0F0YUszdHpaL3BIZmpodHA3MzhReTg0UGJUa3E5Unh6ZTZDTml5c2luc2lpWktudXd2OG1uaWcrNE1odmZtZ3VVTFF1K2p1d1R4dWtaQUlBMnZKeGlvbXRLdHpUdG5EWmVLQ2JFYnN2R2pTbTNDQnNBUUJzcWN3MnhyVldVdEJzbTg1VnpWVFpPek1hZlpHT1AvUXdBTkxGbnJobE9uR3VJbDl2NW9HWnpURm9Gelk1c3hDb3BjVDBuM3BJNGJremVrRjZmbXdJQXJBMHg5V04vZW4wVitjZXpFYmZ2ZmpNYkQ2VFgzNCt2M1BhZHBadi9UNEFCQU1GblkrM0Z0MXFJQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/mipXms6jorrDlvZUucG5nXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG93TkVKR09UTXhSRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dORUpHT1RNeFJUTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQXdOVU0wTmpRME0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pBMFFrWTVNekZETTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTWZ0aG5BQUFCbEpKUkVGVWVOckVtVmxzVkdVVXg4OTM3OHlkbVU1bm9LVXQzVWpwZ3RvQXJZWkFVR01VeEFlTW9ManlJZzg4NFBMZzh1cUxUMFo5MGNSRTNHSkl3QVNDUkEySU1aSGx4YmdBQm1sa0d6cWxoZEtPTGRCMnByUGMzWE5tdnFsVE9uUG4zcGxwK1pML0xIZnVkNy9mUFhPK2M3N3pYZmJKcW5Zb28wbW9CMUViVUQyb2UxQk5xR3IrK3pScUZCVkM5YUZPb241SEtka0xuSWdQT3hyUVZTTG9BNmhYVWMramFpM09xK1ZhaWRxR2VoYzFnZm9XOVRucXJOT0JCWWZuOTZLT292NUM3U29DVzZqVjhMNTBqWjgyK2x0NzV3UFlpL29JZFFiMUpJcEIrWTJ1c1ptdWlkQWZvN3lWQXU1Qy9ZRjZ1d3dYS3VhV2I5RVlDTjFWRnJBSjVqbytTWHBoL2h1TjhlY0dmOHY2a29BUmRqMERkZ0kvMXNIQ3RWb2M4NWdWZEY1Z0E4d1YyUEVJZnZURHdqYy9qZjJZdjJXRkxXRFoxSDNZNGRBQ1cvYk9Wa2NNRDFjMStZckdZVGNUUG1TWkpERDMvMnBZQ284L3N4M3FtMXFnLy93NU9IbjRFS2lLN0N6VGVMMndZZXNMMEg3dlNyZ1pHWUhqUHh5QWlmR3hmQ0drQjFrK3dJOXY1aDRYTnpmVXpIeFJUV09OaXdsZjVMUDhrcVZOOE96TzE2R21yZ0VFUVlDNnhtWm9YdDRKL2YrY0EwUFhiY00rdmVNVmFGdHhINGlpQ0lGRmk2RnJaUzhNaGk1QUtoSFBBODNXdExxcmoxNVRZNk56WEFKVEpCTVplNzlRNk5xMGJUdjQvTld6ampXM3RjUFdIYnZBTFhsc3d6WXVhNXQxdktvNmdQL2FTd1ZESG1kaWM0RFJYOVlKd0RZVlRFLzFEWG1QWjZFbGo4Y3g3SXlyMVRkYWhESDJCTEhOQWs1YkY5Z2JWaGxzS0hTcDRFVUplc3ZMK2FHTHdWSzdldm04WlViTVpVc0R0MHZCZ01pRUxWYTlhSEtNREYxMUJHMEg5c1pnT0QxNXJScXhFZU1NY0lQb2V3VHhBMWFkRkZtR0kvdSt0QTF0Ri9idzNxOUFVNVZpaTQ0QU1hYmhQZjY0c0Z3S3ZvYlJZWDJ4aWFOak5BaGpPR3R1NjRUQTRwcTg1OUJ4K3IzNy9yVVZnZjAvODhMWWRYWDZGN0t3R3gyN3gyNGN0V3ZwU3NMeXlkZVRZUVh3Q0l3NUtqdnNRRmNTTmcyY1lmUVFzSVF2UzV3T1hBcDBxYkI4c2kzaHJKUW9XRlVwQ2Q4SmREbXdmT29SbzR1QXhmTHFCcFpPMWNWUEUvQzhzZ3NWa1VaaXVQWk5sbFF5MndoZGRwS0x2U2lSWm1ScDB4aW1PVFdmc0pXQXpqSVNzS21DTVRMZnNPVkNjMGFUZ0hYRk1NS1ZoS1VKNWpTTkY1M2dHVWFkZ0xVcFF6NVRTVmlLQms3U3VKMkdqTFNQb1JHd01xeE9uekdLVER5bmF3T25hdzlML3dVemhXbVpqS29Rc0p3eTlkdHhRenR0MVduajFoY2RwMXU3MEk4Kzlad2xNTEtkd2xyekZyRUthWDhHaUk1cThSK3RPblYwcnlvcEtkaUI3dWhlYlFrY3liQkZpVlhZNkc4MWFKY1IzZUowMHRBdUZ1bzBIcmxSY2dZckJrM0ZhS0ZHVE9nT3AvbE9xSkZOVVZRQmpnMnBzVzlNY3BsOEMvanZEMEJpT2xaeXVpMEVIWTlGNGRoMyt3c3RLUTFrMmtkc25ERlROVjlWb3dUSllvYXExNHFlVnEvZ21yTjZTOGJqV0NaZFRKZjRrdVNGOElVKytQbmdQa2RyZyt4NmVsRk5IVlFIRjhINDZEQWMzYjhIcG03ZHpCOFpkUGxrU0prOFNGVVVLbTB0bHQzUXhycU9kZzg3SkNhdVhlZHJlQS9mVys3aVJnb29wajV5S2puMkRyNlRPd3lnVW5mdS9OQ09TQVJQR0xnb1Qreld3WXpmTFZnYUd4aytKUlppNG15enkzeWNmQ1kzKytBdFBmWDNGWG55TTF4d0tBc05TMlBTMk1SQUxKekp6THZ6ZzVXcGdmNU1ZYzVBZjVZVjA0alV1cnk5REpoN0lXQXhRU1JDOHVUdUVTMytHMzY5REpubkk3TGwzaHIzRllwaGJ1d29ZTUJPZEh0cWRxSlBOOCszejZJYjdPR1dEWEdHMUp3RmNhNkZ1WldCVzVsU3RaWTBOWFZVUzV3UENwSWZvOGN5VnBuSEJiTkMxNlF1LzNvMk5mNzF0S0ZlNHBZZDRtSE1MQXA4QjNTQzdoTC9Lak9pSlFZU3B0cGZMVWkxYmlaVVpDczJZV2lYUXNyRTNyQXlkUnpIR09TdzF3dkJGbktKbVVtSW9ZNDZYdVBnc1RFdEdVY05MSFZWZGJXNC9BOEZSV20xNExBZXBFVldWRmY2YnFDZi9xc2wraUh6R0d5WVQ3Q2IzQTNNZ3J1RGxndWVUT1JJSW5pRTN6VXRRRnB3b0NuVUZaRXhmNlBMMzRuSnB0UEhYRTBlSnRianNTQk9VaWs3NDNYVGpPSThHRWZYR3IydHkyRmNGNFR4V0p5dkRjYTRyMFo0TkZDTDFvWjJuNFRTaGlIdEM2Q0NmSGUrSGpLbE4rM0JVdEp4YzRrNW00cG1PcXhtUUZSdXZXbCs0K1Bjb2xFZUNVdzdIQzRIajA1TlBpQmRmSXFIbkFDL2dRQUg5K1ZBUXc1c2tvUEdPR0NNdTVsaUY5U1dTMWlBeXpuZ2JtNTVpVjh2bjRVMURpZnpHekJLbmFqL0NUQUF3ZFEvSVBoQ2FoOEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWlZQUFBTDRDQVlBQUFCUCtqd1pBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeU5UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE15TmpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBMFFrWTVNekl6TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16STBNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNOFpLM2dBQUYreEpSRUZVZU5yczNXMXNYZmRkd1BHLzdkaHhZaWVPNHp3M2JacDJUUisyMGFwTml4Z3dtbW9JbFk1cUV0QkZyQUtKYVhRZGRDLzZBbmdCVEJXOFlMem9tMnF3ZHNDRVZOUlFpaERWcWdpQlNEZWdFMzFZMjYzclU3WTJhWk00YVp3SHgzbHc3Q1RtL0c1eTArdmpjKzFyKzE3bnB2bDhwUDhMbjN2dE9DZFhPdCtjOHovLzAvTEVPMk5wQmxxemNXczJObVZqWXpZMlpPT3liSFJsWTM0Q0FDNFZKN054TEJ1N3MvRjJObDdNeHJac3ZKQ05NOVcrYWZQNjR1MHQwd3lUdGRuNC9XeDhJUnVYKzdjQUFLcDRQeHYvbUkxdlpHTlhyV0hTV3VNUDd6djNnMythalQ4V0pRREFGQzQvMXd3L1BkY1FmYlY4VXkxaGNrODIzc3pHVjdMUllUOERBTlBRY2E0aG9pVStQOVdiNTAzeDJpUForSExSaTBlR1I5UDJmVWRTLytEeGRQRFlTRHA2Y2pTZE9uMG1uVG96NXA4QUFDNFI4MXBiMHJ5MjF0UTl2ejB0N2VwSXEzc1dwbXRXTGs2TE85dnpiMTJXalMzWnVEMGJEMlRqVk5IUHF6YkhaR0UyL2lrYm44Mi9zSGZ3UkhxOS8zQjY1ZjJEL2pVQWdFSTNYYjQwM2JCNlNWclZzNkRvNWU5azQvT2IxNmZqdFlSSm5DbjVsMnpjblgvaGUyL3ZTeS91SExDM0FZQ2FiRnkzTEgxNnc4cWlsNTdPeHE5bmNYSnFxakQ1WmpidXE5eXcrOUR4dE8ydC92VEIwTEE5REFCTXkvSkZuZW1PYTFlbnkzb1g1bDk2TkF1VEwwOFdKakVwWlV2bGhoMEhqcVpuZnJncm5UeDEycDRGQUdaay9yeTJkTmZQckUxWDluWG5YL3F0TEU2ZUtBcVR1STBuWnN3dUsyL1lkZWg0ZXZyVjk5THdxQ2dCQUdhbnM3MHQzWDNqRldudCtETW5NV24xdWl4TzlzY1hsYmNMLzBWbGxJUzRmQ05LQUlCNmlLYlk5bVovZnZQU2JQeDUrWXR5bUZ5UmpTOVd2aXNtdXU0M3B3UUFxS1A5UjRmVGQ5L2VtOS84dTF2ZUxiWEkrVEM1UHh2bmJ6anVIenpoN2hzQW9DRmUybm1nMUJvVjJzKzFTQ2xNWXR4YitlcnJldzdiYXdCQXd4UzB4cjFiM2sydDVhY0VyeTF2UFhKaU5MMjZ5K0pwQUVEalJHdEVjMVNJRnJrMXd1U095cTNiUHpoaWJ3RUFEVmZRSEpzaVRHNnAzQkxQdmdFQWFMU0M1dGdZWVhKdDVaWjRJQjhBUUtNVk5NZTFFU2FySzdjY096bHFUd0VBRFZmUUhLc2pUQlpWYmhrNWZjYWVBZ0FhcnFBNUZrV1lkRlJ1T1gxbXpKNENBQnF1b0RrNld1MFdBS0JaQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFOTm84dXdEcTY4R055K2YwejN0ai80bTBkZWZSY2R2dVhOYzk3dXZLMS9PLzM5YWZES1kzRG8rTSs5N3JseTg0Ly9XZUl5TnB5OXVETmYwdW4xcTVJTjMzc3lzbmZjK2ovN2N2UGJmdlJQclNKNWVtWDFpL2VOWi8vL0xQSzZ2WHo2M0ZPd1BENmFIbjl2clFnekNCNXJYNTVoVnordWR0K2NFSEU4Sms4NDNMMHZXcnVzNS92ZVBKN2VmakkvLzdSZGhVaGtuK2UrUG41ME1uci96bjkzUzJqZnZlSXZHZXNHaisxTyt0UmZubmxkWHI1d0xDQktpVGZVTWo0dzdPTjY1WU1DNCtxcmwrU2NlRWczb3RvYlgxc1IvYjZZQXdBWXJ0SFJvZDkvV2QxL1dtTllzNzBzTXY3aTk4LzljK3RTcGR0YXd6TGUvdXVPai83bkVHS003eU5NSm5OdlNtWmQzdFBtQWdUSURwSHB3cnhWbVFHTlhDSktLa0hwYy9kZ3lPVEJrRjhaNlpCa1F0WVJDWGxmS1h0dXJseGpWZHdnU0VDVnhjYmp0M1dlTWY3cjV5d3NIK2EvKytjMFlIelpqajhkQ3ZyQnNmSDN1UHBkOTVlc2VrQi85WkIwNzJaMVNLTXlyNUEvTjdCNGMvZlAvaGtmUkdsZmlwUjBEVUVnYjV5YnYxOUZFNG93VENCSmh6RVFqUHZIWWdiZHF3SkMzc2FKdnkvWEYzU2Q2cmU0Nk5POE95b3JNdFBibjVtZ252KzdzWDlqWFYzejJpWks0bklBUENCSmhDM01aYTY2MnNUNzUrTUYzWk0vNXN3T0R3NlhGZjMzL3o4Z21SOCt6MlF3MjdiQUlJRStBU2RlZkhlZ3JQTXBRdlBjWGxrYnMrMFRmdXRlTWpwOU8zWHg0WXR5M09xdHl5c3ZneVNseGVxdVhPb05rcXJjdVNtMk5UTDErOGRXVzZZbW1uRHd3SUUyQW04Z3VleGVXWjZmaTE2M3BMWWZMQXo2K1o4TnJUcngyWUVCb1JKZm01TUdVeDBiWFcrU2ZWSER0NWVzcjNsT2E1TkNpQVlvMFhRSmdBTS9TNUczckhUY0RkK3VhaHd2Y05aUWY4OGtUWHl2ZHZYTGM0L2RXbU5STW1uQTRjSFUyUHYzWndWci9iWkdkWHF1bWFQL1Y4bVZpTEpYOVpxbDY2Y3BleTR1dUl2OHFWWndGaEFsUTU4TisyN3NPbDJlUFNTeXd0LytEdGF5ZTg5MXMvT2xnYTRhbmZ1SHJjNVlyYnIrbWQ4UDUvL2RGQSttRDQ5S3grdjhuT3JzeEd0Y3RTalJEN0tjNUlQVmZsN2loQW1NQUZGODlxaVdYUmkyNHQzWFRWNGhuZHlycHEwY1JiWk9QbngzTnY4cy9LaWYvQjMzdlRzdExaaGNySnFzL3ZQRkwxNXhmZDJseE5uRmtwUjB4ZVRKaU4xK05Nd2x6TnhhalhyZEdBTUlHUHBIaUFYTFdEZk5IWmg1bUt5eXR4WmlEL3JKeDRkc3pHZFJNZll2ZUQzY2ZxOHVkdWVYV2c2bXR4U1NQT0hoU3R1OUlJY1VscExpYlVBc0lFcUtQeVpaelppclZSR25sN2NQeWVPdzhPMS9UZW1BajcrQ3NUSXluV1hubDRHcE5zbi8rOWo0LzdlcktGNndCaEFreFQrWEpLcGNxekhQblg0djFGQzZ6bC9jKzdSNnBld3FtWGlKTFpSa0hNcmZucnoxNDU0VkxTdzgvdW1uV2N4V1c2T0NNMjEvc0ZoQWx3MFNwZlRxbW04c0FmZDdERVpOR2hrZFBuYnlYT3oxbTUyTVNrM0QvOXovZlQzM3p1cW5GemJHTFNiK1hFMzZrZUQxQVVJZmxMZExFYy83OXRIL1NoQTJFQ3phdDg0TCtRejhxcFZkeFdtNytESlQ5bjVXSVU4MDYrdm0zWHJPYTV4QVRtcVNZRVAvemZlMlo5ZHhJZ1RPQWpiYllUVHlOVXBuTzdiWVRNdzdOY09LMFJJcTdXZnI4L2ZlR1dGVFU5TDJpNjR1OXQvUklRSmdBMUs2L1BVclRvMmt0VFJNVmtTOXZIdkJ4UkFzSUVZRVlpU3ZMcng4VDZKOU85REJNeDQ5SU5DQk9BR1l1N2RQNW8wOXB4bDNOaWZzNVVsNThpWnZLWHhKcjFzaFVJRTZCcHhkeUtyWS85ZU5MM3hCMG5YL3E1MVpPK0orNDQrY3AzZGx6MFp3anV2M241aERrbWYvbTlQVFh0eDgxWndGUk9nTDM3RTMybFp3UTVhd0tOMDJvWHdLVWxIc28zVlpTRVdBY2sxZ09KTXc0WHExaWUvNjRzSmlxVm5uSmM0MnF4K1ZWdUkzQWlkQUJoQWhlZFdKbTBtVVJneEMzTVJjdmlQN3Y5VU9tQWZhSGpaTi9RN0plWGp4aUpPNU0yYitoSkQvN2ltbkd2eFJMMitVc3hzZHBzTlhIV0pQWk5wUWlkK1BsQVk3aVVBM1ZXZm9qZmxYMExMc2lmWDE0MExlOHpHM3BMejljcGlwSS8zSGIyMHNaUUZsUDVzeW5sT0hucWh3TnBzQ0MyWWhKcExXY2c0akxJald2T1hoYXB0djVLUk5PejZ4WlA2L2JlL05vdzhiVGZhdXVQUFBLL1ovK2VFUmJseWJCVC9WbmZmbmxnUXN6RjNKTUhzc2lKL1huYkZKZk5BR0VDRjlSa0QvR2JDMFdMcGxVVHo3NTU2TG05NTc4dUw2MWVGQ2VWcTZaV0tsMGFxV0ZDYUFSQUxmdWxFV3VPbEFPc0hEQVJKZFgyVWY1TVYwUlhmRzgrVG9vaUQ1ZzlsM0pnRHNYWmhXYnhyZS8zajR1U3lqaUoxMlpqc0liSm9YTzVMK0lTVHB6NXFNWExleVkraFRtK2Q3SkxQa0Q5T0dNQ2N5VCsxMTNycE11aUEzMys0WHUxUEhndnIvejAzcTF2SHByMGdYWVJKM0ZaNTdjM3JwelJtWUZZZkt6b0xFUCtURVNjc2RtMFlVbGR6NUxVc2t4L0xKeFdOS2VtMm5PQzRuZTlaOHYyZE12S0JUN0kwR0F0VDd3ek5sYTU0ZUgvY0wwVVppTW1YL2JrSm92V09nK2pHY1hFMThrT3lCZnozdzI0OEI3ODVZK1ArOW9aRTZpemo5cFM1YkZteDhYK1VEL2c0bUdPQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQkFuY3hyOWw5d2JHd3NIVHQ4SUJzSDAvQ3hvWFJxZEtTMERRQ1lXbXRyVzVyWDBaSG1MK2hLWFV2NnNyRTB0YlMwQ0pPWmlCZ1oyTDBqalo0Yzlza0NnQms0YytaMEdoaytVUnBEaHdaUysvek8xSGZadXRTZFJVcFRobFJUL2xaalkrbkE3cDJwLzUwM1JRa0ExRkVjVi9lKzgxYnBPSnVhOEFwRVU0YkpnVDN2cFVQN2R2djBBRUNEeEhFMmpyZkNaQXBIRHg4UUpRQXdSM0VTeDExaFVrVk1haDE0LzEyZkZBQ1lJM0hjYmFhYlNwb3FUSTRlR2lqZGRRTUF6STA0N3NieFY1Z1VpTHR3QUlCTDkvamJWR0V5ZlB5b1R3Y0FYTUxIMzZZS2s5T2pvejRkQUREbng5L21tVWJSWkpOZnovaDBBTUNjSDM5TmZnVUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWjJBUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdGaUZ3QUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtZGdFQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1Mbnd2MHhibTM4UkFKaGpMUzB0d3FSSTI3d09udzRBbU92amIzdnpISCtiS2t6bUwxam8wd0VBYzZ4elliY3dLZEsxWktsUEJ3QmN3c2ZmcGdxVDd0NWxhVjY3eXprQU1GZml1TnZkMnlkTWlzVGttMlZyMS91VUFNQWNpZU51UzB2ejVFRFQzUzRjMWRhNzhqS2ZGQUJvc0RqZU50UFprcVlNazlDMzVvclVzM3kxVHd3QU5FalA4bFdsNDIyem1kZVVlNnVsSlMyL2ZIMWFzR2h4T3JCN1p4bzlPZXdUQkFCMTBENi9NL1ZkdGk1MUwrbHJ5dDl2WGpQdnZOaHBYVDFMMDlGREErblk0WVBwNVBHajZkVG9TQm9iRy9QSkFvQ2EvcS9mVXByZ09uOWhkK251bTdqUnBKa1dWTHVvd3FTOFF4Y3RYVjRhQU1CSG0yZmxBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFnSWxoTWxLNW9hMjF4VjRCQUJxdW9EbEdJa3lHS3JkMHREbUpBZ0EwWGtGekRNV1cvc290WGZQYjdTa0FvT0VLbXFNL3d1U3R5aTFMdXpyc0tRQ2c0UXFhNDYwSWs1Y3F0NnpxV1dCUEFRQU50N3BuWVg3VGl4RW0yeXEzYkZqUlkwOEJBQTEzellyRitVM2JJa3llejhhdThwYkZDOXJUVFpjdnRiY0FnSWFKMW9qbXFCQXQ4a0tFeVpsc1BGNzV5ZzJybDloakFFRERGTFRHNDV2WHB6UGwrM1Mra1NyV000bDVKaHZYTGJQWEFJQzZpOGJJeldrZE9kY2k1MWQramRNbmYxdjVqazl2V0ptV0wrcTA5d0NBdWxuVzNWbHFqSnkvMzd6KzdMU1N5cFZOL2l3YkJ5cmZ0ZW5hMWFtenZjMWVCQUJtTFpyaWp1dFc1VGRIZS94SitZdlczQXQvVVBuT3RiMEwwNjkrY20xcXR4b3NBREFMSGZOYVMwMnh0cmNyLzlKWE42Ly84TVJJeXhQdmpPWGY4TTFzM0ZlNVlkZWg0Mm5iVy8xcC85Q3dQUXNBVE12eTdzNjA2YnJWcFJNZU9ZOWxVVEt1T1lyQ0pKWmgrK2RzM0oxLzRidHY3MDB2N1R4Z0R3TUFOYmxsWFYvNnBRMnJpbDU2T2h1L21ZWEp5RlJoRWlKcG5zckduZmtYOWc2ZVNLLzNIMDZ2dkgvUTNnWUFDc1U2SlhGTGNKVVY1Wi9KeGoxWmxCelB2MUF0VEVLc2V2Skl5bDNXS1JzOE1aSis4c0ZRNmg4OG5nNGVHMGxIVDQ2bWtWTm4wcG14TWY4YUFIQ0phRzFwS2MwZjZaN2ZYbnIyVFN3ei83RVZpMUxQZ3FyUDNuczBHdzlrVVRKYTlPSmtZVksyK1Z5Z1dOZ0VBSmlwZ1d4OE5SdFBsT0ppZlpYUXFlRUhiY25HOWVuc3BOZ1IreFVBbUlhUmN3MXhmVGxLSmxQcmZjQlJPZmRuNCtwc2ZEMGJ1KzFuQUdBU3U4ODF3OVhuR21LZ2xtK3E1VkpPdGFDNU5SdDNaT09XYkd6SXh0cHNkS2V6YzFNQWdFdER6QlU1bXM2dUl2OTJObDdLeG45bDQ0VjA5bmw4aGFwZHl2bC9BUVlBVk9BS3lyV2ZjMkVBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lvIDlpZborrDlvZUucG5nXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG95UTBJMk9EWXpORE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3lRMEkyT0RZek5UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qSkRRalk0TmpNeU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pKRFFqWTROak16TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrSU1rTlBRQUFCb1pKUkVGVWVOckVtV3RzRkZVVXgrL003dXgySDkyeUxkdDNlVzFCRE5EU0dLQkE4SkdJMFlCR1UxR2o4UXNmZk1Rb212Z0lxTUZnRkUzOG91R2xpY0dvQWJVS2hrZU5BVnRpU2x0cEtaVUlsS1ZMQzRYdGExdTZiYmY3bkJuUG1iMGxXN3F6TzdPN0xTZjVaelozNTk3N216UDNubnZ2R2NiMjd1OGtCZE9CVm9NZUFwV0JGb0VLUUdiNi94aW9CK1FBblFmVmdScEJ3WWtHMWxadlV0V2hOa25RQ3RBcm9LZEIyWEh1eTZaYUFub0t0QjEwQzFRTjJnYzZwN1pqVnVYOTVhRGpvTE9nbHhMQXlwbVYxc1UyYWs1dnFpNVhVNWxST0NReVFKK0NYay9ocmNoWkdMUUx0QldHaHo4ZEhpNGxSR3lDNjF2VEFEc3hMTi9FUHNEYnBTa0JNd0svRWhxQ1NjS1VrMmszN0VQOHA2SHFwOHFrZ0FHMlVtVFpXdmcxbTh5WU1kblE1OGw0MERHQldTRzBFQ29laFFaTVpNYU5NV0hmalZVSEZpb0MxdmtHRFFLai9YVm1QVHNGZWpZeU5HL2NaMGdZaDhONnkrZUVZY3BpTlRQZmxraytmTHlDM0pPZlJXb3Z1c2pPbW4vSmVEQ3NDc1dzNThqV0RlVmszYUo4Y3FYUFF6NCtlbzUwdWNkaU1ETmx3UElaL05vaUc5YTR3T2g5SVgxbVU2d0hzZWRheU40WDF4Q3JVWCs3cksxN2tHdzUwS1FZR21HL2VtRTFXVlprdlYwMjVBMlFsNyt2ancwTi9nT21WU3VQYkc2ZE1pUWdCakk4bDdGVExuUnRmNkppRWl6YThwSWM4dVh6bGNTbzB5WUZLeTJGSmozNVlHT0ZiTWlqVE13VVlCZ3ZLd1dXZTFpdTV0d2NjOHh5SmRCeXNORkRUYzZBYVQyeVRRS1d2S3MxdmhIOUpIZGFRMGUvYktQeG9CUEJvdFU3ZXVQT3dHZzJqV250Y3pqQUxjTjVaVi9EVlM5WHE5SFpUeXJtNXBEOExHUE0vN0VjLy84TEptT0lGeFREdGw1emsvY1BueVZoUVpTOVIyUzE4NEJ0ZDliQWhZRGs0Y0dpVmV1Z0lEUGVZK0xFd2dtR0UwMkpwNVhDYmpuWVJQd2hQa0dVWXpJbFJ2VHdJNjdmMkJ2M1ZyM0tjNGJLUkJNSFBZY2VWT0xwRGVWejBnTTd3U3p5L1VXT1l5ZlF3NXlnNGNxVXhsR2xuazRuckRUNUlvd2NBdXNGalc2K211Q3ZCRHFkc0JGZ2lWR1B3RHFSMGVhbzdUZ1o2R1JocFlrWFlkUWhzRlprV0dNeUs3NGE2RlJnSThBU294YUJOYWxzVTFpR0lSbzI4VG1BWlJucDNoUk53MHBCUStSOXlkUldFcnFTV2NabG9nUXlNcEpyTkh6QU01Mnc2WUNlWUVSZ1VSdjB1cVliTmxWb3lpZ2lNTS81YnpuVENZc1RUT21LcU5Rb0k0L0FZWXY3Y2tzNllURWFxRm5HbFpobDBJRjVqREFDQndzNmFsb1lJZXhMRnl5R0xyVjdqL2luOTdDLzBIRWNuUnBFNElCK2ZIRElPTkxkSEsvU05qaldxRjF1bFVLLzkxajhuUUd3bllHekpqWWk3ZFpDb0pHOHpycGo4U285c0xnZ3FVVkJDZlNEY2RwR3krMDZoV3dqeU1xZTNsU05tOWV4Z280L21qUEcraTdKVlhMMGVwSmV3UkpCTy9ya295b3lGVjZwYWFhWlVHRmlpZktDK292YkQvOUlSRkdJVlhFSG5HN3h3SmpzY2lzSFBURHFKenVPeUNReGdhVzQvZEFQeUVZWkl5ZU9PUmNsTHpQbTRVNStKSGRwY2NCa203SjdHeDRQa3ROWCtzZ2lPT0liOVZwU2Q2bUhiRHZVb21wdk1MR2ZMcmFhaU0xaUlPMDlIdkpPOVJuU1BlU05lWCtXKzFMZGdyYjl2OERQVHREb3BHTStuT3N3UTdrZ21ERnJSZHY2THo0SlpXUVZrYnRvbk4valduN2k3VzA2L3pBT2g2c2cvNTJaSDN6ZnZYREQxWVV0ZS9hd2ZNQjd0MkN4YjJEWWpTeklSTmttSC9OaDhvblU3VjNXbnRhMkJXM2Y3V1VFUGpqalNTcm9FL3RHQm1TaFRHTE0zQnBBWTRoemc1eDVWMDgyMmx1LzJjWHl3ZkdaODJ4d0hQdkV2cEdCc29UaTV0Ym9XTG1Kd3lpdnM1YlYrWWJHTzFhOHRobkdkdUYwd3NMcmQ1VTI3OWx2N1QySG5uVlFoaWtaK1VoZUlzcTZsenlEVVFPZkNwZnFzR0dzTjVUWFZYZkJtMjAzK1kyNUpiQjdadEpLQ3FGcjFzQi85VXRQZmZTdHlYTzlIVW91ZzY3Uk1EWWxXU0g3alFPelFYREIvREJHQ3p1bzBGMnladkgxSmM5dThHVVdMazRIcTJIVTFUN253cy9IWjNjM0lLaUxEb09iY3JCeGdhT2dNZHhocm5nZXFCaGtkWmVzTGUwcGZYVE5tTlcrREk3ZlJuWGpOT1F6MzNLZXozZisyV0M3WHQ5QklwL0JidEFKNXFiRFFEWU5wT2dyRW9CemNNSE1VRDcxZUM3dStIaXR3ZFEvOTM2N0o2L003alBuRjRReVp0bWd6Q0t3V2wwa2t4OE9hc0srRWM0L1BBQkRxeWVyNzd3ejk5cmZUaWp6MHIxQlAvVm9MNDBHb1lSUlJPbVhVT3B0ekwxWnFNZHRJRHg2bStsYjRLZzBVVWxGOUJSUFFVTFVlN2dud1BWNWdIcDBoTVpaVVZIWWUzSStwenBVa3Nnbld5UDF1b1ZlRWR3UUJVMmlZSDBVZEpRQzRoWERaVkFwYUx5d2xuQmVVNCtnUEJSUVR4OUNLK1BoTUlVTDBBY1FrcDJvL3dzd0FONkVJSG5qQ1N5b0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvek5rRTRNakV3TmpOR05VWXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG96UXpORk5rTkNRVE5HTlVZeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPak0yUVRneU1UQTBNMFkxUmpFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qTTJRVGd5TVRBMU0wWTFSakV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K2pHVmpwQUFBR2RKSlJFRlVlTnJzM1cxc1hYZDl3UEcvSDJJSE4ybGFwMDlwMHF4clM5TlN2RlUwcGQzSzFCWVFMR05qMnJvVkZaQTJVVFlldGxaanI2WXhlREhneGZabWFJQTJLa0NieGhoMG9HbHN0REFWS05MWStwQ3l0aW5RQWkybGlkdW1UZEttZGt6c3hQYk96L1oxempuMzNPdHJ4OWZjeEorUGRKVDQzT3RyKy9oSzUrdHovdWQvdXFZZnZpTXRRWGUyWEprdDEyZkw5bXk1T0ZzMlo4c3AyZEtmQUlEVllqeGJEbVhMY0xiOElGdDJac3MzcytYK2JKbHErRmxET3lwWDl5N3lpMi9KbGovS2xyZGx5M2wrRndDdzZ2WFBMWU9SRzlseXc5ejYzZG55ejlueWlXelowK3FMZGJmNHZJMXpML3g0dHZ5WktBRUFGbkRlWERNOFB0Y1FHNWNyVEc3TWxrZXo1YjNaMG1jN0F3Q0wwRGZYRU5FU2Ixbm95YjBMUFBheGJIbDM1YVBqQjFNNmtIMk4wZUdVRHU5UGFXSWtwYWtqMlhMVXJ3QUFWb3Z1TEJlNjEyVDVzVDZsdFJ0VFdyYzVwY0ZMVXVyZlVIN21HZG55K1d5NUxsdHV5WmJLWU9ocU1QaDFJRnUra0MyL1h2Zkk2Tk1wN2R1VjB0NmRmaGtBUUxXenQyY3BNcFNGeXJsVmovNW5pcU1uUXp2R1dnbVRPRkx5cFd4NWM5M0xQUFgxbEo2NXg4WUdBRnF6NmVxVXRyNnU2cEV2cHhnb083U2pjT1NrYW96SngrdWlaR1IzU285OFdwUUFBSXNUN2JEclU3TXRVZlRtdWVaSXpjSWtCcVc4cTdEbTRCTXBQZmFGbEE0OWErTUNBSXMzdG5lMkphSXBpdDZWZHQxNVU2TXcyVmhYTGlOUHBmU2pmMHRwY3R4R0JRQ1dMbG9pbWlMYW91ampXWnljV1JVbUgwNnpJMmFQZWZLL1VqcDYyTVlFQUk1Zk5NV1RYeXV2alluWlBsUU9rNjNaY25QaGFUSFFOUTY5QUFBc2w3SG5zc2E0cTd6MkhXblhuVnZ6WWZLZWJGa3ovM0RNVFdLZ0t3RFFEcy9jTzlzYXg2eVphNUdaTUlubDdZVlBpSGxLQUFEYXBiNDEzcDUyM2RsZHUwdndsdm5WTWFQcjNnZHNNQUNnZmFJMW9qbU9pUmE1TXNMa3RZVW54alR6QUFEdFZ0OGMxMGVZWEZGWVZUem5Bd0RRSHZYTnNUM0NaRnRoVmR5UUR3Q2czZXFiWTF1RXlhYkNxb2xSR3dvQWFMLzY1dGdVWWJLK3NHcktMSzhBd0Fxb2I0NzFFU1o5eFNkTjJsQUF3QXFFU1YxejlIWGJLZ0JBcHhBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQXdFbXIxeWFBbjQybjloOU9ZK1BGRzFoZGN1NHBkYzk3OU9sRDgvOGY2TzlKV3pldWJldjNkY2VEejZlZGp4K2MvL2phVnd5bWF5OGRYUEwzRTYrWGQ4RlpBM1UvNTc2UmlYUmY3bXN1eHFzdjNKRE9XTiszb3IrN2IzMy9RRHFVKzkzOTJ1Vm5la09ETUlIT0V6dXNQLy9jRCtjL2ZzZHJONmVicjk5UytkeC91SHRQK3RxRCt3dnJ2djJocStwMjZoLzUwaFB6SDcvL2hnc1dESUcvL05LUDZsNjNtWGpOOG80MS8vbW5EdlFXd3VUbXYzdGsvdjl2dkh4ait1QU5GelY5L2Z6M1gvdDY5V0Z5cE81NXJmcjBlMTVaRnliWGZPRGVKYjFXL3VkcEZoL2YrdDZCd2pZU0ppQk1vQ05kbWYzMWZ1YUdOZW41ZzBkbVB2NlBCNTVMTjEyektRMzA5U3o2dGVLSXltMTM3WjcvT0Y2MzZnaEV1M2VLTDQwZFhaMlJLVDVBbU1DSkxnTGtONjQ0SzMzbUc4TXpIMGVnM0ozdDRHS25Wajc2VWFYWlgvcnhXbFdmdnh3N3pEZzZFRHZpOE9UelB5MDg5cDBmdnpSekZLWlZDeDJ4aVo4aC8zUEVVWW9iZjJtVE53OGdUS0FkZm5QN3NUQUpYN3puMmZUSzg5YW4wY09USy9MMUw5bThydW5qNVdnNHBiOW41cFJGbzVpSUlGck1xYUhsRUVlSFh2WHpwMVkrRnVIMDJQRFlzcnhXMWZZQWhBbWNWR0s4UXh3RnFPM3dZaWQ2MDBjZm1sbTNGRmRkdkNHOWZxajF6NzN4Nm5NYVBoWURWOHM3NHN1MnJGdnl3Tk4yaVpCb05IYWxsU05QVmE4VkEyeGpMRXZOMWpQV3poemhFaVlnVE9Dazk2WlhuVlczdzl0KzRZYVpKWTZnMVA3aTM3WjVJUDFPazVBSTE3MWljRkZqVk1wWDFjUVJsRnFzUFBIY1dGMzBITThWTGZIenROUHQyYlo2ZEhoMC91T0ZCdG8yRS9HVkQ1b1lORnQxRlJRZ1RPQ2tjMFgyVjNwY2ZaSVBoRGlkRTFmVXhMcGFtSngvNXNzcXg0aU1UVXltcC9ZZG52bC83ZDhxVlpmcm5yMmh2eEJGTVVha0ZpWTdTMGRHcm43NWFUUC94aVc4OGYzVzVPTXB4TlZGbTA3dkwzeHU3ZWNwaTNqSUIwUjUzRXpWVlVENVM1QUw2N01veWY4c3h4TW1nRENCVlMxMnZrc2RtQm94a3I4c3Q1R3F5M1d2S0kybmlERWljWVZQUkVUNUtNNkZady9NL0J0SER2SkhEL0x4RkM0NloyRCtrdUhhL0N1eFJGQTQ2Z0FJRStoUTVkTW83MzNEMXFhblNpSVVxc1k0NUk5ZUxNWHYvdkxaNlYvL1orLzh4NC9zSGtuUHZ6UlI5N3hMTjFkSFJjeGRrcGVmejZNOC8wcDU3aFdBNDJGS2VsaEdNUXRwbkRxcEJjZS83M3p1Wi9KOVhMeXBHQngzN2RxZkh0OWJIRjhTUjFzYWpWMHBmMzQ1cHZLdkFiQ2NIREdCWlJSSFIvN3c5ZWZORDdLTXk0Ymo4dUhGRGpDTmNTSXhPTFBzcjcvOFJPRVVTMHdYM3lpUTh1NzlRZjFWTjRzWnVCcEhnVXd3QmdnVE9BSEZWVFF4WTJ0dDl0ZDNmdktSbVV0V2YvKzZMUzNmNXlibUZpbVAzWWp4SFBrb2lmazVybXdRRnhGQ2NjVk5Qa2pLY1JLRFZ4dUp3YkJWeW9OVU53L1cvenpsbVdtcklxZjhzMGFJQVFnVGFJTTRQZksrTjUwL2Y4K2MyZ1JsVmJPYjFnYXZ4ZzYvYXJCcnMxbFUzL3FhYzV0ZVJoeFgzRlFkS2FsRnpXSnVCbGllRGJhbWZLVk9XR2lPa2ZLNEdqTy9Bbm5HbUVBYnhCVXNjY1Npblg1aDYvb2xQMzdkWllOTlB6Y21IOHVySGFrcHo0TUNzTndjTVlFMitmQmJYcDYrUDN3bzdUMDRQdlB4R2V2WHJPalhqMU5CK1JzSzVqVWIzQnFxanNURTNDcGxqVTc1QUFnVDZEQ3hjNytpeVQxYVdwR2ZyR3lobStOVnlkOVFNTy9WTFF4OGpWbHA4Mk5hWW02VloxNFlYL0R6OHBjNngvUHpYNzlxcHRzWVl3SWdUS0RONHQ0cytYdlF4TkdGbFo2TUxDWkdxd3FPVnE0U2lsbHB5emZMR3o1UW5JVzJmTW9uNUsvZWlic1c1MTJ6N2ZUS3Ezc2F6ZndLQ0JOZ21WVGRtNlZWaCtabVZjMTdjZXhvNGVQYWVJOW1zVk4xMVU3RVFTdktrNnpGMXlzUGdsM29IajU3RDA3VWhVMWN0Zk96aURSQW1NQ3FWcjRzZGpFNzRoaVhzdERWTGJYSG04MjhtcitiYnMzSTRhTjE2L0wzNXFsWnY3YTM3dWZKSDBHSkl5OEx1ZWVITHhZK3JsMlJFL2ZlYVdWN1ZGME5GS2QrOGhPN0RiUjRLbWowOEdSZC9BSENCRmFOVHBnaHRSd0dJYWFxLzVNZDV4Zld0WEp2bnZMNGxqalZzNUJHbHl0Lys3RVgwczNYYnlsRVd6bXc0alJRUG9SaW12MFFWenpWN3R1ekdKLzc3NmNMSDMvbE84OGQ5eGdnUUpqQUNhRjhHbVl4czZ3dXA2ODJtT3pzZ1IrL2ROdzc1YXJKMVpwdGc3d0lqaGlEMDJ5c3l6OSthN2d1cUdyMy82bTZRM0ZlUGdRdjJieHVKbkxLVnlmVjVwWXBQeGNRSm5EU0tjLzMwV3lXMVNwVlU5TGY5dlhkaFNNUXNYTnVkcmx1N1BqTGcxZHJIbnp5K01Qazh2TlBYZFEyaUFESUgzWDU3cDdSaGtjK3lrZExGcXQ4eCtVLy9hZEhLNTkzKy84K1UvZGNRSmpBU1NkdW1sZXoyRmxXUTlXVTlLZVZCcU11TklEMHZzY1BObnlzZkNwbG9EUnVJMzlVSVM4bWpZdnZJNDRBTFJRMjVURTJjWFFpLzNyL2w4VlJ3ekQ1WHZGcW52S2x5NHNSUjI0YW5WS3FIVFdwMm82T25vQXdnUk5lSEtYNHliN0RoUjFoekNXeUhNcFh5U3dtanNwaUovL1Uvc1B6d1JUL1ZoMDVpRHNsNTArQnZPMDE1N1o4cENVK054OFdzZlBQQjhiZDN6MVFOOWFsRmhMNWdJbXdpN2xQRmhvTTNNaFhIM3ErTHE3eXY1OUdSMDF1TE0yM0FnZ1RPT0dVTHhFT3RibEU0dlJFSEFrb0g0VzQvWjVuS3dlcGh2d044UjcreVVoTDMwTjhuYmppcEh5VW9MeEQvdWdkVDZiWEQyMXNPbFlqYmo2WS8zNWp3R2h0SnRzUUU3V1Z4NGxFOER5eWU2UVFOTFZMbE9QZldwakU0ekhXNWN4VCsyYkNLSUlrWnNlTlVNaUx1eldYeGNSdDhYWEdzcDh6NWxKcGRObHlQS2MyTHFVV1NERWo3MXYvOXFINTc2L1pVWk5HNDJRYTNUc0lFQ2JROFM3Yk1udEtJR0toSENWeEZPVFI0ZEdHcHhxV2NwU2dLbjdpaXBhWWhyNTh0K0ZZbW9WSmVZQnIrUVo4TVE2bUhDWTNmZlNodXRlcDNleXZQT0hiclovNS92eU5EQnRkRlJSM2E3NjdkR29uWnBPdHpTZ2IzME0rS2hyZEVESEVrWmVJbUlpZC9MYk5QejkvZGRCQ1Z5b0J5ODlOL0tDTllyNk9abGVlL01vbDlXTXM0dFJGSzNOOExPYmVPNy82aTJmTzdPRGp0UmVqYXViWXBhZ04vcjF5a1ZjbnhmWmJhQkszVnNYUEh0dWdGanVMM1JiTlhoZFlQbzZZd0RLS1V4dTFxMmxpUUdsKzBHdCtZckE0VWhKUkV1TTFIdDk3YkZCbnJQL3RWeDhiMjVDLzcweGVESHh0RkR6bFFadlhaanZoV3VoODRJYUxaazdIdENvR3A4YjNzTFBCUU5xRkpqZUxuZlpiWDNQdS9IYUl5SWpYYStWSVVHeXJtNjdaTkw5ZGoyY0FiSWlqSkxYSWlYL2Y5NmJ6MDk5ODVjbktteHkyS3I2bjM3dDJzemMrTEtPdTZZZnZtQzZzdWZjanRnclFWdm1aWm1zQlZ4dlBVUTY2NDNudCtWZ3ovVDEwcnF2ZVgvalFFUk5neGNVUmkzSXNMRmM4VkwwMmNPSXd4Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQ2ViM283L0RydTYwbVRmNmVsby8ybHBhczBwYWJxN2IyWWRBTkNDNmFuVVBUV1J1bzZNcGQ3eEYxTFB4SXZadW1saHNoU1QvYWVuaVhWYjBuUlB2emNXQUN6cEQvenVOTld6TnFWc21WdzdtTG9teDFQZjZKN1VrMFZLSityUVV6bGQ2VWdXSk9NYkxoUWxBTENNWXI4YSs5Zll6OGIrVnBpMDRNaTZ6ZW5Jd0RuZVBRRFFybjF0dHArTi9hMHdXVUNjdmhFbEFMQXljUkw3WFdIU1NGZFhtbGgvbm5jS0FLeVFtZjF1QjExVTBsRmhjclIvY1BhcUd3QmdSY1IrTi9hL3dxVENaUDlwM2lFQXNJcjN2eDBWSmxPOXAzaDNBTUFxM3Y5MlZKaE1kNi94N2dDQVZiei83YmpCcndEQTZ0My91bGNPQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RHd0NBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd3NRbUFBQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQmcxWVpKMS9TazN3Z0FyTFRwYVdGU2FlcUlOd2NBckxDdUR0ci9kbFNZZEIvOXFYY0hBS3o0L3ZlUU1LblNNLzZpZHdjQXJPTDliMGVGU2UvNGdkUTFOZUVkQWdBckpQYTdzZjhWSmxXbXAxUGZ5Rzd2RWdCWUlUUDdYWU5mRytzWmZ5R3RHWHZXT3dVQTJpejJ0N0hmN1NRZE9ZL0ptdEhoMVB2VDU3eGpBS0JOWWo4Yis5dU8rNzQ2YzNQRktaMm5Vcy9FU0pwWXR5Vk45L1I3QndIQU11aWFIRTk5bzNzNjdraEpoNGZKck5ob0w1dDRNUjN0SDB5VC9hZWxxZDZCTEZMNllyTjZad0ZBaTMvc2QwMU9wTzZqWXpOWDM4d01kTzJnTVNVblZKak1icy9wMUh0NC84d0NBSnpjM0NzSEFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQTFJZkpSSEZOajYwQ0FLeEFoZFExeDBTRXlVanhTZjAyRkFDd0FtRlMxeHdqRVNiUEZGYjFyYk9oQUlEMnEyK09aeUpNSGl1c1dydlJoZ0lBMnErK09SNkxNSG1nc0dyZHVUWVVBTkIrNnphWDEreU1NUGxtWWRYZ3BUWVVBTkIrZzVlVTEzd3p3dVMrYk5renY2cC9RMHBuYjdleEFJRDJpZGFJNWpnbVd1VCtDSk9wYlBsczRjbG5ETmxnQUVENzFMZkdaOVBRanFuYUJHdWZTUG41VEdLY3lhYXJiVFFBWVBsRll4VEh0RTdNdGNqOHpLOXgrT1JUaFUvYStycVVCczYyOFFDQTVUTncxbXhqRkgwbURlM1lrdytUOE1GczJWOTQydmx2U0tsM3JZMElBQnkvYUlxZmUyTjViYlRIWDlRKzZDNDk4TWVGcDY3Zm10SkZ2NVZTVDUrTkNRQXNYVS8vYkZPY3VyWDh5SzFwYU1mK3FqQUpuOCtXVHhiV2JMZ2dwVzF2Y1ZvSEFGaWFPSDJ6N2NiWnBpaTZMWXVTeitWWFZOMWQrTlpzK1hKaFRSdzVHWHBuU3B1dXNuRUJnTlpGT3d6OXdXeExGRVZyM0ZKZTJUWDk4QjJWYlpNdFg4eVdIWFdQakQ2ZDByNWRLZTNkYVdNREFOVmlucEs0SkxoNlJ2bXZaTXVOYVdqSFdLdGhFdFpreThleTVWMlZqNDYvbU5LQng3SlFHVTdwOFA2VUprWlNtaHhQYVhyS0x3TUFWb3V1N3RueEkzM3JaKzk5RTlQTUQyNUxxZiswUnA4UlEwWnV5YUxrU05XRHZVMitWSHpDdTdQbDdybEFPYVB3YUh4QnAzWUFnTmJzUzdQRFJmNmwyWk82VzNpaEdCQWJOOUQ1KzVTZmhBMEFZR0VUY3cxeDZVSlIwbXFZMUNyblBkbHlZYmI4VmJZTTI4NEFRQlBEYzgxdzRWeEQ3R3ZsazVxTk1Wa29hSzdNbHRkbXl4WFpjbkcyYk1tV2RXbDJiQW9Bc0RyRTBJL1JORHVML0EreTVZRnMrVWEyM0o5bTc4ZFhiV2hINWVyL0YyQUFzdFdxV29UNW5kNEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ri45oiP6KeE5YiZL+a4uOaIj+inhOWImS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeU1UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE15TWpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBMFFrWTVNekZHTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16SXdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCsrWUttYndBQUJraEpSRUZVZU5yRW1YMUlXMWNVd0crK2pacmc1MnAxYUtkVytvY2ZHMUkvVm9jVk1zSEovbWdwZzIyTXdmN1lCN295SFZNM2hnamlwaFZSViswSFcrdEt1NjNybk1KYWgxQ3BVbXkxczdxMUR1ZWt4aW4xVzJ1cUpqR0pNVHZuNVVaUysvTHlYb3oyd0NINjh1NDl2M2R5N2pudm5pdXkyV3hrR3lJSFRRZk5BazBFalFQZEMrcFB2MThGblFZZEFiMFAyZ25hQTJwMlRIQWtXaTdJb01oRDRKZEFQd1E5Qmhva2NPd1M2QytnWjBELzNHbmdKTkN2UUhOd0xObWVvT0YyME04QitwNjNnWDBvNk1lZ1V1SmRXUWR0b09CcjdtNFc4NWd3Rmg2cUZ6NExkZ0NXMERrL1FSdXRXblBzdG9DdDY1WVVtS2hISkJJbGtSMFd0QUcyN2pTUDZOTThBZ2JZTkxGRWVnTW1DaUc3SkdBckNHeDJjRUd6QWx2TXB2MHc4Q3BNNEVkMldkQW0ycjR5dkxLZkYvRGl6S1JTS3BVMTc2Wm5XYUJEa09HNzIyTkt0OERxb0pBcWtWaWN5RGJSK1BnNHljdkxJOW5aMmFTaW9vSVlqVWJCTUhxOW5wU1hsNU9jbkJ5U241OVBKaVltMktHQkFWZ3FPZFBhOHRKQ3Nqb3dwSmN0RzR5TmpaSEN3a0tpMCtrMnJ5VWtKSkNxcWlxaVZDcDV3eFlWRlpHaG9hSE5hNEdCZ2FTdXJvNUVSa2F5cGp4Z1NuMDNPWHpnS1E5RERoUXAvVlJmdTBwZENPWU1pekk0T0VpS2k0dDVlWm9ObGlsN1MwdWt1cnJhWmNxalRLS25nQ0ZlVW1SeWhjYlZTRmMvblFQYVlEQUloblVPTlZjQ1RLOGkyeFBBakhmOVZjZTV5bTFxYXFyTFNSRzZwS1NFRmRvZExFcDZlanJuR25SbWs1U1ZsZUZmNmhjek5HZGhkU3BjalVwSlNXSEE1dWJtV0wvSDYvaDlabVlta2Nsa3ZHR1RrcEpJYVdrcGtVcGRGMUhJR1B1QXJmSHZPemROaklmVGM0NitBcXRTeGZXWXZyNitwTEt5a2xsb2ZEek5GeGJYaGtLaDRFNXp3SWFNVEVoQU9JajkxSUVhUHF0Y0NMUzNZQjFDR2NWaWUxd3JFdm5tVWI3UTNvUmxkZ3AyUmhrQ0srUSt5aGVFSkg4KzBONkVaWUR0akFvRWxrdGxzbUNoaGoyQjloU1dXWGgyUmprQ1M4VmlpYThuTlY4STlIWmdtY1ZtWjVRaXNHUmIreHdvN1ZhcjFlMTlHeHNidk81ekl4SUVGbG10NjBaUFJ2TkpYWHlLQ3graGpDSW1ENXVNaHNjN0Nlc05hQWNqQXR0V0grdW1kaHAydTlDVTBZYkExcVg1NlZGdnd1SUM0MXNSZVRjejdJeFdCRjRmN3UrNTYwMVl6QVpDeWpnZitYZWd0eDlaRWRqYzluM0QzWFdMMmVndFdFeGRRdDg5T0JzWEZ2UGExZlBmb0ZQTkNHeGFtSDc0YUdKa3FJOXJVRTFOamVCeXl4ZTZ2cjZlRXhqWS9vQzk1aUt5SXJBRmQwYzNtaTljNHhyVTNkM3RVVkhnQTgwMU4wcG55MFZrVzBaV2Nhdld2SUdMc08xQ1k5L01oUFlmbCsyZjJGaVBLNWc3NkppWUdKZGprZWxhMDhrKzJnbmRjR3lSOVBnTzNuTDZ4Q1VibGlRV3dXMFFiaGc5TGJldW9JT0RnNW01V2Fzb3NQeDZxdW9pc2xIR3pUMGQ5bXNYcnY5OHZtK29yN3VMYlhCVVZCU3ByYTBsOGZIeFJLVlNFWTFHSS9qZHdBR2RsWlhGeklGejRZNDVJaUtDOVg1azZialNoSXR0d2RGVDN0em13NHM4ZGlpakEwTEREdGEyOVZVRWhPeUpJTTlRZEF1elV3VzVCNy9RemM5Z09HaEIxN1kyVWt3WU1uQ0R0cUg0ZzFOUUN2WFBDaFp0QTBNanNpQVRaWHR5bXcrTEQxMjlBdnBmZitmdmY1MHIvL1MwRlJMZ2JzT2lUYlNORE1oQ21XeXNyU3FBdHRCNEdiMSsrVnpQbVMvekc4eHJSc051d2FJdHRJbTJrWUd5V0xZMms3Y0t4c29rN3A4ZzRNV0xzMU9HNHllK2ZROWlPM3hIWTNaK1p1cGs4ZnROQTEzdDZOa1J5ckRHMlZ0emJsc1IrMGxRRkdpY2YwQlE1R2NOUHg1TlNEdDhDTGJjWW0rQ1l1b2E3TzI2VlozL1ZzdXE3dEVFaFIybmVkZkdDOWdKR3Z2RG1DMHdzNGNmeWoxMjRNMkNzdHlJNkxnRDNvQ2QxSTRNLzFSYjFuYXJyWGtZL3AyaVlUQkpjeTRyR09laERJWEdkSWU5NG4yZ3oyUERNZVAxTjJKZmUrZWpsMk1Ua2hOa0NoOUIrMEdMYWMzNFlMRC9mdnVsczdkdi9uYjVBYkVmZ3oya0MyeUJob0ZMS0Y2blNBQ092U2ZzRElWUmp6K0hyV1NsbjhydjhKRzNZNUl5TkRGaFVkRjdBMFAzaE1JMXRWUW1sOU8zTExOUnY3SzhORDg3UHpPdW5iN1gzVEhhMWZyREtGelQwM2VET2VyUkdab05MRzZiM1h6UDZhaTNzYXlwcWNkRHNiTFNXTWRmUVVaVjR0UlV4TW10Rk1SQ3ZZZXhpVzllODlTanl6VFA4Z0tSQ2ppSnRGR0RPRG51cjZhcDE5WDBFOEdWVHRERUNkWklRVmNvSUg0YWFMa1ZkTExweWJtYmpVSTd3R1hVODNJNkg1dUgxeW1jaVQ3QWhxY0w5WDhCQmdCNWlEbjBNcysyN3dBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMVJUVTJNa1k1T0ROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8xUlRVMk1rWTVPVE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalZGTlRZeVJqazJNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qVkZOVFl5UmprM00wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K01UR1dCQUFBRmpkSlJFRlVlTnJzM1gxc1hXZDl3UEVuanQvaU9DK05uVFpwM29pU3BtdFJ4Zm9HYTRYVVV2TEhFQjBNcGpZSXFHQ1VEU2lEUDlBMElXMmFKalpOMmxTaGFVQUhIZkRQQ20zR3kwUUZtclNtZEIyb3dCS29SdGV1N1JvRm1xUkp1eVFsdGV2WWp1UHMvRzU4eS9HNTU5clg5cjJKblh3KzBxUGE1OXhjMy9zNDZ2M20zT2VjdStqMG9ZZlNMTFJsNC9wc3ZDVWIxMlZqV3piV1pXTnBOcm9TQUhDK0c4bkdxOWs0bUkxbnM3RW5HNDlrWTNjMnhxZjkwMnUyVC9xMmZZWS9mSDAyUHA2TjkyVmpnOThGQUZ5d3VpYkdxbXhjbFkzZm05aStQeHRmeThZWHNuR2cwVHRyYS9CMmZSTjN2RGNibnhZakFFQWRHeVphWWU5RU8vUTFLMGh1ejhiVDJiZ3JHNTNtR1FCb1FPZEVPMFJEN0pqdXh1M1Q3UHRjTmo1YXR2UFUwTEUwOHNMUDBzbVg5NlZUZ3krbThlSGo2ZlRZYURvOWZ0S3ZBQURPYzR2YU90S2k5czdVMXIwaUxlNjlKSFZjdERsMVhYcE5XdHl6cW5qVC9tdzhrSTJicy9HSmJJeVYzbCtkUmEwOTJkaVpqVnVMTzA2Ky9JczB2UDhuNmNTK1IvMDJBSUJKbG15K0tYVnZlRk1XS0s4cjIvM2RkT1pveVZCeFVXdFprTVNSa1c5bDR4M0ZIWU5QZmpzTlBiZkxiQU1BVStyWnVqMzF2djdkWmJzZVRMRUFkczMyc2VtQzVJdlorRWgrdzhtano2V0JKNzZSeG83dk44TUFRRVBhVjZ4UHk2NjZQWFgwYlMzdStsSVdKQitkS2tqaU1Nb0QrUTJqTHoyVmp1LzVTanA5OG9TWkJRQm1aRkhIa3JUaXVqdFQ1OFZYRm5lOU40dVMrNnZmNU0reWlkTnlQcCsvWlJ3Wk9iN25xMklFQUppVmFJaG9pV2lLZ3Mrbnc3dFdsd1hKWDZVeksyRmZNL0RFUDJkM05HUTJBWUE1Uk1sUUd2ajV6dUxtT0Izbkw0dEJzakViZCtadkZRdFl4NDRmTUlzQXdKeU52WEl3RGY3M3Q0cWJQNVFPNzlxWUQ1S1BaYU9qdWpkTzdYVTJEUURRVEVON0g2NDBSazdIUklOVWdpVEcrL043aC9mLzJLd0JBRTFYMGhqdlQ0ZDN0VlUvdFhkOWRldXBvYVBweEw3L01HTUFRTk5GWTBScjVFU0RYQjlCY2t0KzY4Z0xqNXN0QUtCbFNscmpMUkVrMSthM3hHZlRBQUMwU2tsclhCZEJjbmwrUzN4UUhnQkFxNVMweHVVUkpHdnpXOGFIWHpGVEFFRExsTFRHMmdpU1pma3RwOGVHelJRQTBESWxyYkVzZ3FSejBvM0d4OHdVQU5DNklLbHRqYzQyMHdJQW5HdUNCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBRGpuMmswQk5OZXh3YkgwKy9mOHNtYjdaM2FzVFcvWTFEUGxuMzF3ejh2cEs5OC9ObW5ibGt2YTAyYy9zR2xHaitIZ3NkRzA4N0dqazdaOTZ0YTFOYmU3ZDlkTDZYcy9HNWkwN1pOdjYwOXZ2V3BGeStibmZ3OE5wei8rcDRNMTI3L3pKMXZtZk4rZi9lNmhTZC92dUxFdnJWdlZPZVA3ZWVmZjdxMTViQ2RHeDlPQm82T1Y3M3U2Mm1aMXY0QWdnYk5tVlc5NzlrSzRJZ3VDNDVPMlA3bC9hTm9nK2Zjblg2blo5dlpyVnM3NE1ReU5qS2RIbnhvcUJNbmsyL3pYTDRkcVlpVDg0T21CeXI2cDVGL282d1hHWENOZ0t2V2lxZmljZitmYWk1cjJlNDBZcVQ3UG02N3NLUTA4UUpEQXZITDlsdDZhSUludjMvWEdWV2xKblEvWmpxTWFlMStzK1VqdWRPUGx5NXIydU9Mb3plUDdYcTE4ZmQ4UGpwWGU1dkY5STlQZVR6TmY2SnY1bklwMjd4MU16eDhaU1ZkdlhsbzV3bEU4YXRTb09QSlNQVG9DQ0JLWXQrSUZxL2l2OHpMditidDlNNzd2NHA4cE96clF5TkdGdUUzOHk3NlJ4N21RSEIwWVMzLy9yMGRLOTFXajhPNDd1aXIvbmUxelA5L21ET1lqaTFvQmdIUE9FUks0d01XaTJRL2N2RHIxbEx5VjlEOEhUOVFzc28yakxKZXQ3WDd0Ky9nNnZ5RDE2ejg4VXZOMjFhcmV0blRQaHpmVmZic3FMOTVhK2RQNzk5ZThmZFhxeGJhTml1Y3lIeDRIQ0JLZ29SZjUyU3hHTFZQdjdZaloyTHFtdTJiOVJ6NHVpbUh3MS85eXFPYkYrSU5adkV6bHQzOXpaVTJRSEJzY1Q0ODlNOURRQy9sRFB6OWVFeU14bi9YVzBxenY2MHgzMzdHdThuVnhjVzFFek1iK3JzcHRpbXRBcGxxWVduYVdEU0JJWU1HSkY4Qm0vU3U2a1NDSkY5ZThWMDZjcWxtY0dyZFoydFZXV2VTWlYveStLczYwaVpESTI3UzZvN0tBTkJhSnh0bEVWVDk2ZGpBTmpaeWFGQkRGcUtpM2lEYnYxWkh4bWlNeTFmbU1vS25LejIwY2Rha1hWUkVqOWZiTlJQNlUzNmtpRGhBa2NFRXIva3MvVHNWOWZOL0JtdHZNOVJUZGlKd1lzVWgwY3BBTVRMdndNK0ptdGtkNzRyN3o5OStNMkh2aStlR2E2NWFVeldYSW4vSWJIREVCUVFMTVVyejRybG5aWVNKeWdWUVdVY1hydFFCbmg3TnM0QUlSTDc2SGYzWFNSQUR6a2lNa2NCNnF0eTZrNk9yTlhlbDliKzZ2ZlAyMUh4Nlp0TzRrdjI4MmIvUEVRdFBxV291SG56aGU4M1pOOVcyUHFmYUZScS94QWl4c2pwREFlU2F1WE5yb1dvM2xTeFpYb2lGR2ZGMXYzOWtXYTExaXhHTFNWb2xGdnRhQ3dQemhDQW5NWTNFNStabjY1bytQelp2SFA5dWpHOVVqTXRYVGVRRkJBc3pDbWJOQzlwNzFueHRIRmNvK01DL0UwWURZNyswUFlEN3lsZzBzTUQxZGkrdnUrNGQvZTNGQlBJZTNYN09zb2VjRFhEZ2NJWUVGSks2VWV2bWw1V3M2WW5GbzJhY0ZuMHMzYkZ1VzNyQ3BwMlo3L3Fxck4yenJUWi9aMFphT3ZGSjdCbERmTXYrTEFrRUN6UG1GTnhRWG1OYTdySHhjR2JYNGRrcGMrcnlxZjNsSDJyYTJ1L1R6WUdMeFp5TlhRajNiK3JPZ2VENTNCZGVxL0ZWWHB3NHcvNHNDUVFMTUlFaDZTN2ZIbW8yaWlKRjZWeG90QmtralZ5U05oYTg3SHp0YWM1bjNNa2NHSmg5QmlVdk1WeDlqZkYxdlg5bjlYTFoyK25tSjA0L244bGs4UHNRT0JBblFCR1hYQTRrakhjMDBORko3eGRFN2IxbFYrcGt3Y1luM3ZET1hnaSsveHNoVSsrSis2a1hZK1dndWw5c0hHbU5SSzdSUWZGaGMwWWErenBiK3pMaSt4aFhybHBoOFlFRnhoQVJhNkxuRHRXOTV0SEpkUkN4Ni9lRE5xOVBSZ2JGNU95ZjFyaTJ5ZSs5ZzJ2blk4WG4vTzQwcjJBS0NCQmFVNGxzcGNmU2kyZUpNbEZqOEdtOEZ4ZEdYQ0o1NlFWSnY4VzBzaUMxYmcxSnZBZTVjVHRXdGQrWFhSaTkzZnk3a2YyODdidXp6RnhzRUNTd2NaVmRaM2JxbStaZGhqd0JwZFBGbjJicVBPRjI0M29MWU9JMzROOVl0U2V0V2RWN1F2OHRQM2JyV1gyZ1FKTEF3UFgzd1JNMjIxVE5jMEZydkxKZjFmWjJscC85V0RUWDRHVEFSVGRPZEJmT1BENytVL3VLMjlVMmJsN2ljZkprbm5oOXU2ZStqYkU0YS9heWNCL2U4bkpaMi9YcStyOTY4MUNuSklFaGdmb2xvYVBRc2pJMzlNenZTVU85Kzg1K2ttMytobis2eThEOTZkakFONWE0TFVuYnRrbmg3SW44L2NiYk52YnRlU2xzdStmWGFpWGpMWnJabjJjemswdlh4YzZjTGxlcHB6MVBOWDZ5dEtYc2NqejYxcjZISFVUeGo2ZTQ3dWdRSkNCSlltT0tGZnFxM1B1SmYzU2tkYWNuUHJyNGd4K202VXdYQmpodFhwUGUrT1M3R05qbHV6bncrenNDazU5THEwMzVqOFdpOXorWEpLenZ0dWFpUmE3VGs1eWwrZG9RWUlFamd2Qkl2Y0hIMnk5UXZodTNwMDc5N1NicDMxLzgxL0FMYXFCdTJMVzNvTWI3cmphc213cVN2S1IvQ0YwZFNack9RZDgzS2p1elBMVTkzZlhsL3piNzg1K0RNUmR4UFBuaGlBZTl0TjV4WnNQb0hiNzA0Mi9lcmhvSUlFQ1F3TDFUUGNxbG5ZMzlYM1ROTGFzT2h0ekxpYllpaGtmcFJzbjRHMXpLSklDZzdVeVl2am94RWpGVFhwY1NSbkhzK3ZLSHlvanc0ZkdyV2NWSjlQck5WakpuZTdzVTF6eVhtb3Q2cHhGT0ozOGtmYnIrNGRGODgvOWhYYnovUWZJdE9IM3JvZEg3RFM5KzV5NndBQUMxMThUdnZtZlM5SzdVQ0FPZWNJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFFQUV5V2grdzZLMmRyTUNBTFJNU1d1TVJwQU1UTHBSZTdlWkFnQmFGeVMxclRFUVFYSW92Nld0ZTdtWkFnQmFwcVExRGtXUVBKUGZzcmozRWpNRkFMUk1TV3M4RTBIeTAveVdqb3MybXlrQW9HVktXbU5QQk1raitTMWRsMTV0cGdDQWxpbHBqVWNpU1A0ekd3ZXFXeGIzOUtVbG0yOHlXd0JBMDBWalJHdmtSSVBzamlBWno4WjkrVDNkRzk1a3hnQ0FwaXRwalB2U211M2oxUXVqZlNIbHJrZlNjZEhyVXMvVzdXWU5BR2lhYUl0b2pKelJpUVo1N1VxdGNiamt5L2xiOUw3KzNhbDl4WHF6QndETVdmdnlTeXR0VWZEVnRHYjdnWHlRaEQvUHh0SDhyWlpkZFh0YTFORmpGZ0dBV1l1V1dIYlZqdUxtYUk0L3EzN1RWdGp4Ui9sYmR2UnRUU3V1KzFCYTFONWxOZ0dBbWNkSWUzZWxKVHI2THl2dSttUmFzLzFvV1pDRUI3THhwZnlHem91dlRDdC82K1BldmdFQVpxUjkrYnFzSWU2cXRFVEJ2Vm1NZkgxU3VKdys5RkR4UnAzWitFWTIzbEhjTWZqa3Q5UFFjN3ZNTUFBd3BWakFXckptSkR5WWpkdXlJQm1kTGtncTk1T05iMmJqYmNVZEoxLytSUnJlLzVOMFl0K2paaHNBbUNTdU14S245aGJPcHFuNlhqWnV6OFpRRmlTcGtTQUpIZG40WERZK1VyYnoxTkRSTlBMQzQxbWc3RXVuQmw5TTQ4UEgwL2pZY0VyanAvdzJBT0I4MTdZNHRiVjNwN2J1RlpYUHBvbkx3Y2NWV0FzWFBjdUxKU0dmeU1iSnluY3pDSktxOTB5RVNiL1pCd0JtNkVpS0Jhd3AzVDlwYXlGSTJocTRvMWpvZWtVMnZwaHlGMDhEQUpqQzZFUTdYRkVUSXlYYUdyelRxSnVQWldOTE52NG1Hd2ZOTXdCUTR1QkVLMnlaYUljampmeWhSdDZ5cVJjeTEyZmpsbXhjbTQxdDJZanpnbnZUbWJVbkFNRDVMZGFDREtZelYzdC9OaHMvemNiM3M3RTduZm1jdktrVjNyTDVmd0VHQUVESU1tVXlFUUM1QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xUlRVMk1rWTVRek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFSVFUyTWtZNVJETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVkZOVFl5UmpsQk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pWRk5UWXlSamxDTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrdUIrRFl3QUFCbUpKUkVGVWVOckVtVjFzRkZVVWdNL003Ry9iM1JiYUFnWEtUMHVSaUJTSUNtME5EeWJ3WUh3aHlwTVlOVDRZVExRWUhreEVub3lnSlA1RUVGQjVzQ0srS09GQlZDQVNNYUlGYlBscCtTOHRQeGE2WmFIZDdyYmIzWm1kSDgrWnVZV1c3c3pPYkxmbEpxZXpuWmw3N3pkbnpqM24zRE5jZk8xQ0dFUHpvTlNpUEl0U2pUSWZwUXlsZ0YwZlFBbWh0S0cwb2h4Rk9ZNGlEUTJ3dHJITjBZUmNsc0JMVWRhaHJFR1o3TEJ2Qk9VbmxLOVF6b3czOEdLVUxTalBVVjhZVzlOUURxRzhoOUF0dVFiMk1kQzNVVnlRMnlhamZNbkFrN2tBbm9lcTJNY1oyaDIzaG5PMDRCeHJFTHJkNmo3ZTZxS2lhY3R3b09QakRRdUdmUzNHdVU3dXFhMnF5UW9ZWVd0NGp2c0RCeXFCQ1dvNDEyU2M4NGdWZEZyZ2xLcFZZY2NET0VBK1RIQ2pPV251aHBxcUtsdkF2WkxzZC9IY3ZvblViQnJvRW1MWS9sU0YvK0ZybzFaOHdDVnM1WXdnTVBycHltYUI1OVVOd00rcUJQblVNWkQyYmdjUUU4NWcvUG5nZWJrZWhPcmxvTjY2QnRKM240UGEzWmtPdWhwWlBzYWY2MDI5Ukg5S2VUTGdGazZrZXhCK3hoendidGdLWEtEdy9qbTEvUUlrdjloa0c1cGd2ZXMzQTEreDRJRjNpRVZBL09UZHRORGs4cEJwK2JxbWp0T2pUQUxkQ2VjVCtJL00vS3pudFEwallQWE84eGFDYi8ySEFGNS9WckQ2K2VBazhMenlqbGszRjJQaVJnR2p2U3h6ODl4SzA5VTVyVHo5ZVFiTitmeU9ZZTlmbno3YnRDOHlyU0syRWNDa1hiL0ExMXVGVytWOHM3bHZSR2h2Zlhyb1RMRDYySzBuclYvT01EYmgvZW9wOUN1NHFDai9heng2elhxcEY1cEJxRm9FM09RcDZVZkY4M1Jkd2NVSXNtd2JWbTA3QitKdWZPdUtZbm9QZW93NXlMYmpVaXdoNmhwZVZseXdBazhFTEVObk1nSGl0azM2UXJPamFidXdTUndUSkRHVG13c1FvNjdoaXdOOS9PcVp4VytpMm1zeXB5bXlya0U3bW5iVnJzd0o3SVBJQytIZnVpSy9rNGJkYU5qVnRwTVVtNXJPSlN4YmZOWDZBZjk0UFR3LzExRm1aUU02bDdDNld6VVl2UVRzRVRnb2Rwd09aZ0dkTGF4dXV3YWpoemNXSVplWFZRN3JBSG9zc0xxWkdZd3VBaGJHbHFuZ0VMeU5JWGdlYitYSG1oY0pOQUtIdVc4aUsxWWJyc3RPY0xIbkpYUkdUbjlrU2RHaTR3bWJDK2doUmdMVzRyTFNOZDZ3WTRWbWpCb0JLNUdVM0pGTFdGcGdkaU9pN1dLR3dhZ1FzSHkxUDltY1MxanlCazdDdUozVzNwODhSYXdFTEIwT1JacmxEQXZQYVc3Z05QZXd6QWcwTFhtd0swSktsUWhZN0JIbDNsdURVcE5scE1GdGpkTndheGZhL2RKYmxzREk5aS91Tlh1SWxZQlRLTEcvd3RGZkxCM2cwcnFzZ29JZGFHRkpuU1h3c1hDTTJHTEV5djlRTjErbEt1UGhVRi9UbldUcWtpbFVaMGZXRVN3VHRJYWJVYk5HVElkQ2tTWldDVldIUWs4Y0pYemdkdTllRFUrbTlZTU5uK2tieG16RHJSbTAxdGNEWXNPblp1VXI5ZWZidmQ4VEcyTTBkaHo3TzNzSWtyc1JGNVhIQy9ObWxucmRvN0kzYlNBSzZya200TXNyQUh4NW9KeisyOWdwT01rTldEN05sNVFCTjZrRXRKdFhRZHoxQVdqaDlHSGdjaXh4ZE0vMThJLzQ4enB0NmtkczgzRmZSeFhLaWlLMzYra3RTMlp2TG5RTE0rQVJ0bWhLNmRwNDl1Ykd2cFJNNWtBMmszeTQ4a09xNnNZYnJ1MXU3OTRwcVZyOFVjSFMzTWl3ZzFpSWliR04zT2JqNHRPWTJtK2NpY1RQNHF2WWhRbUhOTkd3TkNmTlRRekV3cGkwK3g2RmJIaW92VmhlcktJOWs1dFQwWjdGU0VycHh0MzBZb0hqM0JPazJjR0c2K0dkZjk2Sk51Sy9WOEQ0UGlKYTF0YVlyZHltL1JOMjVDT2lQUGhHMWRUWDBiYW5qeWNzdnY2dWI5cnZmTnRpYUxhTk1ZeXF5S2V0d0ZOaEJZd3ZRVlNTbVYvZ0VtYlZQMWIyQW5xUVo3Z01SWERIdXhaOG14ZWpnLzlzdXhMYVB5QXIvekhZbTh6dmFyYUFoMEZUZlppOFJTWEs5SnFTd0lJMTVjWFBsL2s5QzNJQkcwcElsL2QxOXZ4NjRsNy9aZnlYZkZzSDAydzhIYXdsOERCb2NuZFVLNTZETWhObFVtMUpZTjZxYVVWMUZRVytSYmo5ZHJRZlRLbGE0dHBBc3ZWSWQxOWo0NzErK3A1QjBlZ1dXMkQzbUJsb3BrbVluYTlJQ0U2TGppcEQwNWpHYWFVR2ZRS2Z2NkkwV1BsRVVWN2xWSis3ck5EdEt2VUxmQkIzdFI0OVRxaWFsRkRVV0RRbDM4VVFHenJmTjloeDdHNnNJNm1vY1pZYmhKbEd1NWszU0dWTWNlMStwMlBhcHRwYmtHbThGS1dZMlRxOUJUY1RZVmhSa1RTbE1KQVUweDdaSm1WZWQ1bEdZOHdUYUxaeTh0VnpIWHNzZ2lFTjVqR3RCOW1Sd1AzRG9HRVliSUtCOWpOQU9nNkM4UWxYY3pLNUs3dUZyV3VFSk1vQXZld2hYQ1lhbGhtY3lCNUF6WGFoL2kvQUFJTitLWFJxSzRFK0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvME5EazRRVFV3TnpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wTkRrNFFUVXdPRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalEwT1RoQk5UQTFNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qUTBPVGhCTlRBMk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0U3WjFvd0FBSVBOSlJFRlVlTnJzM1Z1TVhQZDkyUEgvek41NFc1SFVVaFJKVWFKa1NoUjF0V3pKZHB6VThVMUZhaU1RQ2doMUd6ZEFidzl0V3JzUGVXa2YyajQwZlFtS3RnOU9nTFlvMnBjMGR0S3FLSXpFYVdFbGpnTTB0dVhZa1NWWjF0VVdKZDRra1Z5SzVKTGNKWGVtNTNkbVp2Zk0yVE83czh1OTYvTkpUcFk3ZTUxRE1mL3YvTS8vbkZOcm52cG1Xb0o2dG4wazJ6NmRiWTlsMjVGc3V5M2J0bWZiU0FJQU5ydkpiSnZJdGhQWjlrcTIvVVcyZlN2YnZwOXRqUVcvZXQvalhlOE9MdktISDh5MmY1SnRmenZiYnZkM0FRRHZXeVB0N2Vac2V5amJubXcvL2xhMi9mZHMrKzFzTzk3dk42djMrWGxqN1cvOGVyYjljekVDQVBSd2U3c1ZYbSszdzloeUJja1hzdTJsYlB2SDJUWnNQd01BZlJodXQwTTB4TjljNkpNSEYvallWN0x0SDFWOThQVFZnZlN0dDdla0Y5NGJTbTllSGt4bkp1dnB5blF0VFRWcS9nb0FZTFBYUnIyWnRnNDAwNTZSUnJwajIvWDA0TTVyNmRPM1hrMzd0a3lYUDNWUHRuMHQyejZWYlYvT3R1dFYzNi9XWTFIcnRtejd2V3o3NWZJSFhyd3dsUDdvMU5iMDFGdmIvRzBBQUYyZXZQMXkrdHorSytuK202NVZmZmdQVW11MjVISjVVV3RWa01UTXlGUFo5a1Q1QTcvMTZtajYzV1BiN1cwQVlGNWZQRFNSdm5UUHhhb1BmVDI2SlF1U3JwbVNxalVrdjFXT2tSK2RIMDUvOTN0allnUUE2RXMwdzkvSjJpRWFvdVNKZG10MEtjK1F4RFRLMTRvUGZPL3NTUHFYeis5S2w2NWJHd0lBTE02T3dXYjZqWWZPcDQrTlRaWS85TVcwNy9HdlZnVkpuSllUSzJIM2RCNTRkbnc0L2JQbmRxV0wxK3IyS0FDd0pLTkRqZlNiRDU5UGoreWVLajU4THR1T1psSHlicnhUTEkxL1U0eVI4QjllR1JVakFNQU5pWmI0OXkvZlZINDRMcWoyRzUxM09yVnhSN2I5ZytKbnhRTFdWeThPMllzQXdBMTc3ZEpnK3Nvcm8rV0gvMzQ2L2ZRZHhTRDV0V3licVk4ZnZ6ZGtBU3NBc0t5Kyt1YjJ2REVLaHRvTmtnZEpiTDlhL0doY1p3UUFZTGxWTk1hdnB0TlAxenQzN1QzWWVmVFVsWUgwdjQ2NzZCa0FzUHlpTWFJMUNxSkJQaEpCOHBuaW8zLzZ6aFo3Q3dCWU1SV3Q4ZWtJa2tlTGo3endub1dzQU1ES3FXaU54eUpJN2kwK0VqZktBd0JZS1JXdGNXOEV5ZjdpSTJjblhYY0VBRmc1RmEyeFB4N3BPaWw0WXRvbDRnR0FsVlBSR3FNUkpGMTN2Ym5XRUNRQXdNcXBhSTFoeDJjQWdEVW5TQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBTUdnWHNObGN1ektScmwyKzFQZm5qOXkwT3pXdVgwc1hUcjdaOWZoTkIrNUlRMXUzZHoxMjl2V2ZkTDIvZGRmTmFkdllyVFB2WHo3N2RucnBUNy9SOVRtN3MrOXoxOGMvbS8vNVo5LzU0elJlK0RuRmo4MG5mdTZ4WjcvYjlkalJUMzIrNjJjWHhjL3AraDBPM3BsMjNYNjQ4bVA3SC9odzJwTHRnL0p6NjFmVmZ1cDQ1NlVmcFlueE0xMlA5Zk44bC9PL2hlZS84ZnMzL0gyR1JyYWtvNTk5b3VmelhBMXJ2UzlCa01BaVJWaVVCKy81eE1BZXlsOXpxQjBjUmVYUE9aZ041aEUwQTBQRFMvcGRwNmNtMDlVTDQ2bHhiYW8xOEczYmtROTZ4Y2ZDNU1URlJYM2Y4WEpjN1QzUTgyTzNIbm13OHJuMXZmK3lmZFJyb0Q3KzR4L09pYlBWZEh5SnoybE8yRXhlVGNlZStYYTYrNU9mbi9memZ2alVmMXZWNTNlWGYrNElFdGhjeXJNYS9RN1FNZUR1dUdWZno1bUtCZVBwek52cHhXLys3OWtJZXVUbjB0amgrOUtwN1B1V3cyRWpLTThBVllYUytESVAyaDkrOHU5VlBoNHpQc3U1RCtQdkttWXA5aDc5b0g4d0lFaGdZeHZaUHJxaTMzLzYybFNhdkRBKzUvR1lZWW5EU1ZXdW5EK1h6OHhzQnZFYzQ3bE1uRG1kVHY3azJXWC8vaEdna3hNWDBxN2I3c3hueFc1a2R1eEdiUjNkNlI4VWdnUTJpamoydjJOc2IrVXI5WDQrdjd6ZVk2R3ZYOGpvM3YzcDlLcy9YcGJuRllQaG5QRElZcVJxdGlkK1pxK2ZHek5CY1hpcWMraHFQcGZlUGQxMUdDWitqNlhPRHEyRXF1ZGUvUHRiN0pxTDE3NzlqWHhtcE9qZE4xN0x0NVRtWDhlejB2WWV2czgvY0FRSmJCUVJGMVdEVUsvREJ2SDVuVFVWTWRBVVArL2dJeitYTDVhTlYrQzlnaVMrcHRjaGhEeEk5dDJlN3YrcmZ6MU5aQU43NWF2ZTlwcVZXSVJhWFBkUk5EQThuTGJ2MmJmc3I4ejdHVmpQdnZGSzEvdTc5aC9zSHZRTHYzZk15cFFqYU44OUQ2ejRMRkd2MllRN0h2dkVvci91MEVjL21WNzY0Ni9uYTBqNnNaZzFNcGZPdmpQbis4YnZ1V1dCbVkvQjdPOS9OTnZIblVYS0lFaGdBeWt1TnB3dkdNTHIzL21UZktBb2YxNW5zV3lzODZoU2RZWk44WlY1UDJleHhPR1QyT1l6UFRVMWMwWlErU3lmbGRhWkdaZ0pyRkkwRlFmSmk2ZmZtaE1rdTI0N3RDWXpDb2NlL1lVbEJWd3MxcjNuRi85YWV2WFAvazlmVWJLWUdaaXE5VFl4NnpGbTVnTkJBblJtU1dLZ2lGTkdsOU94WlRyam8ydWd6ZUtvT01EWHMwSDNwajIzempuTUVJOE5ESS9rZnk0UGdoRk1NZXV5a0FpTXNwang2V1ZxNHRLcS85MlZaeWkyNzk1elE0dU9RNXdTZmY4dlBaa2ZEaXZING1aWmV3T0NCTmJqUDRyMjRQeHU2ZFg5K1BHZnpjeEtyRmN4ZUI1NDhORjBvVFJURTQ5MUJ1WHk0YXJpcS9yNVpuRXV2SE95Ni8xYjdyeDcwYk1PODYzeFdHcVFGV2NVNG5CYk9ScjZtWFZhaXEwVnB6dWZmK3YxZkFhckgxY3Z2cmZnUGw2STJSUUVDV3hpMjNidHlmN3ZhM01PTjVSbkhjcGlkaUplb1cvRTAzVTdGak9MMDlwUHFlK0FXUTBSSGlzeEU5VXJoc296TCtQSDM3aWh2Ly84dE9oRmZMMGdRWkRBSnJiOWxuMzUyU05WYXdiaThWN1Q5REU3RWJNTnZSYk1MclIycFdwTndVSmZBeUJJWUpPS3NIam9sMzhsLy9OaUZzUFNyWHhJSXM0Z1dlcXBxcGZQbjVtem9EWU1iN2VHQXdRSmJOSkJ0TmM2aXVManZXWlFOcnI1b211eGwwVy9VZ3FTT0oxMUtZY1k0bUp2VlJjNWk4djJseGZWeG4xMWp2YTV4dWY4aVdPVnB5WEhtVUQ5c0tBVkJBbXNtQmhFZTYxQnVORzFDVXU1ejhsQ1g3T1dGK1phS0NMbS9EK2I0ZUY4MFdlc3M2Z1MxeThwQjB0OG41LzkrZE56NGk4VzFGWmR3ajBXbWZaN0E3eXFoYTV4alpUbDNwL2xoYmNkVllmb2VuMXVyMVBLUVpBQVhpblBvK3J5OWJFSU5zNUE2YlZvTXg2UDA0K0wxekk1K2R6M0trOWhQdkR3eHlxL1I5VmRrUmNqdnJiZnIrOFZENEFnZ1J0NkZic1VXK2U1MCsxR1VuVnIrd1cvSmh2ODQweWEvUTk4T0Y5M3N4eCsrc3lmcGFOWjRNVXNSZnhPNVhVamNhanM0SWMrdm1iM2p3RUVDYXlvT0xPbWNXMXFSWC9HZkpjVmo3VXJWeXF1UzdIUTE5V1hhV0NPR0ZuczZhcFgycjl6NTFMN1hSK3JPQndTQzFEakVFengrVlJkUGoydWxIdmd2a2U2N3BuVGNlZGpmMlhaNGdjUUpMRHVuTW9HdjZWZVA2TGZzMjk2WFZZOHJnZ2I5MHZwSmRZMUhIajRveHQrSDhlc1JpeENMVjllL3RYLzkzVDMvc2dDcGVxd1NjeGl6WGRsMlB4bkRBLzNmVCtaNmFuSk9ZZURGbk92bmZWOGdUd1FKTUNpeEl6QnNXZStQZThaTzUwelFXNGtTcVpYZVBhbkxHNnNWMWExMWlZQzR3TWYvY1g4VU0xOEloVDZXYThSTngwY0x2MmNYb3RVWTZGbytZcTJ2ZTYxRTlFWU4xYnM1L3NDZ2dTV3pYeDNYVjJ1SzdGR0pMejlrMmNyRjIzR29aQmlwRVNVVEYrYnpCZHpMclIrWXFUaWtNYmJMeitmRDZEbjMzeTk4bXRpOXVhdUJYN2Y4aGsvOHkzcXJBeVNIbXR0WXNaazMvalpPYWZnRnZmSHJmYzkwdmMrTForTkVuZFh2dEhEUEhFYmdmTHY1N28wSUVoZ1VjbzN5ZXZucG5uejNYVjFmQW1uNzFZTjZGVmkwV2JjOGo0RzF2SWRabU9CWjNtUloxVVVSTENVcjVNUzBSTm5yRlF0RWwwUElqak9ackZVTlZNVU53WHNkeEZyaEVmRVpIRTl6dkcvL0U3YWZiQTd0eGFhYlNuZmsrWnNLZVFpa2dCQkFvc3lmcXg3RUw3UXh3ekhXdHlISlJ6KytHZG1ycVd4bU52ZWw5Myt3WS9PT1F4U2RhWFRzVHNPcjh3K3I3aWo4SHhpcHFqWDg0enZOZkxjTTMwZnN0cTU3MkJYa0VTTWxXZWhGZ3FTaGU1Sk03SmoxRDhzRUNRd3Y3SEM3RWJNTkx6NGY1OHFEVFkvcTVodWYySE9JTGhzaDJhbUp2djZ2UExOMnVMVi9sS2pKQTZESE1wZTRjOTNUWTNGSEFwWlNTZXoyT2gxdUtZalBoNkxUZnRaUnhMclFCYjZmamRxZE84Qi85QkFrRUQvNGl5TzhtQWVyNWF2WGhoZnRkTkg0K2ZGWWFLcVdZSzRlbWxjTUN6TzJLaGFKQm0vNDlIUFBwSFA4bFJkSnlUT0twa3Z6R0l0UjlYZ0hJYzE3dnI1eDFma2VoNVhLeTZLdG4xMzlaMkI0MEptVmI5ZjFhWDVJNjdLRjA2ckV2dnhubDk0UEIxLzd2czlUNlcrRWZIM3VORHZBQWdTNkhMcUp6K3Fqb1NUYjg0YkpESG8zTlRqVmZCU3JnUWFaOUxFMnBDbFhFUXR2cWJxTXVrTGlkbWh5ejB1ZGhZRGRjVGFTZ3lzVmRkenFRcWZXS2RSdFM5ajM5L3gyQ2Z5bWExeWxMejFvMmZTbHAwM0x4aVRjZmJPZlF1Y0lqeWZ1TmhiMWZWVjRyb3ZxM2tkbEtyTHk0TWdnUTBtVHVzc3ZrS09tN0YxTHJZVml4VG5HK1NyN3F1eVVKRE1kNytSbUNWNS9odS92K3pQc1h3dm0rSzlZdWE3MkZxSU5TWUhKeTdsc1JBM3BZdnc2WFZqd2NVTW9IR3hzemxCTWp3ODUycXdWUU50SEVhS0dJbmZxZXB3VmZ3NUh0c3h0bmZtc2VMMVhlTG45eDFzRllmU1RyN3dnM3dSN1dMQ3hZWGFRSkJBcGFyN21jUWhpdDJIN3A0SmtoaW9PMmU5VkoyK3VaaDdtc3c3dTdIS2R3V2U3MTR4VlRyNzQyajdFdmlMZWM1eDVkV3lYajg3cmc4eWZ2eTc4LzV1RVNQRncwaTkxdERFbjR2ZjU2NCtmbjYveW90ZkYxSTFpN0phNHRvc3NKblU3UUxlRCtKc2toaHdWL04wellpUkdGQmpzZXBhbjE0YnovdWh6MzhoRDdQbEVvZE8raEV6VXdzZHF1cDFqNXFJa2poamlHNXhXR3M5TEVpRzVXU0doRTJ2TXp1U3Y2Szk5NkU1RngyNzBZRytJeTVJRm9kUWl1OFB0TmNjeE9HZk9LU3ozTW9YUWF1NmRIb2NmdHFWQlZuOExuZC80cGZTOFdlL2UwTXpDYkUvRHo3OGtjcklLTitrTU80UjFEbWtzZnZnblQzWDVYUU9HVldKZFM1eHc3MnErK05VRGRTcitvcXVGRkJWejdIWEplYjcrZHlxdFN4eHhkdk5jRU5IS0tzMVQzMnpXWHpnNTUvZVo2L3d2aE5uaGl6MjVucXJ2Y0FSWURQNTg4ZFBkNzF2aGdSU0VoWUFhOHdhRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBREs3TDM2clpUSk1YenFlcjQyZlQ1TVgzMHZVcmw5UDAxR1JxVGpleUR6WDhyUUhBQW1xMWVxb04xTlBBOEVnYTNMb3RqWXp1VEZ0Mmo2V1JtM2JGQndYSmZLNWZ2Wkl1SGorV0p0NDVtUVhJVkw3RFlvZW1XbXJ0dkd6SDFtb0QvaXNEZ0Q1ZTNEZGpiSjI4bW8ydlY5T1ZjMmRTZXVPMUxGQ0cwL2E5QjlMb3dVTnBjTXRXUVZMVXVEYVZ4bi82U3BvNGZTTGZlYlY2Rmg2RFErMGdxYlZpSkkrNXp0dVovdk1mSEFETVZranBqODNXMjJaelptdE1UNmNMSjQ2bGk5bTJmZDl0YWZjSGpxVDYwTEFnbVhqN1pEcjN5b3VwMFpodWhVaDlJTnNpUE9yZFFaTDNod0FCZ1A3N3BEbjdkbVpycE5USTNqWWE2ZExwRStueU82ZlR6ZmZjbjhYSmdmZG5rRFN6blhMdTVSZnluVkVieUNKa2NEQ1BrUlJSRXVGUmI0VklMVlhOamdnVEFKaG5sQzI4YVJiZVJvaGtML2pyclNCSmpWcldKNDEwNXFYbjB0WHpaOVBOOXo3WUdvUGZMMEhTbko1Tzc3N3d3M1JsL0d3V0k0TjVrT1FoVXEvUEJrbHhtK2tRSVFJQWkzajFQenVFZG1aSWFwMjNuWEcya2IvUWp3bUM2Y21yNlpZSFA5d2FsemQ3a01UTXlMc3YvR1VXSStkYXN5THhwR09HSkErUmVudG1wRDRUSURXeklnQ3dOUGtnMm15UHY3V1pRS25GWVp2MjBZaG1vejNXWmx1TXpURkczL0x3bzZzK1U3THFRWEx1cFJleUozeW1IU09sMlpGMnJkWE1qQURBY2xWSkhpSzF6aG1yK2RrM3JjTTJ0V2E3UkdhMmxJL1JzYVJpN09oRHEvcGJydXFGMFNaT24weVgzajR4RXlLdDJaSFdlZEtwYzdpbUV5YWRFQkVqQUhDRFRkSjlna2huaVVRKzdzWVluSS9GQSsxdE1EOThFMmUrYnNvZ2lWTjd6NzM2WWlGRWlqTWpyWFVqTlNFQ0FLc1NKalBqYm0xMkRXZWFpWktCZERZYnMvTnJnbTIySUJsLy9aWDgxTjdpVEVneFJwemFDd0NyR0NidHQ4VW9LYzZjeE5rMzUzLzY4dVlLa3JnQzY4VHA0KzFyakJRV3NKYlBwQkVqQUxEcVVUSzdock5ldUNiWVFIN1lKc2J3VFJNa2NUbjRacjZhdDE3WUNndFl4UWdBckZtVXpCeXBxSGVQMVRGMnh4aStPWUtrMmN5dnh0b3FybHIzTVNzeEFnRHJLRXBtMTNUbVkzWTJkc2NZWHJ5ZXlZWU5rcmhyNy9TMXFmYWw0R2RuUm9RSUFLeS9NSm1aS1dtUDJ6R0d4MWkrNFlQazZ2aloyZU5UOVpwMUl3Q3dubU9rWXN6T3gvSVZ0dUlYUnB1OCtGNXJrVXo3dmpTdGU5UFVkQWdBck1NdWFYYnVJNWM2UVZMUHgvS1Z0dUl6Sk5jdlgyNWZBSzd6eENxS0RBQlkreHFaK1hQM3VKMlA1UnM5U0thdlRaWkNwRlo2Q3dDc2t5cnBmdHNPazN3czMraEIwcHh1ekQ2NVRwaVlHUUdBZGRva3hiRzZWaHJMTjNLUWRPNG9xRUVBWUlQRlNTdE04ckY4b3dkSjliTURBTlozaWF5dXVwME9BS3kxVlF3U015TUFzTEdzM3RodGhnUUFXSE9DQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUI0UHdWSjA5NEdnQTFsOWNadU15UUF3SnBiZ3lBeFV3SUE2OXZxajlVckhpUzFXdllqbWswZEFnQWJzVXV5TVR3Znl6ZDhrQXpVWjU5VkoweWE2Z1FBMW1lRUZNZnFabWtzMzhCQk1qQTBVcG9oYVpiZUFnRHJwRWE2MzdiREpCL0xOM3FRREc3Yk5sdGE1VU0zWmtvQVlKMjBTTE83U3dyamRqNldiL1FnR1JuZG1UMmZSclkxVStkLzRnbHFFUUJZaDAxU0dLL3pzVHNidzJNczMvQkJzbVgzMkd4bE5acUY0bXJPTFRJQVlJMUtKSFdQMFlVeE94L0xOM3FRak55MEt3ME1EV2RQcU5IYUdtSUVBTloxbE9SamRXdmNqakU4eHZJTkh5U3BWa3ZiYnoyUVBhZEd0bldtZjFwUHRDbE1BR0JkaEVoeGJNNjNHTE96c1R2RzhCakxOMzZRWkVZUEhrcjVVMmswQ2x0bkxZa29BWUMxajVIMnpFaGhySzYxeC9EVnNDcEJNcmhsYTlxKzc3YXN0S2JiV3lOZkpHTTlDUUNzYll3VXgrTDhKSlQ4aUVacnZONSs2MjM1R0w1cGdpVHMvc0NSVktzUHpGUlhzNzNOSExvUkpRQ3c2akV5YzZpbU15NTNaa2V5TVh2MzRTT3I5aXV0V3BEVWg0YlQyRDMzcCtiMGRMNmwyRXBSMGl6WEdnQ3d2Q0ZTT0V4VGpKRThSTnBqZEd4ajk5eVhqOTJiTGtqQzluMEgwbzQ0ZEROOXZSQW0yWTZZYm5UTm5DUmhBZ0FyRWlMNXJFaGhKaVFmZy9PeHVCTWoxL094T3BaYXJLYkIxZDRuTng5NUlFMVBUcVlyNDJjN2V5bmJCdkszK2MxNzZyWHNUKzBiOHRWcXJZVzkrVTZzK1E4S0FCWmZJek5OTWhzbHJaTkxPbXRHWm1aR3JrK25yYnYzNUdQMWFsdjFJS25WNittV0J6K1Uzbm4rQitucStYUDVmcXBGdU5Xei8xUFAvNUJGU0N0R1ltdk9uR3JVWEpYVGpnQmc4N1JJcy92UHpjSVpyb1UxSTUyWmtiZ0FXb3pSTVZaditpREpvMlJnSU8zOTRHUHAzTXMvVHBkT24yakZSak5tUlFabVprWmlwaVNmSVltWmtieERhb1ZKRW1FQ0FQT1VTT0ZOcy8yL3M2ZjJ6Z2JKOUV5UXhHR2FtKzk5b0hXMFlnME1ydFd1aWljOGR2U2h0R1hYV0RyMzZvdXBjZjE2YTRhazNqcHNreHJ0dDZrMk96TmloZ1FBRnRFbGhYVWphZllLck0zR2JKRFU2d1A1ZUx6YWEwYldUWkIweEVMWExXTjcwdm5YWDBrVGI1OW8xVnBFU1JSYSs3Qk5hMHVwZTVhay9UNEEwQ21RMGgrYk0zZnVuYm5FUm52ZFNJeWdPMjY5TGUwNmZLUjFpNWMxTnJnZWRsL3NpTEdqRDZhZGR4NU9GNCsva1M2OWZTbzFyazIxUTZUZTZnNnpKQUN3aURZcG5yR2FaaTVJR3FmeWp1NC9tRVlQM3JscUZ6M2JNRUV5ODh0a08yYjMzZmVsM1llUHBza0w1OVBWOGJOcDh1Sjc2ZnFWeS9tWk9mbWltK1EwWUFCWVNMNEtjMkFnRFl4c1NZTmJ0NldSMFozNW90WDhSbm5yOE1YOTRQcmNpN1Uwc25OM3ZnRUFtMS9kTGdBQUJBa0FJRWpzQWdCQWtBQUFnc1F1QUFBRUNRQWdTT3dDQUVDUUFBQ0N4QzRBQUFRSkFDQkk3QUlBUUpBQUFJTEVMZ0FBQkFrQUlFanNBZ0JBa0FBQWdzUXVBQUFFQ1FBZ1NPd0NBRUNRQUFDQ3hDNEFBQVFKQUNCSTdBSUFRSkFBQUlMRUxnQUFCQWtBSUVqc0FnQmdQUVRKVlBHQm9YclRYZ0VBVmt4RmEweEZrRndzUHJKOVFKQUFBQ3Vub2pVdVJwQ2NLajR5TnRLd3B3Q0FGVlBSR3FjaVNGNHVQbkxIdHV2MkZBQ3dZaXBhNCtVSWtoOFVIM2xnNXpWN0NnQllNUS9PYlkyL2lDRDVWdkdSVCsrOWFrOEJBQ3ZtVTNOYjQxc1JKTTlrMi9IT0kvdTNUcWNuYjc5c2J3RUF5eTRhSTFxaklCcmsreEVrc2JMa2Q0b2YrZHorSy9ZWUFMRHNLaHJqZDlLK3h4dWRDNlA5ZGlwY2orVCttNjZsTHg2YXNOY0FnR1VUYlJHTlVURFZicENaSzdYR2RNbC9LWDdHbCs2NW1PNGVkY1lOQUhEakR1KzRucmRGeVg5Tit4NC9YZ3lTOEsreTdXenhzMzc5eUlVME91UzZKQURBMGtWTC9QcTlGOG9QUjNQOGk4NDc5ZElIdmxUOHpFZDJUNlYvL2VCN2FhdXJ0d0lBUzdCOXNKbTN4SWQyVDVVLzlFL1R2c2ZQVmdWSitGcTIvYWZpQXg4Ym0wei83cEZ4aDI4QWdFVzVlOGYxOUc4L09KNjNSTWwvem1Ma2Q0c1AxSnFudmxuK3BPRnMreC9aOWtUNUExOTVkVFI5OWRoMmV4Z0FtTmV2SEpwSVg1NjdaaVI4UGR2K1JoWWtVd3NGU2RpV2JmOHoyejVYL3NDTEY0YlNINTNhbXA1NmE1dTlEUUIwaWV1TXhLbTlwYk5wT3Y0dzI3NlFiWmV6SUVuOUJFa1l5cmF2Wk5zL3JQcmd5U3NENmR2dmJFa3Z2RGVVM3J3OG1ONmRyS2ZMMSt2cHV1VW1BTERwRGRaUzJqYllTTGVNTlBKNzA4VGw0RCs1OTJvNjBIM1JzNkpZRXZMbGJHdVZ5aUtDcE9OdnRjTmtqOTBQQUN6U21SUUxXRlA2YXRlanBTQ3A5L0dOWXFIcmZkbjJIMVBoNG1rQUFQT1lhcmZEZlhOaXBFSzl6MjhhZGZOcjJYWTQyMzR6MjA3WXp3QkFoUlB0VmpqY2JvY3ovWHhSUDRkc2VvWE1SN0x0TTluMmFMWWR5YmFEMmJZanRkYWVBQUNiVzZ3RnVaUmFWM3QvSmR0K2tHMS9rbTNmVDYzNzVNMnZkTWptL3dzd0FPRkhjS1lHQksrQkFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvME5EazRRVFV3TXpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wTkRrNFFUVXdORE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalEwT1RoQk5UQXhNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qUTBPVGhCTlRBeU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4Ky9JS1RwZ0FBQm9KSlJFRlVlTnJFbVh0c1UzVVV4My8zMGZmYXZicXh3U0NiR3hNWmJJRkZCQklsRWpVYVlsQmpOQmcwRVJJakppckdZS0lHd2NRSEV2OFVFSk81aEljbWpQZ0hBaVp1U0ZSZ3dBYm9kTkF0YXhtdlBUcTJkVzNYOTczWGM5cmZjRnQ3MjN2YmJwemttOTdjM3QvOWZlNjU1NXpmNHpKTHRoOGdHWmdXdEFyME9LZ1dWQTBxQmVYUS83MmdmbEEzcUFOMEd0UUtDazNjb09yUVpsVWQ4bW1DTGdPOUNYb1JWSkRrdWdLcUd0RHpvQjJnVVZBVDZGdlFGYlVkc3lxdnJ3T2RBRjBDdlpFQ1ZzN3lhVnU4eDhtZWpRMTFhaG96Q2tOQ0Qvb0M5SFlHYjBYT0lxQnZRQjlDZUFTeTRlRXFRcVR6OFB2ZURNQk9oT1ZXN0FPOFhaVVJNQ01LSytCR2tDUk1IWmx4d3o2a0MvWlh2bHVaRmpEQXJwUlk5amM0c3BKWk02WUErbXhKQnAwUW1CRWlDNkhoejNCa0lyTnVqQW43dG0vWXYxQVJNTzhiTlVnc2QzUjJQUnNIYlVXRzNoZStOcVFFRm5UbXJ3akQxQ2E2VGFYVlJBNi9Wazh1YlZ0RGRqMjdtQmkxbkdxVUhCMVBkcSt2SVJmZmY0d2NmSFU1cVNnMHlqQXp0Y0N5SzJsWjQ0TGVla0dYY3o1Uk5hZ3FNcEh2Tnl3aitVYk52WE9YYjQrUkxVZitKcjZRb0JoMi84dDFwSGF1NWQ2NTRmRVFlZjJISytUNnNDOWh5UU9tUnlxYTNyMGM1MkdvZ1l6STY3K1VLMTJmclh0b0NpemE4ckpjc3UrbE9rV2VUZ1NMVm1qU2trK2ZXU1JiOGlnVEV3Y004YkpDNHZnbjVGcFdGQ1IrZFJQUXBpVFFjckNUUTAzT2dPbEpaSnNDSFBXdVJ2L081Q2VaYm1jY3c3STNSZWk5TXRDcFlORis3N21iZkRpWXhNWVZyOEU1Q1dQeGxkYnNoMERYeWJVNjZ4Z2h5K2Zua1ZLTFB1SC9lQjcvYjdZNVNWaVFGTU8yMzNTUkQ0NWRKUkZSa3ZjeXk1Y0QyeDdEWUZjdzZtSHZndnBINFlRNTJXT09RMks5QlFtR2lhYkUwMHBodHpSMWtFQTRSZElDVzVRUlBiejYxbkYyZE1tNkxhTEdzREpWNHFEbjBJTktQTDErYVVsMllQOGZlWjE1MTM1dFJnOXJKRTVUcTdTT0t2VjBObUZqeVJkbDFDQ3dUdVMwRldxS3Z4TG9iTUtpVVVZZEcxM21zRnloMm83VGdVNFhObGJQb294YUJPWWxoaldtTStLcmdjNElGa01peHNnak1FY3lNSVpoNEM1TWFnZkJOUnhETWpXT2pmWXBDZjUwV2lzcFhVb0dGMFdPaVRFeTBUck1SRUpqTXdtYkRlZ0pSalphTVVLK3ZwbUd6UlNhTWtvSUxIQitsejJic0poZ1NrZEV4Y0F4UmdHQkkvb2hlM3MyWWJFYXFCbkdGZTB6M0xYalBrWUVnVU41dHBaMlJvejRzd1dMcFV2dDNDUDVzQndKNUYxclJxZUdFRGpJKzBaR3RLNit0bVNOZGp6OW9PcmhWaW4weDA5Vko5L0FjL1ZkaExVbXptK2pzN1V3eUcyeG56bWVyTkhhYW10YWc0SVM2TFhWUlVtQnpZNnp5T1pHVnJablk0T0lNOHpjcmxOdEdvL3ptbHdqMjZBMzdSRXNGWFNYMHl2YkZwa2daTnZvVHFnNHNVUWFCem56TzM4NVJDUkpUTlR3azVPMjZJSXgzZUZXRHRycERaTHRKMlQ4QkN6NW5TY1A0bVdVTWJiaUtPZzRocENNYnVTRzRDOVpWQmJKc2NiTjNrWjlZZktIZlpnc21tT0dKT0ZKUzljUTJRWXJCVFZ6ZzRuNWRGbWVnUlNiZGVUcWdJZHMvZWxmY25NMGNiNGJuTjJuaTlwL1BBS0gxMEdlS2N0OFdOZmhqUHdCd1pENzhNMTFPejhYOUpaNTVENGFGM0QzTFRpeDh5UE9QNGJoNEFBRnBtK2tCRUVEY0lHanVMVnhMd3lGNC9kdDN3ZjZCb1k5eUlKTWxHM3FNaCtTVDZKdTd6WGQ2ZmdMWHNVK1dKYUVaaDBXK3NTK2tRRlpLTk85RlNwZE5jZHNwSGE5Q1BHTVpVNkVlQTd5ZnRlQXIzUnhIVXllTmJNQ0s0UjhSVzJIOTFwNi9qeUh4WVBFdm84RXAyOG1UemVNbFR0WVVhQWhDd1hiTjdocTB5YUk3Ymt6R3JQK3NiNDVyWTJOeHI1LzBMUGRsQ0Z1UjM2S2g2bVhDZlV5cG00RTZtQVlCcFhPWUdHNUtXS3l6by9PMkxOcFVMb01nN1l6ODVwM04raGN0MjNVc3pkb0daTlNBaytEeGgyNkFDdUVKWXZqbkVQcjd1OEo1WmNWQ0xxY3JHekZhdDBETmdpQkE5WXJSMDlCSDcwVTlwWWNiTnp1WmR5TzVhSE42RTBzZHdoWURpb0Q1WHZMVjFTNXF0ZXVCcTh2aGVXM1VWMmNodjI2NGQ2TzNPN1Q1OHk5RjNwSTdEUFliWnBnZDJrWXlHNERLZnFLQk9DWWRMZ3pWQUxDK2x3TXNvZ2F2Y2xUc2FyU1YxcFRHVFlYbFFyNjNDSTRaNUZZWGt0bldTRTJISEJ6Z2JFaGpXZW8zOWpmYVRkZmI3WER1WEU2TjNEU1dCMmcxU0NjOG9HVmZnbWwzc2E5Tnd2MU9NNVljT21kUTkrQ2hvcWJ0S21JbmhJb1NKaDZEK2NFT1BNYW9oNTEwMG9nS1hwRHoxV29ybGdNaVgyeU5WS3ZXK2d2Z2hzbVFaTkpzSDRLNnFHQUhwb2ZJYVdneWNwYXlyeW1Ia0dOVVVBZGZRaGV4c01SQ2hla0R5Q21tNmovQ1RBQUExa2hBUE5CUmZrQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVFBQUFMNENBWUFBQUJMRCt3a0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMU5VUkZOakZHTnpOR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8xTlVSRk5qRkdPRE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalUxUkVVMk1VWTFNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qVTFSRVUyTVVZMk0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K3hCVkc2d0FBRHo1SlJFRlVlTnJzM1U5c1ZWVWV3UEhENjJ0THJYVmFDcHBhYW1ScUpDWE93aUJ1UjkxTlluUmhvakhqeWlIQi8ydGpqQnZkdUZZVEhZa3JaM1NTV1UweTI4R1pwVWpHaFlLWUlDYlFhWVovVmFDVXZyWVB6Nis4NHUzbFNsK2xMeWI0K1NTL0JlZSs5aVhuYmI2NXZaeTM0ZjJEbDlMUFVNdXpLOCtEZWU3TGMzZWUwVHo5ZVhvVEFIQ2ptOHN6azJjeXo5ZDVQc3V6TDgvK1BNM1ZmbmozeE1wLzE5ZjQ1bHZ6UEovbmozbkdmQllBOEt2VjI1cE5lWDZYNTdIVytyRThmOG56VHA3ajdmNnlXcHV2RzI3OTRpTjVYaFlqQU1CUEdHdTF3cEZXT3d5dlY1QThudWVyUE0vbDZiSFBBRUFiZWxydEVBM3h4R292cnE5eTdhMDh6MVJkbkoxcnBQK2RtazdUNTJiU3pPeGN1amczbnhhYXpkUnNObjBFQUhDRHE5VnFxWjVuWTI5MzZ1L3JUVU1EL2VuMnpVT3ByL2VxZXhlYjgzeWM1NEU4TCtaWldFdVEzSlRuYjNrZUxsLzRMZ2ZJc1JObjByZFRKMzBhQVBBckZUY2dHakVMQytuc3pHeWFPdlZkT25oME10MDVzaVdOM2JvcERRNzBsMzhrYm5ERXM2aHh0K1JDTzBFU2F4OVZ4VWk4MFpISi8vc1VBSUJLY2NNaVpuejB0clJqMjJqNThzT3R4b2dIWUZmY0thbDZodVR0UEk4VUY4NmNQWi8rOC9sWFlnUUFhRXMwdzcvL2UyaXBJVW9lYWJWR3VsYVF4RzJVUGNXRms5Tm4wNmNIajZUdnoxK3d1d0JBMitKUE9kRVEwUklsZS9ZZVNrLytWSkFNbDR2bDlQZm4wNEhEUjlQOHdxSmRCUURXTEJvaVdpS2FvdVR0SENWYnFvTGtqWFQ1U2RncnZ2am1tQmdCQUs0N1NxSXBTdUpBdGRmTFFYSkhuajhWWHhVUHNNYXRGZ0NBNnhWTjhlWFJxdzV1Zlhydm9hVUd1UklreiticFhyNGFaNHQ0Z0JVQVdFL2ZUSjVZYW95QzdsYURMQVZKekZQRnE4ZFBuTEZyQU1DNnEyaU1wL1llU3JYbGIrM2R1cng2NFdMRG9XY0FRRWRFWTBSckZFU0Q3SW9nZWFpNE9uVjYybTRCQUIxVDBSb1BScERzTEs2VS9yWURBTEN1S2xyanZnaVM3Y1dWK0tJOEFJQk9xV2lON1JFa0k4V1ZpNDE1T3dVQWRFeEZhNHhFa0F3VVZ4WVdIWVFHQUhST1JXc01SSkQwRkZlYXpVdDJDZ0RvbUlyVzZLblpGZ0RnbHlaSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUVFSFNXTEZRMjJCWEFJRE94Y2ZWcmRHSUlEbFhYS2wzZGRrcEFLQmpLbHJqWEFUSlZIRmxZMCszblFJQU9xYWlOYVlpU0E0WFYvcjdldTBVQU5BeEZhMXhPSUxrUUhGbGFLRGZUZ0VBSFZQUkdwOUZrT3dycm93TUQ5a3BBS0JqS2xwalh3VEpwM21PTDYvY3RMRW4zVG15eFc0QkFPc3VHaU5hb3lBYVpIOEVTVFBQaDhVclk3ZHVzbU1Bd0xxcmFJd1BkMCtrNXZMQmFPK2t3bmtrZ3dQOWFYejBOcnNHQUt5YmFJdkJsYytQTkZvTmN1V2sxcmhkc3JmNGloM2JSdE10L1gxMkR3QzRidEVVMFJZbEgreWV1UHpZU1BIbytOZnluQzYrNnA3ZmpxWHV1b1BTQUlDZkwxb2ltcUlrbXVQVjVYL1VTaGRlS0w1eStEYzNwNTNidDZWNmw2KzhBUURXTGs1bGpaYUlwaWg1YWZmRWp6ZEN5cVh4Y1o3M2lndGJobTVKOSsrNHk1OXZBSUExaVhhNGY4ZjRVa3VVL0RuSHlGK0xDMVczUGw3Szg0L2lRbFRONysrZDhLQXJBTkNXYUlab2g0bzdJOUVZTDVZWDZ4Vy9JNTU0ZlRMUDMvUDhvWGdoSGthNWZmTmdPbmJpVFBwMjZxVGRCZ0JXaUhORzRyLzJEbGFmL1A3UFZtTTAyZ21TY0NIUG8zbmV5ck9uZUNIZVlQbS9CVStkbms3VDUyYlN6T3hjbXAyYlQ0dUxpNmw1NlpKUEF3QnVjTFVORzFKWFYxZnE2KzFlK202YU9BNCtUbUF0SFhwV0ZJK0V4SjJSK2FxTDlXdThWL3pBTTNrK2FZWEo1dUxGZUVOL3dnRUFWbkVxWFg0YzVLTnJCazRidnlnZWRKM0k4MjZxdU1VQ0FGQ2gwV3FIaWRWaXBOMGdXYTZiWi9PTTUza3p6NlI5QmdBcVRMWmFZYnpWRHFmYSthSDZHdDhrVGxON09jOHJlWGJsZVNqUHpqeDM1OW1hSng2bDdmWlpBTUFOTHg3dE9OOXFnNi96SE1qenJ6ejcwK1h2eVZ1VEh3UVlBTnNGWU1XYTk5TXJBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+W6lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJOMEl5TUVZNE1ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk4wSXlNRVk0TVROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZM1FqSXdSamRGTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkzUWpJd1JqZEdNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtvNUNybVFBQUJwMUpSRUZVZU5yRW1XdHNGRlVVeCsvTTdPNTBkOXVsM1Q2M3ROQW5GYkN0dGlsQkRURVNVZUVEUWEwZi9HQjR4T2NYUmZsaTFHQ2lNZW9YL0NLdlJGUlFFNk9RRUpHS0QwQVRSR2hMZ0FLaExmVEZsbTY3cFZ1Nzc1M2RtZkdjM1Z0dDZjN3V6TzYyM3VTZlRuZm4zdnVicytlZWMrOFpuYVgxZlpKR000QWVBRDBDYWdBdEE5bEEyZlI3TDhnQjZnVjFnVTZEL2dJSjB3T3N2ZkNlcGdsMUtZTGVEM29aMUFxeUpyalBTclVTOUNUb1hkQWs2SHZRUHRCRnJST3pHdTl2QkIwSFhRQzltQVJXcWVYUnZqaEcyNm5tblkzekFad0YyZ1hxQkcwQU1TVDlobU9zeHpFQitoTlFWcWFBYTBEblFLK240VUxKM0hJN3pnSFFOV2tCTTdLMGlpNlNSakwvRGVjNGY3cnBuZFVwQVFQc2FwbGhUOEZsQVZtNFpvVTVmMHNFSFJlWWxjVmE2SGdNTHMxazRac1o1LzY5NmUxYVZjQzg0RFpDaDhNTGJObTdXd0V5L0ZtLzNaZzBEb2YxNW85bHdqVEVHNlcwS0o5c2UzbzlXV29ySmgxWGU4akJvNytRa0NCb0lqRm04V1R6cHNmSWZmZlVFUHVvazN4KzVBUnhqRS9NdVE4WmdPVWp1SHh0NXVjY3YyTHR2Ly9vSS81bWtlUDN4N1A4NHVJQzh1WUx6NUtTQWl0aFdaYVVseFNTdW9veTBuNmxoNGlpcUJwMng5Wm5TUDJ5S3FMak9HSmRaQ0V0OVhYa2NuYy84Zm9EYzZFWnRubTRxT1g0MHJHempqa3VBU21TQWRnUGxVTFg4NjBiU0k3Wk5PdXpXZ0Rlc2FXVjhBYURhdGpxOHRKWm4xdXl6V1RyVTA4b2hqekt4TXdCQm45WkpUSGNvMG85YllYeGs5bzBkQlp2MEF3NzA5V1VHakN0UTdaWndOUzZyeWJLWUYwOUE0cURJdlFibStOREo0UEZkcm03TDJFNm1Na1c4MkdHV0NZdFZlQzdESy9VNjhxTmdhalA1dWRhNG42UG4rUDN1QmdqMUtmVndQWU0yTW0rYjQ4UlVaSVU3NUZacm9Jd3pPNDh6MUFvYW1Gbjd2STFzQ3B6RWoxbU1DU1FYUWNQa3h1RHc2b3NyUloyMTVlSGlSQU9KL1IvWkVQR3FJWFhCODZ3UTdZMXI0RFpWeWRiT0dnNXRLQWFTei9VZEc5R1lQL3pYY201Wk96Y3IyaGh2Y1RvR3RUR1ViV1d6aVJzYlBGRkdmVUl6RXVzcmxKTDhGY0RuVW5ZS0hDTWtVZGdBNFNPZkswVHB3S2RLaXdOYjhob1lLT0pnbUZNcVNSOExkRHB3TWFDVzVSUmg4QmNXc2NHaGlFc2wvd2N3T0o5Yk5vSGxlaE1ET3g5QTZuMFZoTzYxQ1FYVllhSk1USlIwN0JTZUdvK1lUTUJQYzJJd0xJK0VoeVpiOWgwb1NtampNQ2lJZXpweXlRc0xqQzFHVkYxeFNiR0tDSndaSkZ2dURPVHNCZ050S1J4TlEwWXNZNFJRV0NoekhtK0U4NXhnVXpCWXVqU3V2ZEk2TCt5R0N3SFJtUkY0RkNXNEhhWkErTWRpVHB0MmZTNDVuU3JGdnE1amVzU24wb0Q0KzF3MXNSelZIUzNoak80YlJPWGZrelVxV2xGYlVwSlFRMTBvckd4bFV4Y1JqWTNzcktubW5maVJ0UmI1bXp2TUlZbXJ5dDF1dVZ3cHB6QmtrSGJGY2FPdWlJd2dUdDAwRXFvTkoyaWZMZ3RYanA2NW11R3lIRjMwZ2VPdEJHMzE1ZHl1bFdDL3R2dEpaOGQrVW1oK0NaTHdQUVZzbEhHMkltajB2RUhRakk1L2xGeE1xZXlMTWpuenRtOWVYd0JPQ2Ixa3lWd3hNZEZjdUZhTDlrTEp3VXRlNFBwL1hTUk5aZmtXckxKME1nWStmU2JvMlJzWWpMdS9ibWVXNmVYMlU5OEI1ZDRQdk5FSDJLNm9BM25PcXdlVmduNjdKYjI1Uzk5SU9qTmkvL0hRZ3JFWGQvSXF1djczektFdmVnTy9mZ2ozVjM1Q1lGRzRZYis1VU0vN09Ha3NPLy9nc1c1Z1dFM3NpQVRaWnQ5eklmRkoxT3pEK1pQM2JoVWEvOTVMMnc0aElXR3hUbHhibVJBRnNva3g2MzhESlErTElFL28xTktPWDVIaUE5N1JsMlc2a2FaWWZVTEFjdEtFWCtkdlcxUDZaMkxaM0ZOazlqN2tWREMyaHIxbGR1NDM0Q09MQzk0L05jck5tNEQzeTZkWDUvMWpvQWJmSkUvZFJNdDIwc1pnblBjWmFhRnFaVUp0VEttNm9ncDVBcERVcm5tTVplYVEzeHVPVzZmTStvQ0VMcnlQSU5ubW5vUEhjZ09PTHVwWllkb0dKT1RBdDhGN2NlbjVLU0liSnZvNmpjSDc5ejBHb3V0WVowcEk2VllVM0NpdSs1VzI2R2EyeWRQd2h5REZOYXVCRHNyck1WcldNSWlzUmN5Q0ZnQktnUGxqVmxYMXR3dWJIblFiU3F0aDlPc1NhT2ZCaXora2E3RjQ1MW5pMTFYYjVMWWE3Qmh1c0R1VURlUUZYOFJOUzhXQVJ3WEhWYUdTckR5Q2lyQ3dxUElHY3lqMW9acWw2V3FPc0JiYlNGOWRxSElHaXd5eTBXM1g0d2tDcHdrdVBtd2Q5d1ljam1zN3Y2K0VsZFhIeWNLUHJvM2NGSmZIYVhSSUdrV1l0UytDYVhXeHRxYmhWcThFQXM5SlBiV0UzOEZQUlUzbzZpSWxoSXBTSmhhRC9jRXVQTWFweFoxMDBnZ3EvTDVUWlY2N2VzazlzcldSSzF1b1g4UjNEZ0Rtc3lBRFZCUUR3WDAwUFVocUFWTkZOYVNOWmxhQkRWRkFYbjZFRG9GQzBjb1hJZytnSlRxUXYxSGdBRUFSREFtd2FOWUlRNEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFs+mXrS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1lc3NhZ2VDb21wb25lbnRcXFxcYmV0SW5mby52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtZTJhNGFjNmUvYmV0SW5mby52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JldEluZm8udnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuYmV0LWluZm8ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZT83NjYxZTJhMVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0NBQ0FcIixcImZpbGVcIjpcImJldEluZm8udnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi5iZXQtaW5mbyh2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiKVxcclxcblxcdFxcdGRpdi5yZWNvcmQodi1mb3I9XFxcIml0ZW0gaW4gYmV0UmVjb3JkXFxcIilcXHJcXG5cXHRcXHRcXHRwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0XFxcIilcXHJcXG5cXHRcXHRcXHRwLmRldGFpbFxcclxcblxcdFxcdFxcdFxcdHNwYW4g546p5rOV77yaXFxyXFxuXFx0XFx0XFx0XFx0c3Bhbih2LWh0bWw9XFxcIml0ZW0ucGxheWxhd1xcXCIpXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDkuIvms6jph5Hpop3vvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5iZXRtb25leVxcXCIpXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDlgI3mlbDvvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5tdWx0aXBsZVxcXCIpXFxyXFxuXFx0XFx0XFx0cC5ib251cy1udW1cXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOaVsOWtl++8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLm51bVxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcmVhZHkoKSB7fSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIGJldFJlY29yZDogcmVxdWlyZSgnLi4vLi4vZGF0YS9iZXRSZWNvcmQnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi5iZXQtaW5mbyh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcblx0XHRkaXYucmVjb3JkKHYtZm9yPVwiaXRlbSBpbiBiZXRSZWNvcmRcIilcclxuXHRcdFx0cC5jcmVhdGVkLXRpbWUodi1odG1sPVwiaXRlbS5jcmVhdGVkQXRcIilcclxuXHRcdFx0cC5kZXRhaWxcclxuXHRcdFx0XHRzcGFuIOeOqeazle+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5wbGF5bGF3XCIpXHJcblx0XHRcdFx0c3BhbiDkuIvms6jph5Hpop3vvJpcclxuXHRcdFx0XHRzcGFuKHYtaHRtbD1cIml0ZW0uYmV0bW9uZXlcIilcclxuXHRcdFx0XHRzcGFuIOWAjeaVsO+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5tdWx0aXBsZVwiKVxyXG5cdFx0XHRwLmJvbnVzLW51bVxyXG5cdFx0XHRcdHNwYW4g5pWw5a2X77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLm51bVwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICByZWFkeSgpIHt9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJldFJlY29yZDogcmVxdWlyZSgnLi4vLi4vZGF0YS9iZXRSZWNvcmQnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5iZXQtaW5mbyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuXHJcbmRpdi5yZWNvcmQge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGJldEluZm8udnVlPzc2NjFlMmExXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgcGxheWxhdzogJ+WNleWPjCcsXHJcbiAgICAgICAgYmV0bW9uZXk6IDEwMDAsXHJcbiAgICAgICAgbXVsdGlwbGU6IDUsXHJcbiAgICAgICAgbnVtOiAzXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2JldFJlY29yZC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJiZXQtaW5mb1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJyZWNvcmRcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldFJlY29yZFxcXCI+PHAgY2xhc3M9XFxcImNyZWF0ZWQtdGltZVxcXCIgdi1odG1sPVxcXCJpdGVtLmNyZWF0ZWRBdFxcXCI+PC9wPjxwIGNsYXNzPVxcXCJkZXRhaWxcXFwiPjxzcGFuPueOqeazle+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ucGxheWxhd1xcXCI+PC9zcGFuPjxzcGFuPuS4i+azqOmHkemine+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0uYmV0bW9uZXlcXFwiPjwvc3Bhbj48c3Bhbj7lgI3mlbDvvJo8L3NwYW4+PHNwYW4gdi1odG1sPVxcXCJpdGVtLm11bHRpcGxlXFxcIj48L3NwYW4+PC9wPjxwIGNsYXNzPVxcXCJib251cy1udW1cXFwiPjxzcGFuPuaVsOWtl++8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ubnVtXFxcIj48L3NwYW4+PC9wPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxib251c1JlY29yZC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTY5MmNkMGJhL2JvbnVzUmVjb3JkLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHAge1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xcclxcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/Yzc2NWYwMThcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBO0lBQ0EsbUJBQUE7SUFDQSxlQUFBO0lBQ0EsY0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLGlCQUFBO0NBQ0FcIixcImZpbGVcIjpcImJvbnVzUmVjb3JkLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXHJcXG4gICAgZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICBkaXYucmVjb3JkKHYtZm9yPVxcXCJpdGVtIGluIGJvbnVzUmVjb3JkXFxcIilcXHJcXG4gICAgICAgICAgICBwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0IHwgZGF0ZXRpbWVcXFwiKVxcclxcbiAgICAgICAgICAgIHAuYm9udXMtbnVtXFxyXFxuICAgICAgICAgICAgICAgIHNwYW4g5byA5aWW5Y+356CB77yaXFxyXFxuICAgICAgICAgICAgICAgIHNwYW4odi1odG1sPVxcXCJsb3R0ZXJ5bnVtKGl0ZW0ubG90dGVyeW51bXMpXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uLy4uL2pzL3JlcXVlc3QtbGlzdCdcXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgIHJlYWR5KCkge1xcclxcbiAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNSZWNvcmQoKS50aGVuKHJlcyA9PiB0aGlzLmJvbnVzUmVjb3JkID0gcmVzLmRhdGEpXFxyXFxuICAgIH0sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JvdW5zUmVjb3JkJylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgICAgbG90dGVyeW51bShudW1zKSB7XFxyXFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW1zKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfojrflj5bkuK3lpZbnu5Pmnpzlh7rplJknKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAvLyDkuK3lpZbmlbDlrZfmgLvlhbHljYHkvY3mlbDvvIzlj5bnrKzkuIDkvY3lkozmnIDlkI7kuIDkvY3nm7jliqDnu5PmnpznmoTkuKrkvY3mlbDkvZzkuLrlvIDlpZbnu5PmnpxcXHJcXG4gICAgICAgICAgICBudW1zID0gbnVtcy5zcGxpdCgnLCcpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIChudW1zWzBdICsgbnVtc1tudW1zLmxlbmd0aCAtIDFdKSAlIDEwXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDJlbTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCBwIHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogLjVlbTtcXHJcXG4gICAgbWFyZ2luLXRvcDogLjVlbTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG4gICAgZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuICAgICAgICBkaXYucmVjb3JkKHYtZm9yPVwiaXRlbSBpbiBib251c1JlY29yZFwiKVxyXG4gICAgICAgICAgICBwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XCJpdGVtLmNyZWF0ZWRBdCB8IGRhdGV0aW1lXCIpXHJcbiAgICAgICAgICAgIHAuYm9udXMtbnVtXHJcbiAgICAgICAgICAgICAgICBzcGFuIOW8gOWlluWPt+egge+8mlxyXG4gICAgICAgICAgICAgICAgc3Bhbih2LWh0bWw9XCJsb3R0ZXJ5bnVtKGl0ZW0ubG90dGVyeW51bXMpXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuLi8uLi9qcy9yZXF1ZXN0LWxpc3QnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c1JlY29yZCgpLnRoZW4ocmVzID0+IHRoaXMuYm9udXNSZWNvcmQgPSByZXMuZGF0YSlcclxuICAgIH0sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JvdW5zUmVjb3JkJylcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGxvdHRlcnludW0obnVtcykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bXMpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfojrflj5bkuK3lpZbnu5Pmnpzlh7rplJknKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOS4reWlluaVsOWtl+aAu+WFseWNgeS9jeaVsO+8jOWPluesrOS4gOS9jeWSjOacgOWQjuS4gOS9jeebuOWKoOe7k+aenOeahOS4quS9jeaVsOS9nOS4uuW8gOWllue7k+aenFxyXG4gICAgICAgICAgICBudW1zID0gbnVtcy5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAgIHJldHVybiAobnVtc1swXSArIG51bXNbbnVtcy5sZW5ndGggLSAxXSkgJSAxMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYuYmV0LWluZm8ge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG59XHJcblxyXG5kaXYucmVjb3JkIHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIG1hcmdpbi1ib3R0b206IDJlbTtcclxufVxyXG5cclxuZGl2LnJlY29yZCBwIHtcclxuICAgIG1hcmdpbi1ib3R0b206IC41ZW07XHJcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGJvbnVzUmVjb3JkLnZ1ZT9jNzY1ZjAxOFxuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2JvdW5zUmVjb3JkLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJldC1pbmZvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcInJlY29yZFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYm9udXNSZWNvcmRcXFwiPjxwIGNsYXNzPVxcXCJjcmVhdGVkLXRpbWVcXFwiIHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXQgfCBkYXRldGltZVxcXCI+PC9wPjxwIGNsYXNzPVxcXCJib251cy1udW1cXFwiPjxzcGFuPuW8gOWlluWPt+egge+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcXFwiPjwvc3Bhbj48L3A+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxFeGNoYW5nZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWYzNjdhODZlL0V4Y2hhbmdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LmV4Y2hhbmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcuZXhjaGFuZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwYWRkaW5nOiAxJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmNoYW5nZS1idXR0b24gZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDUwJTtcXHJcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzRkNzA1MDE4XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUZBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiRXhjaGFuZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cXHJcXG4gICAgZGl2LmV4Y2hhbmdlKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICAvLy0gaW1nLmJhY2tncm91bmQtaW1nKHYtYmluZDpzcmM9XFxcImJhY2tncm91bmRJbWdcXFwiKVxcclxcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXFxyXFxuICAgICAgICAgICAgZGl2KHYtZm9yPVxcXCJpdGVtIGluIG1vbmV5RGF0YVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJtb25leWJsb2NrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcIm1vbmV5QmFja1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cXFwiYmFyY29udGVudFxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cXFwibW9uZXlJbWdcXFwiLHYtYmluZDpzcmM9XFxcIml0ZW0uZ29vZHNpbWdcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cXFwiYm9udXNNb25leVxcXCIsdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5leGNoYW5nZSh2LWJpbmQ6c3JjPVxcXCJkb2V4Y2hhbmdlXFxcIix2LWJpbmQ6c3R5bGU9XFxcImV4Y2hhbmdlQnRuXFxcIilcXHJcXG4gICAgICAgICAgICBkaXYuY2hhbmdlLWJ1dHRvbih2LWJpbmQ6c3R5bGU9XFxcImJ1dHRvbkJhclxcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5ib251cy1idXR0b25cXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5ib251cy1idXR0b24odi1iaW5kOnNyYz1cXFwiYm9udXNCdXR0b25cXFwiKVxcclxcbiAgICAgICAgICAgICAgICBkaXYucHJpemUtYnV0dG9uXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcucHJpemUtYnV0dG9uKHYtYmluZDpzcmM9XFxcInByaXplQnV0dG9uXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICByZWFkeSgpIHtcXHJcXG5cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxcclxcbiAgICAgICAgZGF0YSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvbW9uZXktZGF0YS5qcycpLFxcclxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5QmFjazogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5Z2XLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBib251c0J1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBwcml6ZUJ1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZycpLFxcclxcbiAgICAgICAgICAgICAgICBkb2V4Y2hhbmdlOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIG1vbmV5YmxvY2soKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYnV0dG9uQmFyKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJhcmNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJvbnVzTW9uZXkoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbW9uZXlJbWcoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBleGNoYW5nZUJ0bigpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMzY0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtZXRob2RzOiB7XFxyXFxuXFxyXFxuICAgICAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5kaXYuZXhjaGFuZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5leGNoYW5nZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLm1vbmV5LWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1tb25leSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cclxuICAgIGRpdi5leGNoYW5nZSh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcbiAgICAgICAgLy8tIGltZy5iYWNrZ3JvdW5kLWltZyh2LWJpbmQ6c3JjPVwiYmFja2dyb3VuZEltZ1wiKVxyXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xyXG4gICAgICAgICAgICBkaXYodi1mb3I9XCJpdGVtIGluIG1vbmV5RGF0YVwiLHYtYmluZDpzdHlsZT1cIm1vbmV5YmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVwibW9uZXlCYWNrXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XCJiYXJjb250ZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XCJtb25leUltZ1wiLHYtYmluZDpzcmM9XCJpdGVtLmdvb2RzaW1nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cImJvbnVzTW9uZXlcIix2LWh0bWw9XCJpdGVtLmdvb2RuYW1lXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLmV4Y2hhbmdlKHYtYmluZDpzcmM9XCJkb2V4Y2hhbmdlXCIsdi1iaW5kOnN0eWxlPVwiZXhjaGFuZ2VCdG5cIilcclxuICAgICAgICAgICAgZGl2LmNoYW5nZS1idXR0b24odi1iaW5kOnN0eWxlPVwiYnV0dG9uQmFyXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYm9udXMtYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLmJvbnVzLWJ1dHRvbih2LWJpbmQ6c3JjPVwiYm9udXNCdXR0b25cIilcclxuICAgICAgICAgICAgICAgIGRpdi5wcml6ZS1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICBpbWcucHJpemUtYnV0dG9uKHYtYmluZDpzcmM9XCJwcml6ZUJ1dHRvblwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICByZWFkeSgpIHtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxyXG4gICAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvbW9uZXktZGF0YS5qcycpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YaF5bqVLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nJyksXHJcbiAgICAgICAgICAgICAgICBib251c0J1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgcHJpemVCdXR0b246IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WlluWTgS5wbmcnKSxcclxuICAgICAgICAgICAgICAgIGRvZXhjaGFuZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmcnKSxcclxuICAgICAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW9uZXlibG9jaygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ3OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYnV0dG9uQmFyKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDUyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTA1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYXJjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvbnVzTW9uZXkoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vbmV5SW1nKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2hhbmdlQnRuKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMzY0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG5cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmV4Y2hhbmdlIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuaW1nLmV4Y2hhbmdlIHtcclxuICAgIHotaW5kZXg6IDM7XHJcbn1cclxuXHJcbmRpdi5iYXJjb250ZW50IHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5pbWcubW9uZXktaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG59XHJcblxyXG5kaXYuYm9udXMtbW9uZXkge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG4uYmFja2dyb3VuZC1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwYWRkaW5nOiAxJTtcclxufVxyXG5cclxuZGl2LmNoYW5nZS1idXR0b24gZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgd2lkdGg6IDUwJTtcclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBFeGNoYW5nZS52dWU/NGQ3MDUwMThcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gW3tcclxuICAgICAgICBnb29kbmFtZTogJzEwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MDAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6ICcxMDAnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTBX6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MFfph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvbW9uZXktZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEVNelJFT1VVeE1qUXdNMEl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRU16UkVPVVV4TXpRd00wSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tRek5FUTVSVEV3TkRBelFqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1F6TkVRNVJURXhOREF6UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNclBGMXdBQUlOOUpSRUZVZU5yc2ZRbVVYTlY1NXZlMmVyVlg3L3VpWFVKQ0VrSXNFaVFHRzJJVEhDODRCRTdzZUp4aHpzU1FjN3hNNWdTZkdXS1MyQk9mY2M0c2VKTFlKak1tTU1Qa2pHTUhpRE9Zd1RiZ0pVYnNRaEpJUWxKTHFGZjFVdDFkZTczMXp2L2Y5NnE3RVpJc3dFaWtlVmZucXJxcjZyMzcvL2U3LzNyLysxb1JRaUJxeTZlcDBSUkVnRVl0QWpScUVhQlJpd0NOV2dSb0JHalVJa0NqRmdFYXRRalFxRVdBUm9CR0xRSTBhaEdnVVlzQWpWb0VhQVJvMUNKQW94WUJHclczMXZTM2U0Q2RLN3JPK3J1VkduRDVoUUxiTnZoNHp5VXFNbWtWTlZ0RFg2OEpwMWFGRWt0UWp3R3VEVFdlaExBclVGUUhXaW96cU1SYkwxYU4xcTFhcW5VOWpHU3ZvdWhkOUoyY291a0p2cmZ3M0pwZnJ4V0VjRTdBcVk1N2xmeEI0ZVQzK1BYOEMxNmxkRno0QnQwN0JiOWVwVm1KMGIxdDZqVVlpU1JHeHl3a1loNUtaUjgvZmM3SDdvTXFubjVKUVNweGRuenRldlhFOGdIMGw5cUVnRy9YQVdlZVFEUXZNam8zZmt6UDlsK3ZwWnUzS3pFVGlCRTd3Z1VVajE0ZEFwNVdpTy9LU3hWRHoyZ0pzd05LZWkxRUczUmxGV0M3RWppdlBQdThXeGo1dmxzNitvQnZ6YjRJdndtS1VDSUpmVnVhUWhNckNCZVdSbEV6WXExclAyVzAvdW90Um52dlRqVkpJcUxaZ0ZlZ1BneFk5Q3BzeUF2WW1raFFRbUI4ZXMvajkvM2dQWVVrWGNsQlNUUkRUN2R1MTl1N3QvdlZ6VjkwcHNkMk9mbUQ5OWo1dy9jSngzZEFta0RTRUFINlZvRmtEQlE0OVRxQldZV1JHZmkzNXNBbG40OTFkZmNwU1FMTG02Sk9xc3doaVVVczdHYllGKzl4ZW1ublR1clZuNmQ3MENKUTQxQ1RYVEJYRGV5TWRmWHZORTVzK21OcitMbTdmSHZpUHp0MUZhWnVuUGwrRWFCblJ0TnpCUlNuaUZRc2U0UFpzK00vR29OcjE2bHBVcVhlRUVraWdTRGlTNEE4ellwUVRnRWl4RWsrWVR6b0xMaitKS25wNDFETUpnSzJ2OC9vK09CL2NvNGYvblJxK3FrdkVDMFB1bTRTNzNSVTMxR0FxalJYcnFlZ1VDYUpxVnZwanBWcjdvNXZ1T3pqYW1lS1BqeEtRSllJRDU3VTdFbkE4TVVhY1VOU3BPdmhwRE5DM3BMdjhYdGFDQ0s5NTVKdGRjbk8rdDZTbTlEMWdoYUl3NSs5RERXZGdYbEIvOW9WTFMwUDFBOCs4N2VGQTBkdUxaVE5rdXVaa3RZSTBETVJRbk5kcUNxWUs5YXh0Yys1YXNQMmkvN1czTEtsQnlseWJDeVdTbFo1NllhdWxBNFNWQ0kvbmdodFhBV29UcUp5ZkI3VjZUTHNVcDE4SWhlK0U0Q3FHanIwaEk1WUpvNWtleHFwN2lZZ1NSMlo0RjcxMElGU1F2QUZqVVhYUXgrQzJ0dEtYNzNpNHh0UzZhdkhUdXo5eE5QNzhPTkNOWTVNU3RBQ2pBQTlKWmpUQlFYVnFvMVBYZVYrK3ZwL2VmRTNzV1lkVFdxZVFISUN1NmhnRVVpZGZqYzVaaWpEbVRxTXFYM2pLSThVNEJUb3U0NUNYeldnVWVpaEd0UlZRNDdoa0NUV3lONTZicEh1TWtaZXI0Q2VNNUR1ejZGamN3K01qajc2RmdGc0ViQ3VGWXluc0sybXNhcmtiQ1dyTUhkczdMbStUWC9DcXV5KzliYTk5dDNUaFJqYWMrOHNVUFYzQkpoRkZiT3pOcjV4YSsxTE45eSsvWXZvWGswVFNYYXlUbXBUMFJaQ0ZqQTRTWmJTT2N6djI0dUpaNGRoVGRuUTFReFNyVjFvVzl1S2RHY2Fab2JVWm95dTA5UlFla1VnMkI3ZHovWmdGVzJVU1lxTDQzbk1QVCtONldlZmg5bStEMTJYRGFCNTgzcGFMTTBrbldXU1dDZThudTVWSmRUaVJOT2ExYmpoZHZGTllUM2ZlK3MzbFR2WlcyN1ArdThZVUpXMys3RFNtUklMR3MxVHZxUWluM2Z4OVZ0bXYzcmpWeTYrSGUyYlNKektjdUlYd2FEWEZLbEcyQ2krc2hmSGYzZ0VibDVCcG1NQW5SZjJJek9RQzJKUVh5UExxUWFTcGFwMCtSTEhTQW8zeHo4RXF2RHBiZXFxSjJQUjBuQUJreStOb0RRMUFyM054K0MxYTVCZHZ5Vnd1Q29sbnFWUURZdGdvUmkwcUdiMjQ3di83dmsvLy8xN1dyN1EycXFqTmVQRDg4NS9ZdUc4QWNwT1JibXVZR3JPeDEwM1QvM1J6Vi9kK21WMGJROGNIM1pZbEhBQ2xWQXFyVmR4OE50UG9YalFSdHVxOVJqY3VScGFld3JDSlJBVm5jeXBUc0ljZ3RtSUd4c0xvdUVVTlhqbFZ3SlZrTVQ2TkpZcVhDaTZCMis2Z3VPN2hqQno5QlZrTjhTdzRlWWRKSzByU0RyTFFhS2lRUk9yRlpNY3N4UFA0Kysrc09mT3ozMjc0OHNkelNyU2NTSEQzWGNsb0R6c3dSRVZYN3IreENjK2UvZTYrOUY3NVVsZ2tpVHA1TkdhTVJRUFA0V0Q5eDlFSXRHUDllKy9DREd5ZTU3REFCcUVOM1ZWZmZQQlB4RWlTR29GZWJiQ3RhSEZYTmhrajEvNXdZdW8xVWF3NFJNYmtGMUh3RnJrZWJ2VllNRklVRWtqbUtRMXhuNk8vM2Jyb1UvZStYRFgvUnY2L1ZPU3Nld0IxV2xPRG96cHVHSEQ1QVgvL2Q3dS9kaDJMYW0rYWhEZ044Q01rVlFhUGlaKzhpTWNmV2dLS3kvZmdaNnIxcEM4eFNCVVUzcXRNbFJSbHNhWWJ5NkJzYkRDQ0ZpZmdGVjhpOTYyTWY2VElSeDdlaGRXZmJRRDNWY1JqUTRSYnBjWFFUWFlWdE9pMi8wWS92WHZqbTk4NEVEbmdZMTlMbHovWFFRb2E4WHhPUTF0YWdHUGZzTVliYjdwdWw2NDlHYTlzZm9aVElvN1l4Nkd2L2VQR0gzTXdlYmZ2QmFaamQzd2JBTnF6Q1QxcUMxS3BEaFRLa2c1ZThDWEFDdkl3L0Z0aTZUVlFXbi9CUFk5OENQMHZjL0F3SWMvUklEUzJIWmxrVlpPRGVvQ2M5LzVmMlBYM1dyM1RmczU5RFI3MHY4Nkg0Q2U4KzB6eTFWUW1yZng1VSs2ZjlWODA0NWU2WGpVS21HdWo3d0tQVTV2K1FUbTkwaENCTFovNmtQSVhOQkg0VVlDV2p4RllNWUNyMU9vUWNmcHVoWityNUZnVU0vY0YrNm55VEY0TEI2VHg5Nyt5UTlKV3BnbXBrM1NLQk1TU2tpN2dlYmZ1cnozeS8vQy9Ucnp4anlldCtUTXVRNVJoaVpVL05iV3VjMGZ1SDNEN3dQZEVLVUNDWTlDZ2tGMmpCUG1jUk1UanorSzBjY2RiUHY0cjhPa29ONzM0OURNZUtCaXp6YjF4dUdPWXNHZWRWRWZkY2o1S1FSU2RWYlhLM0lzSHBQSE52dGFKUzFNRTlPR2VFelNLbWxtMm9rSDV1WDlmN2podGhzdm10dk1QT3JhTWdlVU5TU0hLUDN4QXU2OHMvdDc2TmxJSVVFaHpLR3kvVktncEUzTVBQMDRoaCt0WU90di93Yk13WFo2T3lIVmJBQ0dPRHRqR1hxM3p2eVlsREtoYjBKOWZJS0V0Ull1aWwvb0tRV2R4bFJOVTlMQXRGeEVOREZ0TTA4OUlXbGxtZ1BhRWZCQ1BQM3hGN3YvZ1hsa1hzL0hKczI1QTVUNnhMU0hUMzlZZkticll4dFhnTlNTejU1ajZHVXEyUXpxSS90dzVMc2pXUDlyMXlDMXBvdWtnNXdmM3RCV2xUZm05WkIwQ2xHRE5VWDMxZXFJcnlhYlZxY2hpK09MdHZYc1hHQzVPSmdHcGlWSk5HMGcybzc4L1FocVJDdlRMR1JjS3dKZWlDZmliZVduUHlJK3c3d3F5MWxDNTZzcTFqV1Y4UEZiK3Y0VWFJTmZMTXJKWXJXbHFDeUJzemp5d0I2MHI5bUNwaTNrQUZra0hheTNGcElCNGl3N3BOMTBpeWZveHdIb3pUbXlpVS9TYXovczZUcE5lbVV4bmp5YkhvN050REJOT2FLdGZjMVdEUDM5SHJwUFh0TE9QUEE5SlUvRTJ5ZHU2ZnNUNXBWNVhwYUFzb0JOVFB2NGphdjBtNXJlMTkrTXVyMDRXUjVab1Z3TTB6L2RUZll1aTFWWFgwamVyRVpoaVJFbUEveXo3bEphK0JLS0Y2MnBDdlJjRC9Sc0hxSjRETEZXbDdUamFqaVZ5VUFyaE1tRnMrNTBZNmFKYVZ0MTlTYlljMW1pK1VWSnU5dzRieXc2NGkxM2RWOEw4WG96ODN5dWQyWE9DYURzOVRXckZYejRJKzJmaDlJTXIxeVZFOHBkWVkreE9vNkpaMDZnYStNV0tCbjZYVE1XcEZmNDRxeDdJK3h3cTVQa2hLNkEwVXpYMXc1QjJCbG82VEZvbVY0Q3VrU0FCMTcxRzdsM1F3cVpOcWFSYVoxNFpsTFNydWptQWo5ZWljSXZ0UVVmSVY2WjUzUHQ4YXJud25iT2tMOXd5UVl4c1BXYTlwMXd3aVM1ZENZSTBKU0d5YWNQUWJHYjBITlJQMXdLM2xWTzhtSXg3M3EyWFZwYWtrNTdxa3pna2JyTmpFRFVPU2RNY1czOUlJd21paS9kbFdSUDh4eUFMNlFBejZvekxid05SN1F4alV5clltVUQybFA2QWoveWU4VGpsbXZhZDF5NlFRd3k3OHNLVU02cmwwb09kdTVNMzRpQkp2aUYycUs2NVRqUm0wWCtRQjY1bmxWQU1rYXJYVjhFODQzMEVDQUd5M1g2SlhqQ09raDNTa3RWN05VY0dKbFJrdFFCa3RKNUNienlac2JoUUlWcEpGcHp2YXVSMzUrWFBFaGVHZzRTODBpODd0eVp1WkY1WDFhQXN2T1hWVzFjZW5udUExenE0ZHRPb0o1OElXMVNaV2ljMUpTTzluVTlzb0JBa2FxV1AvY0NsWHZhSGtwWXcvdWxFRU40ZFZna0VtcDZKWXpzQlB4cVBWdzhuQVFnajlRaEtlWDlTNnVQNkpnTDJWY1dNMFJDbkhsTVNaT1FOREt0N2V0N3lIem94TU9ZNUNWUXpVTHlDQ1J3Nlk3c0I1ajNaUVZva2N6VllEZmlGMjdKWE1tcVNJU3FTVTZNNlNGL1pBYXhXRE1TSFluRnZjOVRTRjZndnBmK2EreUorWEluUktFWTA2K1B3QzYzSUphbEdOQTVJRUdVWUlwUWNpb1ZBbm9TU21JRmFpZEdhUUhNeWkwNVdmckoyMmt5VGFCSXdCYkdFSXQ1M2tVcERVS2pSSHRDMHA0L2twZThCTnR6b1QxM0JDN2NuTGx5UlE4UzV4TFF0MzJEdTF6eXNIS3p1UzAzbUV5aGFBZmVxQWd6T1c0WmRRb2xrczI5Y20wcGFsZ0w1QzlKbUNzSUo1Z21DaXdsTGdIaHlGeXJaMWx3YTdhc0hCR2VBYXRRUmF6alZ4SExqY0lya3ZIUzI3QzRuOFd2V1NqdVBwaXQxMkgrNWZWd3FzTXl5YS9xTGpUVGdCNDM2WlZ6eGJ5RFE1MXBERXRCRjV5dWNJOVYwdXFwU0RXM296bzlGT3poQ3AxSURqZEZpZGZzWURLNWNvVzVqWDU3Y3RrQXlnQ3NXcFhlaXBZWXZFbG5ZWUlWWFlVelc0UmZVNUJlbVlQTDRZdlJrQVN4dUl2SmVmdjhKT3F6QlJJMlhlWk5oU3hKNGUyekZJSFJCTlZNUUtYMWttektJTjQ2QzFIZEN5M1pGdVFhdmZCT21pSlR1bDVwQ2taaU41bzJib1U5MzB6MDFjbnVWdUFRQUdMT2tyOVRuQ04zV3hURklaQTFKTHU2YUl5MDNEK1ZjcXNHQzhSMUJWTHRPWlNIRkRoekJhSy9uU3YwNVhCc3M3WE9HUEVlMzdLc0FOVVZnWjVlY3kwTUNzd2RaOEhtOGE1TFlhWk0yazVIb2prZUNHTm9PL21YWU9JVXpPdzlEQ1dXUWJKN1BVbGpGVnBNcFI1VW8yZ3hRUkpGMzlYWWxaeVVkYlorbFd4b1V5dktSK1l4KzlLRUxBemp4Z1ZqTFJkMkliMjJHMTcrR016NGNaaTl6WkQxU3NJazJsU1MrQVJKUG9IaEtQU3pMOU9FcXFwaThzVkR5QTIySTlYZEhoU2QrYUhOWlV2WlJMVFRRaXZQVk1oSmFvY2JxbVNQRnFWR2RyVzd6MXkzckZSdU5xV2d1eWZXRDJuSy9JVjBtRXBBVy9OMThnME5raGc5MExJeVBHaFVLbkF1bENiTkt0S0VIc1RhMzd3VXFlMFVma3lUQkhKeE5Uc29YSEZRYWV5c0JOVUtXcUlKcGNPek9QR1RJUUtYSkM2VVVJVWtkSUlXVUJmZE85T1hreEtFT3BlRkZzTGRHRi91MDNJUk42dGJaTW4ra2xRZWYrQUFxcU5UYUZ2YnRtaERGU3pZZFNPdVN4NnNRaDFxbjFqUVFCSnV1bTFQdDlHM3JBQ054UlNrTWthYm5EUFBrMjVIMEZ5NGRWZFdIUVNsc21HbUI0MEo4Y2pSVWRGKzhRVms2K2J3MGw4L2pOVWYzWXJtcmIwUUZiS2p2dmE2S2dXMnRiN3RZdmFGRVNnMFZ0TUY3VWgwWmFRTnJFNFVVU1RuSmYvY01GSWRGd1NZK01yaU5odi9Mby9Fa0dSeGtWbXBqbGZ1K1NmVVo0cFk4K0gzSXRiVUpHMzJZaW80ekdJeEdjU0RXM1VsVDJMcFJxanJJNVUyV3BjVm9KcW1tS1pmeVhKcGlRVFREek11SkJHK1RhR0xvaThKOEwxZ2hTL1VodkVNYStpNzZrcVNZaE9IdjdzSEs2cysybmYwUWVRcjVBejVKK1haS1hTaDk0eWtUdmFSMUdGWEZ0bnRmYkt3Uzk4OVJxQVdFRzh4U2VySksyYmo3SjlVV2tCMGFLeENhYUc5L0w5ZmtIVzZHMjkrUDNuR0hiVDRuQVVuVGFvVGRURXRxWkx6NU51Mi9FQTBRcW53R0kybXE5bGxCU2dGNGFadUZVek1ueUNBdW1TWW9IaGg3dFVMYlNVYTJSaHZNY0dPeHRzK0xYUU5uWmRlUWlaTndiRkg5c0dwV2VqNWxVRm9GVXZhUnA1Y2lldHJQTkZnYTh1ZktzSEsxNlZFdFc3ckExRVRhb1BGR0xhQms5YVNJRWV0amdQZmZsNTZ2ZXMvZWhXcDhCYnBTUWZnTGRtbzhaV0ZjRWo2NEg1b01wZzNOaFdhS2Fzd1l0Wk1iRmtCS3NpL3B6VXNVSnlHV3ZMaHBkdUQ3UzB2T0NHMkVMQnpEU1I3U2cwSnhTS29ETFJUMWRDK2Jac3M0em42eEN1b3oxdFlkYzBLNkNTTlRqbXNSUXB5UDR2cVBrVkIvMWdCeC83eE1KS2RhYWdrcVRGU3AxMlg5UVJoa0l5SHVlSlRrWkpaR3ByRGtZZjNJZE9SeHNvUFhFRmtaZ2pNK21LMW9MSmtTNWF1WVpvYkNSQ1oySENEK3drT2VTd0t3UE1UdEg0dHNhd0E5WDFoTzU1cVNZK3hOQTJGUWdRdjNRWS8zVUtoQUtIalc4RlpFdFdWY1YydzFFL1JLUFowZkFOTkd5N0N4cVNHVng3Ymo3MlRKVno0MFEwdzBnUnF3ZWI5a05kc2NudVdpMFRPUk45N2VpazBjVkVlTHRGM2RDd1UvTkNyU3A2UWxvMWg4cGx4SEh2OElBWXU3a0xQbFR2Z3VSUm0xV3FuMzRmbGNoVU9VYmhLa1ZRelYrbjdDbWVMS0Z3cFQwR3Q1cm1JQWJadjFKZFZwb2dpbFZxMTZoY0RhVFZrZFo4Mk93b2xQMHIyVlFRQzZMaUxaU2dpWFBXbjZ1VGRPcVJpWTIwcmNNRTFhNkNMTXZiKzNUNVV4OHVrSWdQN0xLWEdEVUN3aWhiMDlnUmEzak1Bc3prSjF3cHN0TlFHZmxCeXlkNzJ5QlBIY2Z4bmg3RDY4amIwWExJVmpxWFRBcWdHU1l4VDBTRzh4ZklUaDdmbE9FU2hxWnlmSnQ2R2FlRk8wZWRCR1V1dDZwZVdsWVNXU1BOTVRHRktPdkorT0NUcnBkbEptR29TWlpWQ2xqb3RZcFc4V2k2b2ppWEM4TUE3cGJRS3B3YVhWSnBxdEdEZFRoLzdmM1ljMHhTbURGNDlRSUpDQUZLY3FzWjVQMVZEYWFTRUd0bEV0bkZPeFNhVnE1TlcwT1YzMkhsaTZhd1hYZVNIVG1Cd2F4cXRxMWZBOXVLY0ZUaTFwcEFWK1pxc3lvZGRvN0NYdEUzZEpudXBJNmJTT0ZPY3FDY0hpY09lOE9qaStEVHp2b3dBSlllU21ScUJ1elNYVGhQc2FqQjUyNGt6Um9VQ0RGSmZmcFVQSWFXZ21Fa0s4TXdncEFtckMyUmxnMHcyNkFSR25lYWNZbGlhdUphQkhHSkpVcThUYzNBZG55UlZSL05nRXA3dG9UNXJ5UzY5YlFJNTNob1BQaXRWcFFxV1Vrb09WOHRBUnRMaWxNZ1c2MVpRV2VnRmlRT2w0V0F4RGF4aTYyWHlrcXZFR0sxVXp5TDdIZkRBWjZjY2l4WUtlKzNoSVhIbWVYd0tvOHNLVUc2dmpvdkRLQXNaN1RtTmhVLzJ5MHlvOG1SOGJhNUtvVUdjVkMraGI5RXFWK2VDU1RYaVVOZ0wwb084cWd3Yk9meXB6TW16bmI3bXdiVVZ4Qk1DVHI1TVlhN2duTGhNVkRSM0dxZ1MwR3BZTXNCQ244eG9VTW8xMUVsdEJ4Z0pVZ2dNSHNXcEZSK0paQjMrREptRFZKT3NqRmRrbnNDVFl3bUhiYjBscSt2bHpkZ25JQ0JyOC93d0Qxb3NTVnFZRmJwQUN4ZzBtTmt5Y0h4Y09iS3NBRTJSc0IwZFZWNHVUZm5JWkJUWVRpTlVJTStTYkJSN3FaVkpGMDE4YWx2R0Q0RktGaFRFQ3k2K1pybFV3ek1yY2lFRVJ5VllldTJxUlpxWlFERlZ1dFpmclBZandEakV5V1pWTkFySldkSTgyNFhqaFY2MG9pd2svVFc2djhPcWs2KzJhdkM1MWxiVEYzWitoQWozUVpWUTNZWTAwbkpFcFVROGRHcVNGNHQ0VXZ4R0JrbEJhVXJnNkppNmYxazVSYmtVY0d3Y2V3NGN3d21rZ3RnemlBRko3YzVYa015cEZKbVNIYlU4ZVhESUo0ZUZRZUxuS3doNm4rVmFtbFN1WnVkT0pQdENrNU5jcTloU2hmT0JNRUdpejNaUkp1TjVxNHgrZDhva3hYVnlZR3o2dWVMSTk2VGVaeHJjNFB2c2tHa0V2c3MvOHk0T2VhOXlqTVo0TWl4V0pTMU1rNlROQzJrbG1zbW5sVHd3THd0bExVeEQwZ2Z4UEhsMERIdVdGYUJ4TW91elJhWHl3Z0U4RGQyWEU5SUExU2FibFcwaE5aaU1vVGhSQ1dKRHp6K0ZaK2t2MU96SW42WEQ1TUd1TzFKS0dBSUprQmZFczhMeDVIRUcxdGFjZm5QTExrenlnaFgyVEIxdjhYdlVQUUxGSUVCOThvd2R5dzVqeTVQSE80a21MemlPeURRamFVb2VtSmNHbU13alY5Z1R6MC9ObHBUeXNnS1V0U0Evb09tcGw5VEhVQWlsU1RUeThCcDByMG9oaFk3Q3JFZXFUNUdyWDRMYUFQNDBYU1liMkFraUZlZzc0VFZTNGtpK1ZJRkVRa0Y1MHNIQjUyYXg5K2twRE84clU1akQ2bGtKd0E4bDJpVTFiT2pCbzNQcU5XY0JsTk4zWDlMSTR4YnlIbUpFdTBFOE1DOWg0a2p5aUhuaStXWDE4VlQ4bkJZc25JT2FJbUt3dlVuZ21mM3F3L3NQd0lublNDcmtwTkNFa21OUm5jZ2oxMFUyTUpsQm5WTjBmdmpaR1RvN1ZCNDdSWnkzVlJYcDBUSTRiTCtTNUdpaDV1UFFNMFc4L1B3TTRpMUEzNllFSnFkSzJQMnpQUExINmtoUzJNSlZvbEpGazJUR3lQdmhCMDFaQktnaS9BWGdUdFY5TDloeFlWcTlWQVpOUkh1RmVHQmUrRFBtalhsa1hwOTVXWDJZZVY5V2dFcTFTNnJ2eEN5T1B2S1U5Z09ZUWxaOEJMbDRRUTZrZ29SU2dkbVp4TXdveFpHNkp1M2FvcVNlM01sKzBZUmFGQSt4QThyeHZFY1N5aXFWY01MSS9ncDI3OHFqV0s5aDlTVVpESzV1UVZ0TE16YnRhRUdtVzhXUlEvUFl1MnVPQUhFbCtFR09uU1JPY0paT2xqNmNBVXhQMHNZME1xMW1aNEpvTDhzcXdNQ01oTlVzeE9NalQycy9KSjZINGpFc1AwQjlLYVhBdzArcTl4V0hnWFF5bEVLT0F5azhxUTVQb0xWZmc1TnBRdlZFS2NpcnMwTWl3VHU1Qi9hc3pyc2ZOSWxwVXExSlE4SGNpSTBYbjV6SDZJa3lPdGFaMkhRWkFaaEtvVTZoUkwxQ0M4UTJzR0pOTTlidnlNS0x1OWozNGh5TzdDNUR0UVhaZVVWS3Vrdk9reStjVTR3WjBrSTBNVzFNSTlQS05GZUhUOGlTRldsbmlTZm1qWG44dno5WDcyV2VmYkVNQWVYV21oUFlNNlE5OU5CUHRWZGl6VjVZQnhSS3FVdTJ0RENPM0xwV1RKT3JyL0l1aVJ1cVp2ZmtIdGhQaTd6WE5NV2JvdXJocFdkTGVPVklBV1lIc09ueUhMbzZzN0RLR3F5cXQ3QXcyRlpXaTZTaUVjZjZ6UzBZMkpKQXZsYkRDOC9PWStSQUZkbTRKbTA0UytucngvUkRXanlvWkVPWXh0eTZGcUo1UXRJZXFPZ2dyUnRyOGNBOE1xL004N2x1NS9Ud1JYTkdPUGM5YXZ6WDhqakZpRWxmSmdLa1IwaFNXaHFaUm5PMmhOamFRVXdmTGNBd05ibFo3WWQyYTJsWEZGOCtvR1Q4aUlVWFhpeWdianBZdXoyTmxhdXlVaEpyWlZvTUN5SFEwbXZKa1NMQWFrV0JiRHFGVGR0emFGbWw0ZWg0R2Evc0xhTTJMMlNjS3Z6WGo4bTBNRTNUUXdYRTFnd1NyV1ZKTTlQT1BEQXZ6QlB6ZHQ4UGpMdGFNc0xCZVdqbkRGQjJqanFiQlY0NG90MTc3eVBHZnJNbGpEZERWY1VwdjhxaFEraGFZOEp1NmtOaFpJN0NEZ2JWZTcwTlpRZklWVkFsME5wV0cxaS9LUXNUTWRSS1FpWVBoT2VkMGFuaXorMnFDN3Vzb3JzampRc3VTY05QazZOVEphOVphbzNYWHM4ME1DM0Y0VGxKVzlkYVU5TEtOTXZQL1NBY2l4TlBmL045WS84TGg3Vy9ZVjdQeDEvRFBxZEg4dG4rRkNvSzI1VWJ2djlucFFkVzluc1lIZGVDdzdGc055a09qR2NNcUtzdXc4Z1RROGdwRTBpMForSFVmRmtUdEhSeGNMMlJiZ1RaSHNkR1dBRDk1aGFhUm1HTHB0TmljRVN3SjZBb2l5ZjBDU2dqcWFJMlZVUkJkS0gvdld2Z0gzMEc5WklUYlAveFUrYm9tcjRlRDhlR05Yendqc3pIRkJVUDVsS0xnQzdiSS9uTVlITmFvRlJWSHZ6Y1h5WC9rcC90MU1ZUGJYS0RHSS96dHBWOERkNngzZWkvYWhVcXlSWGs3TXpLNmo3UFdiUm5qVGpWc2NTQ25UeWxtanlMTGlzaUxKWllYejR3MGcrelNOSnUwcGc2alQwM1BDdHA2YnRxdGFTTmFXUmFBL3N2MEpieE9XZVB6Mzg5K1pmRm12SWdxVnVjcjc5VmY4NFBNTEoySGV6MDhlTzl4aC9jOGEza3JuaktSVndMSjVNbVVZc25VSmtzd0RuMERIcDNEc0xyM295Wll3V29XaEQwUzFCbEhPckxjR1VCSFBjdDlJWDdMZDVMSHRXZ01hZHBiSjlvNk4yNUFpN1J4TFF4alJKd29wbHBqNmRkM0hGUDhpbm1pWGs3bjA4Vk95L1BuT2ZWdTc3UGMvN240L0hiL3NlRGlabTJEbGQ2ajlLbWhxQlc1K3FvUFBkajlHM09JWG54bFpnZWRlQlVpekpuTHR6RjlPRXZ0VXZwRkhJTUhtdDZ6RUZ5MjVYb0lScVlGcWFwQVNiVHluWEVUUHUzSGtyTTNQdFkvTFoxeE5QNWtzenpZa05mczVMVXdKN09sZFVidi9XWjR2KzVibWRkR3g3VkYyeXRQQkZOTmxVaG81YmJlaEdxYU1mc2l3ZUI2UkZrT25TNlBpNXRYdkRZdGwvR0tpTTdhaWl5Y3I0NFJmRkhXejlhdG0xQUV0TW83bjFScHZZQ203bW9UZ2Y2WER5NksrNzlxNy9JL25aVDJ2OE8yMDMvRlB2aTc0b25pY2xOWndKMXFxQ3lHdjdjZlorZHYrdFhMckp3ZkZSZlV2b2FsSlc0NUlCazEvUkE2OTJJd2tRVjVVTUhvQmJua0dwVkNRVGVSdzFPckwzaGh4cUlZRnROTmRoR2swYklrK1JsbTVCZXV4RzVuaVM4c2Ywb0RvMURUeHZCQ2d5cjVYbVl3VjRYLzdUWHhPOStyZW56Rkw1K3JhUEpmODJ6aWQ2VmdNb05XZkp3eDJkVlBucnk3KysrYmY3UDNudXhoWkVKUGFnYlV4ZmRZN2RrOFg0M01wdTJ3bGJiVU10VDNEajZLdHlwU1poYzZKQlI2ZnZrcVBqcVFwTDhkSnNGOG5HQUtvY2JOcXdTcHhHSmpvNU9KUHBXSU5HYVJzeWZRV24vSHZLdTZmMk11WEF6enZyd3huVi90NE1mNzQ3ajk3N1JkQWVCK0pXZWxqUGJ6WGNWb0ExUUorWklVajNsRDcvNnljS1hibnBQTlQ2VnA3aXZTa0NyaTdXMm5QSnppeDdpYlNaU3F5K0FxemJCcXBDSFN0SnF6MHpDbTUrR1lnZlBSZVl6dWZ6YTJCZVh1enVOSWowT1RmaHNURk03WW0yZGlPV2FZU1lwZlBMblVSazZnUHFNQlQycjBiWGFBcGllcnlDVDhOSFo1dUU3UDB0YXQvK3YzSjJxSXY3OEY0SDVyZ1MwQVNvL043ZFFWVzc1N0srWC84TWZmTERVelNwc2JGYkQwcWVrU21BOUYyNVp5TWNCcGxhdXBQL2FLUmFOU1U5VmVEYXBZQXZDdGdoQUo5dzc1VkpnTGhuaHY4M0N6d25rZXFVWVY3WERpTkVLcUV5amN1eVlmSXlmbnVacUNIMEJ5TWJ4ME40V1Q1NTkrUzhQWnlhKzlram1qM0pKLzU2emZVN3V1eExRaGsydFdBcEdaclJyZjIxTC9VL3Z1S0Y0eFlYOURrYnpLc3FXVk10TEtBOW0ycXQ1OHNtbkJwOHRhbXVIbHMwUllJbWdaQlRxYTBXVUQvVnk4cDEwS1o4ZnRXYW00WlNDSjdocUNXM2hUNG9zaEZqMGM5cjAwZGZxNDZVUkExOTVLUHZrRC9iRS82U3Z6ZnRoMmhTbnRaa1JvQ2ZaT0NicDFXbDlWWHZHK3plM1hsdjZuWnQzVnBveUNXQ1ViQzAvVmVUa1I4VUVsVVJoUXNBT2t2NE5XL21hQnlDSHRsV1dCc1dDTTZyS1NkWDJqYkFxcGd2MGtUb3QxWUZ2NzByTmYvTkhtZnVuaTlwZEs5cmRJVVhCRzBvY3ZLc0JYU3F0czJYVm1DbXBIN2xpbmZWN3YzTmw1ZXIzYmF3WmFYS01UcEJuekpMY09BVDJ5d2xiQXVGTWtlUjFraXF0a0tQMCtQNkVjLy9QVXo5NThwQjVkMXZHLzRlV3RPK2NyVlJHZ0o1R1dubVd4K2UxSG5LWWJyaHlmZjJtNjdmVUxyMWliVDNSMTB6ZUtUazRzeFRMV280U0hsTjhvN3dFOG1sUzJOSkNNU1NmWXhvbDUrem5oK08xUi9Za25xWFg3MmlLZUxDbjJSdkRHNVRLQ05BenBiTVVXZXRGa3FtdGNEM2xtazI5OW5VNzE5UXYzYjdDR3RqUTdTZ2RXU0dkS243NENKL2o1VVBXYnVPWkcwdlVNdCtIdjhlaFI0THNac3dJRXV0VFJRVUhKd3p4L0t2bThLNGo4ZWRlSG90OVg5ZkU0MTA1NzFWZGZldWIxQkdndjhDK3psWFYxdm1LdWlXWDhIZXU3blF2V2R0cHIxdmQ0ZlFNdExoTlpIZVZMSVVYckRxTjhBOUROSExJRERTcjZtSk54WFJKRThPeit2elFsREYrZURKMmVHaFNmN1pRVTNjMXBmeTl6VWsvcjd3RmlZd0FmWlBnc25TVjZtb0g5UUg2ZFZVbTdxK21jS0tYZ082ZzNrU3FORVdTRnBPbkdIekZKb2VxV3FpcTh3VGNGTDJPMFhWRHhQMVJ1dTQ0OVdsZHc5dXlTeEw5dWNtelRQQ3o5RFVsL1NudTlOWnpMZ1gvTlZ0SkZHcDZ5dkdVSkJmZ0NTRjU1QzFPbDhJZXk5QkZOYWFKU2lvdWFybWsrN3A3L25OdmI3dUVSdTNjdHVoUE5rZUFSaTBDTkdvUm9GR0xBSTFhQkdnRWFOUWlRS01XQVJxMUNOQ29SWUJHZ0VZdEFqUnFFYUJSaXdDTldnUm9CR2pVSWtDakZnRWF0UWpRcUVXQVJvQkc3WjlMKy84Q0RBRGFLS1hoUXZscVdBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBZlFBQUFJSUNBWUFBQUNZYmh4MUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk16ZzBSamc0TVRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTXpnMFJqZzRNalF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPall6T0RSR09EZEdOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWXpPRFJHT0Rnd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzZlN2c4d0FBRDJSSlJFRlVlTnJzM2IydkpXZDl3UEhuZWViYzNTamdoamlLTEJZcUExVXFUSStwRWdrWktZNEFFMWVBWkFPR0lta1FJaTVDSXY0QXI0dEVLRlVTTHhLS29raXBnb0FhU0VjRHVHT0JCbGU4S0h2dm1YbnllMmFlT1dmTzd0WGFFb2g3Ti9wODdObVo4M0xQV2xCODcyL2VUdjdxMDMrU1VtNy81bFJpWFhLc1kyT0k3U0hXdTFMU01MUjFUbWZIeDJYSStRUHgrdFB4MUZQeE0rK045VHRUem04cktkMU1UVTRBd1AzcXNwcFN1cGRxL2ZWVTAwK25XbjhVNisrUFUvMzJXT3YzeHJGTysybEtGL0hrUHBaNG5OcmpzVzNIejAreC9wdi8vdG5KeCs3dWozbUwrQkx5V0lZVzhaTE9XdENIMG9KK0s5YWZpOWYrS3BaM0xlR1BuKzQvMnhxZXM1WUR3SnMxdmRaME05WTNJK2J2aU8wL2paQS9PeTBCLzhsK3FQKzZIL09ydTZuZTNZOFI5bHhUaWQ4QTlsSHozS0oreVdmdURqSHZjVDZFdkFVOGxodkw5aC9kR01yZlJkZy9IVUcvc2V2UmIrOWZmeEdZUTk2amZxRHNBUERBZEg2TWVtMWhUeEgxV0ZKTTM3Vk40ZStLcUg4eGd2N1hGMlA5Mm5uSkx3OWxlcU9NcmJsVHloSDR5L0s2TzB6bVBlWkx5SE9LYWkvTFVENGF5NnV4L2ZpOHl6MWVYNE4rMkVYZngvSWk1QUR3bHNNKzllMGw2RDNxZlRmN2ZzZzNkbVA5N0xEUEg0M212bFRLOVBYUzk0TG43VzhHeDZBZmQ3SFBNWStaL1dhc2IrNkdYVVQ4bFp1Nzh1SWM5djc2ZkR5OUgyY3ZmVUpmZHJVZjk3WHJPUUM4aFVHOTlpazl5am10WVc4eGI1UDYySG83dFVZL0hsRy9FODM5WUVuNTg5SFlmY3JUSlVGZmo1blB1OVo3ek0rR1A0eVFmejJXRDk5Y3B2UWw5dTI5dzdxcnZjZDgzYzErK0sxQnpnSGd6YU5lbDdEWGZOajlQc1gyVkdvYVd0RGJjZk0yUEk5VDcyMTZNWlpia2RtUHhkdC84MERRMjluczYzVGVKdkUybVVmRVgvdURPZWJEOGx6YnpkN1BkRDg1RVM0dDY3bm5tNDZMT2dBOFBPYnIvdXpheC9YYVl0NWVpWFdKSjRmNVJMamFtNXZUOGsvNmNMejF0WGpiczZsTjZpZEIzNXdFMTQrYjM0NmdQOU5pSGxGUFo3dmxtSG83MjcyVSswNkNXK045RW5NQTRHSHk1aWo0UEJDM1hlKzVMcy9IZG02NzMrYzk0ZkZjMjcyZXkrRTh0WGpwbWZqamRteSt1UDNNMHE0cmI3RnVaN1BmR01ySEl1WXYzT3dueEoxdGRyZlBaNy9uemNsd0tSK09tK2QwWEFDQXR4TDFUVHY3SWV6U3J6d2Jlbk1QZTlDSDN1UjVUL3E4ZnVFL1B2R2U1MDZDUHZSajUvM1N0TnY5elBaNU4vdHkvZm5tSkxoeWVjZ0JnTjgrN2lkaEw4c2w1WFBZTitlNTNSZ09WNkhkL3ZlUFAvbkhtd2w5dVJRdFh2ajdkbW5hZWpiN2VsT1o0eG50cDd2WGhSd0FmdmRoWHplMjk0bHBMWjZidkI0aUwvUGw1ZStJN2E4Y2duNjIzTkwxM1ZIK1Q1MnRONVFweHhQZ2pwZW1pVGtBWEVuVSszQzkzb1o5dldkTUxKK01LZjNkZlVKdnhTK2ZpZVZzdlc5N1d3NVRlUkZ6QUxqS3FMY1dIKzdxMmp2ZCszM1dHajRIdlgzUlNoVC8rZDE2Ly9aKzE3ajFXdk84K1dReEI0Q3JpUHJ4cnE3em5WM1hXN1V2eS9QZitQaVRaZjdXdEhod2EvMVNsblUzKzNKdjl1TTE1V0lPQUZjVDlaeU9YVDU4SytyeHk5UnV0WmFYZVBDaDlXWXgyenZBbFhSNkJ6Z0E0SXFpdms3cDIyOUhYYnU5aFAzcHRuNy9jTGlOYXpyZXpqVzc0eHNBWEord0g3L1pkTnZzM3ZDbkl1ajVmZHR2VFR1NXR0eDBEZ0RYWmtwZlYrc3g5WEw4R3ZQM3RRbjlpWFVpWHk5b1QvbjAzdXdBd0RVSSt5V3Q3aFA3RXlXMkhsdS8vclNZeWdIZ2taaldTOXArNDJsK3JOMVo3a2ErTCtMT2JBZUFheGp5ZEhwK1crNVRlMnQ1T1FsM3Z2d0hBSURyRVBWOE1xVnZHMTUwR3dBZS9mRzlQRERMQXdDUFRNalRZVUlIQUI1NWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3RC9mNEplL1k4QkFJK1V1ZzI2a0FQQUl4LzJjaEw0ZXR5dVNnOEExNnpiOVRpWTE5TWh2VXdwbmRkNnVzZjk1QWNBZ09zd2hEOHdjTGV0MXZEVzhoSmJ2MXllcU8ySmt5a2RBTGlHWVY4aVByZDdlVngvV2FhYWZqNC9VWHZNKzdoZVZSMEFybGZNTDJuMTFBYnlhSGtFdmY1d09qeXhsUDZ5WStvQXdOVk81ZXVxTFlkdUx3My9ZWnZRLzJkYzZ0NmY3Q044ZFdJY0FGeWZxUGMyMzlmczN2RHZsM0dxMzU1aXF6MHg5dHJQRS91YWMxTTZBRno1ZEQ1UDVhazN1bTY2M1JvZUxTL3g0THY3cWQ0ZGx5Zm1GOVlSZmp1bGl6b0FYRUhNVDZienZxdTlON3N0YzhOci9WNFp4enJGZzMvWkwwK21mVDJkMWkrNzFnMEErUDNFL0RDZGIvcmNXbjNvZGpUOEwrKzhQcFg5TktYOU9MMGF5M25ianNEUHl6S3B4NGRNZlVvWGRRQzRncGpYdWNYenJ2YXBIanJkKzMzZUd0N2VXaTdpeFZqdVhvejFhN0draTNGcWorZnFyN3ZmcHlycUFIQVZNWjgydTluM1M3T1hWcy9OcnYvOEYzZGV2enNIZlI3WDQ0WHpjWG81UnZRM3p2c2I5KzJOcmY1MU02MkxPZ0Q4Zm1QZUQ0ZlBUZTZEZDJ2MTNPeHgrdkw2SSswWWVxLzgvTUpMOFlZVzkzU3YxNy85OENIcVV6LzdmYjJnWGRnQjRIY1M4c1BaN1BPZFczdHplOHozdmRYM2xnRTg5VlovNGRrN3I3K3hmc2J3WjA4K2xuSk9zZVMyL2tGSitZbVUwMVB4YVBubWxyeThzVDJ1ZWYyeGZQSjh5c2YvcU96L0Z3QjQ2OVA0WmlJLzNKdDlQdmt0eldleHQ4bDhIcnozUzhqL2Qxbi8wMGYrN2NkZjNYN0ViajdsUGQ1WThoUkwrL3ExL0lXbzhoT3grVXlMODNKLzk1THFNS1ZkRkwzRW00YjVGNEQ1dmJGZVJ2V2NqLytCV2RZQjRDRXgzM3pCU2oydXAzNTUycmc1WnI3dmsvbkZIUE14M2R0UC94bkw1Ky8vekYzN0RTREhEK1I0YzE0bTdQUDQ0N25ZL0VhODlPZnJMdmF6aVByVVloNDFuNkxlWlY3cU10bHZodmJsa1IzeEFQQm1VZC9lTkdhOUE5emg4clR4ZUFMY2ZDaDhQeS8vRmN0ejkvYmorUU5CbjArQlQydU01N3EzNTM4VG14K0o1Wlg0ekJmV2cvTFRVTklRVS9vdUw1UDZJZXBwMldXL2xMMmF6d0hnb1RFL2JxemZtSFp5TnZzYTlPTUpjRzM1eHphWlI4d3Yyc1QrWU5EcjRYNXkvWTh5WDN3ZVQxM0VueS9HYnduZkdhZjZ5cmdyajdlL1lEZVZ0R3VUK3J6clBTKzczdWVZMStXWWU1L1dBWUNIRjMzOTJ2TDFEcTN6Wkg2NFljeHk3RHhDL290MkFsd3NyL1d3ejg5ZkV2VCthMEU1UnIwdXMvcDZ1dnlkK1BCdnh2S1YvWkEvdVJ2cWpXM1FTdy82NGNTNjdhY0xPd0JjTXBvZmQ3TnZ2Z0wxTk9qamRONnVNNCtRLzIxTTZoSDE5ZnJ6NWZLMUI0SytYT2VXVDZLKy9DVlRILzFMKy9CZnhQS1ppekgvUXdUOXBRajY4N0c4czJ5aXZzWThaeDBIZ0RmcmVyM3YyUG5tUkxpZnpyZGtINmZiKy9uR2IvMHM5MzRkK3I3ZncvMkJvTS83Ny9NbTZubjdGK1FVUFUvN1dMY0Q4MmNsMzkyTjlZdkRrTDhVSWY5QVRPa2ZpcGkvUHliMDk4YjZWdFQ4N2ZIMk05TTVBRHg4U28vNStTSmkrNnZJNjkwWW9IODBmNTM1VkwvVnZtaGwrWjZWNDUxYjExdTl6bC9JMHM5cnU5Ly9DVEFBd2NJOGFHVURwWW9BQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUJzQ0FZQUFBQ2NsRUFRQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yT1RSQ05UVkVRek5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJPVFJDTlRWRVJETkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWTVORUkxTlVSQk0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZNU5FSTFOVVJDTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrRklXTXdnQUFKL0ZKUkVGVWVOcnNuVDJzTk10WjU2dXFlMmJPZWQvN1loYmZEU3d1QkJ2QUprVFlFZEo2c1VTd2t1VU5rSXlzdFl6RWwrM0ZFR3lFVnJzRUdFU0taRHRZWkNGa3NUSklKQ0NSV1lBM0JKTnRBdWxlUkdJditONzM0NXlaNlNycWVhcXF1N3E3cXJ1NlorWjgzZi9mR3A4NTg5SFRNK2U5ODZ2L1U4K0gvT0luZjBZSUtZVVVSbFJTdUlzU29wWjBNV0tqNkNMNHNtMnZHMlh2LzFpdHhFOHJLVDVhU2ZOajl1Y1AyNmM4dHo5M3doZ2hUQ1A0NXhvcEphU3E4L2ZiODcyRVRITVFRdXQxVDZiUGtNNDVuTnZTOTU1OHZMRTM2L1dmSXdSQkVQVGdaTnF2ZlhscnI3OXFqUGhIYmNRL05FWis1MmpFWHgyTi9OdURGdnFncGRqYkMvMDgyQWZTejZPOTJNY0wremp4ZTMvMnJkNXhhem8wSVNqQXZGWUI1QTdnMjBxSUhmMTB2NzlqTDc5cTcvc3ZtMHI4U09XaEwvMXpKWFBOSFkvUGVEVWM2WVMwdjVJQytBVUFSOUNVQk0rVjUwd3dWNlovYm91aFB2akZuSEErRUFSQjBBT0d1aFRhbUozOXB0OVptUCtRdmZ5RUJmclBIaDI0LzUrOS9PKzlGbC9iYS9QdTNvTjliMUZJRnd0N2k2dXhzYTJabmQ2ZDE5WmVienk4Q2VJN2dubGw2UHFIcnlyeld4Ym12MlR2MjFxWU0vQ3RNK2ZuS2JyWVl5ZzVvTElXSzkxbEl5U0ZDVlIxQXNCeml3Q1pQcDV1N0szTkNlNmNmcG9GN252NlQ4M09YTjhEek9QRkV5SURFQVJCRjNIbnpyUTVUR3BEY0xma3M5KzVGdXJXZlpzZnNVRC9EUXZ4LzNhcjVkZHZHdkdiR3kyK1Z6V0J0MlBDTWRBZGtBMVpkYkdSQkcvQklMY0FGOWNWUS8zVFY4cDh6ZjcrZG5Ec1B1ek9CdzdQcDRNSG9Fc1BCb3E2ODFtdTRRcWRPVUY5RWJSTFhIem05a1lUUmxlZXF4TDkxWXc1Q2VyR0xpNFk1dFY5Z055Y3VCaUJJQWlDU3NHdW1ldkdBNTFkdXpnWUNyTmIzbXE1dFpmL1drdjU2ZHRHZnFtUzhrK3FocmJJWlJKL05jRjRJNFYzNWc3bzE1YlNGdWExdlh6bHVqWmZJTEJ6NkwxeTBBOWhlWlVLdGROMTVWMndzcjY5V2JrSHJMUUZwWm1COS9sZ1kzajFzZUo0NU03cEF4azkxMHk5MkRUTTVSM0NQQWR5QUIyQ0lPanlUdDEwd2V6Z2diZjIvdzVLY21oOW80bTU4dTFhcVQ5V1IvRWZMVzErelQ3c21IVG9uUHpXd3R3STY4WUo2TStlMWVKUG5sWG1reGJvMXEyNzBIdllWdyt1UElUYlc1QVQzSVpoZDBsUVA2NEFqZUZGZ290bEwzMXU5SW5KRXNiYTlSRzlsbG9PTDFuVkxwSXdBdDhVS0dVYWxFYmI4OUNyenVNMG1BUG9FQVJCOXdIMThCWExhV2ZHY1BpOUlaTk5lK2xrb08zM05MUFdZbDhKK1FVbDFUc1dJVDluSC81NkJQUksrZ3oyU25DSTNVSzhmcWIwTjUvWDhwUFhGSHF2M2UwaHc3M3lEajJFMkpVSFFldktld3gxS2ZQR3lCWEpYWTE5ZGpPZDBUNlg3QzRMSHgvMno1Y216OXZGaHF3cjk3N2xIQUROK0Z4TVA0SE9tR1AvV0JjRitYREJZZktmSWFBT1FSQjBHWWN1UTJxNmMrY0VkZG9DcCtTNFVIVkdPZUpzbnRsQTYwL2EzNzVwbi9TejlMQytRNC9kZWNXWHIxNVgrbE5YOWlEUHJIMi9za2QwN3R4d0JsMjhieDYrNzZXU0NXYktDT3FWQzcyZndwMFNnSi93MFpvVng1WjFuVmcwNU1yV0VzbDQwanQxRDNONUp6QlhFNnNmay85REFPb1FCRUdYZ1RvblFvdTJZb3hjT3BlU0U4eE5sd1RYMlREOUtTUFVWKzNWTDhUSFUySHZuR0d1ek05ZDErYno1TWl2bFJZN2ViU2cxNjU4VGJtU05wY00xeVhCRWN6bDRNVkdWS0pzOVJXaGM5NVBGcU9ERnk0RzVKSVhXZ2RHenNLWEU2dVJzcENDMGNmTEExTzY3WTgxbnlVRVFSQjBnYS9sK0JKdFlTdmZBeVl3ZDhzSjZxWk5WcjkyMXovL2h6Ly9IejdUQjdyMDllYktmSGpuM0hsdzZoYm9sRERYK0ZDN0M3ZTNJSmQrenp4NWVrT1FTTGZYdkp6b1dkZm85dXZ6bDVMSDhPTk10SEJZOG9mZzl5UEY1SXJEdjNlUis0ekltVGQzQVhNVllqVXphd3M1RXk2QklBaUNMZ3IzQ095aE5KeVMwUWVSZEVHc0ptWi8vWE1mLzdjcGgvN2JsdnB2Ny95VFBPVEZSalJDbVdQcnlxWC9QeWtMTnFqang1Q2JWUXRkK2dCMFEyQ2ZMZWl4RktqMFBwS2Q3T1Q4NXhBOTFqbnpDOWFhODc4TXRSREdnRG9FUWRCOWdyMzFnNkpMUUE5UUQyRGZjUUs3K1NFTDlTKzNhUExoOUIrMWQvN2l0dXNJeDArdWZHbWFvcEl1Q3g4cGMxLzVzc0NaaXVsMnJqbFo5M3graVBlUHY5eWRiMFJpbjJGK2NSTzloNVBhekJhN2NqV0lJcFN5RytDR0lBaDZTRkJYUGtyZWdWMEV1UCtDZGVrL0dqdjBMOXJMeHZWdDk5bnNTclFIWUc1UlNaV0g2eXpNYzg2VjI2TXVjK25zWXVlREZLc3YwOGRQdWZNcTZtQTN4YjhKdDA2dnFac0wvVXVRdmhlK0FxZ2hDSUtlQ05TRHdhNVUxOXpOODN0RERQZEFaNmgvdGgzQzRwMTU3VzErekdqSkhjeWFGVEFmdU50RlJEY1RFRCtERm9iYlpiMU5Sd3RLM1hwelhGZVh2OENWUzUrQVdCVFZXT3JTRVhhSElBaTZjNmdMNGVldGVFWnZwSW5CL3RuZi85ekhsYkozZnN6KzhrN3RZL1NWNnJxL3FiajdXK0Fmd1VqckFwaW5FdVF5RG5mV3BXdHhpZlRzcGNsd2xBZ1huRzhXbGxOUXAzcDNDclZmUXQ2VnowTjhTZWhkQU9vUUJFRVBBZW9SazBOOU9uZHVkWjFlM3lHV1U2ZTRUOVErdEI3QzdDRmVIOXY5SGdndGxHUW9nOHJDUEg4VHVWeHp1Q2x6eDl3UDd6aTlDRmdMbUNVWjVsd2d1QjNjSlAwcG12UjdqVzhtbUIvM0YzSGxicEdSN3ZwRzUyaEszbU95REgyaU5oMkNJQWk2TzZqN2RpQWRvNlUzNEs2Ym5PWDRUeXY3eTArMlU5T29rTjFQVFZOeVp2UUpPVTNLMEY0STh3REhKUWx5WnBnSkxtWC9zdGFoTDhnd3AvTjFEWFFTeVg2NXBMMFc3UG95enB4ZGViWEdZdU8vRUFpQ29FY0k5c0JuWnJXZmxPb1liajZxN0IwL0hoN1F0WmJMdS9QWU9ZOXJxTXZDdVF3L3F1TXViVFpqL0p6eEV3SGVQK2FDb1RGMG5yejNMeWVCbUE1MzI4L3BlSHZlV25OZjE4K0xvbXl0Kzl4NXlRWC9oTTRZRllFZ0NJSld3VHl1TkpNUnQvM2x4NjFERng5UjhRalU5c2tsNFhCeW5uc1BxM21ZOTVxK3RPNVNGTDdPY2VwdExyNllwaW11QWFmekhHZU41OTE2eFBJTHdGejVzamsxQTlnU3FNTzRReEFFUFM2d081NG9NU3hwY3l4L0VVQWVJc3FMekpjTzRXUXpDL09SR0V5Rkx6YUtCSnlZSkZjYWJxZnpxNmZPVTJiaHlUQS9WNjE1Y09WVEhmY2tRdThRQkVGUEh1cWhFbHoyK3J5L1VGS2E3WEJyV0M3OXVxZHM4WGlQdUFUbU5LS2RYWHJoWG5vTDlMc3RWeU0zM0VZU0prUCtVZE1ZT2pZbHdKMnIxbHo2ejBrdEhaSitMcGVPc0RzRVFkRDl1L1BFTjNLN1hXNVp6ckNJeHA0dWhubUFHSVhFQ2VxRk1HK3ZiYlpGWUtBR01KTmxaa3NpN3FZcGF5aERycmplcGtFMjliN09XV3RPNFg2S0VDaDFJUmQrd2w0NkpyQkJFQVRkRzlTNzZ6NE1yN2d1ZkhNV3Q4V2g5d2hrc3FnMlhhV2htWUpIQUVnSzBrdk9VNWYxYjVmMUxtcWZXalo4aFVCK2x2STB2NWlRdldTODBsak0xTjFuY05YR0FPWVFCRUVQRFBTcXRld2MwajBEMUgyb2VjbndGbG1hOFc3T05TKzhwQzViT1djOHR5QVp3dnh3ZXlaWHZzdC9Kbk5RTHZuc0Y1dDJBNUJERUFROVVNY3VSSmZVN3NHNnNaZnFaTGRPVU9jczhnS1lMM0hwTHFOKzdxM05YRUxtK2R5SHRObVZKOEpSOHhadUhITWl6RG54YmVNK2k1SDdMMm16Vy9veVM0QnZscFg0UVJBRVFmY2lOUUlFdWNOcXMzelU2Y0JKRTl4TXFrVnN4a0d5UzU5TCtxTGo5YkxUMThUZHpYem1lZmdNWmsyNXoyYTNpNWZpem5mWjExVE9sVS9PalQ4bDlMNWdMOTBBNUJBRVFZOFQ2REt4cjExdHAwdWtTcUIrQ0ZDUElKTURUYWl2TGdMVkNTVnJSWHZuMjBSM3UvUkxzak0vRWViT2xWOE54cDBXT1BHenVuVGpRQjRXVFFBNUJFSFFJM1hveVh0ckQ3ZVZicDBhd2h4dkpscXN5akZJWnlJRGkvYW9FeTFpWnhQV2VQOTZtMTh3eU1IN1k1aXZyRFduUlF5RjlwTjc5WmR3NlptSUJaMy9LUG9CUVJBRVBTNmdUNFZtdWJlY0I5emlHbWd2YWp6REVEYnpZQ0x1a2xPZHdrK3FKL29RM0xteU10cnJudW1wem9DZHMrWFNnWkJodnJKeEREZUoyVngxbjZ0Y0NlWkZMcjBiSm1NQ3dEWGNPQVJCMEJOMDZQa0dJclMvMnlackxZWTZoYVgzK2RlSnVDbnJncjMwazRhenlHbDNuZ3o3eTJTa1lGV3RPWDJXZHRIQUY3WFdpYTl6NlJRcFlaRHJCbUYxQ0lLZ3B3MzBuUE1MQ1hQQlZTNFB3Wk16ZGs1ZHpySkpiU2RjdXQrYlh5TmVWRXlFbGRYMnVpaXpuV0crcHRhY0ZnejJOYks1Q1ZKTVIwdld1SFQ2dkVJakhkMGdyQTVCRVBUMGdWNElEOHBJdDFCZjQ5YTVuQzBHWWE3TmFMdVBuVkUyYkQ1VHN0YmtJZHpiVnBody91WjRXTDZnOEUxaWFNRWdCL2tJNnh1OXpEelBEN1RoTFFhRTFTRUlncDY4bHFleEI0N1FIckNGRTllR0w5aEg1bjFuNFZ1K1pnL3VBT2htcnB2Q0V6b0JnaUU1VFdZeXpQMDU4SUprLzJiaGtrbHhYa0IvV2h2M244MmZvcGx3NGpPZkI3ZkhOUVpPSElJZzZJUHAwS2ZjdWN6eWtKclFNS3hLeXMwR1VPL3ZxU2NPemlOTDZ3eTAvRDd3RXBoUDlJTG40U3RxZW9yWkdwaTNyanpackVmbVhicWMrRnhTV3lHVWVLaURHMGRZSFlJZ0NBNTlnZnZ0NXBwVGlOeUZxNWZNL21hblR1NlY5NVBUR2VtMDMyeHVFb0RpY3JpRHZiK2VQTGMrenc5cDBKRTczMTBuM20vMFBtai9md25NT2ZFdDNpczNzdzZienRsa1A3dVViVGN1MlRBNGNnaUNJQWhBTDRQVTlKMnUwNXZpc2FHbDJkOW1mMk5oK215YzFkNTJyWFBBVHlhZ2hRVkY2UjUwNW5HdWozeVZoNmdGcHI0dGh6azNpZG5zQ212M3ArTHJxUS9NaGRJWjR1Y2F6UXBCRUFROUNha1M2SlU0WUhlN2NsbmNwUWx6Rms2YW5XL2tZQWZQWStDbnhJdUd3bWdBT2ZQTUlrUHVudWNYQlJhZyt2WjFXUWc3bEtPUjJ4OVZBY2pGbi9Hd2dZMGJ5YnB2aDk5QUVBUkJVQS9vWE02VUJKWXNkdWVqV3doc1ZBSlcwb3lHd3NaWkIreXkwK1YyRFBYaHFOWkpoV3p2RWN5ZmRWc0hCT1RoS0ZTQ2VRazg3ZnRVdEREb05hVlpIdm9ZTFN5TUcvamlodDBjVmpleGdTQUlncDYrYW9aRW80V2h2ZkJLK1JHcTgzdm5PWmZhWHFXYTlWM2xHN0JNWjZ2ei9kYXA1OXc0TlpzeEIzVkNpOVhVSG4yNmQzeDRmL3IyMVd4WHVYWTZHdGZORDhMbm8yaTZGQ1Y3NmE2Zit0RnRXeUM1RFlJZ0NDb0dlZ3NTU2pScmZHSlc1ZUF1NXh6Mi9BUXYxNGltNXA3dVV3NHo3Sk4zVUk4akJCVWZ4K3hmOTU5RGM5Y0wzbVJxVDU5cjZUTVJCSWI1WEsyNVVxNFJUUzg3ZnVHZWVPOGNHNS9rZGtTU0d3UkJFSFFDMEFjQU5Ob0lRMlZwWE5KVk1DTjlZblkzT1d4WlBlY2t1Q25YMjBIOStkZzFrMHMvcXQ2aWdETFBEWVgzSnhMUXVOM3BNRU9kRzlmVXEyRk9PUUxzeXVsMVRhcEh2U2wwNlM1YkgwbHVFQVJCMEVXQTN0SE5sMFVSdUh5M3M4VzkwMlVIZkU0WWF6WU9zQmtYT29SNlZ4NVg4MGhYbzIvRXVoTVlBRGxSZHo0TGMzc3VpaUlJY2FpK29Obkw2RDNTWjByNzRwaHdCa0VRQk4wSjBEc0N1U21iMUJDRzk0M2RtTk4yUDMzQ25RL2h5bnZPVnhYRE14ZUNaNmhUb3RuMnV2OXNxa3NmZHFhamM4czVkRG92UFFpM2gxRDVFT1lVUFppQ09UM3Y2cTFvRzhLVVFUMlljajhZaGJjZXVQenNpWVhWNDM4RDJES0FJQWg2b0VDUHY2aDU5T2FOK3dJbnA4b1R5aFoya0pVRXh4Y3VZZTZRZHR4OEg4RS9Palpub3ROZSttMjNsNjdmdkJUVjh4OU1MQ3k2KzN0Y0RnTllJdWh3bDdWRDN2bHpLZDdtYW1GVXdMZUxiZHhRRkY2a1BHYlF5WVVUM2dCMUNJS2dCd3owQWR6YmhpOE1kalVlcURMVHdwVDNvZTN6MkJrUDk1Q3BSdDI2ZUhYOUE3M01lbVhCMmd3Zlgxby9IMmFRRDZDamIxNmxROThjSmJqaTBiSHVMWnNrdE1jUU0rMWt0MVZUMlI0RXREUHRhSk9jTm9BNkJFSFFvd1Y2L0hYT05lSHVwNlNNOUxhTXE0QWh0SjlOM2VBc0FFY3VtWnp0emZ0Q1dxajNPTHQ3WnAzMys4dDVOYXhudDlEUnI3K2ZURWpqTEhpQ2VSVE9uMjdQNmtGT29mdkhrT1FtZlhtaXpBQjhDdGFsMFJ3SWdpRG9jUUc5QTdCMXBNSmVibzR1Z1l6RDI2b2dROTdOQ2VjaEtPUytJN2RNSVd2OTVqMTI2dDNEWFh2VjhGaUN1N3ArTVQ0ZGdyNC9GamU3cVRjOTRORDlvNUkyampUc2t2dnNpUlBuNWkvMHZybmpuWGxnWTBwbE43M084VG8wejhuYmJYT3U4NGREaHlBSWVzUkFqOTBaQVpOQzJYN2ZtOGVIaHN6eVhPdFllaHp0a2QrODdKVzNPYWozb2QyT1Y4M08rcFlqU1BkZ1BuaU5zRkJJTFF6Nm5QSXVuUWEyY0VuY3pmMW5xdmZjZGdUdGlaYTIvYzhJNElVZ0NBTFFDK0RPOWVLK3F4cDNhTnRlcGNIcmdTa29tNXhIck41MHM4Z3RRRnVvK3hJNlNZbHplaitiWmM4bGIrMyt2b2Q1dkxmdHA2T3A3WHppRzJYRGl6Q3E5RDRjYUNnaEhFSzdkZDRtQVc0SWdpRG82UU9kbThiUTFRdnYrY1pKZEZSS3htTkxuMlZkTUplb1dRanJtL2ZiTWpVSDlmZUVldlloOXpqN2ZHNkNReGNMOXpnVG5VdnNDTHI4T2wyakd2MzZ2YjR6cDNJMFNyeUx1OFlsUU9qSzdKcmlTWEpuRVpjRytxWStjV25lcU9mN0hZSjdmVE04Q0lJZzZKSkE1N0t3U3JsdWJteWdxWjBxQVRRRzEzbnJwZ01VQTNCcHNJbWJVRFp3NjVSbGZ2MGhUb3dMVFZnNC9IN3pTcWlyNTN4L0dLODZiQU5yZkNpZTlzMERySHY5MlFuMGZQd1h5ZEMwOGFOS3ljMWZiRzg4M3MrbVJjeGNWejZUL1FXQ0lBajZ3RHYwQUpZMmY4cEJoY1BVTW5LQWxMVWRKNnZSOVZPbmZ6RTBHM2Jkb1VUTURJYW1zRnUzRHRxQi9HVmJDbWFhSGNPY21yMDBMLy8vZU95cWtvdzhiZ2JqRnc5dDR4aGFSRnkvNVJya0RNQklyVmpic2E3bnpGUVBicnY5blJZalZlZThld3NHMHkwcUx1S3lrYkFHUVJEME5JRSs5LzNQQ1cwaDVPdGJzVktKMXJCMTZTa2hhZnRjVHFJVFBpT2RNdG1qdW5hR3Q0V3dPUjU1U0F2QjNZWEtsUXUxRStUckhidGNjdXNjZ2c5WjlwSFQ1cEdwM0xCbUU3MGY0M3FxSC9lVERXYUtlVWxSRDBvQWxBUDN6U0F0ZDluelpYSjNJY1RZSVFpQ25nelFjMS8wL1E1eDdvdGZrb09tVUhlQWtRK0g5MXo1bkhFL3VCbmdrdURxWjQwN1VEb1FHd3R4QWpUVmtGT1hPQUszZnZYUFF0THJFRGlOVzFoVVhPcG1SUFBxWHhqbUZGN3ZaYnY3QkRrdXQxc3k1V3c0Sm5hejdRYTFTTmtQcFQ5NkdBTG1FQVJCVHh6b0dUZEhOZVVxOHZMVW5TMiszN3RuWTVvK000YWxYNVJFUjI3ZlhocUNPMDg0dTNZTENldmdsWDBSMmhOdkxNaXI1Ly9HMzJmYTQwbGZSKzdDOFQ3eGpVTHNmc0hCbWZmSDIybUl0elgwSm9MM2xWczBDSk4zc0ZNZDVSNjQxa1VGNE9JaENJS2VHTkJ6WC9hUkNQQXQ1UDE5K3RnZmpFSlE4WHZaTGR5NTcvdXRINjdpSnA2Uk82Y3dQVGx3UlpQY2pOOENzSXNGQ3NYVDdRUmcza2ZuZnVxMythRXd0SGNmTjU0UlB2U3YwaCtSTWFWQWUxeWdNMVBqWU9IaUlRaUNQc2hBTjJLNnJhamsvV2E1cTNzOTIwMTlkRjNZSXRCd0V4ZnQ5OE01ZWE1MldlelZNOWZrNVhCamVWOXpRaHQxZXFOTWVOY1I3cjMrQW9FejY2Lzc1elVjTW1NZXcvNzJuU0FlLzVWQUVBUUI2RUxNalZQTjNzTndyZnMra2ZlL0k4QlE1dnYrdGQ5Yjk0bG90SS9QUDZYUGhqL3dIanoxY1E4UWxzTzY3aFhRZXFvdy8rQXNWQ0FJZ2dEMDh6djBMRFFIOWQvRCtteE9tSHZMWlpGemYvZHJUcFRqeGpQMDJNWTZlTE56Ymo0Q2xhc3hQMGFIVmN2R2cwS2xxd09VeDBFUUJEMEtvSWVzN3BMSGNUS2E3cHRoT2NaNzZ4S2JZOWVyUFFPTDBFcTJnNGQySld2Tm5wUHoybjE1S2x1Ym1rZk80Zlo0OXJxWmRPYXR3MjhYQXVkY0ROd3ZBTS9xemdGekNJS2dod1YwNTJnOWJQaExPdW9jTi96U2pnSHZIOXM2N2NJditLbEhjUjA1Z2RUdmVldmJOKzQxR042U2srR29WdDExdW5NTmM5VHVoU3VkQ3dOVmJsLzNEMHFMQU02K1g0QmNocm5vV3JPV3VGV3AyblBxUlFYdUdueG5mejFrdVVNUUJOMC8wS2swVEZuSVNlZWdqYlp3cEpKcWFYL0tER3J2Q2tEZS9YSnltMi9mR3RxNDB2NTRxQytuc2pWOSs1bzdyeGxUT2FoYlFGTmlISlcxTlJiMk5FT2RwN21Kc0JjdmZET2JsMkpWYTFzZmJUQkNyM2hQdk5NL3pjZmMxTFI0Sk9wYWQzLzJVRGhnRGtFUWRPOUFaK2RLWVcxTjRYTVRPZW43bUNRbXV5RXA5VmFvelhqNkdZZml1U2U3Ry9CQ01IZkpiM3N1TTZOR05nUi82aVpuN0UrNm44QlBrOXBrOVViSXE3ZTZValNsdVBUTkxSQnUyeEE5ZnlhWFdyUzB4eld6ZkRRTFA3c1c5SEswT3ZBUGtmT1JHTEFiZ2lEb2tUcjArNVlmaGNwWHFYbE10Y25BeHZkd3B4N3JCQjRlclBJRC9IeHkyZFJJaHJ2SW1WZStiZXlPYjY5ZXZNM1FibDUvM3kwR0tHbU9wcnhWVzlmUzFrTXV6R0lQRFczQ1pMalo1ak1QUmZGQ3dTeGtjWEZDb0N3bk8vYlBJUWlDUGdCQTUvbmpWOUdFc2VuVDRQbmwxSnJWSjhneCtDbUU3bHZBOG43NkppNXBNL3c3UVpuR3I2cXJGd3gvZHZaODJ5djduSnR1MnRvQVF0STN2K0diYUxGQnJXUjlkN2tuQ2FyaTl3UklReEFFZlhDQkhvV0MyUVhUaERIT1ZGTVp0blI5NExrOUsyV3NoMHgzS2JuclczRHhCR1lld2xLNUVha08vRzVmbkI4bkZkK3YvVDQ4aGR2ZDFMYjMyMFE0N2laSDRYM2ZLblowK3I0ZW52ZmUrWFhkNURtWGpCY2NNVUFIUVJBRVBVV2dSNDFiS1BSTnM5YW5TN3Y2OWVqc292ZXYreVZyRFBNWG5YUG1rYTYrbGp6c3Uvc1o2TzN6NkhZdWZXdmFFanZxTEVldW5QYlV3MWhZV2pnMHgxdlhnQ1lUOHVkVG9MMTVlbzVkbEtobmZ2UnFOSmIxb252dkVBUkJFSFFuUVBldFdCMUlmY2g2YVhtMjcra2U5cS83TUgrckIzTkRicHdUNDN3V2ZCd044RC9wZGdJMTFiTVR3RG04N3V2WDZYaHVwS3BwRndPY09FZjkyK3ZkWUpKY0Z6MFlLUnJGS2tQdGZCZ3NZelQraFVFUUJFR1BBT2p0UUJNWFFuY1o2akpqdkFkZDRlS21OQnhlZjUyRllCeG1aeld1cFd1SUFFeTVZcnFmZXJ6VDQza2s2OGFWckRtb3YrQSs3ejFvODRMaTRQYlJRODE3RXVhSkNXdTBseC9LNnppazc0YkY4QUlGY0ljZ0NJSWVCTkFqOStzNnRCRzhFblhTTSsxYyt4Q2tKaTl2ZktoYUoxOXpDSFBLZHUvMnIwVUw2T3hwYjY4WjZHekNiMTliNW03YThpMkNOaVhMOFo1NkRPeVFVYStQYm1RcVpjVXZDamNZdjhBSjJ3NGIzOFZ1QUhlRTV5RUlncUE3QWJxVWJYTVgxeHExR2o1ZzdMYm5RQ2VrRDBrZkhHaHpVS09KYUZmUEJ6QjNrOU5hSUNvMUdMSXljTXpDMTE2VGEvYUxCdjNtKzZKNjlvUGR5eERVeWFuZnZoeTNtU1VBYXhjTm9EN3hER1ordmFuNTV5a2o3K2ZFVjkxRU56ZnIvZEMxdzRXRGh5QUlnczRLZEhiZ2xXTTVBVHpLUm0vN21KZUNPMkhZMmZtU1M5Vk5maDFCaXdjYWJ5cXIzbXR5OGxrRVhVNWlDL2Y1UHU3T1lEZjhld2lYMCtQYTBEcnRsZTl2aE5wZTlhSE9aVzJ2eC92M0h0aTBKVUREWHFqaFRhaWJQOFZsdStsd2xjdWU1OFkrUi9jNnVXZ0ZCRUVRQk0wQ25SUGFLQU9jd3NNV01aVnlYZU9rS0krZ3o3bDA3cFYrNjV6cEZPaW90STFoSzNzTENaY3dkOU56OEwzSEhLSkZBci9XM2gvSFA0d2U3MEhKZStwUnJibGJ4OWo3ZDg5OWw3azM2YmZJcnZySTNlZ29sTjltMTQ4dCtlanErRDRUdlJYcVRlOGpFZFN4enpRZTdzZjhjQm9JZ2lBSWlvSE9iclBTRG5yTXlDVnRYMHRvYjZKOTh1bmpjcmUzZGs4OGR2bTBiLzZxNTF6bEFNampjNDZCV1hPNHZEZDk3ZmFsZGVVZjZrVWM2RHFkQTlXdHN5UFB2U1BLWnI5NXhTRHU3Nit2M1JPUFI4VHltMnZQTzlTOXQ4NGQrKzRRQkVGUTFxRXZtSlkxR1hidlphNDNuQzJlREdIbm5Qa293YzFCblk0enJFa1gxYklFZllLL2lVZW9jb0xhcmV0WU4zeC92dXRjenFtSFJZRnA3T1gxZTc3VWJUdVlORmZtenFkUG1oNHJYUm5nQ082RHFYY1FCRUVRZ0g2YUVSK1hvN2tTc1VQeFhqQTdjMjZ4T2c3Yjg5Q1VnVnVtMGpCWjc1WUJuV3JMQnlGLzNqUG5aak83VVZtYUEvMjBVMitQRTByZHd2NzZvdnA3VTNpWC95V1V4dmtaOC94NXQrTnBFWjZISUFnQzBFZk9NVS94bkV0bmtCTXdKeExlK3RUMDdXRGpKTE1STEc4eTFyV3JEWmVsdzBVU0dmSGF1bkJWYlROUmc2MC9oNEllN3VUWWZiMjdHdzZ6WGV6T2U0c0tNeGttNmQ2UHBFR3NLcHBQcjl2NmR3aUNJQWdPZlpGTGQvWFZOOHNTdUNnUmIzczE3c2dXUVkxRDNzTmowaUtBOTYwSElEVHpwV1Qwdk5ESnJTTzY1cUV0NDFwejAwS2RoOEJZTjE4RVNSOFNweDcwM0I4K1YxWTNTKzJGQ2pQT09jRlJkWEJ2M1R0Qzh4QUVRUjhzb0p1WTNOTXVuUjhiWFBrUzBaUXp6aEpYMmRmSjdyL0xSTzA1NzJmdkI5RUNhZ3l6R3p6Vzk1ZzN6ZUMxOXJ3bjc4TDRxZmF1TmRmRU05UkxvdzlVSG5malJybUtldE9GeVRNd241NUZ2aExHQkhlcDJ2MzJ0dVlkZSs4UUJFRlBUbW9STUV3RS9lUEJoNWlYd1p4YnJwSWJIazFiNjhPTzU1Q25UcGlkdElrdXpoV25tc0trNEtzRzdyNTlSYzZBencwU04xMmptNG50Z2VSVGFjRkRVK05vbjcwMERHNG1ZRDZ4S0pqNTVDM2MzZjY3RzFuckYwWlM0cjhDQ0lLZ3ArWFFCL3U4dVI3c0JQS1Z6VTk0YnpuVW1DZk52N3VSNTVYbm5QQUlRQXVkWmc1Z0ZDYS9lY2tqVnRQdzlGRDB0ZTJsMmZ2aE9QeDRXdnhVdGU5L24zSG5KWHZuczZBditSaVViOXBuWEtraW5Ec0VRZEJUQWZxTVplUjk0Y01KbmRFMm80WXhLYWk3RXJVMHpPWHNudlNzM2ZWNzk4K1MyZXNtTkkyWkdLSHF6bU1GMVBrSnZrZThmUjJHZXJJeHpYMUkrcitEN01OOXhVSUJnaUFJZW1oQUR5VmtuT1IxV3NjeUx1ZEtOWXlKZVVzM2FaM0phbmZPbWp1cXRSbmVjclZMcCtPWWtFUTJmTnY3Ryt2U3E4ekN3WndPOVFCMkN2RlQrSnNXRDBxVkxVYUtuUHZDQlU2Rzc5M2ZTQUx1RUFSQmp3L293NGxqVFhrU1dBN0NveEt1bkRVM1hFS1dDK1Z6WTVYWTBSYkJKZk1ZM2tldTJ4R3NROWp5VkRacUF5dW5POEJ4cmJxVS9ZWTFTeFNheENnL3RFVlcrWE5mQzlQU01ybDV3ZytLQUFCM0NJS2doeVExTHZmU3ZwNzhjRHJNNjEwSDg1bDU0clAxNjBxSmJNWjkwOHpmSHJMeXcza29OUTFhVHZiTHRNR05idWIzNk1HK1d2UjZ2TWRlT2pkOVJkZTVJbmMrZDcrTTRDNlJVQWRCRVBTZ2dCNjd0UUN5Z3I3cjA5Lzd5aldNbVczUEdrSzVUVDdVN3VHYkxTa1RKdTIwaGVqMi9GTTE2YlFGTUFGMWJpYVQybVpJbkFMM2xkK3MyZC92TzE3dUVVL1ovY05jaGJXWjdhZTY2SktuQSt3UUJFSDNwdmhyV3ZFdlBQZjc2Qnp0cVJCUUh1WXFNemM4NGRScG5PblU2NGFNN0w0OU50MnZPV2ZQdDV1czI1UlRBQTViQUxPQTh3MW9hT1FzN2FzcmRlSmZKN1RPM2M4dnJFNzRXeGx6aGtFeUVBUkIwSU1CdXpMUnNJODR3THpxYTV1ZE5NRjhKbUV0N2diSE04NmJTUWM0SHRxeUFDNG1md2NmdDJEa2F6cnlQcjVSK3NqRVdiTFgyNHo0ZUhiOEtlN2N6TURjZ05zUUJFR1B4SkgzZVMyOVE5ZG1yd2RzV2dWMUhwaHkxZFUyejlHaERURVhaSWxUc3BnNTlTTXdZM2RmQU43MERQZjhJb1dncnJaWDV5dEoweUduWVQ4UmhqL1ZWWnZUam9NRU9RaUNvRHVGZVh5ajV1QzMzRlBJL1gyT1dndDM0NXJlSWpLMFRlME5YWnVIZWduTWUxUFZUTW9ZbndhVG9xbHQzRmJXRkVVYy9GRVo2bkxoaU5kWnNQc2E5dmxCTVFBc0JFSFFrd1c3NlVDdU95eStyeG9qL29sdk5GSUVzTWNXdmdUbUlrd3JHMjJabTR4VEZ0MGU4ZXp4cTBuVGJlYU9ZWnI1ODUvNzhDaVNrR29ObThrSjZBYTc3QmEzaXAwSHUydndrMzNmTXpBdjJqdkhlZ0NDSU9pQnVuVEg1Z0J5WWpjeG5GaXU3SlcvMTRIMG9iSXI1dFVrRERjZHpETXdTQUhFaERLdFdaaHZmT2E0bVFUY0hJeVRFZmR3NGZLNmVlZzZkOXpNZ0RNOTJPWHNVRGRtSHV6RmRFYTRIWUlnNk9HRFBKcVNIVERRdi95OWRlank3K3lGNkc2SmIzOEsyY0Y5Q3JZRUtYYTNadmE3ZndoMTUzWUxwS3FrODEwQzlQa29nQ3plNytiU3VobFhubnpmbDRCNkQrekhETmlYVEhTYjRqYWdEVUVROUJDZ0h2ak1yQmFPM1k3aDhqdnFhTVJmSGNNTk9qellRVDNwMG9PalZkWDBGMzRHNmk1cnZLQjVDbVhNSjhQdGZZdHRabHJTbW9LV3RlMzBzZGxQTTlXYU5nM3lFVHhWUFo5VnYvcXZyQWZOY0piODg0QWdDSUllaXp1UEdVM01KbllUdzRubEZ1anlidzVhdmtzM0hEelVHOVBGNW51cFlMNlZxNUJxdHZOYkV1cFpKNW1BTExkQmxkbkdNTXMvanZGaW9MMXduL2l5QkRZejAwVXU2WUxiZnZXVld3eEpkYUcvdW00LzQrR28xb3ZzblNQY0RrRVFkSEdZZCs3Y01ibnhNRDk0bUR1R3k3OVZCeTIwL2VXUDdNWGU2S0hPRDNKV3Z2M2VKZ2kxZTlxNUwvUUptSVVSb2lVUUlCYzdURlk3R2V3enp5V2dsN2huL3o2TVhnanpMaHpnSXh6cWd2OEN0SU03WmNhbm9nV0w2STI5Y3dpQ29IdUZ1Yi9Tc0JOM2pDWldNN09aM2ZLUGZ1VWIzOWFLZnRscitUVjcyZnM3K0VFaC9FNVBOQVFmRHp3ek96UWs0VnlOV0RiQUpFeFd5NEZrMkpkOXJaT01qc092VnhvT0oyQTIreDdJaTJBZXY3L3EwbEEzTGRqWFJGTWdDSUtnaHdGejU4cTdNSHNFY3VMM25oak92blRQTjRoM2I3WDh1cjlPRDJpZHVwWTBhblRENDBhN0RMdUZrOEQwY2RHZ2x5NzhiU1pKNC9iSDU3TzRUWURhekdKZ2JnNTY3NmdVMnFaTGRyRWdwaGM2TGRRdlBCTjlCSGJzc1VNUUJEMG1tSGVsYVk3Tk1hc3R1Ly9nbDc3eDdYY1o2Sjd3NHFhUnYvbW1rZCs3ZFE5d1R4Q1ZPSXJhWmNEcllkcDhvVlAzTFV6TGFVNUpkNXQ1MSsrb1d0WmtwWFRmbnJjVXlwUFdrbEdIYkp2WWROVEF6VU92N3VCZmlPbWdYbURZVjBVOElBaUNvTFBEdlBFNWJudlA1c0JwWXJabDkvOEl6MVVISThLRHZuZmJ5Qys5YVJUQlhkem9TdXhON2R5NlQ1UnJRdk9adGw1OWdQVlV6WGxtRWxyZW5WY3pielc2bkJweVR4eGJMb0ZybXhjd0ZVeVk3eXpIbmZiTzJWVnVDZGdOM0RrRVFkQkRBSGxjWHg3QzdESE1iNTM1NWd1eDJqTDcxMy81RzkvK1hqaEc5VlAvL3Q4Sm1xVkN2dFQrL0wvMjhoRUx0WThxNnMzdWIyOU5xM0ZkYXZoL012cktqMXl0akcvalVhekhaVUFmREdLUkU0N1pIQS9GVUM4R0ppWDlOUXZPbWZiZitZTlNaVURNN1dkVHNoeC9xUHB1L3duSjNsOXRIdVp3NXhBRVFXZDE0N0VqRjk2Vmg4VDBZd0xtcngzUWYvL24vL0QvL0c1OHZQcEk3bHd5ekVWbGlhK1UvSFdweFVmVTBYeUt2dVoxRlJXelU2STd1ZExLQXQyK0NEMUhlYWNzaDFBUDVWMUx2ditwOXR6SUxFQ0djTmVsVzhJTHRvNXB3V0lJem5vQldPM0NRdFlxZ25wSnYvZkU0NmhVejM2b05NcjJ6c0JwdXRJOU1kZnVGekNISUFnNlA4eERPOWZJblI5OUdYbHc1eTNNand6elAzOXpsTDgyUEdiTmRsNFRSeXlnQ2FpTjJkdXJuN0gzL2FtOTZ6OXAvejNlVkZ5NExyYktoZCtWTktKU2twOG5JN01Yb0d1T1RTaGVMM2ZuY21PZkk4cytBVDR2T2YzNDlvSFNEMzR2WVJXNTdZMzlmYi9zTDhOUTN3M2pGTkhCVXlObFplSUVsSC85NDkwQzFJaDVzSVBuRUFSQlovM2FqZHU1aHFZeFlZdjcwQ1crK1RBN3cvd3ZyRVAvakwyTUlGVVRwTWtWODZVSlgrWG10VjB4L0dmN0NsK3h4L3U4OWpEZjBVOTdBNW5SbXR5NXZVNVFkeUFQYXd6NzA1QTdONHRnenNsd1JuWFRZVW8rREg3M3N1aGprMHNpLy9ZOGpGSExnS3JwZlIvNzlmTkw2ci83N2Zqb1QyT2YzdHlmSzVaeml4SUlnaURvWkljZUpxYUZkcTVSMDVpRHoyWjNDWENjMy9hL3lKbGJtQjhJOENPZ2gvN3RNVWg5VTlXRGRjQmZzQ0QvYXd2eHIxeFY4dTJqZmNXTmZlaEd1VXZsb2M0bDNEUXlORHlicUwvMHk1K2lBM29tSVUzMkFXT09zc3cxYXVtTlorazVWWGF4c0REc1RtcWFRZWc5dFRlZDIxS1E0emRMU1lpNnVmOVF0NVJ3NXhBRVFSY0F1amFST3hjeWdya0lkZWJrekw5TENYQTNXbjR6T1BWYm5RUzZjdnhWZnBrZ1pDL1R6Z0w5ajQ5R2Z1dW96WmZ0U3VFWHRrcHVOL2F4Ryt2TUt3cTcrLzMzc0ovT3RlRStETDRFNmRJNlVuRmM4Q3h1YzFvSUd0NFdNTk9OWEliSDBmWGlESDMzUEozb1FaK0I5cXpyZGVGdjk1bnFlLzduQjNjT1FSQjBObWNldWZOb0JHcmJtejAwamFFNmN3dngvMm12Zi9mR2czemZ1RkQ4Q09qR1I2MHBPUzVBM1VRSDkwM2Z2M3RVNG9zYkxYOW5xOHlYckR2L3JMMzhjR1ZCV1Z1b0I2QVRkSlJ4Ym4yeEE3U3VlQncrbnpnT2ZRck5BdER3b21YSmVkWHN1SmU3WXg4dmFjdmZscmp5MU9HNC9zQzlXYTN4WHdNRVFkQ1RBTHZzdS9NK3pQK1IycmxhYUgvMVlNUzcxcDIzTmVpaGxQeVlCSHBZSlhpb0d3dG8zajdXRWRUdGxiMkY0YllTNzI2aytBM3J6djk3cmN6SGFpaytvYVQ4U2V2VWY4eTY4M2VrRm05SnpteGJpSFFxa1ROcW1UdHNwQXVMbDY0WjZMRnFXY3hBTkhYeE1Kbmg2b0ZkZWlyQmJNbGVkRzh4WWMrRlZpV0FPZ1JCMEpOdzZkWThVeXVZbDVhejcxck0vZ09OTTdkQS8wc2F0T0xuckhpQVU0YzQ1OXFKMDhGc0QvV3ZBZ3dBVm1Za1lzeVZvK2dBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJUUFBQUJHQ0FZQUFBQU5aRHdZQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBCT0RjeE5qSTJSVE5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEJPRGN4TmpJMlJqTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qY3pNelZCT0RnNU0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pjek16VkJPRGhCTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTnpkYzhBQUFCL1pKUkVGVWVOcnNYV3RzazFVWVBpMWQxMjdkMk5qbUdQY1pGQ2VJUktnRDFPQVdqWW9nTEFxQkVOQmdKSTQvSnNPTmlCS3lvQkNDL05HRUVnMyttQ0dTRFlJb1RvMEdKQ2lJb0NJQkJvRTR0MFhHM0tXN3QzU3o4M3ZPZGo2K2xuWTkzYzJ2M2Zza0o5MjZmcGVlODV6bnZPOXozcTZHNnFKNUxCQ1NzcGVabFlmbGZXMkIwaVlvemN3STBReUhLUWdaQ2xpUGQwOVhVeTNyY3Q1aTNlMU56T3R4TStVNTZySW9oakx1K1NhL0o2WXBEMFZkenRwOFYvVmw1blYzVUMrTk1waDh5TkRUVSttcXFXQzNhNjlUejR4U0dEVS9GeEVaQ01ZK2RkalMxWFF6bjhoQU1QSnNvc2Y3bnF2cUV2VUdnU3ZFQ2svalRTV0xjRkZ2RURnaGxpdFpCZlVFUVNXRS9kK09adW9KZ2txSThkNHVOL1VFUVNWRUxQT1NBMG5RcEowRUFoR0NRSVFnRUNFSVJBZ0NFWUl3T2dsaHROM0RteDd2SzFwZ2lxU2JuYmoxSy83WTl2TXgxbnlrT09qZ1pCU1dNVTlkRldzN2VaQzVMNWNQKzMybGJYQXdveVdPdGYxMGhMV2YvSWdVWWxpWW1wNDFvT1BHclN6bWcyT1ptc1c4bmNOdnlTZmxiV1BtOUNuTU5EYVZHYTBKcEJERFFZU1VOZS95RHE3Yit6cnJycXVRUGpieDJVM01PcU8zYU5oZFZjRk1xVk40Q3daUDlSOWhuZDhmdGtVYldNTDhKWGZ1UFhrOEVXS29nUUhDREVkTGZ2RXRWcjkzbmZUZ2pNMVpwZjRPaFVEckQxNTNKMnNzM1RXZ1pRWFhTMTc4V3U4OXR6UndBc2ZQZVZKUkNRZHIrQ1NmbG95aGhQUG9oK3Fnb3VObGxFRU1Ucmp3VkowZk5CbnE5eGN3Wi9uSC9IY29WSHJCNFFFdmVhUVFBWUFaMjNFaGg4KzRoTWZ5Z2dacUNDQVJNNGhsd2xOWHpSb1B2TlB2TWlDQ1RpaFF4NFhqek52K1QzZ3h5dXJkL0w2MFpNRDEycFhtN1d4bEtTOXQ0akZGK3NaOXJPWDRnWWdMTW5VYlZEWi91WnRMT3FRNHpyNHE2TUFLTXJpdW5lZGtNRTk1V0Nyb3hMbGJ2M05JMzQ4NWN5R2YrWUlNSUo4Z2cwRG51WU9zYnQ4Ym5DaDh5Vk5VSkcxalNVU3BoVzdUVHN6Y3RqTmZNRTlOUmNBMVh2dzlZY0VML0xIejkzSStLM21HTVgwdWEvcXNNS0RVQ3dKaDlzcW9BNGlYK0hTK1QvQ0lnTFd4NU0yQXgzc3FUN082RDE1bUtldmVWK09ZaklJU25pcURnT0VxMGtqRDBIcDRlMC96MmFPNk42UzBnNkwxSWZBMzBjbFFFa2kyR0RSdFFHcVp1WmlsclN0VzFTUlU0SWZ6Mmg1Znl3a0hrZ24wNTRFRURIUnoxNmpIUTVWQTN2WWZQOVVsTVpLeWwrbmJtQkpFaUorVDZ6TW8va3FobFd5czR4aDR6RXpJTlVpQm9GTmtJSkQ2cHRKdC9hYTlpYm5ybWZXQlIrKzZKb2prZGJYejg4a0NjWXE0ZnpUY0Iwam11dm9MNjd4NFlrU01zNGhmTWpBb3RvVXJmWWlBZ1VTd0poT1FOaDVLNUVyQjVYckwxendPQ1NYMS9ncWpUVTNGMG9UbFJpdzU0YUsrWkJzYis4eXIvRDNnUFNFV1FYT1dUOUpWNEduU215SWtMUzFVQXpjUnlRdExlUEt1YzNKZVJrTzFTaUJCQmhtcGg4SWcvc0QxY2QyTzM3NVg1VDMra2FlQ3FsVEkrMUhPQmFLaWdYVHg5c1djckZBY3ZXVWh1bE1JU0xWMlpyWitzMGZxT01RSWx2dnR6Sm8xWHlXQlVKYVdiL2RMU3pPeUcvZU5Yems1dEtqZDhWekExNmV1ZDZpcVViUFpIdkw4T0M4YXNwYnUraHVVWmNoa0ZrQ293QXNFaUp1ZHc4WWtwd2QwSkVHRXRsTmxkdzJzekQyRWU4eUFEREVsRzZHMFV3S3lpdERkVUtsSWUvRmRKSEJkT2MzYzE4N290c1BKaHhoQ0lDZzBXdUo1cEE5RHFPWEVRV2EwMnBUbmJNeHo4enB6WHowMXFNMHFRb1Q0RUtFeUVoZy8zR3hTQ0NLck1LR0NXMUY3TVZ6NGUvdnp1dk1pNEVORWZBbWRLVFh6enBKUlErb1FkVXVHMWplUUNnS1ZiRVFnWmVWbVpma29EdXQ2Mkh2d2p6Y3djeHNQeVNsTndoTXJlSHFMKzNBZWs5OGIwYXVGcmI4Q21UREl3T1ZkNHcwTXhDZndkanFEcG9kYWJ3VHBjS0NDbmJpSEZqSFdaellGeWs2UVhxYTlzcE03bHUyblMzVWY0K2lPRUhEMGpIR0pVcTgxVDVyaHMra0VkRno0Z2ZzSTBvVG9hQXc1azJNeTd1VUREa3M3MEtaWmYwak1XZHZuVE9hR3RidEtoQkNaUkJqZWZyeTlSRjAyVUZRTFB5STJjMWJ2MXZrUVNqS01MZXlQd01Gc1BaNGxQY3ZobFlTN3UvcC9JMktEU213d0NVTUtjdXc4dkZPdG44RFc4MUNURkNrdnY2NmlFckpJV0xSS1RaY2pwVkRHR0tsazBPNWVZbzhDczFZRWRXS25jeWcvTDRHU2ZxNUtxSnVVT0MrMnZnVmhRZFpJUVVRUkFwNEQ5ZzRFR2JCcGhDb3BiU0FvYWh2NVRtZGhtVlJOcHF4S2dIdzhrSnk3UEtTUGdUb0k0WTFFa2xrV0VVNGxJblhiL0R5ZkdvVmc5Wk9RWnRSRUpDL0pWOHZZVUplSm5VdFVWUTFtY0xBM2duT0hpbk40MmxxNmkyKzJEWVZSTnBMUXBWT0pHV2FlT285M2FHem1iSjg2Q01RSmlCbENiV1ZEVFZERzc3L3hCU0oxMWY3SnJXNVA5U1crNDZnTjlyUVYxY09OY0txdlJnSzZxNWlDRXFTczNoclFpeEJFa0sxTGhCS2dXZ3FSdmkxN3FScnRnMXhvb3ViQ2YxQ2k0ZE5YVWJOa3dESHN1dldYU2dqRUNMY3JMdzJxMUV3VXBrQjFMRm01dkFBR3ZnSklJUUpTbjlkZk96Tnk3MWVIVnJ2dWxneElQZlluOEFHYTRjN2J0UVc2QkowVzJVTHFSeW9xSnpKRWlROUJJRUlRaUJBRUlnU0JDRUVnUWhDSUVBUWlCSUVJUVlnT1FyUVp4cGlvSndncUlXb05NUmJxQ1lKS2lJdGpKS3VjQ2FPREVKL0hKR2RRVHhCVVFwU1pVeVl3bzlsS3ZVRmd4dWF6UnozTVlIemJPblVXOVFhaE4rMVVTTEVqWnR3RVIyekdkT29SSW9TSzNkYkpEN0xZOUV6cUZTSUVWNGxLWmpETXRFNmI3WWkvejg3L01RZGg5TUhIa1ZKSWNVVjUySmlVdmV4R1RQTDRQZmlTZUh3dk9MNEsydXR4TTlaRFgvZ2E3VEJVRndYK3Y0c0tLY3pLd3dxbDVTbHRydEltS2kyR3VpeXE0ZmhQZ0FFQVZZeTV6b0xNRUgwQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW6YeRLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSVFBQUFCR0NBWUFBQUFOWkR3WUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwQk9EY3hOakkzTWpOR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBCT0RjeE5qSTNNek5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa0U0TnpFMk1qY3dNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rRTROekUyTWpjeE0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K1FRakpVd0FBQ0JwSlJFRlVlTnJzblh0czAxVVV4MDkvdjdYMHNZMk5QV0F2MlJNSGlPQkFIaEpRMUJCaW9pRWpRRXhjb2hMSWdEOUlISWhHZEtDUU9HUWtBMkVMeEdDY2tTRHlra1NSSUZNV1RjWXpJQXRUOXlLTXpZMk53cmF1bzExYjc3bmRyN1JiMi9XeGtEN09ON25kOW50MFhlL25kODczbm51N242ejcyR2Y3QVdBdGtFSlp2YXkxc0hhTnRST3NuZnF5ck13d1lMYkF4OVdkRGdmS0dCQ1dZMS90QTdWY2dERVJNaEJsOU82Rmtpell5YUljNUNvMXFHTVNJQ0V0QTVLZVNnZEJFSXNxOXU3WnZhbXFZemdRUDM5VERsRmpCRkF4SU9SRVJFakJnR0tCQU16c1lZQjlOWmdzSUNpaklHUEdYRWllbUZuT2R1K015dC9TN0FERStlOHFZQ3dEUXEwUVFDRVFFS0VHQlcvc3djU2dNTEwyaUVIUlp6QkQ0cVRwa0pzM0YyUXlXWVlFUlFRK1lGREF5SUF3VUlRSXpTaUIzNWdGMXM4VzdHTUxSTWhrMFBudkRhaGp1eWJQblBjKys3SU9EeFBvTFF0dHlhVEdIZ1M4NEZrYnd5NTZ0VndHa1N3cmRQeHpIVnFiRzliMkhOLytFUUVSam5ESU1DTllNNEdTZVVhMENmVlgvMkFldzdTZFFhRWdJTUlSakVFb0ZJUFJRbWJVdzkybUJ0eTFnb0FJNDNBaERIcEhoS0t6cFFtM0xvMmdkeVo4MDRjZ3M5YWRSRWFHVHNzTFZMTW9Rb1E1RmRiMEFURFFyOE10U1FRRU1jR2hBSXNaZnlSVFNVUFN4NDJHbmFSaElpQklCQVNKZ0NBUkVLU1FCa0tNVHVHTlJFQnc1ZTZxNW0zQ1c3dmRRcE83NXlha2YzQWFJdk9XVSsvNm9JQXNYU3RTbmdQRDNXdGVuNWY4emk0UWxXclFaRTZGZHAxMlZGNExncVZLZjhhdjV6RDFkY1A5TTZVRWhDOGdwSzBwQlhsc0lqU1dGSGdGUlVMK05vaWVPb2QvcjJ1c0JVVmlCbXVyWFI2dmI3enMwZk5IVHBrSGNRdVgrdjIzRVJBK0NEdElWR3I0Vlo1YzhDazBmLzY2UitlTlcxSUVpVXNLYkQ5amhNRG05cXJ0NzRPV3I3ZEI3OVdqbENjQ09XVzBIdGtGRXd0TGVJZGlSNDkwWldGa3NJZkJHK25yLy9UcStObzFtVjRkajM1bk5LSkxXQU9CVjZ6MjBtS0lmZjRWaUYrMHdpVVFhQ0RSTTBocG9yK3RHZTRjS0hLYkJ2Q2NuTzIvOEFqMDRPSlpNSFhmcFpBUURLT005aU5iZVVpWHh5YkEyQVdyWFhhc0JFTjNiUTJIUVpVNXl5UFRpYzk5NzhkUzZ2MWdHV1hnbGR2MTJ6SFFOOTkwbXVPbC9YRXZMZU5mSDlhY2hNek5sZFlSUnU1c2FEMjQycW5Qa0FEcStPa1FSWWRnQWdKMTczaXhMUm9rdkZIa2RQLzljd2RzSGR0MnRBeFNDejdrcVVZUmQ5ckJrT0xRTVNsL3ZTMmFCSXZqSnlDR3BBVUVJV2IyWW43bHU0b2traDVXSHdTVDdvSE5rR0p4Q3FHd041M29NMW9QYmZUck5YbVZqMVZSQk1SbzFDTEdMU3B3QUFFN1VwbVU3cEVoYmFtTTRaRUNvWmhVVXNOOWlGU2J1TE8vMEs5VWdaVlNpaEJQTUNLTVg3bVZoM3hKUnUwOTZLejZub2Y0cVFjYVBhdGxkRFRaQUpKZzZMcHdFdjc3OWozS0I4RVdJYUtuemJPbUFqWUtRTE1vK1lpUmhCNEJLNHJSMCtiYklKQWlTL3VwY3IrS1QvZXJLa0YvKzVaL0pwbWxNZ0xDeDVFRjd3UTdzK2dLZ09pWmk1bDVuT0MwSW9rZ2RKNDd6SDJGdjhLNmhpL3pLaFFoUm5Ga01XSW50ZGV6MUZJeURJTHU2OVhRVzFzTityL1BVZXdQdFZIR1VLRXBGRlVhTVBYMThDdTI0MHdsaU9vbzd1VDc3OVJCNzEvbi9iNlMwZENPbmJQVUo0QzluUlYxVldNaElEelUwSWt1N0F6c3dKeGlsbWFZRWUxUVI3TnQvZ0dCbFU1djVrWHNVNXUzczZKb2RBTVJpS0JlUXFjWW4rMXd4VDBScjhNTUw2V01KeVQ3dW9HM25aUDZkakdJaFNWZS9iN0cwalV1L1ViZHhnVk9qYTBuczZ2dVprVTlIVDVUaEdEeUJnWmV1N0NyWUxxcVpyb0ZxcmVMWEdRZ1I0amJGWnRCMU1SNGx1OG5UaDZXczdXWGZnVmQzVVhQZ2VqcElBSUNHUWh2VEZicy9OTzJ0TkhmMnNUckVaSFp6MXFuem1rbU03eE1KZVp4cVNDRkMxMWFLeit4clo5SVcxZEJ2UnBPUUF5ZHZjUTVDcXcvNFBRM1NwcnBwTTl3aERnUWZFWDJoc00yR0hEaUMxZEpTY0l5ZGR2eGZUWW9jRVVWTG9vaEJiR0hjR29lbjM0VlloZXU1Qk5mOXRQaHp0WlA0cXlvU2RjTlNjczM4R054VVF5dXk5VFduT0dycXJ5cFpPTE1xMW5mTTJ5N01qVm54SFBkZlppSWdQQlNHT3BWMlMvd3lwOG1aNGJET2dqMENlZ1ozRTFsWTZUQXoxemdNbjZNRk9nck1LcGdRNUQwTFEyODFLMXZ1ZzZHdGxzdURhajlOTHkzQ3JhVjFnRUpCRWFDdEhkM09LMUZTQ0Rnd2xoUFJoQVlDYkRVamZNTHNRdnliV3NwRVM0TzJHQm51MXNuZ2ZBNHIzMW9ScXlYdURwWGVnMEVoQWZDaXFHK2RaWHR6VWFQMEZ0L0E3cXZuUFc1NW8vblljT29Fem45TmI0QVY1V2F4VHRGTXFTdTFGeGE0SE9sc3FINFpaZjdBcjFTR1ZBcG8vMkhuYUN0enVZZm9Cbk5XZ0krRjZZUysvVVJ6a1lobUdvd2Fram5PQk5PYUtFZkdYb01McUxwdWpEeWE1R0tiL2k3QWxIOHYrSC9mcmdDWWxVaWFPUUMvZlB6TUpQUlpBR2QwUXhhdlFsZWZMT1EvbUVJS1VqckVDUUNna1JBa0FnSUVnRkJJaUJJQkFTSmdDQUZsU3hER2dGQnN0M1RFMlFjQlFNQkVlWTA4QnU4c2hhaDFPQ1dOZ0lpakNPRG1kRmd3bWEyZ0NZMkhqZGZKaURDbUFpOEp6aE9idUd0bitOVE0zRHJTUUlpSEZuZ2FjSUNoc0g3Z0Z2a0traEp6OEpkUndtSU1EU1FDQU5HaHY0QjYwM2hzL0xtZ3lDS1c2THl0enlpKzNhR0FRU1BVNFNGcHdtTURBaERMNE1oY2RKMGpBN2xESVlkZUJnSHdqU1lTd3lpaGQ3QlVLMDEyRVVHVEJNWUdlSXlwMEJ1M2x3ODdBdnBlQTdFSTBhTG5zTmdCaU90bUFyUk5BRjhOSUV3Q01vb3lKazVCNUpaWkdDNzk3SG8wT1FBUkorUjM4UVREQ2Jyclg5SklRYUVUQUNGVWdQcXVIaElZcU9KbEl3c0VBU3hxR0x2bnQyYnFody84SXhBbEM5YnRYNHR2WFVoTFNOcnVDTDRDbXNuY0RTeHI2ek1ZRFFQdHdqL0N6QUFQc040WEZ6d0I2RUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WlluWTgS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQS9DQVlBQUFBeEJleUlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJORGc1UmtReE9UTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk5EZzVSa1F4UVROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pWRk5UWXlSamxGTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkwT0RsR1JERTRNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtDZ3NGRkFBQUMyUkpSRUZVZU5yc1hYbU1GR1VXZjlWZDNUUGRjL2NjTzhDZ0VEWVlpU0tDdWloS2dxNG9zT3N0bUpVVmhlZ0NpOUYvRkR6WUJCRUJFeVVpeTVKc0FBL0lMZ2hCM0lCWHNwcEJ3RVNRd3lFZ2Noa0c1bUttZS9xYW5yNXEzL3ZxcTVydW51Nlo2cG1lcnA2bFh1YWx1bzZ2NnF2Mys5NVozMVFKVFE4K0NIMGtFL0t0eUZPUWIwRWVqVHdNdVFBNUR3elNRcDNJUHVSTHlLZVJEeUYvZy93RGNsVExDVWFlTDR4YkYvdlFpUnJrdnlJL2lUemN3S1JmbE1mWmdYd2o4cU44KzBYa3JjaC9SNjVQVjh1MFVqbS93Rm5rSlFhWUEwckR1WXpQY3BtWFp4clFtY2lua0JjaVd3MTVaNDJzWE9ZaysxbVpBRlJFUTc0Qmw5dVFLd3o1NmtZayszOXpMSHAwazZLVWVwOGQ5MjBYQUdaSWhrQnpnaENMdnlDb05ZSnNNZjNwYUtnWVFhMGtNQTB4NWh5b015S3l4UlExQTRvTjFwc0IvbUNJTHplSnNDR01OQUhhS2NHZnNNR3podGh5SHRSbkVhdlozVFM0OFlFSDFKV1dpRkJaYnBaT21lUzh5S0FjSjR4dG5KZkNwakdUNndzYWsycG9zVWxhYVlBNXFQeHBXYVU1dWlMTzVFb3kwbkFoWkJwbEVXQ09zbTd3NEdERTdLbi9Edk9OaXRQUVVSZUtCRFMxaTRTK2xRSU4wbGRMUmNKTy9za0IvVjErSk04bVNFOFk0aG1jUk5nUmhpcWdmM01FSnBrRnFEWkVNMGdqWHNTT01HUUZCRFMzcHYwMTNudjE3cFQ5OGNmWjB2L0pKMm0xSzFtOEdEcVBINGZnOTk5RDFPbE1xMjNCTTgrQVpjUUlpTFMwZ0dmZHVsNlBMMTIyRENTL24xMHY4UG5uT1FWcXFVbjZQUzYrSVo5cHlUUEJlRDNMZThXTEZrSEJ2ZktZQ3A0K0RhRmp4elFQQXRzZGR6RHV2UHR1YUh2cHBiU3VTMkRtanhzSG9mcDY2TzMrYmRPbXNXTlpIOCtkZzF3cmh5S0dFK2lXeU9SYXJSZ1g2ZGtaNzlhdEVHbHJZNy9MWG54UlV4dFRXUmtVUFNvL1BveDJkRUQ3K3ZVRDJzZWltVFBaa3ZxWnJoWEpCbkVNclNJRFZKQjBmWkpDcHJKOTQwWndvSWFaSFE1bVJ0dFhyKzVad004OUJ5YWJqZjMyN053SmtmUG5CNngvaFdpYXFWL01YK0Z5eU83ZHllOERCNWJ2eXkvQnUzbHo5Z0dWTWJTYW1Kb0tZTmQ3aEhWKzl4MEVqaDZWVFNtYVVNdE5ONlUyTDNmZXlZNGhvallEcVRIVWo2S0hIdEptTlhDQUZkeDNINWhIanN5Ni9EaUdGcEVGU1pJazVvSlBjSzFaQTFVYk5qREJGRDd5Q0xSeGdCTk5iY204ZWFyNW96YVMxUC9lSnpzSFhVdHhBY3lzZi9oaGN2ODZjYUxxWDhsYWhOSEg2cEdQRXBhaWtwRHE0c2p2dWd0TVJVVngyMElYTDRKWVVRR2RkWFZnbXo0OXFmQVU4K2VycllXODIyK1BOM3NlRDNUdTI1ZFMyL0ltVE9nSzl5dGtUMk95MjZGdzdseDVrRFEyUXNmZXZiSS9mKzAxOVZwT2pJS1RuWmZ1UVFIVGYrQUErTFp2MTdYT29DdWc1VDFFcFNXelovY2VIYWN3aFpkVEFFcGdKbXREb0NuYktlTHRQSGlRZ1prM2VqVGIxcjVsUzFJd2FZQ1VMVm9rdXd5TXpsMnJWdWxlT0xxcVNuMlMxNnR0b0sxWUFaYWFtcmpCMWRzQXN3d2ZEa00vKzB4ZGIxbTZWSFA2bFVsaWdPcnRQNzFmZnczdDc3L2ZyM000M25nRGJOejBwYm9mTDVwRGI0eEpWTnFRVmpZdlhOZ1ZNYUxtbGIvNnFocEZhdzJJNGt5LzI2MkxYSTFpZkJJS29tWTF6WjhQUTNnUTVQNzBVL0R0MnRWVllYcjRZZFZFTjczd0FrUmRMdG1rb3o5M1lEczl5UUMwaDl5NHAzVjFPNEtaYnNseFFOTVhBN3IvTDhvSkh5cGx1QTlTaHRzazlrL1MwSGRKSjdtS1BLdldHVkVwczMzb3c3bE1wYVZnbXpvVjhtKzRBVm94UXUyeGY0bS9sZlZVMjY4MkgxcUVnaVRXaXloRkdmclJSM0VWSXExK01aZjg1MVVaRkZreFRiRlJkV2ZNbUxoY1V5RXFFUFFxdEtvcXRneTN0aG8rTkpaYTNuNjdXK21QSmZZTEZyQmxCeFhlRHg2TTIxZjI5Tk1zNTB1MmoybU14NVB5Zmh4TGxrREJwRW5kMjFDZGR1ZE84SC8xRlZ2UDUrVkUyazdYSWdCank1Q1dhNjlWOThkdEg5WDFGTkkyWlFxRXI3OGVnaWRQUW5nQW53VGxsSVlHa3BUVHhKZ25GWUc2T3ZEenVtb2kyT0htNW03N2VzMHZVYkFLb0FIVVJMRzhuREZwbW5mYk5yYmRqZ0FwMTFEelRteVRiQ0JZVWNNVGoxV29CSE5Wb25iTVg5MVhDNkRKS1ArMjI5VGY0Y3VYTTNwdVJRTnBTYjZ2WXZseUJtaWlocWVWcjNJdFRybmY1N3U2ZmFnMVJrT0RxS0daTGhZb210aVQxYmlZb3JoUE5PU0REK0lHZ2VlTEw4QzlhWk5SV0VoRnR2SGpaVERyNjNNdWdpeWVPMWNGMDdkL3Z4eWgzMzkvbkp2SUNVQnpaUlo0d2F4WnF2bnlmdnR0MG1NU0UvZFVUTE1HdEZ4VDYvbm91YWZpRi8wWWtMV3VXc1g4TVBXMy9PV1hRY0JVUjIvNWRXbW9rZ1RyeUpUN2xjWk0rbUwrTHRteHlSTCtKRnk5ZWpWVXZmTU9lM0tTOGppTjU2SnpWRHovdkpxcXRMMzdMdHZldG00ZDZ5c0ZSeFd2djY2L0hIUEY1Sm9jRHFoNjZ5MVZPMTA3ZGtDVXp3THM2L25vWFBtalI0TTRiRmkvK21hZk1RT3EzM3lUblkvQWExNjJUTzBiVFRXNXdoLzcwYldxRUdpVHc2Ry95WTFpMzNTTGFpZFBodW8xYTlnb1o2WVdmVk52Z1l1V01sNWZvOWJZUWVGNDVSV29VTklrMU16R3hZdTd6UmNLMU5aQzI4Y2ZxNkRTdmRBOVpac1VERm1VRzVJZ1lCV2dNSnNhYWNQa3ZmQ2VlNWdRRkNJd1cxZXU3TEV0Q1pZQ0U2cjBrUFlrSFNSangzWlZmakJTVGxWb29MbEVzVDVVTFVXaUx5OTk3REhWWXBDdmJFRXRUV1UxUERnQXd3ME56Q3hUMzZyUXAvcW5UZ1VuUnIvWm1qQkdHQ3FBU2dGSmNGb0ZLU3VBVnFKZzhxKzdMaTUzSTVCYzI3ZURiOCtlM29zRE5Ja01oY2I4Vm9xa1hzMDdNWGhKQktFY3RhNHdvVWdROWZ0VklJdW5UMWNqV1RLeGJreExhTTV3YjlTQm10cUFrWGtsZ2tsOXM0OGJCL2ExYXpVTjBvd1VhUkJEd3BKTXJ0UWVGUzVsU3p1cFhLZUF5WURjdFFzdXpabWpDVXlpVnZSVEpLU2U2cWdzcUtKSWxJS1h4QnMvZnJ6YnNUUWpnZjMyZWxVd3FYMERUZmpXQUtZNk1GRWJHK2JQWi9kRTUyVWx4WDY2RDYzRU1aUklReU9ORWRQcDRXSjBZall1VE1DSjFkWFFjZmd3QkpQTXUrM1ZWNkRHOVdmRWQrQ0FjbFhMLzJnWHBpbWJ1SzVvTWZXTmZHN0U3ZTVUMzFUaDRpRHdJS2ppTmRka3plUmVSZ3dKU3dJMGRLaFRQSFJMWHZpcGJHbXBLNDFSbjJsaWs3Tjd1TDRmVFdlbXJoUHBSNlNlTHYzWUtkSUxIME5rY29QL2RPY2Q5c3MyMktCQlNJUWRZdmdqWWNrQVJZZnFPaEUwN3pkRU16aUpzQ01NQ1V0bWNwSGRHOTE1dThaWGhLYVoyU3R3REJvc0ZNRS93bzR3WkNiM1JJMlRYclRyMlJldy9Gd1hGUGNaSWhwczJpbnVKK3dJUTRvWlRUeWg3a0J1WHU2MGIwSFY5Um12aXhrY1RGZ3RjOXFwVE5YTU1WUnJ1V1IyVzArR3pML3M4Rm4vWll6N3dVR0kxYlpUSVRPbEs2MGNReG5RdWhvbkFVNy95Vk8vMG1YZmV6UW9IakRFbGR0MERERkNyS2dhVTgreGsySTFsRUFONHFJRitkY0ZWd28zbmcyWlR4aGl5MDBpYk9ZalJvUVZ4eXlvN0V0OGZFWkZ6WXVlcUhCbTNwWEM5UmZDNWxPRytIS0x6b1hNSndrYndnamtqdzNFdlFnNURsRFUwZ2dWY21nUVhJbVlmcDdaVlBUZWthQjQwQkJqYmhCaDhVUnowVnJDQnVRUEREamx6Q1VHME1USTZhY2FaNGlyOFdtL0pKejVjM1BScGsyZWZDUDYxVG1hM1l3WUVCYUl5UzhnZitPbGhXTVZSMGxuL2VHQndSdnJ5NXI0K1lMdnR0dUN1LzNXazB0TC9YKzhPUzk4cThrb1BtU0ZvcWg5UnpyRkg1YTc3UDlCdjBuQnp3V3VtUVJtTUZrYjRXeVNGMU1vaEtCYWNFR1AvK2s3SWpSZHZHcXNOVHgwUVhGZ01nSjdjNEVnbFJoaXp6ejVKS0VkZ1R6eUQzZCs3ZkdnZUpubm1iOXluK21LMVV6RVNEdWd2QUZwSXozYXJ3VDVxMHBEQ0dSUkFQc01lM0RrNVB6UWIwZUlrWnB5azFSWmFKSktMSUprTlRSWXV3YUdKQ0hvalFydHJWR2hCWVBRK3RxQTVjd2V2L1Y4V0dMQkRzVXpEVHcxSVRmby8wbU9jNkRQZ01ZMHBJL0MwS3dHZWdMOEc3NHNSczRIK1lNeEltY0JkSHl6eWlBanhVMkdPWk1acGFra2JsNHNhT0pMYnlvVDJ3MVErOWduMCtrQUFVVm1tS1ljRkhGQWl6blFOZzZzR1l6L0RFOURTVm1VR3VTbE95OEhrOWpEdDRVZ2pmOG5FL3N3b29LY1Bkd01XRGxiT0ppR2hxYXZvUkVPbkNMYkVHajhPbUVpL1UrQUFRQkx5L0ZiT1E4TjVBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJleGNoYW5nZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWltZ1xcXCI+PGRpdiB2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCI+PGltZyB2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiLz48ZGl2IGNsYXNzPVxcXCJiYXJjb250ZW50XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiPjxpbWcgY2xhc3M9XFxcIm1vbmV5LWltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIgdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIvPjxkaXYgY2xhc3M9XFxcImJvbnVzLW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJvbnVzTW9uZXlcXFwiIHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCI+PC9kaXY+PGltZyBjbGFzcz1cXFwiZXhjaGFuZ2VcXFwiIHYtYmluZDpzcmM9XFxcImRvZXhjaGFuZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiZXhjaGFuZ2VCdG5cXFwiLz48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJjaGFuZ2UtYnV0dG9uXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJ1dHRvbkJhclxcXCI+PGRpdiBjbGFzcz1cXFwiYm9udXMtYnV0dG9uXFxcIj48aW1nIGNsYXNzPVxcXCJib251cy1idXR0b25cXFwiIHYtYmluZDpzcmM9XFxcImJvbnVzQnV0dG9uXFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwicHJpemUtYnV0dG9uXFxcIj48aW1nIGNsYXNzPVxcXCJwcml6ZS1idXR0b25cXFwiIHYtYmluZDpzcmM9XFxcInByaXplQnV0dG9uXFxcIi8+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxSZWNoYXJnZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTllMWQ4YjY2L1JlY2hhcmdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuZGl2LnJlY2hhcmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYubXktbW9uZXkge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1zdWIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjI2YTMwO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NGQ1NzM2NjdcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUhBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxXQUFBO0NBQ0FcIixcImZpbGVcIjpcIlJlY2hhcmdlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXHJcXG4gICAgLy8tIOWFkeaNoiDllYbln44g5qih5p2/XFxyXFxuICAgIGltZy5yZWNoYXJnZS1yZWNvcmQodi1iaW5kOnNyYz1cXFwicmVjb3JkSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInJlY29yZEltZ1N0eWxlXFxcIilcXHJcXG4gICAgZGl2LnJlY2hhcmdlKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuICAgICAgICBkaXYuYmFja2dyb3VuZC1pbWdcXHJcXG4gICAgICAgICAgICBkaXYodi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJhcmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5tb25leS1pbWcodi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIsdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVxcXCJpdGVtLnN1Yj9ib251c01vbmV5SGFzU3ViOmJvbnVzTW9uZXlcXFwiLHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tIOWJr+agh+mimFxcclxcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5LmJvbnVzLXN1Yih2LWlmPVxcXCJpdGVtLnN1YlxcXCIsdi1iaW5kOnN0eWxlPVxcXCJib251c1N1YlxcXCIsdi1odG1sPVxcXCJpdGVtLnN1YlxcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbWcucmVjaGFyZ2Uodi1iaW5kOnNyYz1cXFwiZG9yZWNoYXJnZVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJyZWNoYXJnZUJ0blxcXCIpXFxyXFxuICAgIGRpdi5teS1tb25leSh2LWJpbmQ6c3R5bGU9XFxcImZvb3RlclxcXCIpIOaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nXSxcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuXFxyXFxuICAgIH0sXFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9leGNoYW5nZS1kYXRhJyksXFxyXFxuICAgICAgICAgICAgcmVjb3JkSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nJyksXFxyXFxuICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nJyksXFxyXFxuICAgICAgICAgICAgZG9yZWNoYXJnZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZycpLFxcclxcbiAgICAgICAgICAgIG1vbmV5SW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJylcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIHJlY29yZEltZ1N0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyOCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OTUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbW9uZXlibG9jaygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYnV0dG9uQmFyKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyNjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYmFyY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJvbnVzTW9uZXkoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBib251c01vbmV5SGFzU3ViKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYm9udXNTdWIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMS41ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4ICcgKyA2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbW9uZXlJbWcoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDExNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAtMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICByZWNoYXJnZUJ0bigpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM2NCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZm9vdGVyKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG5cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LnJlY2hhcmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2Uge1xcclxcbiAgICB6LWluZGV4OiAzO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYubXktbW9uZXkge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1zdWIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjI2YTMwO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cclxuICAgIGltZy5yZWNoYXJnZS1yZWNvcmQodi1iaW5kOnNyYz1cInJlY29yZEltZ1wiLHYtYmluZDpzdHlsZT1cInJlY29yZEltZ1N0eWxlXCIpXHJcbiAgICBkaXYucmVjaGFyZ2Uodi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxyXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xyXG4gICAgICAgICAgICBkaXYodi1mb3I9XCJpdGVtIGluIG1vbmV5RGF0YVwiLHYtYmluZDpzdHlsZT1cIm1vbmV5YmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVwibW9uZXlCYWNrXCIpXHJcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XCJiYXJjb250ZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XCJtb25leUltZ1wiLHYtYmluZDpzcmM9XCJpdGVtLmdvb2RzaW1nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5KHYtYmluZDpzdHlsZT1cIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVwiLHYtaHRtbD1cIml0ZW0uZ29vZG5hbWVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tIOWJr+agh+mimFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5ib251cy1tb25leS5ib251cy1zdWIodi1pZj1cIml0ZW0uc3ViXCIsdi1iaW5kOnN0eWxlPVwiYm9udXNTdWJcIix2LWh0bWw9XCJpdGVtLnN1YlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5yZWNoYXJnZSh2LWJpbmQ6c3JjPVwiZG9yZWNoYXJnZVwiLHYtYmluZDpzdHlsZT1cInJlY2hhcmdlQnRuXCIpXHJcbiAgICBkaXYubXktbW9uZXkodi1iaW5kOnN0eWxlPVwiZm9vdGVyXCIpIOaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXHJcbiAgICByZWFkeSgpIHtcclxuXHJcbiAgICB9LFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb25leURhdGE6IHJlcXVpcmUoJy4uLy4uL2RhdGEvZXhjaGFuZ2UtZGF0YScpLFxyXG4gICAgICAgICAgICByZWNvcmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmcnKSxcclxuICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nJyksXHJcbiAgICAgICAgICAgIGRvcmVjaGFyZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvC5wbmcnKSxcclxuICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHJlY29yZEltZ1N0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OTUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MTggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb25leWJsb2NrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAnICsgMTYgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnV0dG9uQmFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJhcmNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0xMTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvbnVzTW9uZXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9udXNNb25leUhhc1N1YigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib251c1N1YigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxLjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggJyArIDYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9uZXlJbWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDBweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVjaGFyZ2VCdG4oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzY0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb290ZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogMTM2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogNzEwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG5cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYucmVjaGFyZ2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcucmVjaGFyZ2Uge1xyXG4gICAgei1pbmRleDogMztcclxufVxyXG5cclxuZGl2Lm15LW1vbmV5IHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuaW1nLnJlY2hhcmdlLXJlY29yZCB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbn1cclxuXHJcbmRpdi5iYXJjb250ZW50IHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5pbWcubW9uZXktaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcclxuICAgIGZsb2F0OiBsZWZ0O1xyXG59XHJcblxyXG5kaXYuYm9udXMtbW9uZXkge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG5kaXYuYm9udXMtc3ViIHtcclxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XHJcbn1cclxuXHJcbi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuZGl2LmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBhZGRpbmc6IDElO1xyXG59XHJcblxyXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB3aWR0aDogNTAlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFJlY2hhcmdlLnZ1ZT80ZDU3MzY2N1xuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGdvb2RuYW1lOiAnNTAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogNTAwLFxyXG4gICAgICAgIHN1YjogJycsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMC5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICcxMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogMTAwMCxcclxuICAgICAgICBzdWI6ICcnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzIwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAyMDAwLFxyXG4gICAgICAgIHN1YjogJysxODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8yMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiA1MDAwLFxyXG4gICAgICAgIHN1YjogJys4ODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzEwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogMTAwMDAsXHJcbiAgICAgICAgc3ViOiAnKzI4ODjph5HluIEnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwMC5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9XVxyXG59KVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2V4Y2hhbmdlLWRhdGEuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTXpnMFJqZzNPVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJNemcwUmpnM1FUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpRd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZek9EUkdPRGM0TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrM1EvOUtRQUFFajlKUkVGVWVOcnNuSHVNWE5WOXg3L252dWJPWTJmZlQ5dHJHOVlQY0luQk1ZOGFremFRSWtJTFVWWFJKRzFwMWZ6UlZnbi9KS21hL3lyMWpmTlAycXFKcXFocVVLcW1rVWlhSm1sVUpTQklLNEpGd0FFTXh2WmllMjN2ZXRmN252ZWQrenFudjNQdmpCa21NN3RySUI1am41OTFkR2ZtUHViTy9kenY3M1d1bHdraG9PemFNVTFkQWdWVW1RS3FUQUZWcG9BcVUwQVZVR1VLcURJRlZKa0Nxa3dCVlVDVkthREtGRkJsQ3FneUJWUUJWYWFBS2xOQWxTbWd5aFJRQlZTWkFxcE1BVldtZ0NwVFFCVlFaUXFvTWdWVW1RS3FUQUZWUUpVcG9Nb1VVR1VLcURJRlZBRlZwb0FxVTBDVkthREtGRkFGVk5uNzBJeE9mdm1CN1NOdlB4a2RLRllaU2xVTk9xUDNUS0FudzdGVTBOQ1ZFdkE4Z1Z1MmN6Z2V5LzdhbmNIRXhTVTIzcFhGbGwrNVM0eG9ZTjFuWmxqUFVKL0lKSHJzaEVobE5XYW1ndFdjcUNTejVzckVqbVJ4YXJLMDhzd3orYk8zMzJUTm5UeVdQeDJXblBNTGMxVzhjZHpGYi85bUZ3YjZkWnk3b0dOaUlvWGhZUWF1Ry9pdjcweWo0akFjK3AreUF2cU8zUWJCNUFLWVdkV3hYR0xZUE1DMzNMUEhQM2p6dUhkd3g3WmcvN1poTm1GM0czM0RCQUJnY0FJZENjdkF2cjBldlU4QW1RRmFKR1AvUTI5QngzTEtaWXplbGNEQkI4ZUEwTVFkaFhIZjF2VUxyNzJVZS9HV244NGZNYXI1SHhjV2lpK3N6T2tJeG0wd3pWQUtmYmZHV0R5bWwzV1lHaEwzNzNVZStZMzl6aWNPN0tyY3YzMkxiaHA5YVlUVkpGelBoT2ZxV0x4SXA4OFpkRktTWjNBZ1BRcTlleFJzbFVQVGRlaXBMb2dpYlJMNEVEeEVhY1dET08rQkdRRzYwcTdKYkd5NzY0SDB0cnNldlAwUlFNZmNLOU9uK2c4dmZGY3JPbCt2TEphT212M3ArSVFVMEhjRzB3c1lwaFlOM0wzVC9keWZQbFQ4N0wwM081dk5McUNNUWN5VlRQQlZ3Q1EzYk9nYUFTUHhKUVJCbzUrZ2NlaVpMaGlqNDlCSm1TeVpCSGNDVkJZWElaaUY5TmdJdEs0TWJTZC9yZ25oQmdoSXNXNXVCWVdmekNQa0oyQVA2Qmk5ZGZmRTZLMDNmOTdQelh4KzlVMzMzOCs5ZE9xdmMvT1ZFMVkyL2I0QnlqcjU1MVgzYnhxTWxpTDZweVB2R09PZi9PWHlrMy8rVy9rN3RCQ1k5ZExnM1Z0SVpVV3djaEdtR1lKckZGOFRGcEpaQzM1SXI4blZHcnFBMmQwSHZXZVlRRG5rWGgxeTJWWGFyb3pFNEkzMFdSclpMVm13UkI5OUdSM1lzTUFzaSs0SU83cW5nNFZGNUNlUG9yUjRCcjIzanlPN2ZZSStEK0dzMkhqeThXZisrTG1uMy96cVYzOG1GTkQxN0o3eFpCd3pDVklGdmFNUDdpMGUvWXVIQ3dQbmw0R3Fua1p5MHdTY2M5T3cvRlVZbVRTTXBBblg1OGl0dUpRc0dlZ2RTU0UwR0tuUUlMZExUak5yb3hxUUJsTW0wcHQ2WWZSMUF3UysrRHFCOURneVcvdmpIMDMrUE5xQjFZSzF6TWJTNU1aUG5jYlpwNTdDMEgwNzBiTmpzN3c2dFBXTitQSm52dm5aejN6NTlOOHJvT3ZZb1QvN2RKVFVWSDBkWjQvOTZJblAzWDN5RDRiSXhTN21pY1B1UGZBV2M5QldMa0R2U3BPTHBUelcwR0RUaGVlVU5aWHpQaXpKb1NjQnU4ZENTSEFxZEJ4N3FKdFlNUVRWa09JbWcxK3QwTEZ1SmcrUXBSdUhnK21rVHQyRzBFejZaak0rcms3eGw1RnlNeHFxcjU3Q2hhTXZZTnZIN3lTZlFaOG5iOERzc1RMRzl2ekwreUtZZGpTR2Z1R0xYNG1XUG8yLy9NTVA3YXdXVHFKQ1dha2hjeDFCc2E1YWhtN3JxTjkwVVp5VlN1dE9Jckhad3RTeEZZcC9ERjFETmdKeXY4VlpGekxpbHVkTHBNWmVNRC9BMGlzTDZOclpoOFJZQ0JJNmdVMVJrc1RKOHlacDZERHNrTlN2UjVrd0toN3M0UjVpeXhDV0M1UmdEVWJIeS9TbFZHUGhjc3lrc2UvZ3dlT0hYd2Q2S2JRRjVEWlpkUW5HMENaNDVaQk9Nb3hveW44eUdWcGVMR0h1K0NvMkRTY3h0TVZHdWVpRFYxME03YlJnZERHTTNya1pmVGYySVRuYWk1MmYrZ0EwY3hkS0p3aE9NQTRXak5FeGVtR2wwN0Q3TllKSjMwNEFZZEV5bmNUc2M2L0NHRW5DR3RoRW54Zm96TVl3KytxVUFyb1JlL2pPdlhqbzlsL0NweDc5QXJUU2kvM2p2OXFMbjB3YUdLQ2tNcGlmZ1l5c3hyWmRCSmhVNmpwUjJLczZsS3dVQWd6UVJUY3BQaFlxcEhES2pqa1ZuSXgxUXdRSmxCZkxsT0NzSWpsc1FPc1pSSG02Q3NPc3dzd2tZS1E0eFdJamN0K1JneklwTWVycFFaaDNNUGU5cCtFbWN0aDA3MjIwanR5dGZSTzhtUk9ZZi82SFhHVzVHN0NkYVlaVnh6YjJkRmUvOWZpbjhiRzdIdDJPWjE4TUVVd3VZMHlVMFo4bFR6ZzhCSmVUeTNPcjBNaUZtaFFIRTExR2xOaG9NbHMxQ1JwZGZMTnZrTXFXRzBoVkFhcjVDa0dYQmVneXRNd3dyT1FnTXB0NzZmWk54ZjVjTmgxMFVtVFZoME1aYm1YK0xOejhOTXhoQzRNZmxEQXB4bGJ6S0o2YVFmbncvK0xFR3loKytFc2lxMkxvT2paSzllR0JVZjc5UXc5WEg4Z0xDL25URGo2OFg4ZTVMWU5ZT05jRlAxZUNOYjFBR1MxRFlxQVhoQk9oYjhDaDJLZHpLbGtvYnNwK2dxQXNWU3Zrb1NXWHdESjlTUFgzSWIxMUszZzVnRnR5eUxXU2NqMHFUK2ltQ0gyUGxsVFdlRVZTZm9rZ1YyQ1AyZWkvZXgrZFVSck84Z3pjcFZsVUowK2pjREtQaEVmM2lKYXNxTWJDQnV5bU8rLzkwQUh6eVFleWxBZ2RuOVBSU3drT24vV3cxZkt4ZFc4Q2M4VitsSEpabEVvdXltVnl2NVNnR0FRdkxlTWRLWTFScGtxQ2hVNUtEYndxL09rM3dicEhLQjRtbzNwVGRvczBxbG1MTTdOVXcvTG8xNGFVeldwcEhkWUk3WnZPUmdvT0tpNXlreWRRdVhBZTFkbEZCRXVVTkJGclRqZVBsdVl5eERyWFBkRFIwZEYxdC9uS1AvM3o2TGtudm9Fd2pQdXRrSzAvaXlLbkk4QUtWUXdsQkVZSERaUUdiRXBBN2FnNXp5bGpjc2oxQ2lLWlpBNENxbUdGNFVNVHBHSWVVS2xSQWs5UUFwVHVJcGRNUUdpZGpMMmVyRmZwaFMwN1MyNkFBcW1melV5aHNyQ01jS1ZBK1E4QnB5UlplT1RBWGJwaE5EcUhoQ3hYaFR3M3ZwSGZzeEdibTV1N2RoWDYwUWZ1dVBoWC93cWNtYVhzMXZhUUt3Z01qaEJWUnhiN0RLNnNaNVlDTU80alMxQzBCSzFMNmFpRVp0UVBrTU1MaFV3RXFNWWs5Y200U01vVXVYbUljbDVLbHhSTXRTZUI5dWxnWHRtbkxOZURRVGVFWCthSWttZVNINmY2VlFRR2xVQ0lRR3BXZkd5ZHhmbEZvYXBQS1plN0FUdjJnMzlZZXVEaExodzdaMklpdndKL01vZjViQytHQnpWNHBCaGYxdnR5SG8xZ0JYVHhSWm1rUW5BWlhXM1pHcFFYUEZFcklZa2JwVWEwbnVBS0NTWW9nSlAwWmFjdmpNRFJ0b0lLSU1xSWZkK0tkcEw1b053bjZnaVpVVXM0K2t6dW41U3pOSlJSSHptTk55ODYxbU9xYk5tQWZmc2ZEeFgzakdUOGovNWVEM0s3UjZnRUNmSGFVOHM0KzRaSHRhT0dkRmFMeXNPb1JjUGlzNDBBeDVPbFVjZUl4RWFBaUI4bEx3RkZ1ckEyQWxkSDZNa2tpdFRNRFFJdEZVanVtYVNzV1ZUUnl1UEtvZGVPalhqYUxtRVNlRU5nYVlWanh0NktxZFN1SC83dDA5WkpwZEFOV05kZ2QzbjZnbC9adTUxMzMzZTNoYW1kWXlpZEwrSGtsSXZUVXdGR1NLbkRJenFWaVl4eUlFWlpxWWpneVlGYTJLM0RpR0RqclZqOHRpRnEyOWJYaTlvcUtYNkNSNWdqZDF0eU5Dd1ZEWXJWUUg3UlEvcVdBWHpzZCs5KzdPTENkeTU4N1ZuL1VOUHBDd1cwcVFiT09VeEdNZ2N1Ni9hWEhOeElnVEs4TllVdHU1SlluUGV4ZERIRXdubTY2R2NGTWhaSG10eGdTczVmcHdWTTJSTXdhcnhFemVYeTJGM1dsOUVJNjI0MDhxL1J2RTdnTTVrWDBXQ29lanBjTCs1T2hUVTMzcHNNa0IzZ21DOFhLVk11NFA2UDMvNTNYM3YyK1M4MndXUlhJOXhPQVkwdXh0ZGZ0YjFQUEJUSUhqbTRyc0VwMG5YSk9jaVNTK3diMVRDeHhVVEZaVmpPY1JSb1hhNGlVS1lMZm1GRlVBMHFZSnNpbXVEbWdaeDhpK01IYTFBaHI4WEpDTGpRSXhXR2dZamhTOUF5b1lvbTd1bzNESWVweFlxZHA1ektEeE9vbENvd1UxWTlQTFVDMXdoWFhHOUFXZlByY3pQaXBkdEMvTHBOcGFORDVUc2oxK3FSV3FxTDhvb0hVYmpjVEtwa0JGakdQSTlnbEt1a01Db3haR08rV2hYdy9Kb1NKVEFlUzFiUWZTSS9RMWp6dDBUWEpPb1NHRVZVV0hMSmVFeUoxZ1dVN2NyRXk2TmoybjZJQW1XOWllRUV1ZVIrTEU2K0prOVZmK3RXdVRTdU9yQkdCMkEyTHRrTHI0YVA5ZmZnZy9mY2E0eWtaSysyUkRCWW5QeElaVWtlRHBVeG9oeEdTcFNmR1JEUkEyVHlFTjIwMUpJaXZzSlJoaHRudVpFQ3BScERFZTBYTGVYUTRtUEs5ZktHQ0dwWnJUeXVSZkdVRjBLY3VranY3OTJMemZ2Mm9mRDZKSXJIRHRNV2cwYmM0TDBFazc4OUt2OGNXSEU5S1pUVlBlUVRMOXNYVjhydWdlVVYvMXY3YnRYM0RmUlNuRXhSOXVxS0tMYTl0VFZscGtiTmxUYkd5Rlp4azcvbGF1UFhyT0YxRFh6dDBMcWM2MllocW5rZXpjTldoMGFRZmZRMjlHL3ZSdTZWSTZqKzdBZ01qMVZxMTZvT2t0Zk92eGx3STh5T1FEVTY1R3ExeHZHOXljVHlqazN1djkyMEcvdk9UTWZxeTZRcEM2YVJzdU1kb3FRbHFOV2pqVWRpRFVkc05ONndUVzBIMlh5SUhrUWorckpHZFVzY3BTb2xSMVlhYkhnVTVoMUQ2TDJoQzdaWXdzcFQvNGZpcVRKcytjU0trWkN0UDZzQlpxdlJyTmFPUURXdXNDcWJZZXIxUVdXSnVXdUhUb21Jd013MFI1NWM3Mm9SVVlKaTFHS2ZyQTl0MmNiVjR1c201MGFaSHJ2WjZJcldmSFNVOUVRM1FJaEF3Z3VrZ3VWenZTeDZ4dGJWYk9rR3dFYlNFTjBwcElkUzZCa2lZdDVGckI3NUtSYlBCMUZOYTRVRzBpbUtzMFVROXVpQlVQazFZVzAwdnE3L3RrYTRIWUhhQ1pkYkgzV1k4aHdNeDRXb1VCYWJvdVJvMjFZdGF0NlVxS2dwbEFtQ1ZGRW9HemNFeTQrVEdObnVrNHJsUGwxd0ZpYytnU2RxZldFWmgrVWpLL0w1V2swbXd2RGwrMTRMbWUwU0VuMnRyYU92aC9aMVZ5Rld6cUQwWEFVbE9lTkdaWXpobW5TSDBURk1XU1pSRnF4RjkyUXowS0RoeHF4LzF1Z2ZybG1GdG5LTzlTckRxQTF6YWhHVHVUd0JIYVR5WlRIcTQwVVo3bUEzYmRoTEFNbFgraktybFowaG1jeklYcnJzRUhFOTZyOUtjVlk5UkFxUHZvUjIxaTBkQ1pOQlB1QVhQZlhBSzBnYUlVSDA0TXk0Y0NmRHFCa2Z5cTVTWUVWbGpqeVdtWXhqc3F4SlpZeGRyUmpUa0pPa1B3OHphUGhkV0VPWlZ3eXNjWVZqWjF1RmZ2KzRkWHpQZjN2ZitLUGZOMzRuTlVCdWNWbEVjVk8yOXVxTmdVaVpOQ3dhVWk0WnVxU2FXYzl3NmJWOGZKYlZzMXhPa0doUWh1eVRjb1ZzREF2NUlCbFJrSjBtK2N5U0hISnZQVzd1czRhRUsyWEpQakhIMFJuYi9lNVIrMHMxaFRZclUyc3FWWnBMR242bHk1aE9OQlpheGRFSTZ1TS9zZzdseTI3aGt3L3BmN0pqRjZtTHRnd3BsbGJkdDJlNzlXYThiQXdJcndZOGpPTmt2V3lKQjRzSDRnWkV0RjF0TmlYcUhOVnkwL3BERy9Ka2JIS3g4bUh1ZklYaCtUY3pKNy81c3YwM0wwM3JzN1drS0d3QnN4a2tiNkhZSzZiU1g5Z2pLTFg1dytZeXBhNUtzMkZZVGNQWVB4YnNlbkMvZU9UZ2Jld2oyOGRaS3BPdGxTc2VqOXQwWGkzeHFRT3NseVRSYS9IVzZ6cGMwZnc2bG5Ua0poaVBYQ3VqNGJvTUt5V0dVL1BXMmVkUFcvLzVIeTliUDJpSWgyR1R5L1ZydzJ0YStyWDFZVU9TZENuei9VWFBoM1lDNktXNDJRS20xYkRlR092aVBmZnREdTdaTzhFTzNMZ1p1OGVHMEpmTnlLbXRPTFpwTW5hR0lpcGxvZ1FweW5ERkpiV2lCckV1UXhZMTVlUEVLZkJGRklQTGxQVVdTSTBYVnZRenB4YU1WMTZlTmc3LytMVHhXb3Y2Y2kyZ2phTVJhSGc5QU5YWEFGcFhiUjFxZlIvV1pZbmtCOGJDR3lhRytZNlJYckZscEpkdEd1Z1JveGxiWkpJMk1wWkJpYW1NaFN4V25vUVo5VzRsdk5vc0RXWFNUc2xCcVZEUjhvc0ZkbjZweUJhbWx2V1Q1MWEwNlRmbUk3Y3Eyc1REeG5vejJDRFE0SG9BcWpVQk5SdEFOZ1BWRzRiV0lxbGlMZHFKYVBOK0xXdlZrMjFPYkVSVDdWbUgxZ3FtMTBtRlhzbWtxTjBkSHphVkFLMjJiVXhDdEJiTkNyYldCTUFHWVlvMjV5cWF6clVSTEYrallYOU45bkpGbXhwTk5IVlltdGZWTDZEZTNDWnNxbWVid1Y0dTBIWWcwZWJtNHczcUMxcTQxdVlrNkpwdHpvc1dIVmJXQUxYNTRobTFkWHFUcTJZdGxNcmF6T1MwYzhXaXpibXRGVCtiWFc3UVl0VFYyMUhGR2xjSUptdHgxNi9samh0aHRsT3B0a1k4WmU5QW9jM3E1R3NBYlFlMW5TdStKcWZQR3R0aHpRMXMzc0xOdGxPbnRrNlMxQXJzUm1KN0szVzJjcmxoaXhJbWJLUFFhOXJsTnJzNzN1YmloUzA2U1d3TmRXb2JWQ2hiSnhscWw5M3lGb2tSYjZGWTNpS09pbXU1OWRjTXRka1Y4eVpnMm1XQVhFK2RiSVB1VnJRSkFhMlV5dHRBNUozTWRxOTBMN2ZWakQ3SDJ4NjR2RFN2MkFyYWVxNzJuV1M2WWgzWHk5dkFiYlhzaUNvNzNaeHY1WDVGbTlxU3I2UEFkNnJNOWNxVzlXSXExcWhCTzFxTGR1b3hUckZPR2RFdUhyWXJVVnBCWEt0N3RGN3BzaDVjckZPYVhCZFAvVjB1MkZad3NRRjQ3YWF1TnRyMlc2cyt4UWJxeTQ0K20zdTEvT0Vwc1VieDM4cEZyd1dRdlVmbnNaYmlyaXFJVnlQUXRTN09lbTVaWElZaUwrZDcxMXVuL20vTGV3aDRvd0RZdXdSNTFRTjhQd0s5M0F2N2J2NFRrY0Q3M0F4Y2V5WndIVnRILzZ5TnN2ZmUxSjhvVjBDVkthREtGRkJsQ3FneUJWUUJWYWFBS2xOQWxTbWd5aFJRQlZTWkFxcE1BVldtZ0NxN1pQOHZ3QUJ5TkVyUFBSOFBwd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpSVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZelJqUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpORE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pSRFFUTkdOak5FTkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrWjRnMmN3QUFHSWhKUkVGVWVOcnNYUXVNWEZkNS9zNjlkMmJ1dlBmaGZkcnJSeHpIem9Na0RpRXZRb0NrSkU2QlFBTWswTkpXZ1pRV1FkV0tGbEdwVlYrb2FrR2xWVkVGbGRxR1VCQlZCRUVxbEZaUUdzb2pJYzA3VHB6RVRteXZ2YnZlMSt6TzdEenYrL1E3ZDJhVDhUQzdkaHJpM1hqdmtZN25kZWZPN1BuTzkvM2YvNTh6MTBKS2lhaWRQVTJMaGlBQ05Hb1JvRkdMQUkxYUJHalVJa0FqUUtNV0FScTFDTkNvUllCR0xRSTBBalJxRWFCUml3Q05XZ1JvMUNKQUkwQ2pGZ0VhdFFqUXFFV0FSaTBDTkFJMGFoR2dVWXNBalZvRWFOUWlRQ05Bb3hZQkdyVUkwS2hGZ0VZdEFqUUNOR29Sb0ZHTEFJM2F6NmtaWjlNZk16SXk4bklPRngyUFgvRzFDYWFucHlOQXoyQVRwL25jenczZ0NOQlhIMGh4R3VESzF6S3d4Z1lCVTNUcG5jREtqcjc4bkhndGdXcHNJREMxdGx1dEE5aDJJSU5XN3didSt2K2oxOU4xaWo1NVV3cTl2UUszdkdNekF0ZkgxSlRFNFJjcTJERUd6TTY0K1BxL2xYSFZWVm5FOG9uY3p0MDk1eVJ5NXJiakJYLzBMVy9Oai9YMngzTUhuNjFsNHdoNlRETXdwVjNYVUMzTFVzR3g2cTVXM1Q0Y1ZDWUxLUC93UVcwbW5RaG1aNWEweWYzait2SHhrbGpxQU5OdjllWDczWmdibWFLWHp5MkpSdG5CNG9rcXRnN0Zod1ozOXJ6cFkzKzI0OXFkbHcvczNYRmUvSFZXMWVydHlYRzhwUTkzMFlkMExJeTlPUUY0Zk1yaHVBY3BCUFVFZTRHVHcwT2ptc0MyUVE5dnZNZ0hEOFhNZ2dldllWZWVIUThPSHAzVzl4K2NqRDN5eERIamdVVlBUQ0E4UzlqUndkaDFMNy9yaTZIN1V1akpBemRmM3dldkt1Rm44N2ZIQjFJZnVQQzZzVjh3KzNOcG9BUXNsdUVVSkVFeTRGb3h5Q0FHWFl2RGlNZWgvaFJOMDZFWkd0eHFHUjZCZEwwQVhtRUNkclVLeXhhd3lYdy84Q0hZb2Z0SW1oTENjT0dWRzVpZThlMkhYa2cvNFRudS9DVVhad1ozMzNUYnVRMnJ1RFJ4WVB6TFAzbGsraS91L203ZC84TmJBL25GZTRCa1VzRFF1LzhkRDQ3UFJJQ3E5cnR2alNNdVhYejR0Ni80NE1pbHc1L0s3Y3hlQlBUQUxiMkFwYWRuQ1Y0RzhmUVFFajJEU09SeUVBUVJCc25qazB4dURYYWhqTWJDSEtUbndPenBnNUZPd1BOOFdPVUs2dU12b0ZGM1lkc0IyZXFpWVVsNHZvUkZOanN1VHlFRDlPYzliQnR5RWNzSzlGMTlFNUpqWXkzVnRXRk5sSjZwN1gvNEhSZmRXUnZ2OTZRMFRheExRTmVWNURvMUYrLzduUnZ1MmYyZTNiY0J0WEFncDM1d0gwUlJRLzdjaTVIZXVRc3dLYXRPZ3k4NUJLNEc0WERBWXpxczZWbFlGUmZKVVJ1MXlWbFVwdWZodXhxRW9PeHl6dFlhUHVwMUI5VmFRTlpTenEwQXBhTEQxeVN1ZW9PQnNXRWdZWkRCVGgzVm9Xc0k1aWpRZUFxSVo4bmtHTXl4MUFWbWJ1L0RuM3piLzF6eXQvL3FUYVUzbSt0U2ZkZVVvZGZzR0Q3cDhaLyt3Wjd2M3ZpYmI3NFIvbVBVeml5bS92dFJCRE02eHQ2emp3T2JBc2lzWnJHU0lIbzZBdHRYSVpSUzY2QTJWVWRxMUNFcmo4T2RDd2lVZzlMeEl1T3dUVkFEVkJZSUtGbnBrSkh6c3c2S1JROE9UM2JMalRGczNpMWd6UkJvQmJxUVNGOTJIVEpiYytIbjJDY200VlFkWkxmenU4YUhNZm40ODgrLzRSZWYyWjJzQjNKVGp3Z25TMmQ3NUhqRTBMQzk5YmE5TndMMEpDS0QrdFFFcktObDdIejMyMmxKS0t0VnhWZ2R2b3F0VHNDNFY0ZlFiRWhSSmFJMmNoY1pxQjZjd015OWg5SDd1aEZLcndVdEpoZ3ZUVlFLTlNTeU1RamJ3NGtUZGRRY0FaRlBvMGU0Mkx4TlEyT1djZFpWQWRpRGtlOURJcE1JdjAvcHlVTlllbUtLY3ltTDhqTno2THVtaGkxN2QrKzY2NDltLytuakgzLyt3LzFiOHB3U2NsM3hkRjBWNSt0VkZhOWlKQWE1aytDZ2tsbW8yWHpxNUs4cGRKMWdObE5JSVdLaDhnV1dUbVUwWWZhYVNQUW1FYzhsbEVPQ25tU2c0N0VxVGxxZWlwWEtHQW1VcXdHMmpqYW5kTkR5c1VKblhLVzhHcmtrSlh3UzVmMEZqRjEzUFViMjNZRGU3WmVnOU1CeDJQTkhjUFBIOW43b3p0c3pOOHhPV1loejBsRHhUK29Sb0NFd3dORWYvSWozQmpuSUF1YkFJTEtYanVISTkzK0VvRkFCOHZrd2x1a1pBekZLblpGTVE5UDcrQWNNRTdldHFENmZnNUhkamkyM1g0RGtwZ3p5NXpEMjBZa0dubzFVWGtPbGFLTmFEMEtqNUFjQ2l3VWJJNE9pbVp5MHlndVN3SnNtSnd0QmJreVUwSGZlQmRDMnFJSi9BcW1MOW1EdzhodFFlbWlLNEZmeGtVKy80ZTZFOEZBc3VaVHhBSTc5VXQrd2dEbzBOS3JiRHZORVc2Snk0RW1VZi9KTmdrQlFrZUVBWG9MOGxjT1lldkNIS04zL0VMeUtRMVBFMkpZZ1dFYU02WWxLT1R6b3FUak0vQkxxMHlYVWo5b29IcHBHNFZBZFhpMUQxZzBoU0c2R1NLVGgrRHFxRGFZMGZLK2VOcEZLS1VEbGk5N0dKeFp4VGhqcFVNYTlPTkpqMjJtK09FUUJhVmZuNXd3Tm9uZjN0U2o5OURqNmQvVnUrZlU3Ti8vRzRoemxQcXNoblJZdjlnMWJXRWpxMWVhc29qVFcwVHZpZTNGWmZPQVpVWms5Z2Q2OUY5Q0RES1AvZFZld0w2QzAveWhLaCsrSE50N0RRZC9Fbm0reU5KRU05VEl4c2dWYWZBbTFlY25VSm92VVNDOThoVVBWZ2pPN1FOVVYvQnlEVXExY0xobElKaVZpclpKQmk2UUJIWTZ2SjlTTDZ0dEJwSHNJZGdESjNKWDJrY2RRWXJkdmdiVTRCeFNuOGQ2UDdmcVRyMzVsOWg4bnBnT2trdXREN05ZVTBIZTgvNDV3S0MxWHgvaUI3LzBsWWdWcXBJYnlnUklsN3dIRXRxUmhiaGxBWm13YjhoZnZKSE5kZUtVeS9QSTBQSHNhVHBtbXg5WVp0MVFjcGVzVk9oTEpKSTlqN2prL3gvTXlQV2s0cUo4NEFac3BpME9DVzNUR3JnS090TlIwNENTVHJ4NFlCdE1kSHdZWnJTUmVwVTZCby9HNUFQRmVOUk9xeUoxM1BxclAzWTlOVjJIempiY00zLzdsTDgzY3MrdThaRE1XYjJSQVAvWFpMNFMzOUN2NDh6dXVPeThJeHFISENiRm53QzJUTWMvWDRCeXJvWm9kUjZ5UFJtZXdIK2JJSUpLRFBaUlBEUW1oeW5nRTJXcVFSUUYwcHdVS1dhaVpIbUpPRFc1bGdVLzVWRkE2NUJnZHFTRkQ1dHBDSGFxZHROU2lhYXI2dzVUSFV5NDZFWm9wRldORlhMR1VqdHFtVTZZSlVybXdTTkpSRlNmeEt4OGUvZjF2M2p0M1Q5M2h4SXBGcXkxaFUrTncyYlhYUGx0LzR1R3JZeHFsalFNZW10Y2dSdmVxYXJOOFhMSGhUVTZpWmt4Q1N5dWZRcVBTbDRLZk5BbFNBbVpHRFRZbkFobnVhV3FTV1BCRUJVNkdYTlExQkVzU3hBUmVndmVKcHFUeDhoazBoZmFTS1ZLQUJwYkRWTWdQNzRlVGc1S3JxS2ZGYXZBOWs0Q25JZXNWcElaSE9kbE9ZT2VGNHZKTDl1WXVldmpSK3RPREE4YkdCdlNXS3kvaGVQa1kyUE4ydk92eXgvckxLUk16WlI5RGVROFZTcW55SWd4N0hHOE92bVQ4WS80SUowdzc2WWtvcDNTL3VsRm01OU04dHFIek9HV1gyY2xYZ2hxSFJVY2JNRjdHNmpRdWZHL05GNGd6YllsN3FpcUVrMVpFRmJiVnNvTmtRcjJiUUhvcXoySDg5RldheEprVmVQQ3RGRldFcjVseHBrSjV4RVVCNzM3dndJZCsrdEFMbjBqRU5qaWd6ejI5SDhXR2FWejR3bWUvTWJRVjc3cnFqaDM0eHIwbXlyTkY3Qmh3b1JPZ2hpZkNORU14S1dTdXdrc3hTZDFSdzg3WFFnYnpPVUhqb29XM3lzT0kwT1FZdmd5ZGFtQUZqTGM4bG1BcTBpbnlXUmIvMGJXbTRDcEM4ck1Nbml6R3llS0g5V0UzbkhCQ2ZUQm5sOVFxOEN0VUJEcHozV3dna2U4SHB1YXc5L1dKVzg4Wk1RaW96L2R1WUpjN01qcU1hMGFDYjMvbUZtdmZrb3hqNlhBRDc3MVZ4NEZEUTNqODBRcDZnd2JaNmlPVERFSUQ0MUZPRmJoQnk1WTJ3VzI3RGNFa1lPRWlGKzhISWp5T1lSRWF3ZEo1RHRXMThGaUpZbGtCMmlKcGFITTFhSzVGYVNXSTVMZDBiTVpQQVk4UzZ6UU1wTGE3eERoQWZhcEJSMDNaN2RzRWE4N0VsdjdxdHJmYzBIZlo0WU8xeC9JOXhzWUY5UHdycjcvdW10alg5Nm1penJQVE9nRWtXQ2NjWE5nbmNPR3RHUnlaeldMaW9BVzNZTU1rYzdLbVJEWXBLWWxTcGFFaHVVVExxWVlndHNCVVhUbE9WYlFScmNKQnVNQ3BXTW5uRzNSaFZVZXRpYmJWMTFWYXcxNHJXMlNxeDVTSzhtcGJFTXh4Nm5NTm1FTUpMRDQ0RGlPMWlOejVXMUE5TW9mR29zZUowVU5XVjNEUnBlbDNIenRTZXl5Yk9Vc1planBiS3IvdzkvOHdjdXp1cjRWaGFubjVXTVNaa3pab2pEaXcyd2pjT1ZjWXFNb015blZnYnRySGpLck1sTlI2SnVNY3RWTlZCUTJ5TFVFbXFSQ21NZzNSQWpWY0hpTXphd3gvUzN4L2dXbnZRbDJnVU5GUXFHazRQdXMyVjhkYUJQVjRiQ3hPT1pVRTAzVWdhbFhZekVrVGZjdy96UnBxNDJYRTBqWGt0alAzZFJhb0Zna2tjd09jSlJxMmozaHZTOFhzUDQ1UjlsZjcyMS90WFExcnl0Q2I5MTB4OCttN2dDTW5nRjdUUVlrU09ERE1vVzNJc1B4bnEzeW1RQllFTHZwSXQwM3F0VEVEZGQ4SVZ6bFV0d2xhTTNhMmdHVE1Dd2kycDVrME9RWTBHaUpSOStDV1BLUVhtT1l3dDFGZXgya0lMSlowcGp4YUtNTkJDMWlOT2FnV01QZFVlYTNkWUZvcTRjd2ZZMzQ3Z040OWczQ3FOcHk1ZXVqTlZaeldPYVBjUlEzRHljcGxuRlI5ODBXNXVQcnUwTE5ZY2c5ODUrOEsrMjdKNHNDeEdNNWRXb1I3cUlUWlhDK0dCalE0NVlBcGlKSlVFZHBQVHkyVDFTVEJjZ2t3QVZRYkRnaGtRbTl0QmxMWkJlLzVmRTNWOUlWVERuTlR6MWFGZXc1OGpjYTB3Vnl4Um1rbGlBYmx2VlFSS0Zja2VuUDBQeTNIYXhBa3AxU2x1NmI1cVJhUk8vZDhMT3lmUW1PdWlIZ21nY0pUTTRpbjlKYWdVQ21NQURaWjMyOVU0bVlxZHVVekIvQ2ZHN2FXZSsvblAxTzVjRGpqM3Z6QkhwVDJERk5XZlR6MVh3c1lmOFpoM3NjMEk2Y2hIbXN6TFZvTFlOVU5WVlFTWVJtUFpoUWVBZkVhVk5EbHpqeEd1Z2Jqb1dLUzN0eWFRZ29iaHBKVmhFVUFpNU5pZm9FVElMR2NpS3JnYThCZUxIRnlOTWg0RjM1NUNka3RXMUdkYU1BdDE1QWR6WVRTSUMwck5GWnFkNFJ2MVhrT3NuUVRyamcwdFlGWFc3SUQrZHJFbEZ2djhXcTQ0WTB4Ykx0cEZBT1habkh3cUlNZjNsZkhnY2RzbElwQkNHb21MWkEwRWNaSklkcEVUYlNEM2N4YmxTTldYVDFXT2VxeXUxWGQwR1c0ZFNTdWJ2bmFNNGVEOEwzS1dLbnpCcUY3NG5QV0lqU25DS3U0aEhndUJUUFRENjlhQzZ0SWxZa3lHZTVRTVlyd0NsTVFOdW12eHpIYTUxL211UnMzRHhXbGhxZ3Awd2xiNU4xQ0F6dHpPdnhMVXhqYm5jUThEVXRoeHNmY2NZNzN1RVNHeVh5YWJqaVZVT0RLRU5nUTNGYTFMMmdXZE1JYzA5ZWFQWXlycmRkOXhscVh6TFFKV04yV2RNZ2lmTzI1WTVSeHhtd0Z0cEoxZFk0NFJKaXlCUFY1Qkk0Sm4wcGg5bWJSbURxQlJNeEZJcTNlNDhPMTV4aWYxZVkwZmhHYXJLMkR3YTRVUDZPeUFRRU5DZll2VDVyTys5K3ByS1hLMnpVMEdNOVFhaUJIeDlvM291SGNzUmdIWDJDaEZJU3hybFNYcURGdVRpMFNBQUpreGhTU2FzMVRoaW5LY2hWUHRuYll1cTFpajhPUHFEc0NGY2JTSlpKcGlZWkl1Vi9scnFlWXVoUjR2azI5elZSR25jUndaV2pJUE1WMGF4N09oQ3BOYVRSUVNpMThNbHNMM2JFamFiSmNHZTRnZEhuZWZFWnVIOWtrQjJZWHhQeEdBZlJuZm1keWJGSStzdGZIMjAxbUFnMmFSOEVZNXhBRWExNjVJQzhNbDF2VTVnVUNyT3E3anRyRVFHQnNHMkdSUVZWNzFHNkVjRzlSMEZ6VGxDckdLY0E4aGJjTVV4aWRLRE9ORFFGV3I2c0pvRk5qUzJUV1lTckE0REJCVWhOS0xYK1N3WjRxeVBQRDAzUmZGbk1ldGFVcG5DajhnTVZaaXk3WlEvK1FTWmZ0OE53R014ZWxJbXJkSU5pS0JXMURBQ3E2M0lyL2ZkTC9lSDhQWHYrbTY0MWhta2RZMVNZQXl2eUVVc25lb0NUS21oOHlNVnpob3NjMFJOTm41bFhLa216dTYxRWIza0l3V3pzN0ExZUdERkxMWmcwT3VOcVZwR3E0d3FlWmNtaTRXam5zbzg4R3VQcHlyUldiUlRncFlveVZ0dERJWXBvZWluRGdOSzIwQWxJdHIzbjhmdlBINjhnTm12UlJsSE1xZ0FvRmZPOHcxbkJEOWxveDlNWGZtdHo5dURteldMT3ZXVmgwdjNIWnBmcGxTdnJVVGdLWExBbUw1eThlTGNLdElaQXZ4Y3IySG5SNUhMUVk2eXEydGpZbUNLMjVRVHBPRU5RQ2Q1THlQbFVJTURjWG9DL2YzRmlvUGl0R0thaXJ5aEZkVWtvNGNCc0dGWUxQTGFtdG53SkRZeG5NMHh3VnB1dm9IVERwY3VOOFc0QmNVdmEzZmVzekRxcTJSbEs3L0lPaFVQbStkU2l4OE1LRS9FckRBbzVNU0R4M0tNQnNRWVl4enFUSlVPNVdPVjJqVlp4SHA4TnRQMlA3VDVGYXhRYXRWWGhRSmtyRjNUU0JTUnNlRXFTeDJnbFlkM1U4ZFlqbk4wVVRBYlg4VmxmbVNNSlNPeGFrUXpNVk5NdUFqS01xMzNYS0RyTFpCSklaSTl4UEhLZ0NCOStjaUFVWnJQNnp4ZGM4UTd2OUN1d2tRRlZuZmhqYnZVdUh5NEdabkFpd1JPa3RWaEJ1azFSQXFuWFNoS0dNVUZNbTBkcHhvSGJxS1prTkMvWXRqUTdaU2NuMUtJMHVBVkZWSUVQRlpjYmVlbFhEa2hkSHphQlVrbG14VFRIa1NQMG5aaXU0dG1hRnFZemF1NjFrM3lSTGF6UnJGVDV2OGdXN0pwRk1hU0hMbmJvYnJ1YkVHZk05bXhMc0JXRkk4RDBadzhtL2FqdWpURjBMeVYzdXkyQ3E3MkEwYk1nNlhXeUs1bWo3TmkyYzdXcVhlN2xHRUN4VjRtTWNWR0M1VFZNanBHekZ5U0Jrb0JveXo1R3R1ckNLd3lwQVVncDVxMUpMaXhUMSt1S0liZEVaZHpXNlpBMDl3a2UrV0VkcHRvN0ZPUmVIanlWd3dTNjZYcXRwenR4S2dFU1A4a29TV1dHam9pVTVNZXBoVmNMem1yOWxVdDlIZldZc1pMV0RjaVBSYUFQeGpNdXVzUVpBTGpOVFd3WlRGVWFQenVOUWFZbUFEakI5bVEvcmVLSERIV0JjMDNwbHVDem1LbGVyS2tPOFZibC9tRnFFcStCTnMyUXg1aXFHaHgvQ04yc3h2Ymx2MWtCekd3cDFWQ045N1lxTHhZS0xKYVpEV2tXSFVUV1FDalQ4K0pFQXUzZG9vU0tvZldFcTdxWkkxMXJhd09KOEhkbDhITlU2V1YydlFtcXgwSVFKb2hub0NVb000eTNQVzNORXFlMXZsV2M2bmhwbk9IYXV5TkJ2UHh0LzlzSi9kNzcya1Y4emZqbTFpV25KZ2d4VERGWGFhKzRFYVVxcnF1UEcyZFhlOW93cUhzU1dIUzZhVzFORTArVUdkRU8rK3VWWm1mSE9idTYyMThoS3hmWUdwVmVvUFVDZUFWTVY1cFBOYlM5MXlzQ2hvd0o3ZGdEemhXYlZ5ZVg3czMwQmpqTTFNWXRGSkhvSFlETnZSYmtJUGM3NDJYQ2hqMnlpNjY1amdSTnlzU29XMnJ4SjBDYTlaMjFob1ZzY0RVSDlxKy9GUDdOVXM4c2ZlS2YrVzd0MjYxQWxWdlhUQjhzKzJlMHVGK01sS2FSMks0U0ErODF0bU10cFM3TUxBaXRDRXlPbENGZktWQ2t3Ym9acjJmREo3S0Jsb0pSQ3gvbE5tRVpoeCtabURWbkp2SHBQb3VJajIyL2d4TGlMYmRvYzNOd2daREpOWTJSQkcwbkJvREV5eWxPWVdVcTRNMlY5SEN0ZncrRlZCMVpiQXpDN3NmVkZLZjdpL1ltN1B2RjUvT29YditSOTY2bkhnN3JhSXB2T01jZkxNOGxQTll2cW1taHp1KzIxM09WdEttMDlyTzB1MTNtMVpvMVhGWHFVd1VyU1FlZkp6djZNeEdBMlFFK1N4b1lPNnFIOWtQbHNxNzZyOWlveGdSMlNIcXhlRTBkUEJFaFdwdmk4QTJPd0Y3cEtaYVlta0tBNWUzdzh2bitSR1JCKzlsb09PTnNaaWxXQUZZK2NNSTQ4OGkxOGJ2UUh3VC9mc01kNzB5WG5pbXQyYnNHZTBVSDA1WmdVSkJQTjNRb0tJTVZNVllNTkRaSy96TnlYZnEvUzNEOGt3NDdXZmNkdFZwZ1VZZzFMUTdFcWNMeWdUejQvWnh3Nk1LMC9uWDFNeG5hTXVoOGQ2RkZsUVlSYk4yMGlkVTZmaTRkVGFRUXpEV3p2bmNXU1BSdCtUcHFNVnd2dzl6MmQrSSsxQkRNYzBGZnI1NFN0VmZ2T1FrSjczRlQyUHQ3Ulk2MitiSmFXM3lPeWNabThlTlEvNTl5aFlOZHdyeHdiN2hXYk4vWElrWXdwTTh4VE13eG51bHBKMFVUVEZLa2xMbFZVVUE3VTg1cmxRZWE1RFE1OHRWVFR5ck5MMnVSY1dSUU9GL1FqeDR2YTNQaWlWbWd6YTdqemF1Yzl2M2ViZTVQRzhWbGlIRlVicmRVK1lJdHB5LzNQSjlGSDZiaDR1QjdLdE1xVDczb2dLei8zL2N4dVY1ZUtvY3MvNlYrK1ZzT0xGOTU0dFhjc25HbEF0UTVBWTIxQWRnS3F0M1Z0SlRhdmtNQ0wwNmxTZGN1SDI0NlhuN2plL3VnZCs5eHJrMGFBU3FXWloyWmpsTjQ0SGZIQk5BclROZlNsWEJ3djU3MnYvamg5NTdRZGZBZmhSdE1Yd1R6amdKNUp5ZTEyNlpqbEs0MW9PT2wzWUQ5emJFZjlwMnNzWG5FQm9NdmpvQ04yK3gyUHc4LyttL3NTZjEyMXhPUXZYZTI4TDI5Q3IxSldueXZ5eHNKa3JWNDd2S0R0UEhMUVB2L2dRd2NPUGpGdEx4N3VNRDN5YkpUY2xRcDBuZExiZWF1M3NiUmJVVzhsWUU4RktGWjVqOVlsYjF5ZWRPMk1jOXB1M2JiYjl0N096ck9Tb2JJakwxc2VUTDl0OE5vSDBHaTlwbmRNQXRHRnFXS0ZsWnlWR0NvN1h1LzJ1SnVhdElQcXRoNjdIZkZ5dGVzYW5SV0ZCWFFNV1BzZ3JTYkg3V0RxSzVmZVY0eW5wMU1jRnl0OGgrWG10MzBmMlFaWUo2anRQZWlJbXhKbmFlbXZzMUFkZER6ZkhsTzdBYWwzS1VpSTB6Qks0bVVxaU93eThUcTcxd0ZzNStNMUFYSXRKTGV6VWhLc0lHOStsMHFTV0lXZDJta3lWS3dnZjNJRmhyWXpVM2FZdU01YnZ3dndhM0tkd0xWaWFEY3BEdEQ5QW91bkErU3AyQ2xPZzVseWhjZkJLbXp0Qm1Ld2xtNzNURmVLWkplbHBhQmpkVUswUGFkMWNjbmlOT1gyVkdDdXh0QnVnTW91b0FWZGpsblRxM2V1UmVtdm0vektGWExMNEJRTS9QOHlFNnZJNzByQWRocTZBQ3RmWTNmTmN0RzEyc2E1MmpxaFhDVWVycFNpbk01VnE4VXFBeTFmSnJnNFJXcXladGVpV3V1ZkhKOXFBVmllSXJkOHVjV0UxZGlKVTRDemtubGFWNWMwWHkrWGhwTmRrdi9WSlBwMHludXY5SHVzeHJoMWUxMzY5WGdCWkxsQ2RXZTFZZ1YrRHFES2wvbmF1cndROG12aG12TnlCYkJPQndEeENvRmM5d0MrRmdGOXVRTXJYZ0VJcjhuL3ErVzFEdWhaRDhvcmFldnFFdVZSZStVdCtzL3NJa0NqRmdFYXRRalFxRVdBUmkwQ05BSTBhaEdnVVlzQWpWb0VhTlFpUUNOQW94WUJHclV6M1A1UGdBRUF3T2cxRkFzcDNzQUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpRVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZelFqUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUkRRVE5HTmpNNE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pSRFFUTkdOak01TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNlliWmtnQUFKVGRKUkVGVWVOcnNmUW1ZWEZXMTdyL1BVRU5YVjgrZDdzNDhFVUtJWkFJQ1FzSVlNSUFnb3dOeVJmVHE0OGxUcm9Kd0J3TlByeUI2VllTbjkrT2lQZ2Z1MWV2NGxDYytCY2xGSUVRZ0JBSWhKQ1E5cERzOXBNZnFydW1NKzYyOXo2bXU2a3AzcHpycHBGdFNKOS9KcVRybjFCbjJ2OWRhLzFwN3JkMk1jNDdpOHM1WmxHSVRGQUV0TGtWQWkwc1IwT0pTQkxTNEZBRXRBbHBjaW9BV2x5S2d4YVVJYUhFcEFsb0V0TGdVQVMwdVJVQ0xTeEhRNGxJRXRBaG9jU2tDV2x5S2dCYVhJcURGcFFob0VkRGlVZ1MwdUV6Rm9oM3ZHNTdPMkdIUEVXZFl0S2FBcUE3TVZvRzVEbER0MGtySGFxa1h6cUsxaHZZSGRCV1Zpb0tRcXFCY1VSR2l5NHRFNHlDdCtuajM0QnpjY1dEUTZyb3VMRnJqZEgyRDFoaGRvSS91MTBHbk5kTTlPdWxlM2ZROCsyaGZld0NJQjhUdkMzalhsNmNnNTFtYmJ1b2lEYWlEd0UwemRGeXhaQ1l1c05PbzZoNGdKR3VBVUpqTzhYV0tSUzJzMGRNSENUcGQ5ejdMenNER0JQQ1E3NllKMkxhM0VyQnlNY1YxbWRjYkREcmVOd1FrNDhCOHVyL0MwTjBSd3pQdEpqYUhnSjlHNlRBS0JQZDRMZXg0Wjg2UEpxR1pQUWVCajljRThMbDNyOGJTOGhLdmtmc0p6QUFCR1kxNjU2aWExNEkySFhOOElNUXJ1Tnpici9uSCtXaEErdnN6anlDMlRQRTZTZVk2Sk9YeXUwYXJTL3RzQWJ4QjRDYnBPMjBySTlTSjZKelhHdEcvclJ2ZnF3QWVvRWZ0Y2FlSmhFNDVvTDU2blV0Z2Z1K0NaYmo0dkRPQmdSaUR5VFZvSVJWMTlSb0NKREtNeEVPaGxoWmJWV1VFSEsxNlVJSWl3T1N1QjVicitpZ3lIMEFmUkFFTzkrL24ySmI4QVJmZnVQaHV5cE1aWGN3eTByQkovSG5tdDdTcXFpZTVYVDIwSldETDZlekZWVUJyTi9EOXpUZzR4UEdGV3VEZitJa09xTkNlMUQ3bjlRSy8vTXgxUzZ2WHIzYXdaWStEK2lYTE1IY1dnV3FwU0JzSzBpbWIxSjRKdzdCaG1XVDQwaFpCSVl5bENrY1lROXVWKzZReE5NVm5rMEJ4NExnRU9obFg4ZDJ4MHJJemlIK3VZMG1rWEU0R2xQU3RZNWwwTGE4ZHJIUmFmcmVkckhSblZIczQ3SUhiMGttR2xwVHQxU3VBRll1QnJ6ME92Tm1MNzg0QVBpbjZ6Z2tKS1BQczVVWDl3UC83NG0zcnRGT1gxdUNmN244Qk5iVmgxTS9RRUI5TVVVTTZaTGVvMFVrZm1vWkZLK2xZMXlhQUhBUkRuRHFFSzFWbVFNK3FXbkZoY1FzaHNXSXJBTWhJbWJpbnkwZXFZcDc1VGVaWTV2ZitNK1kyajFETGhpRnRxV1JQVFczQTdSY0Rhd25VV3g4Rlh1M0JVdzNBZTRUUW4xQ0ErbXAyYlN1dzVmN2JMbFp1dW1VZGJ2L2JyNks2SVlFU0FraG94RkRJdDJXK2RHaDZqczN6MWF5d29SeFpsZXZ5a1FCa2lBOUhsdlF3SHpCeDdZeXl5QkF0Y1YxaG80WGFacm5HUGVjakgwWWFHQ1QxOHRKTHdOM3ZJU3BPS3ZpVGo1Q2s5dVAzZGNCbDdna0dhR1VUc091MmE5YlczZlBnUjNIamhqdGdETVp4NnFua0U2UzhSaE1zbHZza1NJRGhTUllqRmFzU0t4WElDWnVxU1JXcWtlK2lFOVZWU2IwNkR2Zk9wNjE0Tjl2T0FpcU8yWTVMeDBnMVd5NkJUWi9sKzd2eStvckNTVVhUUFJVdTk0dnp1UTlpUmdWbkNKaXdxV0xwSUVwZVIzN01qKzhNSUVFQWYrTGJKbnBOL0VzbGNPZUxKNGpib2hLMytObFY1NTlUZCs4dnY0ditwdDFZc1c0RHFralYycllRUFZOYVIwMFBVTU82S0NuUlNWckRaTDhDQ09vTXdRRFpRQkpIbGJuMG1TNG1mbUtud053MG5jK2tlSEVwcm9JbE9mSmEzUDhzdHJabFN4VXViS3hZeFdlSDBISWM3M2ZDSGpQcUtKWXQ3TEVsN2JaQnY1SDIyK0x5dkRTcC9DVFpiTkVwaE1ib1Q3cllNeGpHUmFzQ3VPdkdJZHo3V084ZGFZcy9TKy82MjNlOGhLNWc3UHEwcXY3czMzKzRFYXN2UEFrZGUzc3hvMGFWaElhUmZYVFNmWktTQ2ticnBHTnd6TGdrVCtJeEhhS1kzRXg0cXM4VmtRR1B3cnFrb3lWVGRiTzJrd215eEgyS3dyUEdrL251RFpNcWxza0xzeHhHSzZ3ZlU4VHo1QnlELzN1bVNTTEc2Q1pNTW1uWjllU3pIK3l6RVEyVHZpQ0ViMzB3aHIzOTd2NDluTTk3eDBzbzNYQnJ3T1didi9xRi8zdkJuVVFxU2txQlJzS3dMQ3BVbmFmS2hHMjBmTnNuVkc4aTRic2R0Q05sZUtBSlljejRvaG03bUhFK3hYRnhERHduME9EbTJORGNhSUFQV0VEMUNaVGZLVXFDbmk4cTdrbEt3anRPUHd3b1dZWWVvSmNoNFVXU3pFUTFQWCtLVk81OXZ3TDI5YU9uakh6cUV5S3djSVlmbXpzQVBIWGhFbHowcFM5NG9QM2d4MEIzcjBlQ1RJTWhiWElZcGthcVR0aEJaOWlmekFBRjV0c3pkd1IzZ2U5YURrdHFmaVFubit4a2RxbzVKQ2tUb0ZCWUZteHdVdjBFY2xuSWxpNk9Ubjd3WUpKaHhSd1hONTFIdHA4NjNiMC9BNTV1dyt1emdDdnBjczB2blFnMk5QT0tNNEVOVCszQml6TWZ3ZWxmM09SRmFINjNROFdDRUtrMDBuT0NvRGl1VGcxbkl4eDBobituNjFsZzJCaGhQYVptV1N6M0dmRHd2ZmtZWWFyTWRYeDE3UHBCQ25HTkpQbkNLVE1BbHJEUlJzQXE5SHlHcmFBcjVlQ0tsYTZVM1AvNWMyQnpHM1lRbU92bzFvTlRGUTZjc2xpdTBHWkU3emY4NTNONFkva3ZNT3VPVHhQbGY4dEZXNmRHTmxXb1dHSzBza0VWNmJZTWc4WnlwTXovTE5Wa1RndUt6cUhxdnJUYTJiQmdSaDNuZ3NueU9sbys0RUpLVTZhT2lPSVFBeGJFaWRnMWlYTnpwNHRQbld2ajZyT0FUNUc3OGxRclhpTXcxMDhsbUJsVE1DV0xQeVF5UU83bTFkOGdwN3lqaS95NG16bE1FYmx4bVI5ajVmSVJNMzZqNHZ1Z3d0WUp2MVJJSzVGaEJFTGV2aEdyNW0wbHVJcjNQUk9ubGF0L0RRSDg4TG5LeUZVR0l4UVBlVTMxRExLNFoyYy9zSEtPalZzdkErNG5OZnRFSTlwSjQxeXFUakdZVXdwb0J0UUs4czE3T2U2NDd3SGduTE9CODg5eTBIWFFsYkZhUm9DS05SK3NETUFDRUMyUVhUTkFNSllGU2F6SUNlOW1nSk1kZ25wVUlPajlWczBBbjNNZllVZTViQ0pGZGk1eGZDak5FRllzZk9FR2pzZTNBbzl1SXo4VXVKeE83Wm9Pb3k1VFBzQXROR0F0OFBYTmUvR1hYL3lhSFBPYmlWV0dIQm5oMGRRc0NJZUF5a2VDR2d5UEJERWp1U0t3RUIvMEpIdG95QU5iZ0JndTlZNXJRUS9Jak9TUEFGUVhIY0Y3Q0Uzak1oYmNIN054K3hVdUVzUzJ2L1JiR2FpL2dXNzE2blFaUXBzV0dRdkNrRlA3ZnZpaDcwTXl5UnV1Y3RIWjQwaFFtT3FOdEVpd3RKRXEwYld6MHFpSFBGQ0ZWSWxPTUVocXNiVVZNSWg5M3JacEpiNzIrMnZ3L2h2SzBkb0V4R0lFbE9LQkx2MU1KMC9WYXI0NlZyTnVUb0RPUGRERHNYR2xnM05QQmU3NmtSeFkrQWE1SnorZlR1T2gwMktBV3pUSWZVOWo3MjBYNHFGdmZSdWZ2dXZ2aVA0LzUxRERxeWlKUUliM1JEZ092dTBUQU1USXhUSFQ1RVpVVVdlb0ptUGM1eEVld1RndGtwNXpMNmxFU2YwTUxIOVhCR3V2VkFtY1JmallQNTlCeUh3YnJiMUpOTzdvUTV3UTBSWFA1eFhnQ2hBVmFwRlFKQW96bVpSUkJ0bFo2TG85Z3dvYXlpeDg2bkxnVzZSSlhvOWh4M2VleHVmdXZ4RFRhcGxXT1VWa2kvN3gxeS9EM0xNWCtPZ0hPUWFHUEZzYUNIRlBhalJQQ2tYd1lkR3lLcHgvN2FuU1JXbWo4OCsvY2drdXZHNlJkUEt2K3ZCeTNQN29WZmpJcGxPdzV2S1RZVGNTTTkxTitsWmJoZzk5Y1JIdS9OWXkvTjAveklGTjUzYVFReHdpTUZQVU9SVGR1LzZzaFl1cDR6aWVsSXJnQVRIYm9TRWJkMS9qWWp2ZDZ3ZXZBZzNBTlppR3k3UktRZm5DMDRoLzlrSjg0OEZIY1Bjalh5ZVNkSG9RMjNjNnFLNzJTSTBZZyt4cEJsYWNXWTUvZXV3V2xGV1hZZmZ2L295V1hhM1krUG1yeUwzb3didlhWV1BwS1RPaHBnYkFXM3FseDh1cXJvZGlQUU83KzJFNGd3ZWdSTTdBeWhzK2o4L0VObEZuMklsenIxK0cxNTVwd3I5L2J4RGRQUXpMejFtQnh0ZTNTelVPVnlGWHlzRXQ1enRZU0NoZVMyYUJNTCtIbm5WZkVkQUNGbkpCdi9LWGRuem1ENXNSdnVrNkM5M3hlV0RPSHFSSXdNNDRid25LNTgzSG1yUERpRVIzd2Q0VHhPS05IOGNwNy8wOWxMZGZRcWppV3B4OGNSSktyQXRLaXdvV1dBNlg3WU02OEN4WXpRb1lmWnZCOUZVSWlSaHQ1MWE4KzdLWUROMngwQ0pjOHBtN2NOTFpqVENTTG5UTndvNC9NU1NHT0pLR2l3dE9jZkNSRGNBWGZ3dzBtM2p6ZnoyTkwyS2FMdE11alhNYjU3RW84SjJIL2czWS9xcUJlZk5tNFpVRHRhaVlQUTkzZmZjNi9MZE5jN0htblBWUXV1YVNaUTNBNldwRytrQUFwbElHTmJFSG9kNHFXTzI5c0tOWGc1VVFCMDI4VGIyMkhCWTVTSzRkUjdqOEhMQmdCRWJ2SzBTWVRvWnJYUS9lWVVHSlYySEpTWC9DaXJVaExMdmdLdno5ZDc0R3ZYUU5lbU5oVklSZFBQRWkrWnM3WmZMWVp6Q05sK2tHS0x2OFZCWk9xMWgxM3J1QmVTZFhZZjRTQS9jOS9DVmNlZk5LT3RvR3ZORUNKYlVFZ2ZwUElCaXhFVGo0VTNEdFVpUkxseUVaZTRKZTZHU0VRak5odUNTbFJweUkwbnl3MmcydzAzc1FWdWVUbTlTSHhPQXVtRVlLU3ZRV0JFcE9vL01Ib1hmZUI2V2RLTEJOOStsK0VndktIOFVuYnRxRzJ6K1Z3RnN4aHQ0QjRHRnlxUmFYNDk3UGJzVGFVU0xDMDZNQnAwUFduMWorL21ueUFhNURiY3NnZnZzM0YrQ3NEMjRFS3QrMUR2VVh2SS9zSDFGWjNnQkc5a3prZ1BCME42bE9HeXoxTXBEdUJJK2NDY2Z1Z3AwOENEdXlHQUh6ditER3lGOHBQWU8rdndzQmZwQmF2eDR1aVpmWjhSVmlyYk1ScUNHN3lvamVwc2kzcVpoUDl2Yno0Q1VrclRVYjRCeDRnTnlWRXJDWkZVRFV3aE1QYjhVVFB3SHV2SXB1VCtUcG5wL0RlcjRGbjN2NFQzajRLeGVPbmNaNVFtYjlaY0t5UElnR2tlOTY0M3FjZk5lbmdSZTNSM0hhaHJOUnYyb3hXUHhrcUhXZmdCMzdFNXlPSDRDWExpV3lRcHlrNXcyeWpkZEoxYXAwL0pKQVBvM281NVZ3a3EvRDdYMk85R01OM0JtWElLZ0dZWFVUbTNINm9LVk5zcGxMNFpiT2dkdjNRem1nemNQTDRDWjJRaWxaU2VRckRTWFpBYVhzQXFtYXVkMko5TUVuMFpsVThNYVQ3WmhOdG53K2thT3YvQXI0MmF2NFB2bWh0NUlQYlU2WE5NNHBWN2tDVEpLVE9nTHp2ejV3TGs3KzhpYmcxK1RuUGZ0R1BScldMSVF5U0NxdzdIellBOFJJa2lSTk5WY1QrbStDOSsyQUd6a2J0ajREcHIwUGFmWTIwcndKeGlBQmErMkZQdmQyNmdUWEl1RFlCSkpJNmlVZlpaQ09WMStCbExVTjZmNC93Mkoxc0lPcnlJNXE0TFczd25YSmxpb1ZZQnJCRkYxRTl2ZDVXanRRTXZNbUxMcndMdFFzQm42OGhmb1JzZTFON3dkdVg0OWJ5T1Y5cHArbzlIU3hYY28wQUxQMklQQm5BblBKcHJ1b1Y3OUUwcm03bW56S05XQjJFSWh2SnJXNkZhejNsK1QwMTBKVEE5QXRoYVJ1TVVMUk5TZ3BZWWowUG9sSXhjMEloMHVncDFyZ0dOdGd0OTFOUHFvQ3Rmb3lNQkgrRVNHODBCd0VVbHRSNHVnb0xkdEF2N2tlSmRGekVTQXBETkxUNk53aWhqc0RHcWx0dC85cEpMdTNRUTNXa01TM2dlM2Jnak5YMStJOWZ3UDhZaHR3c0J1NDVSSlN2Ky9GV1NHR2wzcUFNNVVUR1ZBQkpua01NNmhkdG55UXdQekh6d09kNU9SLzVRSGcrayt2eDRZYnk2RDAyYVFHNTBEdDJRbzFlaEVVNXlueUwxK0c2dFpCcVRzVFN2cHA4Q0VDejB3ajdaUWhhWWRnT1JFQ1lRM1p0VTZTcm4xdzAvdkF6ZDBJelB3eXRKcmJZR3F6a2FTYnA0MWRjR0svb3hZSWtHM3Voejc0TXZTeWRlQldMMVJuQUJwVEVhcTVuRlJ1UDlMZFQ4Qk5kZE9wcTNENWpZdFJmMllVano0QkdXbDZ6eHJnL2c5Z1pvV0dMWjNld1BhSkI2Zy9nRnhDRGJEbHZhdXcrTFAvZzdUcElQREN6anJjOGZWMXVPUlNVcEd0RG1DUlZMbmtlcEJrUWlQbDF2Y01OWEFabklvMXNGS2JrVTdzUXFxdkUyYnR6ZURHY3dpNUFYSkxGc0hxZndHczlLUEVZbGZBUHZBd0FmYzZqTGF2MGoyN1NhS1hrblJYd05FcWtVNitoQlNkYTFkZlQrcjNBTm5STGJDSGR0RjlPNkVGUTlCREpTU2xmMEQ1akZQcHZoM1VTWVRHbUlPckxuZlFIV0Y0L0FVdkJXVVZhZWV2ZmdEcTNBaCtReDMwUnVWRWxGQUM4MDhYbkl4RmQzM09pOC8rSy9tZEwrK3F4L3FQbmtxc2swQ2NRN2J6SkxKTzFWdkFaNlhoUkYrRVhSZUNXZFVHSzBBZ1ZLMEduemNmU25ralNkOHBLS0Z6MUxLWGtRelNieFpmaFVCdEEweTJFMnFGQlh2V09RaVZQazYyOWxHazR3OUNYN0FSa2JvNkJEUUZMTm9HdDJFNTdOcHE2ais3d2VyQ3NKWjlnc2pVSE9vVVE0aldoSWhjeFFqY0RnVEx4TEJMR25YblhvWXZQMWlPM3plVCtuMFdHQ0pKWGI0QXVPOTZNdkVCUEVZbTlvYXBhdGpqem5MUEpKWkx2ZmluQzZONC83L2NUM3lIK01jZ1NlZHZIaWV5UVZoYzliNVNtS0ZhMkNrWE50azlKbXBZMUpUTTZURTUyVThsQVYwMTRMRFpjTzBZR1dFUnNRK1RtOUVCVnhra0thb2hZbk1xNXB4eUpscjNQa05TUjc4dERaSk5mQW1PNWNoUjlVRDBISmdEalVqSGVoQ3RySVVUWG9oNHovT2tiamtpRVJXQnlyT1JpdTJCTVhCUWpyallhYThpallrRWNQb2VyU3FCYXlUeEpKbjNDSkdBYTgvMkVycnJxUjl1SlFILzV6L0tWNzF3QitlYjMvR0FMbWZzOWxCRSsrWUQ5NVJoMlRJSEIvWlRneE83TEkxd0dFUGVrRmVLQUU3RVNaMDVmcnFsNW1mNE9mNW9DK2xySytrbllMdWVudEVpTXZlYVZDWTFjdWxzNkZVS0JqdjJ3NkpyQmNxOWV6dUV2eHJ4em1maWQ0YW9aWUZNNHhlQitVQ0puOVZnZXVPa1VMMHNQekVvSUtSWnhFbURJaC9HTkVqaW82aXIweEV1RFpEdEprb2x5Rm9vaEprTlVkenpyVWI4Ykd2Nzl2MmNyMzdIeDNLcGZXOWRNWDhXTHJyallWaTlhWlF1N3lmN1JMNGZ0YkJqREdDK3pLdTBpTWpFUkZtUmpNcGJoRFMzNGpKZlZnUVh4RC9YU3BHVURJcWNkOWpNbGtuU0trbTB6c1dRVEJWU3hnRm9iZ04wVjRmQkRKbWNIUlFOTDdMcEpVcUNESEU2UjRjaTBrTEpWMldFcUMxeWc2bW5NRG91a3IxRkVyYXFsMUJuMGIwUkFqcUhPWXpPRlNEcTFLRTR5dnhVUTRXUUQxZUdTU09RcjR6MktkRzZ4eDFRNnZSTmlhU3h4T29qTnlGVVJnMFNocTVyVUVRMUw5ZTlESGN4OXNrVWFzUk1EWVRsNVlUSkZDTS80NHZPcyswNHJRbFppaTJPQjhsL1pDU21oaFZEbVBZSFZISmpXQWdHcVdiYlNaRzBlZCtwNjhCd2h1UjF4UGxpbnlwRVZDUVFjUzh6VzNZWTI2dDM0Q0xiWGlTQzAzN0g4ckxPT1BtM0lybGJoVWdjY3hBZlNzblV6djVCanFhM08wVE1kK0NFQURRQU5BOTBENkRqN2QyWXU3Z0JHdlg2cGgzNzhQMnYvNFFRSWJYbWVseE5aQ29vVE5TdWtDOUprcUtRZElwc2VvVWtSNVEwcUVHUnhlQ1NaREZQdWsyZEpKMUpYYXFHRGE4TzFOQUlEUHBOZ053ZmphVGVaWEJTQVZuekF0VWlOV3Y3bWZXa0N5d0cyNENVWkpGUmI5dWlaTUtXdVVTaTdOQVU1ZHowZTV2MmlXUHkrdFNSVXFhTDJmVmwrTWhOYTZrREtXUXlCdERUTlNUZXMvTkVBYlN4TDU1RzEvNTJ6RjFVUlQ0bHZYbExGMTdmK2haT1d1TFp4VXd5ZGFaQWFOaFdpa1owWlVXQ2wwenRDNVNvZ2hERVJiNlFJRDBSenpkS0QzcHBLbXJBMzhleisxeWV0Wm1aaEcxWk5wcXA1R1paZTUzSkhPUmVFdUp3YVlZWS9CNFlFTmtUL1hEU3A1RmRWZEd5cnhOZGFSc2hiNDZHZHo2ZzFONk5vdXNlYUR5QU04NWJEQ2R1MEVQWUlDOEQxWFY1ak0xUGxCN09nUGMwOGZBSzVnTmg1UGhod2F3ejVxUzhFZ3JSQVZRL3QxZVUxVHRXMWlGV0F2NW5ueHZLa2dzN1c1Nll1VytHTzdvNU9jQXl3NURBWGpTbmtqUkxIRHlsWW45TEw0alBnVHpwdDA4SVFLa05kNHR0eTk0RHhKQUdZQ2N0Q2FpUVBKRUxKTkkrM0J3UU15VXJycC9saDl3Q0pNVnJmT1lEbXdFWm1YcFJKMXVBNVBwUzcvS1JvTWg3WlZJOTNheTBjaWY3eklkazVyT1JwZnExNVNFRWVCS0pBUnVOamYxUXZWdTlPYTBCWGJCZ3dhVGNzQnJZUyszZTE3eTNzOG9pUUlWdlNCNG1ldnBDYU5tZmx0bDFxdC83UldOcm1UemNuSWt1Y2pQeUZKYXQxRmI5SE50TUJiZVZ5amE4WHVwM0FzZFhtYjVVeXF3K1BWdnNsQ21IY1AwT01hd1pSaG4xRSs2TXlDQ01CbDFvVGh6ZHhOcjNOZzZLUmhXVE5ydzVHVzNXMU5RMHZTVlVESHZRVFhlMk5IYXY2Ky9xUVRpc3dvNFA0clRUVDhMaTFmT1JHRFJsN1lnb3YzZkUwSllzVXZJcWxkSXBDNmxFU2hZdkNYZEJsZ3k2bGlRNXdzVlJOTC9PVTlTSTB2ZUF3V1Rab1hCRlZOMnJEelVOTGp1UmJYbGk1NHByd1o5ZEJSNUJFa1hCVnViK3JvZThZM041ejF6cEZqWStuV2FvQ0JOSk1vZlF0aitPam01RDJNODNJQ2QxZVdlclhObkhlK2ZQUjBsejg4Nk85c0YxemZ2YUllWldDQk1RSWQxQVdiZ2I1UUZIems0aUdLMUxRTmgrcWJTWW9VUUFKMll3NGI1eEV3MmNUcGtTRk00ODRBVVFZaFlUcithRllDWXhNMFFOSXZPcXNSMVJ0RXRBT1puYVVwZG5KVkJxQmE4VENDYm15aE95dGpNWFRGbGxUdC9OSVFXVlFSTjJ3a2J6L2dTNkhabDh2WVBlODVDeW1iOTJRTWRNMGFBZXZLT2JHclN0cFJzcmxwUWdGT0RvYjIvSE03L2VnN0pTbjhuaVVMV1htZEFpMTY0eDVWRDdocnh6cE8xVmM1cVhIMm9YaCsxMlppNGpuaTJLNGp4YkQ1T0JSNXliSXZaVFNVeTVNaEFuKzhteHU4bVFNNkRScVZ2R2FRZisxd1lvTzl4K2tyWnRwdkEvOS9iQ1Bxc1dLa2xWU0E4aVFVeFI1TVVPMTREbU5HZytRU2wwMy9Cbm5nVUxmT3pmNTVLbE1hL2wyOCtCSVdLNHRTNmllbEtXV3pSMWVQYlpWWlRuTVVwaFcxNDc4T2tPS0N0Z24veHVCd0p2S1liUnQ2ZWx2YW8zSFpPSnJoV1ZwSzcya3lEVmVoTEtNVDVJaGU3am81UVI4c09BZGJqam1UY1JHZmRWRVM1aS8yaHNCMXA3NUt2c1MxWld2cDFEME5rWTBubE1nTldPQTVnc2YxK3NvU0dwa3gxdFBXQ3U2eVFTTkdjbTJaMHE4bUoyZUs2TExMUFBLZW5MTUY2ZVcwYlBjMW9qNXpQUGxVUmtQMmVxejNKYk1CY2dOb29tR0czTjJOSTBnUm1pMzh5czlNeHNjemZRWlVyL2MwdGZOTXJIVUxWc0RJbmwwd1hRdzBrbEcydGJ3dGpMSGQxOFhTZjE3TVh6Z0ZLeVJRa2pqSllPVFJJaE1UdUpaVG1TdldaSUM4dHhJU1RJYnZaN3ByVVVkU1J3M3Z3THpKOUNUaGxHejd1V1Q2NGNQa3lPWE1tY2ZWWHZqZ1F6TTVlRFdPTmtMQ3ZvY2czVUVVM3FnTHNQeU1FYlJCbDcvakJnc21NcHJaTnRROGVTU3BiL1dXTnM2d0Mxa2hndXMwNEh5Z2pRVld2bjQ1d3J6c1pRWDB4T09XTVlsdWRpa0E1V3dHVThWYmdiTWtXSVBIL2h4a2kyS1djWnM4ajE4R0tCZ3VWbUZpOG02M2p1UzJZcUc5ZHpZZVFVY2NMQmNjU1VjOTU1Y3NvNDF4MUpzcEN0TzlYOEdodUZiT1pzWW5kbEVXQW81WVcvNU4wMTdSbmt1THFqZ0RxZXRFNnBoTExEZ0prUDRvanZaRWUzTyttMDFkZ0VYZFJ3VmxKUFQ4VTYwTEZuT3pURmtxZHgwcjhLTmJDWURGZk1MNlNZSm9KQ0Z6dkNYVWtqNEl1TnJwTGJFL1RFeWhGQXFjNncrblJVUnc2eHVVeitENjY2L3B4RTQ3eFpqcHJPVjc4Q2F3R29xT0p1SVA5a0JxM2I5Z0p0dmNERmErdmJicnp6dys5OWU5dC8vdkMrbjZpeE1VRExsMVkrbWVwWE80NWdqbGdINitzN2xPYm1YZnYzNHpSUmlGdGJSOTNhR3NEelQyeEhkWlUvbFJzYm5mamt4M2VSbzQ3SE5BSjhwRXN6RnVrWjdWNjVMUzJ1SVVpYkNBRXZtT0h0aTRVamVPUnJOaFpzbURzbnNtendxK2Rkcys3dVovL3k1elhQTm1xZEJZQTVxYUJxeDBETnNzTUFtb200Q2p2NlN1c0JmbG9iMlovVFYxT1Bid0M2cWVkWDFIZ1o2bU1SRTg0bnhrcnp0N2t0bGh2U3k0OGZaN2JEOHdpNlhrY1Q4eWFKVWFMWjFjQ0JwSTVyYmdySnNWeHJaaTJTYjc2R1VHVlYxYjFmVzd6NW9tdWJsNDJ2QjhZRTliaEs2T0VZN1doZ0txTjkxeFRsaFQ3YnVibVZBSDMzV2Q0a2pWMmt1c283UGRVMlBGK0Ntc040Y3lZdEhzdHRHVk9xL2VHMzNEbjdNc1JLZ3VVSE1qSmJPWHluYUpnL1YwTk50WVphV3NVVWRTaXRRU1Nza0psSW9YZklSZE5CQzNxQW9hby9BVDI0REVxd0ZndFh0OHkvOTZPdG43MzNmenZmUk02VXF3WGEwaU1HZURKWjdtaEVTQm52c3gwT3Y1aU94ODA5YnlNZzdHaE50WmNXMmQ0K2NxaHFtTW42Mjl3cHlUTnNkNFFrK2cvaDVBUW9iRDgvS1RNUlpNWWV5Z21RWGUrK0dYWXJoL25JdWZ6WWV4a3VXeDlHVU9kUXhmU2dvVkpnM2tLaXNyUTFDTmdRUGZDTWtFeHdTcmZ2ZzBVOVRRUVlhbXZEWU9sRnVQNURCemM5OU5qdVIvcXNRREpubkFnand5YWpmc1owVUxuajJVd2xaenY4T1ZGVDA2RWtFbTgyTnZLVlBTU1pNK3VCUmJPcGpXWjZnOUJPM2dCM1p2Q2I1OFJWTS90enQ4TXFRczIybnVJUFVBOVBYSlZocjJ4a0s0cnpvalgxMkhSbEp4b1cxcUN0S1NWTHZKbHFvS3hPaGR2WVRFVExSWWdlTWhTcUJPdFZ3WUlOOUZtRk12UW1vaXVTc0R1Nm9Ea3pVTEo0UWVDS0N4cXYvZEVmOGRoaHdvQlRwbkxaQklCVXhnQlRXVEhUcUY1M21yVjg0UnkrMGh3cWk1YVRkNTZzckVZREFmcSthRUxtOHFSdGh0N0dYblMxa1F0anUrT1NsL3lCOEJHQmhRTERoYm5IVnAyM2pHeDVKOUtORHJsWGlxLzZ2VmRnV2hDSzV0SjNNZU9aSm5zTkZ5TTI1RHR6a1FJaG55TU5KOVVDRlRvdU9hZnlRei82NDhCLytOS3A1S2xmVExiRUhxdkFBaHRGOVNyTG80bExQM3RkNHI4dk96bTBVaVdsRmdycDBLcG5RNG5Vd0VxVFMxSTNBNHRXVnNvUmtYanpXeWk1WVNFQ0RkWDQ2UU92NGJjLzN1VU5rN0hzbkVMQ2xtWlNRdzZKc2VWRmtqZ2ZHUmQyM2F4cnduM2JLaVJjekxWd3c4WVhNUCtjZW5UdEV6Ti9CaENnQTBJRmN4WkFLRklQRm8yU3BnakNTVHRRYTFLd2pXNFlMdmt1M0VUUHozZWdjdWxpdUVZUFNzc1c0TXhWZGV0WExPZ3RlYTFKVFl3VFdKaHlsVHVlZEI2eUwyeGE4NzV6VS9kdjE2NEt6ZTBab01ib3RSR29FRjJWbUtGSXZsSmFTSVhOSUY5UkY1T1hRZzBFVWJIcWJKaHRqWWp2M0lNUC9NTVpJck1UenozdUpRR0l1SUhNMDZWdDJoclpHcTZiMSsxNWRpQTg5L3Z3SEVqTVczVi9icUtMYnJnWVR2TlRLRnRmalpMVG9oam9NY0JraE1tR3lXTncrbmFBT1RWU044ZUpCS0hSSmtBdFdEMEpwSnNINGNSMFZNeXRodGsvQ0RQaUlCQXhjZnJzb1kydk5WWDhjaFF5Tk9ucVZ6dEthVHljRzhQcWRYZnBReDlzMzNyU2trcDB0SEVFaVIvd2dJNWtMSTJLaUFvSGNiaHBEY24yTG9UbmxWTGpjRm5TcDZnbXRIQUlSdHg3ekhmTmorT3NXejM3S2Y3c2hpQlJZcWpVOEpQRFdCN1J5UjBxRys1cFR0Wm4xWDJXbkFFMHFIcHoxOGVqZThEbVZlRE5WeEpvcU5NUTBVUjJJWU50dWJERXhNbnBOSFhJZnBsbDc2UmQySEZISm12YkluUFFWVERVVUVmcXFBck03SUxkdVIrQldodlJvTHFHYnZXckkzQlRKZ3p1c1F6OXlmWFRmN3Z4YXQ3NkNHSkprajA3QVJid3BoVVh0UVZpVGovUktFcVpnOGlzQm5JVmFxQ1hWeEl3Q296K2c5UjRyWWdzVzRUNGxtZlIrM1liT0RueXVqOHBsR2o4YU1TYjA5YWI4QmpaM04wOFFMbWI1WmdTZEQ4TFAvTjNYd1RESlNGRHloUVMzNDYxSDI5QSsxL1NHS1I5UXdSU3VwOUlrUGpUSWdTVjBBcXVUZXJXOUdiS1RnbloxVGdDekVhNjFZSjlLam5UQXdmQnFHTW0rdzZnUkEyaG9VYWRtYWUxcG1Yb3J5QkpycHJCWXRaZ2lDUXZnVkMwQkE2MVByMC93cVdrWHZVUVN1YWNCSWNIa0doUElsUWJSN283QmhheG9GU3JNSnM2MFBXOUo2SDFjMnorU3dDdjdUSlJVUVp2YW5MVk04eUN0YXBLOW8vbmNENkdJdk5WclpCc3l3Y3liWGhBaXJKQW9jYUZPeE9sNjIrYW5jVFNSYXEwMlNtU3pJVEM1WjhQa1ROb00rNU4vNnFLVkJZWEd0Rnh6WFJrTnIrK2NoWk1laSt6djRNMGtDbmp3Nlh0QmhySzNlcGpPY0p5UE1aRGgzdGp6eXVQcFM3NmNCVzZleHdNZEZzb3MxSUlsb2RoS2lwc2wyeE81eHR3cTJkQXJ5dEIwbTRrOVR1RTlKNHVHTTI5Y09LS3NLZ3lvYjZwWC8vTjY3MUtpOXZ0Vm9nRUFwS09Tc0ZZNUovVTRGenNDMmVWNnZpaEdkK2tKb2k1eHBqWEQwenFFU0xUbmJPNEV2djFIKzJ6Yi8ra3RucXd6NXVLM0NKcFl5U05PdlBTVjhSM2tadkVpZkZxTldIcXBBcDRlUm01THhxMDE3Y2pVUmVSOGVhQXptQWtUSkhzSFJ4RlFvOEpzTnBScXRYRExra3psRktKRGRhU2MxNDlVNE9CY2hncEd6bzNQWWRmL0pFY0FpK2RkS1Q2ZGRLK3J3bHFySUFyL3Y2WThSOWJvLy82NTk2eVg2QStHNXhnMmUxNHNlVHhzQjBtdzA2ZWtoNTBrdDNoS0ZzZEpoc2Y2NkZuRUNNMUp0bFJjbGNFZUNKQjN4WlZjV0VDTUVoYjE0SWE2d0E3bU1ZUVBYL0NKZHRMQk0rSUdhaWNGVVJQakJzVGFOdWpVc2ZIUEVuc3FkZTFKeGM5Wi8zaHd2WGFwWnhVbEJFbmhpdUhyc1JmUlBMK0VJQXNZYkJWV2ZZZ2dxU2tGbFBkTWRiK1drdm91Y2QzbHY3cXJXNjlCOGR4R3BtZmJpdlpIUGxtSW5yRHBmakFvdGw4Vm5tWjU5czRLVTRrekpOU1JUdzNtUkdyejVGekRpWk1CWDFXbUpkVmE4d21WZHREbmJNcUVrUW9uTVRlL1lHdTQvWHNCWmNUTGxpd2dJMUhma1lMSU9TdVY1d1VYM2J1YWZ5RERiV1lweW04TnFEeVdick9xelhpdkk3RDQ2a1Uycm9IMmM3V0htWG5qamI5cmEzTm9aYUJ0R0tQRW1GaTQ3aEtFMkhqZkpUdElldmx5MUx2V2x6dkxKeFJ3V2RXUm5sbE5PU1dLb3d6VXJ2T1lJTEYrdVBvalNYWS91WmUvYzJRenNOM1htZjhNQUFMcmYwRWNrK2FOQTl3OS85cDJOaHFCcmY2UVlYY05UZHRuSS95VENJdmwwOFZvSWVFOW5KV05lK3ptcmRmSGVVOFpZeG8wMWcrN3hHcDNEd3c4NEYxUjlubXJrNys5bU5yaHk2K2VMbnh2cTd1OU1GZWJlbmV4MThKYjMrMXVYdnJHRUM2bzNTaWFRZm9tRkphQUxES0VRSTZFVHZLQzlnV0N1aG93RHFqN0hjTGxNNmpCblN5YmVpSVljUlJWamZ2dUZ0QTR5dDUyK01KNkVSQWRjZjRIVDhjYUZQRmNubUI5cWxRVU1jS1V1ZXV1YXpQelpQUUl3RnpvcUM2WXdDYkM2QlRvT1FkQ1pqSExUaGZhSkI1UEZCSFc1UzhjNVE4SU4wQ0FTMUVRbzlXU25tQmtqb2VxUG43amxweXRVbFNzZU1GbVhtQjBqZ2FpTzRvdGhNVEFQVklwYlJRU2VYajJNYlJBTVlvQUdJeVZiQjJsSkk1WGo3cGFPRGsyMFlVQU9aRVhSVjJCT3FzSUJkbUFoTEx4MURCN2pnU2k4bVExTWtnUmVNQnkwY0JOMTk2UjdPVHh4ck15UVIxTE1BS3RhZVRTcEMwU1FhVGpRSWt5d01KZVRITmZQWjZ2TUNjREZESFk3WHVPTWNtVFNJbkE5QkM2amJ5WTVHakFacy9sRFFlZUVjS1pxR2xmSVdDZXJRZ2oyV25KODJlVHFiS0xTU283QllJM0pHUW44bVEwSW1TcFNNQmVyeDdUSm5LSGExTWpoVUFMaThRdUNQeE15Y0wwSW40cVJNRnVoQXdwOHh0S1FUVXc5bmJ3MlhkNHlpbGNxTFYwNGVUVmh4R2JmSUNQaDh6TUk5MTZBOG9yRmhuSWdHQ3lWS3pFd1YwSWdFSkZDaU4wekpqZ1kvU3NQbGdUcVFDYTZLU2VLd0JQVkxKUllISHA1M2JNaEhtVzBpbjRFY3BpV3lTQUR4U3laM0lzV01pcWRveDZOM2p6U25BanlJK1BKMEFuUWhBL0NqdlBhVTJGT05JV1NIZ2pqV2lVeWpBZkpMZjRValA0WlBRaWFZTm9JV0F3TWVSc0tOdFREYkowbmtzZ2YrckFyU1FGMk5UK1BMOHIrU2FFMXIrdndBREFDZUpmZjFxcW9xekFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMjAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dRalV3TWtGR1JEUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1FqVXdNa0ZHUlRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pCQ05UQXlRVVpDTkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakJDTlRBeVFVWkROREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtMMzNJYVFBQU1kWkpSRUZVZU5yc2ZRZWNYV1dkOXZPZWMyNmZPNzFQeXFTSEFFa0lKVURvUlZRUUVCRUxzaXFmNHJvcWxoV3dyS3lyZ3F1N3NwYlYvVnpVUlhGWFVjUU9LeUJGRVpCT0lBa1pra2t5dmRjN3Q1M3lmcy83bm50bmJvWnBhVUQ0NXVSM2N1NDk5OVQzK1pmbi8zLy83enRDU29uNTViV3pHUE5OTUEvby9ESVA2UHd5RCtqOE1nL28vRElQNkR5Zzg4czhvUFBMUEtEenl6eWc4OHM4b1BPQXppL3pnTTR2ODRET0wvT0F6aS96Z0w1R0YrdTEvSEtCUU9CZ1hrN3N3N0VIcldyQXR1MTVRRjhtQU1VTUFJcERCZkE4b0FjT3BEZ0E4T1drMytVOG9LOE1rT0lBeks2Y1FZc1BPYkR6Z000TXBwaG1PNVBKbGROc3hUU2Y1d0U5UkdCT0I2U1lCZGlaZ0pRemFPZ2hBZlUxQmVoeFlsSTdXeTk5dlVXT1Uxc01MR2U4MXVnQlZaWkFGVnUxMGpTeGdHdUV4RGpPTldZWUtHS1RCNlhVb1YyUVRTL2tOQ2JYY1dFN0RoenBjWlZJY3B2eVBBenhwMTV1OTJROWRQQWlQZnkrY3dUWTBXSlpQWWNLMVA5dk5MVGVjZDYwSkliM05TekI2ZWtFU2thVFFIa2xFQW9ESmx2QmRRRlBJV2VwY0ljdGJVSWphSERyeVFsOW02eDI2Z3ZCVktEcXJjZXR5d3VwY3VjSVVYUzVyMzhVeUthQWtvZ08vQWVYcFoxSG0wWndCeS85UHdRM2RUQkJGYStsUXV2Skd2b3NOYlRCY1U2S0F6ZWVmaHpPS0lteWtZdUFzVFNCQ3dGaHJ0UWdEWnBxQlFXRUFzVExBYWYyVTJ2SEYzV3NJQ0pTM1VjZHc3WlR6YWUrR3FiUTZxYk85L1dPcXMxakRYNDJEVjlnaGdiNG5RREgrRDNBYXozU2hKWW5lbkJEcjJYZFBCMm8reHFIdnV5QXZzUXNUdVBVMUd0UWRPTlVsZ1ZzMDBWc2p3cTJRUVYvcTJKN05CaktUQktYZ0lreU5seVlqVlpDQU1LOHZIcWhrTW9yOEVPUTMwTUJLM2RQb3FGdXIvSFFyMjFva05RTkxTSW5MQU9Cc0lsQXlLVG1Xb2dWQmFpdDNCZmdSU0lCQ2tNQWtxZzdXWnVYNG8xb1c2WG4rTUFTTWMvTlF0OWV1c2ltazVDTzV3dUI4TFUrVEd1UXBEQU4wUmhYOHZ1NmFtQkxOL0RqSi9DL0pjQzdtaXlyL3pVRnFISldmRitUZnVhSzZnQXVhS3pIbVU0YTViMXNnQXFheDdBeVdVYitSWDBYR1FyNWpaVjNsOU5kZnZKcnF1L1piTTVjT3I0R3FTV3JycXNBNE9jTWZ4K2d1VXdtYUxJcmxiWUtETHNtM0NBQktUZTE1dmsybUlCU05WVmJLbzFVR2k0MDJQNTkxQ01wVFZmUEtIeTVRbnUvLzdJM3ZoWFkyZzU4NXJkb3BXOC9hNGRsN1Rqc0FjM3ZJVk40WDJVUWYzL3lCcXhXNWxFMThpREJEQkxJZU53L1J2azc3YmRjM3orcFk5UXI1UDJjWlUzNHVwY0FtZHVmZndTdHJZWXZKUG5yS0RPcnZsTlp0ZmwwRlBBWmdrdWY2M0ZiRnFNUThaam45Z0NqZks0MVN3VWk0WnpaelpsWXk1SWFiS05nbjdxbEJqdG4xaFhBUFh5M2dUYmdoa3VBMy80VitNSWZNRVJOUFhxN1piVWR0cW0vbkhsZFJEQy9mK1lhbkhQNkNUUkp3d0paYWNHaStWdDVqRVdpSXJTSk05ZzZhcXMweGVJK0t4RFNEYWw5bnVlRHBVMW9YaTJrLzFIbWZGdWVWcnFPclUrUThIMmg2MlQxd1lJWHN6TnBPR3hFbVQ5WCtvMnZOTGU3ajFzQ1MxbkQ1YWNEcmIzQUR4K2s1U2dKb2pocThYeGZKUzJsamFaUGp4MCtrTkpXai9zZGQrS0JiTWQvbmhmNDRzbGg0TlpQUnRBMWtpMzl6aVB1M2VzYzU4aG5sVlFjRHFTb1VFUFZDN045VHFmMStjVkhMMTFkY2RvR0Z3ODN1YWhkdVFhTEdnaXFiU0tkTVpCT09UUjdXV1F5RHV5c2kweWFQa3g3SzVvL1plN29xOVErajQxblo5WG5MRUZ4U1hJSU9sVkZmWGZ0dEJZRzljOXpiZDJ3SG4yZFIzdnIybGxleTI4SE81M1czeDEzUXJ2enBqMFM4Y0hkMHdVTWsrQzhlUjM5NEhMZ1gzN0wzMnBLOGFaVHEyR1NHaHZLVWhqQzk5RlVmY2w3Mkh4RzlVeWVGSHBmT3MwNGgvdGNLYlNwdm5CVEJBc3JCYTc3VmcvdTJwYitTYnRsdmZPdzBsRGhrNTZ6YVhYKzk0WVBuMm9kdWJvUy8vRGxSMUJaRlVGdHgzWThPSkppUTdvMFU2NXVnR3pHNXFyaUFvY0F1U1F0U2dNOGJUS0RnUWxUaXp6cHlaRVJtUXMvbEprVU9RWmJhSXFsOENtVVpxZzVPcFVqc1hteU9yNG9zNXppUTllVzB2VFM0ZDJ4aGFhbERyajVLdUNETncvaHYrOGN4c2N2Sm9HeWZEOGNKcUVLODlrQ3ZHQ1UyeUMxMWpRREJKMkN4b2NLME5JNG5vbmhoSWQwWWhRWllURVFWcFlENXgwMllZdlMwSnlaM2RnS1BQemxENTlqWEhIbHFmalkrNytLaXJveFJBbVFzb2lLRVdwZmx0TU9LMURnODNKbTFzMlpyYnpKOWVUZUFPU0pqOFFFNmNtelhIWHR2TEhJRXkwZFlsaTU4R1JTUGtnVSt1U2NPUitoZVhuOGNlQlRyeWNWTHdjKzhGMmdrOCswYm9uUVdocmlNMGRJb0lnallpRkpLczR0M3l1Y0ExemRMODdmajFvSUxRUmZ2aDI0c3huUDFnS1hQR05aelljTktlSjdsTzBDdG4zNGtvMDEvL2oxOStMeWN6K0p6RWdDUng0SkpGSitvNm4za0NnSStxWGZyQzVWemxGTVJTcWZhbWtUYWpGMlVYMmZKczJyU3orbGozZWxObVdPTXdHbytzMWgyT0Z4dFcyUFlQdStUYVVVMVBVTncvZC9waUgxZm5WOGpzU09tK0E4QWN2bTJybVRsTHlHb054NlRSQmpCUGlxYjJjeDVDbXJJY2FKbUtHRmpzL3VCQkVOT1RUSFVzZXRyZlNkSHozVHdmdlBBYTY5aFJyL0loNG9GK0oxTzAzVHljZWxoNFBKTmNrdGZuYlJHWnRxUHYrTDcyRncxM2FzTy9WY2xOUFVPbzVTUFQrV3N3SkJOcXlIS0cxVm1QRktoS0llVXZGZ2tENkk2bWlTZ0lTVTlLdFRuQlNFbCtieFBvMlVXbDA5SFErcWE4bmNaN1YxeUVhVUNWZitUUHMwZm5hSmx1djY1eWwvTENnb3l1ZlpSRTM1N1F6UDBmN2JsdnE0TkUxK2tqNWJDWVd5R0lOSkQwMGpFWng5VEJEWFhUNkt6Lys0WDV0YWxieFF6NmRXeDdIMEkxazBCd2FmczNzUU9IbWhqWGVlQ256eE51QjJnamxzV1djUEhtRFc2R1VIbFBKMlNkQTB6L25nKzhyZ2RmNG5rbTM5K01RblNqV2hFZlNQYmpxaEthbGl0RzU2R0c0Mm9TVmNhWVpMaWltelk3N2dleXFZOXhtalo5Z2tRQ3FvblBDZElwZkYwZm04dkYyR245SlRGeFFCWmZMOERJTW9ZTFJ3bFZrMytUd0Z2eUYzUG4yY0ltS0t0WXBjaW9paXA0SHFZY0RhMFNLd29kRkFRNUZBODRpSDZvZ1l0OVdlc2lTV3A4T2hNWVkveGRUVXoxN3E0YlkvQS8rMUdWdWxhWjUzTUhwaVhuYVRlNndRQzdQQytPRVJqZDZaMTN5QUlVQVJZekV5eHVLNG55SlRwa3o1Ump2bis1VEZHUnZMaFIzY2tjcjRvQ2xsek1laWViK1lid2IxdS9vTnNpRFI0Qlg0MEVsOUl1cGpNSmZtMCtFUDEyaklqMFhWUFgxQzQydGEwSmhnNkNydnE4S1BKTjFFUmR4UFVOeDRCLzFxSjMxS2lVQXc3TCtUcEhEWVdWb1lranhCbGU3bzlmQzVOOXVJOGZ5cmZvcmhtQkJIdHBobTk4UlRUcVNNWC9VbWwrL1hHcExlV1gvZWhYc0RQOERaWC93Y1VNM0E3cFpiZ2Q1K253UmxNd0xwckVRbWE5SFVLVC9vanNlVGVhQ1FTOStORTVnQzlpSXhvYW1UT3l2RlZKMWZ1WHlyS09qY1VzOWhpQW13SVFNNjkxc2NkblNJbzlLSkkwbUJkUXM5WE1HWU5FR2grK0l2Z1Q4VGx2cHlBMmJBZDU2S0E5Z1pVMTlIRWJ2Mlhva0xOdGhZVkFWODZIc2tRMEpjUkREN0NycnBEcWpQOUdVSE5QK0U5Y0M1OXpiaHNmcnY0cmd2WE85bmFINi8yY1FTVWtHaFlqa1NCOWNMc09FY1JFTHUrSG41dWk4eG1Ya1c0bU5Pc0ZpWlk4RGo5NTZoK2tmbTlFTGtWQ1dmaDAweUZrNVJ3OFNZZ3pZQ2EvRDVNbzZCN3BTTEM5WjdXblAvNmVmQVE0eFBhd21tb1Zoc09LaGRDUCtEVkd5ZHp6UTRKckN3ek1GRkc0R2JxTWtkanZqc29HaytPZWwxRHMvdU0yV0phZ2pxYlEvaCthTnVSOE1ucndhMnZ1Q2hyY3RDZGFVeXNVTDNmaWdUcGNJV1dTQzNvZ0JSa2RQR1FsQjFMMGtncDYxT1FmY1hKc0RkNjFxRk9FOENYR2xwS3FzNlNGMkNvb2dUMlRYVmVYZVhodytkNHVETkoxTFRHSzdjMTY3OG9vR3M5TU9zZUVVbEVuMGQ0OEtWcHRuTlpEeTgrL1VTZjN3YXVMOERmeG0xelA4N1JRZjZBZldUdm1KMXVia1lmb2h1NXMwMzNVejZUMVAxZ2ZkSVpGWG14aE81SEt2dXhKcklrK2E3bzB6ZmZDbHRKUm4yZlpVNWFiWDhyUVkzWi9yeWVWcTk1cTZoZ0I4LzF0aDdWZnVFNGJlelN1V3BCMUgzN0NJVlhiL1F3UWZmeU5qeFo4QzliU1lXTlJoWWUyb0VGVlYrYjBvb1ZxK1QrenJHRllvMFNWeDh2S3ZmNVhzUEM0ZHM5KyttcUlnNHZEdTRGVnlsNUJBZEVwKzg4U3Y0MS8vNEJuREdpUzcrOUtpQmhXd2cyL0VkWjJHZjVMZ2s1a0FTQlNLcExGeWUrT1NUK0lxbE9nVzlIcnJ2VTdrM3l3ZFQ1RXlyNTB6UzN0dzliTWZRUW1VWWpyN3VhRm9nUWxiOXVjc2tmdnNvY0RNTjVybHZxa0p4Y1IvQ3RVdXhjazBEZXJ2R1VCUU5ZcVJkWUd4VUNTbHcvSEliSjZ3RS9vMm1scnp1eTRPRzBUK0Zkb29EWmJtdmVPVzhha01LOWRmdTM0Ry8zazVTY2RWN3lDckRyczd3S0wrVDczcWF2T3BxQXNQWE1vdGFHb3BNYUpwYTg1cXJtR2RpeE5mczBWRWZiQlVmcW81dTlic1Z3bmpQeU9SN3FHdEw2VCtFeXBXclhQRGdzSU9QWGVEcDBPT0x2d0dPMjFnR0t4cUdheXlDMjhzRFEzRXNYZ29zT3FvZUYxNzVMc1FyRjZCLzFFUjUxTU9EejFONkI5RXlHalp2emJXOU1RbkkvU2toZlhVQm1qY1RiTjkzZmZNSGZoWEJaUmQ1Nk9wek5TakM5SHRhTkZqVzNpYlJjeWEwTVJEMlFjMzNPWTdRTExhMlVodklQajk4L1hyOHkxMlg0RzJYbGFCMUZ6QThERTFVOVBYOS91aTlUYTJWTThmbVJKZ1Q1TEh0ZlJKdldPL2lsQ09CNjM3RTBHUlpNVXFyRklOZEFpa2E0WWtVM0w0SDRHWXNPTU1wUnF4UDRPd3oyM0RaSlRhYWVFL0I1LzNZS1NpcmN0MXJZa1V3cDlETXc5dmtGcHJlRysvRGpnK2ZoVzkrNDl1NCtycVBrMlE4NUxMaFRVUmowT2s5bFk1RHp2Y3BBSVpwc0xKcEVwRnlDa09GWDk2aFRLWmluRGExNTVUWGxTRmFXNDJqam81aDQ0VW13Vm1HLy9PbDQ0bk10OUhhbjBUejVnRWtrZ1RWOEdOZUJhNENVWm5pY0N5T2JES3Bzd3hhV0hqZHZoRURkY1UyUG5RKzhBMWFrbDB5aUkzTEdjSll5eGdMOTlLc0ppQVl2QnFwZm1wc0Z1Yklrd2lrc2loZnZoR0xUa2tpRm4wTzdkdUE4NDlGZkVFNTN2K051OXhqMmozeG9ZUmg3TUJMS3c0UFg1TmJ1SkQxZnZhWFR5RGJ4RmQ4N3pza2hrWTkzZThaREV0ZmF5eGZDMVh5WWRtYWNwenhsaU0xaTJ6ajhXZGN1QkpuWGJwTUIva1h2ZXNvZk96bWkvRHU2NC9Bc2Vldmd0Tk1acnFkOXRaYWczZCtZUm11K2NZYWZQd3pDK0h3MkU2eVUwWVlTRkU0aklCLy9ZYWx5eWs0cnErbEtvNGtzeDBkZGZDcFN6dzh6WHZkOGd5dzdwZ1MyRlkxc3U0UTQrWk8ySFl2bkd3S2p0WEFiWTlPUjhyZ1FtcHJHWnpPU3F3L2VTTXUvcnUxdUhNTFVFY2h2ZWtLSExlKzFMdW4ySFhQZmMxcGFINzUzSDFJZk9JczNQVDE3K0pUMy8wYXNPbTRFSjdlNHFLaXdpY3lxZyt5YnpjYjg0UVMvTU9QcjBSeFJURzIvLzVQMkxPdEZXKzQ5aUtHRjMwNCtkUUtyRDZpSG1acUNISlB2NDU0UmZsYllkZ1B3dW45RnR5UmRoaXg0N0grc212eDBlSHJLUXhiY01wYjErRFpCM2Zodjc4L2d0NCtnYU0yclVQemMwOXJNdzdQWUNqbDRzb3pYQ3l0QTk1Q3Q3RGlpRHFZVWRQUE96TW1NZ0w4Ym5sK1pZSlZ3bjE5M05aVHpUdzQxRlFqWGdsUnRRbWhvaGJVcmRxTXUvOEtYSEVDOEpYTFVmeXZ2NVkvdmIvRnVYYklzcjU5VUxvbFh5MDFSWisrejkvZWVCWktxRFNkWDdrS2tUVXJRN2pwbHNVb3NwcVFwSUt0UFdVbFNoWTM0dGlUSWpqNk5KcTczU0dJNVpjaFlOMEY4OFVXdUtWdlFTcitFTXpoYmtUNlRTU0NLK2pYZHNMS2hCR3RQQnBqQS9jVGhBWkVBaWFNNHFWdzNKK1F4YlpCaE44RVVYRXBkajNXakV6UzQvVnMzUFR4THpIc29KVklCTENreE1YbjMrWGhDNlF5djJ1eGNOeVpLNGx6Slp4TXErNFVzQUlSaE1JbENMck5pTVliRVNYRGpZV3lpRWRkaElJU3BURVBJWE1RWldXTEVHOFl3ZWFIdXZIRTdVUDR1emY0bFlIZnZndjQrUlo4YzlDeXJzbm5OQXBTZi9Ld05ibHFlVkxLNFRqd25XLytKL0QwTXhrc1h0eUFwOXFyVUxwZ01hNzczcVg0MitzWDRkaE5wOEhvWHFUcW9PRjI3MGE2UFlpc1VReHpyQW5oL25MWUhmMXc0bSttVHlzQnhsNmtHYUo1WklEazBjOUZTalpCaEdMSTlEOUZ3clFLbnYxV3lFNGJScUljSzFmOEVlczJockhtekl2dzZlLzhDd0pGeDZKL09JTFNpSWM3SDRNMmw2dlcxdktjVVpwU2FycVhvU2FXMGFlclRvUit1RllkWEpkYlo0akg5T3JPODJDMGhpYTVGeUVHc0o2a2MwOHR3NG1iNHBEMUFyYzk2UGVYZnBUeDdIdlc0K29heC9tdmc1Q3dlVlV0NHZ3alJTUnQ0cGpUVHdZV3J5cEg0OG9NYnZ6V0YzRWgzeGlpRFhoK0Q0bkhTZ1JycjJMdzdpRFk4MU1Tay9PUUxGcUQ1UENkZktGVkNJY1oxSHZkTURJSkVxVkdtcnR6NGFTYkVESEpSREdBc1pGdGJPUVVUZUdWYlBDMVBINEVnYTRiWVhTUUFqdThUKzg5MU1xYmNkVVZUK0pqSHhyREM4TUMvVVBBdHhoU09lMURTQ2I3NkFMb0o0MnNwcjhHa21UaWRNZ3hCbUJXbXZmc2dJd3ZnaGVySWNBZDNKZUZZOXJjMzRwTWl0K2o5ZmpnSjVkak0wLzUwVDErUGZCSDNrQ2F2eGJ2ckhLY0g3NW1UTzVObDZKcXp3aCs4emRuNHNSMzhBWExqajRWdFdkZVRQOUhLaXZyYU40b2Y1a01aTG9YSXNCQVAvVUVrTzZDakoxQXJlaUdrK3lCRTF1T1lQWUJlTU9NVjRxTzUvZWpFV1RqQzFDelNIS3luZjlNMXJvQXdVcjZWVUZBVW94dFNodnBiNitGakZKYks4K0YyLzRWaGl0UmlQcFNJRzdqem04OWlqdC9BbHh6RVc5UDhuVDl6NEZ0U1lNeFpraG5OcngwR3FHUVJkUExjNml0cWk4MEhvOGlSQlpuMkNPSUJpU0N3dSsxSWVkQ0JRMUhNWW5SODg5SlJFand6bG5uZHdDVWM5OVhmdy9jMDR5dnRmcm1kNTlON3F1bWpGT0dVTmVSeGYyWG40WlYxMTBOUFBaMEhHdlBQUW0xeHl5SFNLeUNXWE1WWTdzL3d1MjhCYkpvTmIzTVRqS2s1eUVxTDlXbTFlajhCVUZlU3dwNUlkemtjL0Q2SDJLOFVRbXYrblgwWHlIWXZXUXo3Z0FWaUVRbXZCcGUwVUo0QXovVUhkb3lzZ2JlMkJZWTBmWFV2RFNNWkNkOTdKbmFORXVuQyttZWU5QkZBSisvcHdNTDZNc2JTWTcrK1E3Zzl6c0V5cXNOWFlWb2toeFpiTXRRMEVCRUZXb2J0aTQzaVVXaWlERTJpak9raVlWTnhFbXBvMFF2RWdxaW9TR0dXRkVRS1RlSVFDQ0VwY3NyY044RGJiajZob2ZjRnNzSzdBK2dyNG95VHVwSlRXOFdEN3o5Rkt5ODRYcmdoL1FrellsYW5QZXBwUkJEYk9UU2pYQ0d5RWhTREVBcjM4enRMeUFIdGxNek4wRUdxdG5vVzNtaEZ5bWRjWWlSWHlBZ0RRUVdmUXllbDRMbERFS1N3T2lTdEpGZHlOUjlBSExvTnNqQlhkUkNCa3FoV2dqYmhhejZJTHpSUHhHY1V2cEZhbmQ4R1RENEM5cllLQzNrRlZpMmFBRzZkbjBVdDVLTGZ2Qk1hdW5ieUovdmt2alI1aUJXSEw4UXNYaVE0VThBMFVnRXNSaFhnaHFMQlZFVUQ2TW9ZaUZlUkdDSmNFd0JHL0VyTUlMOEhDTFladHBtSEoyQXVhSUsvZmNNcXlmdFB5ekRsaHlZVlQzQW45NUJNSysvRG5qaWNXcm45Z3BjOXRGaklSeWF0QVNaS2VOUU1YQUhSUEg3R1hlcWdpT0QyK1ZzZEI0VDVmYzJPcUxTOXhEWUhYQlRlK0NLQVhodHo4QmMrRTh3Uzk0SUwvR01YLzRYWG9oZzZsR1liZ0Npak9HZkVkUjFSMjdmYmZwcHBMUVpmbFFydFlJOWVCOHl2VStpcVBiTk5PVnRDT3hzd1FrYnFqRDZONzI0L1ZmQTI0OEhybndkVUYyU3drMTNONlA4aUFhVTBHWUdMWmZtTTAyeVl4RmdrNThGd2lHRFZrTG9XcUtRWmVocXhZQ3FNMVpoRFI5LzZZSWlyRi9MTUtkakJMdGYyS1VLTHdieWJiUmt5WkxEQTFBRkpoKzh1aGY0QzhGYy90bHJnUzdHSy8vOEZlREQzendONTE1ZURPemlFZEdGTksyUEFpVm4wMlRlU3pEcGdEeHFWazA5d2I2UFdsaE1ocGxtQ01LdEU0WkJoaEdJTFlGci95OFo3azU0VmlWa2RqdUM5VGZBSXhuS3BQOUU5dGtCTTdNTmdXd2JqTktMNlpzSFlZMDhBVmw4S3R5eEYyQ0pKSTh4YWM3UHA1QU1JdDFQSVNnN2x2Z2ZnL012YjBaN1J6ZHUvdjBvUG5JSjhQcGo2ZnVLSFByVlBXaU5DZ1NDZnNXZnl1dXBWWUZvaVluYUlpTzNYeGV2R0g0djA2a2JxM0g2OFhVWTd1N0I3cDM5Q1B0RER3OGZEYzExSUVlN2dJY3ZQQWJMUHZFUklEa0NQTEtsQnAvODJrcWNkaDREbDFhYVYxdlZjcGI0VDJtUjhuYzlTUC81TG5pbEREZkcvb2VOM3dNM3NaZzYvaDZJNUVOc2lGcHFaQjFTdlhjVGdQZVN4YTZEM2Y0dFhxTUlkdi85TUl0UFpJeTRtaHJYaEF6RERYZm9selRUTlRBclNJYkdIb0F4TmdwbnRCdFdKQVFydG96QUJKRm92UU1sdFNmRFRuWFN2Tk1xSkJiaW92TTdjTjBEQXI5OVJPTGlUY0F4dE01ZmZUdncrVjlLSlBtc0phWENIeCtqOHNXbXYxV2tKNUJiRlpCbXJwNVlEZkZZVEEzMVVvUG9heDlHeTU0aEJXaHpjWEh4ZmczZmY4WENGb0w1eHpOWFlkbDFmKy9uWi8rRGNlY1QyMnB4Mm51UHBQa2tpQXNaUHF3WUpDVjhHTEloRFRmK0dKeWFNTExsYmJDRGo4QXAzd0M1dUpGNE4xUDdqa0NVeDVqRlR5QVo0am5MTDBLd3FnNVpzUVZtcVEybllSUENSYjlGMXJrWjZjVFhFVmp5QnNScWFtZ2VhYnJqYmZEcWpvSlRWUUhiM0E1UlEzTzc1aXFTcVlVUVJhTmtzbXpld0RBQzRVNkVWQnN6TEtrNTVZMjQ0ZXNsdUdzM2NQdWZBVFhXOUtnbC9zQWpjMEFpTlNyMzZyL05meTRjVTVQdm5sTm9WY1l0TXZFRVduYjNvQ2RocTM3aUZ5YkovNXhUZzY5RVRSRm9abis2T280VHIvbUluMUR2N3ZLN3NzVGdzN2pueXp1UkRWZkJTU24vb29iNHFjN2xwM1ZOVDVZYUV6QitUU25QMEU4dWdPY00wd21yMXZvQ0c2bVRjZUVJRzZpSERYVWtGaDV4QWxwM1BFaE5Kc1Vvb3VrZFZFTWN0dWhlOVdEODE4Z09OU005bkVXOGpENDNjak1TZlgrQkpLR014VG9STExzVnFXRnE4VkNQN25GeDBsdTB4Z243TjdwWU9sNGVoWmRKWWlXanFUNTZPMVdvMk1KdEkrWHdtak9BTDkydE9tR0Y3cVpUbFlYYTlHcVQ2NDkzeVJkWksyQkgrQW9sWVlaZzJXSHMzRGtBaWlQb3haOFBCQUlpRW9sNDAzU255VmNOb0JUbWoxWEVyTGQ5NW5QRnFHMTAwZDZpQmpEYmVQdmJKVEtqcXNzcmdkUklBbU5zSk52TmRVcGJ1UW8vTjlmYnd0ZTBrLzErUWJYblM0a1Y4NGMxT0tOZERBVXM5TDM0SWtZNlc4QXdFTUVTLzk0TUVXSEcxUEYvVWFVK3VxZTVKODFBMys3UWlmbGdsRnpZZEdGa0g5TDlwTWhWTWFpcWRxWE5xckZDb1pBV2puQlJDZDczZWpWbU5JZ2t5VnZRRENJVER1UDhFK040YktRWnYzcXFDM1cxcGg1UHFycnFQRDNrVU9qeVR5Y24yS3BpTUVTSmlRY3k5Tk45YU40OTRvK2RzcXhucCtnUGxYTUI5bVVIbE8zN3dYV05EVGo3azkraVgwdWo2Q2lHRlE1alA3YXdteGxDbzY2cnRFbGtodFd3SXAyVnQ0bTB0Qk82WGxZbEZ6UlB0RlBVa2hGVjgwNWxjSFNSdEVtTkRralZKVk9PVktZZGxsZUhnQmRBUm1SMGNYYUlEYThiVk5WaVdrR2RXTGY0dTZGSGNmTTNJdXFvMm1CS2l1RHZxdGhiRldHYmdTaUZKZUQzRUFSVjhvREFVUDJFR2FCQVNSVG5TZzBOeTBLa0xFS0xjQXVmdFFPVnBYTGNaMW81WCtyN1Q2a0pVc29tb2ViN1ZBU1RhRzkxc0lQQ3pidHM3YTZvNkRFTVk2b3BjYVlxY1pPdktLQjhyMTFqeWN4S2U0Q01NRnpNQm9rd3FMWmdxTkc4TXVCWHVDdWFLQXcyWW40TWhPMDdFVjFpbEovc3dJWGpKTGlPNmRIVGVzeVJ4YWFsbW1ic1lVUzRQMmhHRVJCaFpHaWFIVGVGb09GL3ArZ2c0NDdxNjZqajFUNVRxYWdlYisvbnhiWEFPSDVOckZUVjlxb1FuUHRkMjY4Nms2NmpoeUdhVUlWakxoS2pLVjNhT1RnaXNldEYrdHZjK0ZKVkM2N25hOGhaRXFXdHJ2QnJlZ2RwTVJwS1hWUkhodkZzczRlMlB0M1IvNGhOd1pCU1RqVmppcGhOVzE5MlFJUEE3cUhlSVhTK3VCMkxsdGZwN01xdXpUdnhnNi85QktvVkxNLzN0S3BTd1JCcTdJcXFjUTNTOUptNm10Nmc1cWdoRFdaSStGMVcramhDbEExUTA0VnVPVE9TOGNlQlp0Z3dqRm1Ob01QemJHM3kzSlFmZThLMGFXYWRYTDhHYllFdDRHU2dOVm41UGNkUlF5WWNYYWltaGgxbVZjVVh6M2RjUi8rbXIwOUJTbVU5TEtndHhydXYyRWdCTXVneWh0RFhQWXBJYU84QnYrTURmM1ArVTdrT05TeFZsYWFvQVV0N0dMNG8vMWtzeE1OQ2lLbW1scHZUbERpdkJLRE5BNGswdWxzNnNHaFpPVXcyYUJmZjVybEhYOENLbGI2ZnpCZFQ1d2NJamZ0SytJbHM0dXdYVStjVVNqVU1yYmIvUW9yMHhQeFhUby80WlNwbU1MZFBUdXp6Zk9zNVhqU21ycStIamVaSGNvc0pmNTJ2SEpSK0VlTDQwQXpWK2EwcS9JYjdCK0dtMTlLdm10aXpzd3ZkYVFjMVJYNVlvdVBPSEpnYURkN1l5WTJVTTF4L2FLTE43eTkyYUpjT0x4QjRXRDA5U1pIRTFITUdUbGZxcWIrLzdJQ3l2WnRKYXRIZTNJN2pUMS9PT0RKRHFYTEFLQU1WTlpNY1JLNVFlcndDM3JmRTR5dHlROXpkVEFHTERrMEVZN1N5MnV3cEFUQnp0YjFxV0wxclR6U0JFZHpiaU9raEY4N0U4TVQ4ZmZNcGI2K2dCbGlISWdSNzJjSXlXcFlFWk1wa0hOa1A4am1VVStNVmV5K3NCRE55eVFWVmVaR3gvWkhnaTZ2SThpa1VUUVNVUlArNWdhcXFEc1BYVUFOVFQxdzFJNmd2TzZCOGd1MXF1MmRIT3huU0VJTjhXd09xTkUvVkFxbVV0RmNBWXY2SnZWeVZId29ISUJsKzR3c3hNZVhNK0ZCOGIySThETnpjZERPNW9ZQ0ZvSGc1SCtkcno0UzJTcmVnSmVYVWdwWWZxbDlWRW1ZY21jVFlrSVBtNWtFZHBoVEZDVkEwQjJDdXhsZUZMUUZWbzZRMG0zUy9qdHZhTWpZSW02S05ZVTlVaUFjZDAxUWRKZ1lteHJsZ1gwQ2RNNkQ3bWxPY2Jxa0FkdkJwQjNidjZDcTNDYWpMMklRUkp1TzVNUGEwcEhWMW5abVRmdFhZbGpuaGQvS05XVmlSbC9kTHVzRkNma2xuZmdTM25acG8rRUJSN3JYZEF0SFBDWTRJVEF4MnlnK0h5RTl1TVc0WnBnanJsYWFwQ3NKNHlJUGxKdEJMMXI2amVRUnFhR2hadVc5eXpaeUpGdm5VWDI2ckJsblZzVEVxaTRIZlBlNG5iOHRNOHdHdHlFTElHV0xObVRUMEZVbjlwWGpUTFh1YWUwOGQ3TzVESkdMQ1NZeGc3WEVyc0h4REk4WkdzbnJzaUJwKzc2cXVMVjFyN1JkY3A4bnpVMk1wUFhoSmhRdDZ5S0JuYTVLalFoekR5bzN6VkdORStUMllFVG1mNVpCWStlTkRzeG1waGNqSjlVcDU2bHJJRldiREowaHFVTENkdjcvbnQ2SHJTSDNQUXUxV1BqNmRGaWlOcU1UQUtOcGFFdWpzemFBMDdLZjQ4aVdnSXA5VXlBdWxxU016TEs2a2h2TWFUZTFhem9iR1Nrc2YxckpzS08rSzZiUjBLbUlrWGdtV3ExK252N0VSMGQyN3QzUjJqSnk2ZTJjSDFOd0tFUUlSWm5CZEhPbEZTZERWczVNb1J1c1JDQ2MzVkZxNUZkMHo0dGdhSk4rZlNZS2MxYUJJNFFPdmdGQ3ptUGhqWGdnejFTeWp4aUFLZnpTMnF3YnRxc2txOG1OTHZZblp3R0Q0STYzMTlkVkVVdnFBQ2Q5WkNLWWVaYzd2MlZFRFphRXNuREVIdTF2RzBFc29WbFZaV0w3RVFuV0ZoU3F1a1hBUWdaSktlRlRYWkRxRnpzNE1LbHVUYUdpZ0FQUm5vYnhQUklpSDdGZ3NDejljeVlNNUc2alliNU83dndCT3RWQ0FOL2V5UWR2MjlHTGR5aWpDUVluQmpnNDgrTXNtRkJmbG1DeGVhdmJ5RTJJVStqVmh2TlMvWWRJeFJyNkxJOThNOHFWK2NkeHY1K2N5a2hPRG9xU2NHQStUYnpwMWJJcnNwNHgrc2l5WW9QK1VlR0szeEJjL0VNWkZaMFFRSWtrMTFVUVJZYjZRS3FXUGM1dWhQd2pUemxhSFZhb0w2WTZkNkdzYlFjV2ZYMERMTTRtN2JWODc4OW8zSGFoeW1zVENJV081czA0ZVRHMTdNcXZpengzOWNFNnNna210Q2dkQ0dDTlRWSFd4NDJOQUN4cDBNa0daNjc3eHp3V1RMMEpPZjM0aFdacjJXam4vT1RSS2hsdkZPREtReEYvYmF2SHB5N3BRdDdRU2JidFN1dGhYbUxRNk5TYTg1dDF3R1orRnErc1JEcGRCOUpzUW9UcCtObEZkc3hXM1BuNGUxcFQ5NGI1SnpMWVFUREZGUEhySVUzOWlEdnYwZHljWWZNSElaQWFhOW5TVTk2ZUhkYUZOYVJuTlZRc1ZxU28zbXlWbUJtbXUrK1FVd3dqbExHRE45bnYrVFZURmZYbE1vb2hrckhURkd2UU9kQ0hkN01JU1JxNTN4VmMwd2VEWXNEeCtWMk5mTGUxRXBmTGRkQ2VTd1hBMjQzckprcExCWEQ1QlROSlFNVXVtcUZCVEQxcllNaE9ZZXZ1V3RZbUtvMWQ3NitwcXNLRWlYblRNWjc4cWdxM3RhVFY3RmhiV0F5VmtoU09iL2RCRkQ3TXZHTktYWjd5eWNCaTlMSGl6Z3MreVVCTXg4Vm5LbDdaR0lVQmlDa3N3MVpyM3BXbUNHZVk1OVF3Ny90UUVOQjc3Q0JyUHFVWDN6akdkUGduU0I0ZUl0QlJCaEdPMUVQRTRMVThJYnRxRldVbGlsK2xGeHR2Qmk1TGgvMnlYblJ2c0w2ZGdzVk9OU3B2Mmp4UlloMWdyeFlhU3hCdXZmc3ZZeDFldWlCd252RkE4SEE3QUxHL0FtU2YyNEtjLzNva3VCdFRMRnpOdWk2ckpKQ0xZMDJscElxUm1KN0Z0VjdQWFBHa1JCU0dFQnRtYitEN3VlTXhKOWtuNG11SlBJV2VNbytkZkswZXVYRGxPanZ4ZWtaeXA5L1lHTXorWGcxb1RoS0NVbDZ0VDRja1I1eUM5L1Y0VW4xS0I2Tm80aHZveTlNRjZZamhrNVREY2djMFFicVYrNk1RZ0FXL20vbVFXQSswcWpWa0Q0OFZ1VjRoRmhabzVYU1pvMW5FdjFpSHluNklvblczODVydjc3ajErWGJpeGQ2Z1kyVDRIa1JJMUdXSUFiaWFMSTFhNXF1ZEZqeEN6andPS0NlZ3hHeHV4NllLVE1Eb3dyS2VjeVdSc1A4U2dEVFlnZFQ1VmhSdTZZNWlSdndwak5OdlVzNHlwZWlBL0YrZ1VURFRoNTJSZFAzekpUMlhqK1NHTW5pSk9CVGl1bW5MT1AwNVBHZWQ1ZTVNc1RIUlFXN2t4TmdZZmZrSFlMOGRNcDVzUVcxdUtyVStOb2E3R1FzeFNlV2FHUDZUQnRwcENKNTJHMHorbysxdmR0SWYyL2pCcWF4d3MzYlFPc1RYcitYdGpaT1dEajFZMzlacWRVM1JxNzlPWVVlc2dhdWM0bUl0QzNwcXZ2TDF6ODRvVlplaG9rd3l3ay9BWVpTZUgwd3hOVFBySU1TeHRET25PNitaZC91UlFLaEJQRFhlaXMrbHBXSWJ0VjkzUS9ocFM2c2x3MWZ4Q1JqYUxrTExGcmdwWDBucitjRDJxMm1UWUUvTFZ5bFZBbWU2NCtYUk5WM2V4ZVVML0QybDZ1VG1KWm5pekFqTTkyZnpxdVlZc2Z4UjNYWWtxRWdPZTZlbkFHZStvUThkZjB4amhvNDk2QnRLREpFR3FNSXlpcU9UR2MyaHVzeEw5cEF3bm5CM1NQVXQyZlJXU1c1OUZ1S3hjL1B0M2x2N3lkVy9kYy9JTVljcTBYV1lIQTFBeGs3Lzh5QWN1dUZRMi93ZUdraVFCVGhKQ1Jka3F2bE56MjdsY0thVVZaSDhybGhlaHBXVlVEOFN0cXFIVTIwUDR5NTFQbzZJOE41V2JtSnI0VE03dm9zQWNUK3NFNU40aHpYU2taNnA3N2NVNmhFL2FWQXA0U2JXL3IyazdnYjByaVRYTFRXM0dVOVRNTVVZZmFpSkpQWmVTa1A1RUlDYTNTaHBvTGNhTUFBVE5ieUMwQmthb0NpdU8yN1B3dW5lMi9lMVgvc2Y5emh4QVBhUTFSUy81aXdtVk5XTFlMZzRSdUNRQ1JSRTRPak51SUJKVFdobEdySDRaZ2tVcmNQVFNFclNxUENiWFdnSmFWK2YzSDViUzNSUlI4bU54Zng0anRVWmlmbTVVaFRWcVZTVXJnVkJ1Ry9SVGZvSGNuSUQ1ZGE5Qnd1YkVFNHBKY1d2aC9IOTY1TFk1c1ZYdGJ4b1Q0Wk95Sm9NMHQ2cVhhQUZEU2pYY3ZtbVhnLy8rZFJZcFQ2Q25YeUl4VFBlUVVLa3REd0hIZzZXNlZ6TGNsNlE1RjM3M2p1dG1ZVVhLWVpYV01YamtDNldYNFlyM0xMbzJacXJhMVFNcjhUbllqRmIwUFhsTDh2Z0x5aEZaVllUaEdGOG1RRWtzOTVBSnFEK1hNSUt4cnExSTJoMVlmM0lNQTJ3UUJhcks0YXJaUTdyNy9Sb2pOUm1WeXBNcTdWVXpZS29oK3ZrNWlmS1RPdVpuc2c0RUpsWjFIYlVXZmxiWFZkdHdidmJyL05COVlVelFTbVVSVkZLSzdrNFBCRmIzSFJnQ2V2dEFrUGhNdlVCbkQwMHQxMjBrcDlVVXNBWFVVRFhiOW9CWmk3Y2VsMEVrTGxDejBFUW9hc0FMR0hwMnpUU2xJaDIwa0NFWmRHSWh2MndoTitHU1Nnb0pOVC9oV0xkT2lNWldMQWxjY0pwNTRTd0ZZWWVVRkUzNWgybVNkamhsa0o2WFd4SWx0WHdaV1V5ZlI3cXU4cTRxWFpZYWhUc3lnTVdHQzVkUDBQU2lML21WRlg2ZFRVZkgzbDFWNDB4V1RzemZucCtTUE05Mjk0b2pjOC9oNWhJVWlxQ1VscGxZc01EQzRvVVdhbGRWSWx4Y29aKzRyMnNNcVRFYkE2TUNlemIzNDdtbmgvWDBNL2srV01Nb21IQWoxMjJuQm5jdnIyVU1TZ3VpQmdDdlA0MW1NM01mSHYxZEJuWExlSjhHaG1IRnZpTjJVeEtadEo5dU5HaCs5cVFjdjFkWStmRnNpcDVJeGFkcFhTQnVJb0R6VHkrOTlMYjdoMzlTRU1MSWZTbmx0QTZpeVIzWDBNZTNHMytvZjlqOS9hYVR6Zk1GL1VncTRTS2dKdDkzcE02bHFqREJzUTJVVWFLWDFwdG9aakRlUnkyb1p5TXRXMERwcjh1VmIwenE0RmFybmUrckxPanF5ditlMzQ0L0VOWHk0ck1GVGo0aGlnaHRzd3FacklvRk1HS1ZzQmxJaG1xcVlaYVU2V2RLN0g0QjBZOHNSYkN1QXJkOTlWbjg3dFp0Mmg4cVRjNERxK2VHNUZyRVoyMnM4czN0L1Z1QmQ3NkxNZWdHUHdiMU1nWmVlSWJhUjVzdkFoWmRTOVJQL0t1OHNnaGdKS2lDN0NGNDZRenMwUkZZZGhkTmNRdlA2ME5SOFJLY3VLSDJsT1YxZytFZG5VWmlDczJVQnh2UW1mNmsxUGo2dTZiWTBPK2FjTm5iSGhsZHMyNFYvcWFtQW8zOG9ab05vdjdZVFJYNUFlTnVNWnJKb0tVOFlwb3R6ZTdxZGpWeFU3RkFlWldKQm1yU0lxNGxpeXJaSUJYYS93MzJqVEVZdDVGSUNmVHQ2a2RYeTdDZUVYcXFqdkJreHNTNTZ3MmNma0lZZlVNUkdLTU96RkxGTk1nczllUkJleEN1cnRZTmJLcjVHNElobEI1ekVySnR6VWhzYWNMYlBuMjg5a1ZQL0hIclhqMHJDdGoraE05c0YxVDZmK0hocERlZUEyOFBZOURUSjJMUTRqby9sUFNIVmlRZ1N2d1kxTTRTOE42TS9xTUVRZlhYZWdaN0VDaXRnVXdPSWt2SG5JMjVDTWF5T0hYcHlMazdPa3QvVmREek85VmZhWnBTZXc5VllrSHZ2MjFML0lYYnR1QWZNTkZ4LzVJMTNwaytOeGdKL2lDZEVGalZHTVhmWHprSFRYcTdyMGsvLzlxenVQdTJiWDVTSUhmVExNT0JxOS9vWU1YS0VuUzJxZEZnU2NoY3lGUWFZOGlFQkxYRFFyS2pHNUhGUlJRU0ZkZVdVbWdVU1Franc4Wk9qWHBJOUEwalZockdra1VXNmxiU1JKZFVhQzN0N2hoRG5HR1ZWY2FRYTBjLy9mMkxXSFBTM0dQUUVLMVZmMzBGR2lyb1gwZnBrS1BEYkloeWlHdzNuSzRXQktzY0ZJZk5EWHlWTzZZQWJUb3RIZi9kT2xobUZ0TlBvalRWcXNFTTJjNmlmN3RhZnVua1kzMU5zdnNjUlBkQms5NTY3ZkZJa0pUYy9iT3Q0MkhGbWhPUGcwdzhnbUVkTW8xQkJQMUprbFYxczVxaFREV3FVZXdpMWxCSHMxNkpBQVZGRlFoa3FDMVBQdkk4aXQxTzFEYnR3SnRPQ0NKOFd2V01nclh5cktXbzI5S0daVWQ1YzRwQlZUSkRWeUgzdWxoSUMrUU9wSkh1M29hUVFVQXBXTW1CZGtUTk1PcXJ5TEwycnMyWUN0UURMaElUK3hIR1RBZW1xTFRrcXUrOG8vM2VGU3ZMOWx1VDFPTWZ0U0NCMWU4bTB4eFJCY3NHR3RkTHRENFg1dkZqQ01lamNOWDg3dXJQVmhWUktBSmhSQmV1WUdnVXhGaEhFdUdxQk5LOXcrZ2FUcURyM29leFlZbUh2cEVJc2d4TDVpcFlwdWhDNStNZTZzdkZyREdveTk4c3o4Rm9yL3JEQW96RlBCT3BUQW9pUGNqM3p1cHNWVkVIaVZXSlYxRVFpM296Z1BpU3Y0cDRzTWUyekFsTXRYNzR2ZWRjSUJtcitacVUwVnBrcVA4dFkxeVRSSUNhdElBQnF0S2thQ1ZWT3FnMUtUbXlCN0UxeTVCNCtNK1F2VzJ3YUtLckdSS3RYUmxIYjlOV2JMeXdITkhWY1l3VVVSdURDWVFxWFdSRGZzaVU3SG9lS1lmbjFLU1I5SnF4dldremV1KzRDNnRyRFFxV0NVTk5zc3pHVjRKbElzTldTdWlFdWhJc0dBTVVsQkY0YkhpWjlnV3JvaWFDWGxFL3B4alVNVUt3S3VNb1cxcUUxZzR5NzVEUWFjc3hOZUdTSy9XMDVwbXhMTTJ6RjV4R1E2ZnpwNGUwQkdWR3Y1b0h0cVNjRmlxMWI1b2tZamFNQ2hQWlhaM28vdjQ5c0FZbEhucytDRm0ySGh2RGoybmhrTFJ4SmdHb0NraFUxRE5rUWdreURCVUNNdXVURy9VblAzYjNJNTEwdGRCazBuUlg0NEsxYnliYVNiZHF3UXB0K3dzaTlRSVJXcGJoUGw1VDVZMno5S01Xd3gvR09hcGMyRkZqZENJV0xJSm9NWHpyYVhXd3FKWUNOQ0F4NW1VUW8vWm5oak1vYXdqUjJzajBITUNVaDZLM1pYLzlLbnFmL1huNmdpdkxHYmk3R09xMVVXeW5FQ3FodVNPbGRhaEpMalhKcTZoR29DYUtwTk5NOHp1S2RGTTNNZ1REVFNoZE5uV2gvZjNiekdjWEgybVViYWdKTDFMQ1VWRVd4Vk9QdXpoMm82a2tuYWJaUVZBbjR0WGZkL0duTmRjRjJZNnBiVUpSM01GZ3lZRUpWcGlDZGNzRHBZOXRPamxRdjdSQkxwZ3VCcFc4aHozZzZoblFTbHdETy9mRTVPSUtpQmQ3SFBSUmNNcGpJWVFqU2V4b0NYVE5FY3lEMHNFdDl0R25Ubm1OcEIxSzdZc211ZWxjNFRWb3RvS2Vtcm8wODZPSGk3Ly8xRmo4MThjRnQ3K1JadmFqZWVHb3BYQTBidzlqSUdFaEd2WW5ZTlRKQi9vdlF6RmlDbzMrZ3dLcExCS0o1M0RTaFFjdVdOczd6Vi85MHovRy9uRHgwYW4xeTJyY1pUVmxzcjYwU0pTckVmbUdNSVNka2U3SVdIaG9lQXk5bzBteHAzM1FlbzVoYXV4REY3ay9XeHluMytmTDlUQTBhMmtEZnY5TStmZjJBY3hYdk9wUEwzYytFM2hnZFdQMnZ2UE9OTSthaXlhcDVLbnRJTjB6SkRxZjJSMTU1RGZQeDM2N1l5Q2c1eUpJMmNIMFZNSlJWdW5tM2xnUkVodnVaT0ZRQ1p1UWlRTVZySjgrRnYvM24yNk8zNjFFNWxmUFJaN0FjL2lyN2d6TkpmbHk1dE9kdE5WckxEUnkrU21yNVdVOXZhbnVvZEJSVGI5K3F1aXAzZG11UnpIRi9QTnowRkE1NTFsUWxpeFpNdHVmTkRZS1E1SXBWbk9LclhuNjR1U3FzNC94M3RKUUxSZVNwRmFHTGE4MkdKVGxGcHZiY2VYWVdCSWRCSEhiN2g3emhjM3RnZTFQdElaYVJ6TzUvclhjdFd0aWJ0Rm4zcEs2OXNMWG1TY3E0VWdrcEI3R2x4Y090VlZtejFPZkhhbGp4RlNHRWNPZzZINnlPZmpNMHFYVzRvdk9NOWZ2eTdtOVE2SmpjMHZnejcvYkVydDlXMit3b3dBc2R3b0Fwd1J6MGpwZG1PSmg1ci94dmRmK2d3bG9JWmhpR2pESGdad0I1TW5uRkFxTE9ZVnZIbWZPNjJveWpXODQxamx2VVkyc0N3ZGthVFFncThOQnI5UVNNbUE3TXBrWVExZm5rTkcwdTl2Y1R1Rm9lcVk5MkpySUdsb1ZlZTZpTjJ4d3psdGNLMnRDQVZsV2VLNFNMSjdiMlROc2JHdnBOYlkrM3g3WStuaHJhTmR3V3MwMjlSTFFDci9QQlVodkJrYUxTWm82VTRMK2tBRTZGeTJkRHRpWlZqSEZGcE9BQldhZlRIaHllWWVjSm1jcXAybnNRb0RrTE5yb1RnTE5uUVhNNmN5c25BM0lRK1ZEQ3h0cnF0V2I5THMzQzhFcVBMZXcxc2FiQkNBbVhVdk1rSGZHTFA1b2NnTk8xZWlUVjNlS3o4NDB4N3VUOXN0WlVueHpCbk5mQVpWelpMWnpCZFdiQmNEQzYzaFRtRngzR3UyY1MvR2FuRVZiNVRTYUthZlFMbmNXTStwT3MzOHVZTTVXTlgvUXVzL21VaU9LV1VDZHJzTzk4SmpDNm5GUkFPeDBBQnB6U0ZYS09XanBiS1ozS21EbTRpdTlhWVJsVG5uYVE5RjlOaGV0blR6bVFzNVJHNmNDMFp1Y01wd2k4N1N2MnJtdkpuY21UWlV6YU9aTWZsTE8wQTBtOXhYRUF3RjBxcUhoMDkxMEtuQUtyMk5NMFdoVGdUbmRPaDJJeGo2OEMyWUJkU1lMTXhlTjlXWWdWelAxYys0emtBZVRGTTBFN0ZUak5DWnJyNWlDN093dm1QdmFJM1F3UUoySkRjdDlNTFA3RGVLaE1ybFRBVnRvTXIwcFRPWms5aXBlQmpBUHBxYktHY0NhRGNpNXhKYll0V3ZYSVFkMHRza2NKaE9qNllDZFBBaEh6Q1dwdjQ5Z2lqbjZvN21DZXFBZzcxZHMrVXFaM0xuOEVUWnZqc0NKYWJyZFppSS9CME5EOTVVczdRL1FjOG5KdnV3bWQ2cHhpbUlPNE1vNUFqY2JpSE5sc3ZzREtPYlE4SEkvZ1o1VGd2MlY4cUZ6QVhVMmZ5dW1TU1ZPWjFMM1ZTdkZQamJXYk5xS09XUnpadnQ4eU1BODFLay96QUtzbktNR3p1UXJ4U0Y0L3RsODYxdzFlQzZKaTRPK1dBZXBBY1FNaVlXNWdDcjNVeE1QTmFEN3E3bVk0KzhISFZ6cklHdm1UTm82RjZHUUI2aUo0aUFCdUwrYXV5Ky9IUkpOdFE2QmRNODB4NnM4Z1B6d3F3blFmUUZJSHVDOVgxRWZDc3hoSG9BWndKV3o1RjFuQTA0ZTVIZlkzMlBrUVJDaS9Wcitud0FEQUdDa0lLaHE5blBWQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMFEwRXpSall6TmpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8wUTBFelJqWXpOelF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakJDTlRBeVFVWkdOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQkNOVEF5UWpBd05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzU2RkdPZ0FBUUFaSlJFRlVlTnJzZlFtY0hWV1YvbmVyNnUzZHIvY3RuWDJGRUpKQUNBbUVSUVZFUUdYUndYM0RiZHh4UnNVWlI4Y04wSmx4L3p1TzRqZzZPb3FLdUtBd0E4b2l5TDZFaElTczNVbW45NzFmdi8xVjFmMS85MWE5N3BmbTlaS1FNUHIvcC9PcnZMM2VyWHZPK2M1M3pqM25QaUdseEltLy8zZitqQk5UY0VLZ0ovNU9DUFRFM3dtQm52ZzdJZEFUZnljRWVrS2dKLzVPQ1BURTN3bUJudmc3SWRBVGZ5Y0Urdi9pbnpYWE53WUNnV1A1dmVJSTNudk1rczJGUXVHRVFGOGdBWW9aQkNpT2xZQ2ZwMUwrUlNpaDlRSUxVanlQaVpOVFhwZi9QeWpobjR1RmlqbE1qRGhDVFo4NmdjZExzSC9KU25oY0JDcG11UzltZVo4c2MxK1dtYUJ5OS85L1ZjTGpKbEF4aXlERkxJS2RTWkJ5aHNsNXZrTDlTMVhDNHlyUTZTNTZwbU11azFQdUtEZFJSenRKZjZsS2VPUUNQVU9Vak5zcS85YUZ0dDFjQ2F4Z1FMdllCZW90Z1VZK1hXZWFtTThqWWdWUVNYSVpNd1VxcEVCUVNoMzdodVFNOEdYYktEZ09iTmVGemZkbnBLdVBFYjQwd09jNjhpNjZlWkkrUHQ2ZkFQWjFXRmIvWENkSmpUY09MUGZIMjhEeE52QUQ5Y1h4QnZ6eEdnWXFNRG5lSU04cXBodXo3YURBTWR2U0cyOWFqWmZqSFBYSGU5QWZiLy9SalBjRnM5QjV0djJLSlRHOG8zVUp6czhtVVpWSUE3WDFRRGdNY0dMVVJjSlZNeEh3ZE1Fd3ZhR3JXN2ZFMXFhcXNYcWdQc3NKZ3NPREUrSWRmRDVpZU04Tmp3UDVERkFWMFptUmtXVlorK0U5Q2R6S1UvK1lrNVVwTjBsVHh6dnVqemVreHN2eE9jWHhXaXE4NFV6elpHS3U0N1VueCt6eTF1R0paTWw0aDQ1aXZFY05rek1WaVpWYTZOTytoYmJhOWxtMHlCdk9Qd012cW9weTBCVkFLc3RKQ1BKKzJMc1k0ZWVmSE9rTHhaOEk5YnhWbkNEaENVcGRvVkRmbzk3RHNhamhxSWNtVFVlZFJrMFFMWnYzYVNwOHdsQ3ZHWjRBUm9mNW1PZVA4WEdBNTNwNER6b2U2OGYxQTViMW5lSzRweHR2TUVUbEMzbGpVRUpUUTFKalY5OVhISzk2WGlsbjhjLzFyMDJXR2E5QkNCTCtlRDI3bTMyOEQzRzhqM3ZqdldrNm9SNXBISHBFQXEyMTdXdlhONFcvY3Mxcm9wQ2NEVHZTaW5qY1FFMXRBSVdjaTJ4R1lZK0xmTUdGb3c0RU9Ba0MrYnlEYkpZNFN1ekpaSW1sQmQ0dmVCZGV5S3ZIQlU2VTRCeW9HYlgxWkVqT1hpR2JRNDdueldWc3BOTlozcGM4RnkyaDRFMlFtbXVsTU1YN0FkTlRvbXdCQlo2TzcwYUFseEFLV1A1MVVCcnFrclE4cEpmNTFFb2xsS0taRUphQlFOaEVJR1RTY2kzRUtnSzBWajRYNEVraUFTcERBSkpTdC9PVDQ1VWNyeFlzQitFNmVaNUtTZHBCUHB1RzVGeG9KUkNlMVN2MDRtVmdsR0JjejhmcjZKeDIwSEg4NkhIOGR4WHd4ajJXTmZTQ0NGUlp5Z0ZxK1l0T3F2KzdENzFqTTM3MnUxM0lJSVpsSytMSXBuSjZ3QVZlWklyMzg1a0NKNzJnaFdZRjFMbGRYaVF2bk9KMTFHUVFtMngxb1p4NU5Ta09yMWc2eFFueTlIUndsSk9UZHRCWUpXRVRrQVk0QVhVS3poVmtHY1VMOWFBOEZQSW1xK2ppeFRTZWVlcGxxc2RhT1d3ZjNoM3YrYnc2cnhJQTcrZnlIcnluazRUc2VtV3RBbU9PQ1lkb1ZGOXJhc3Z6TUZncG9LTUZxeXhTV2JqUXd2YStSdzFKV2JvYW8vQ1Jxa3VKanNLOTRhK0FuVjNBMzkrR1EvVHRMOWxuV2Z1T3EwQk5UNWczYmx4VTkvRWYzL3hlZlB2clA4YnVnL3ZSR0FNeXFjbkoxSDdIOEtGS2VQNW9ndW9KSDlLa09JeitxY25UQmlLOTJ3NWUyRkMzeFBxVDZHK2kzaVNQVUpoQkNyS3kwanVmOG5kRlAxdTBUblVKUlQ5bldaTys3am1DTEVLL21CUytHck5oVEo1SHdheDZUR1BWOEdrcndlY29YUHBjbDdjMXZHNGFNTFlmQk1ZNXJ0VkxoWFkxR25aOWlMVXNxWVZ0bER3bml2UGl3N29TY0QrdmJiZ1R1UDRxNExaSGdNLytEMFpwcWFmdXRxek80eUxRVFJ4bEwvRG14bGpvQjNmKzhYcDg5NnMveGYvYzhoak9QYy96UTY3dmQ5UWtTbUZ4VWsxTkNBdTBhVHV2L0l2SjU0UytFcE16cFh4UG9VQ3JVNVpLQzlXV1FVbmtjdzcyZEtXd1laR044ODhrSkkwUnBxVUZpL0RYMUd5UnFBaHR3UVpuUjkwcVM3SDRuQlVJNlluVVBzLzFoS1VodEdnVzByc3JpNzdZZDIrT3dteGxRZkEwemJIeitzM0tseGR5V2UwQ1pQR3owcHQ4cFh4OWc3eWxZRG5wV0Y0TEhCb0FmdkJIZ1hCVkVQR294Yzk3SnFsNGdtVjY5RmhSZFdXdHJwVDZtb3NES3RqZWVIYVI3NTYvQVBqaFJ5SzQ4ZVk4L3ZVaDU5bFc0SlNubFZZY2E0R3VGbUp6cERyNjBFOS8reVVzMzNJV2ZuVDlseUUwTVNDSTJtbkt5ZEJhRjdCY1JLSmhXaWtuMzNESUVEMC9ZeGllRHlsd0ZoelNQSWNYVk5DUXkwUDVITjRlT0RpRy8vaDFHOTc1OHVVNDczUUhEKzV4MEx4eU5SYTJVcWdGRTltY1FkOU1INXJNMDRmYTJ1Zm02Q1NGOWxhRVB3VjNoSEQxbkt2OGJsN2R6MU1vaEhqNmI0dW1vaDQ3aGF3ZXQvcm5PZ1U5c2E1VVk3RDVXcDduOHVhaGtNM3F4N1l6YWQxRmFJOUVQT0VlcEphUGtlQmN1WTUrY0Rud3o3Znh0YVpxdk9MY1JwaUVHME1oaFNFOEg4M3JsQ29PNHhqVm1KU0NxK2NVcDFDdVI2R1drc0VydDBTd29GN2d1bS8wNDQ1bnN6L3BzcXpYSC9Qa1BJM3dpbE1iZ21nTTNvcitlMzZBUzg0Tm9ZYnFLVnhlY0haY2E3UzBjeWhreGpuWkZCSnBTRHFWUVNiTkNSUUtxaVE0bHpBVktlSjlsMk1UdGhxbHgzM2FPNENiYnBmNDlIdlB4U2tuMWVNZmJud0k5UTBSTkhmdnhuMkpEQ2ZTb2NJNGVnTHlPZnJtbkswL21DT3hDb1dWQmJnYU1vdWhVZEVFTmVueHlZajB3dzhGazhKbnNLVlFyTDFBeUxOYy9WckkvOXdrV1ozNFU3Q2NvVTl2cmliMDB1SGR1b054YlF1djRWM0FlMjRheFgvZFBvWVBYMEVDWlhsK09FeENGUTU0ekN6SzJ5Q3QxalFERkRvVmpZTUtFR2xzMThSWWtvUXl5VGtreWtVQ0NqbHc4WEVKV3pZS0VTSEtmUCs4RmJqNkh6NUttQ1hjN05ycit5NGVPZm9VSlRET05aSkpqMXlRM0NLVDl5WkN3WEd1SVBSRXFmdU9mMHRGMWVkNnJFUGl4dmRmaURkZGN5NnVmZWMvb2E0bGhhamhzVmpGQ0xVdjg2M0RDcFQ0UEI5bUhSKzJpcERyeXNNRlVDUStFcE9rcDhoeURXUFNseGFKbGc0eExEODhtWklQRXFVKzJZZHpGWHMvOWhqdzhaY0I4d25CNy80MjBNTXhyVnNpdEpXR09PWUlDUlRsaUZoSWdoNEVNVjVYMkJlNCtyNUt2cjZHa0t1VTRNWmJnTnZiOEhRemNOVld5Mm83NXBCTGdVTE5BejMwcmRlY2p5cy8reW5nWTU4RWZ2dWdpZm1WaWdYUy85bUVQVWY1dER4a2tSS0xJZ2NSRXhQdStscnYrZ1JoZ0JiNzNpczM0UisvK2phODRhS1BJSmRJNHBSVHFCZ1piOUxVZFVpVUJQM1NtMWFISm1jcnBpS1ZUN1UwaEZxTVY5UmFwMGw0VmJDdTMrOUlEV1cyUFNsUTlacnkzeTZQQWpVdm4vZDhtMklENnZ5RzRmay8wNUQ2ZWZWK244Uk9RSENSZ09YOWVlNUpBRTBVeWc4L0d0UksrcTV2NWpIcUt0U1ltQVF2bnVaNEhUdUlhSWpzbitkWGNldWhNZUJETDdieHpnczVyOS9uSk8vRnZiVkN2SFMvYWRyRnVQU1lRcTZlVUI1TjFKai92QStQblhFYnp2anJhNEFISDFWV1pxR2lraGZ1R2hyVHdrSFBBcVVzc2xxaFNWT1JPT21nM1g4OG1wQjR4ZmxiOE9sZmZCY2o3YnV4N3R5TFVFdW90VzFsZWw0c1p3V0NuRmdYVVdKVm1QRktoS29lVXZGZ1VGbThTOWh5ZVovalV4OWhiQ1BjTE4vdjBVZ3ZublYxUEtqT0pmMzc2bGFGVXdyQ2xUL1RQbzMzSGRzTHFYUmNhU3NZdDdUUFU2R1k4dHM1ZmtiNzc0TFU3OHNTOHRNcTJDMTRrRCtTZHJFbkVjRUZwd1Z4M1J2Rzhla2ZEV21vVmNrTE5UNTEyTGFsaDJRUkRneU9zMjhFT0h0QkFhOC9GL2pjVDRGYktNd3h5N3BnNUhsbWplWWNoL0tMYWtNQ0IzNzVQVlRlZHovdzVlOEZzS1RGOE5ncVk3TlFLS3V6T1U0UkFqVm45NFNyaEtrMFdzTXRZWG84WmVDL2ZuQUpUbi9KQ3ZUc0cwSmp2YWtKamFCL2RMTERtcElxUnV0a3gwaW1rdnI3TllTVFhNbDh5bE0yVndYekhtTjBpZEdhcWJxVHZsUDRXUnl0UVVXWThFTWt5R0lZNFdVWVJBbWpWUmNnREZNblJDWmVnLzk1K2poRnhCUnJGWDZLaUtxbng5NC9iS015UXJ5Z2hOL3oxVEcwSlZ4ZWwvQmdYSWRvUVcyWktoeEs1WVNtdWQ5K2w0TS9iQVUrZnc5MlN0TThMU0Uwd3pnc3NYOWNNMFgxdG4zcFMwL0M3Mjc0REhEdHh3VTZlNE9vWmZDZkl4dU5SQlNMbEw0bGV0YXByOFRQM2loL1c5QnhJOWtyL2UycWVTNCsrbTRnV3NGWWpES01WM29wTWkxNDVZdDkzNmV1SjVYeXd3NCtrY2w1UWxNVFZZeEZpMzZ4cU52cWRmVWFaRW1pd1MzeG9WUFdSTlRkb0ovbWs3NVNSRU5lTEtxKzB5TTBucVVGaS83V3ovdXFhMHJUVGRSVmVoemlobHZwVjN0SW1xb0VnbUh2bWlTVm81QW53cERrS1lGM0Q3ajQ1SlVGeFBqNWQ5Mk1zWmdRcDNTWVpoK21oTy9IWGFEcS9UVzIvUjlmZlEvZVV0OUkzUCtNaFlVTHZOQWlFczdSTDdnNkVGZmE3ZmpKQWhIMC9LYTZjSVo0T3BSZ2lJbUJJWWt0aXlRKzkwbFBhTi8vb1hyT0kwRjVhbkNXL2ptWHQzUzZUNFU1eFhpeUtDajQ2YnNKQWxQQ1hpUW1MYlhzaW5PWm1nU3poQ1FWRXhTR21CUTJaRURuZnVOaFc0YzRLcDJZU0F1c1crRGlUZWZUOTFQcFB2MHo0SDZHTlBPcVZiclFTeTVvb2VjSTRWVDZpb2lEcmdHQlM5Zm1jZmtad1B1K1MrU3p4WXU2VGZOaFRIcWt3NVlJajN0TkViWHBmVi82ZDNubDk3K0MrSVhuT1hqZ1VZRzZCbzk2S2dJamZNdFJJWW9mcjhPTUZCRkxLQmVwTTB5VmNZRS9IZ0MrOVcwSlJiWlVodVozMjB3c0lSVVVLcGJUMWg3Z3hObUloSnlKS3l6V2VZbXB6TE5VUHVZa2k1VStBNTRRN0F6VlA3SUVqdDFpTXA0UDBsVFlEQzFNcEd4MFVyQUd4NWV6RGZSbEhMeDh2YXN0OXpNL0J4NmdNSnRyNlNNVml5V3BVQzVFQmU3U1g1UVlTUWtzcUxGeCtTYTZMRnB5dHkwK01XS2FUNVJaSDM3aGxzODZUVE9UeXR1ZitxK2I4ZFdycjVCNDlHa0c4Z1ZEaHhhbVo4UUlCcjBrdEpvTUJaZjVjYUM2eVVLZUV6RE8reHZPYVVSOGZsUTcxVi8vb2dOcmJuSHhrUThDTzNlNWhIR0x2a2RCclBCV2JvUjNibG15bkMxS0pDcDhheXdWcWw0bENmaldhcGNzZjJGU3VJZWRxMVRPVXdTdXJEU1RWd3VrRG9XaWlCUDlJazN2UUsrTDk1MWo0OHJOdERTR0szZDMwWHBEQnZMU0M3TXE2K3FSSE95ZVVLNHNrVWt0Tkx6bFpSSi9lQXE0cHh0L0dyZk1meXV6Z1A2ODFrbVBxdEI2eExMK3o0L3ZSMStDd3JucUVrbklyZkRXUVRtSktUN1gxUUdzUDJjeHJybmgxYmprNnFVNCtaUUt2UEt0bTNIZXBVdHd4bmwxV0xtNUJSVzF5cUpEMkhEZWNuejVKdEovZXBCM3YxV0ZRYmFHWlMvSHFqUERrM25TNG5LVTZjV2x5bHJWc2wzUVg0TTk3TEM4V3kxY3czdGN6TlBxd3orSEd2UEVlNDNERC9XY3R4UW9kQ3BQRFVSOVp5OFo0dm9GTnQ1ektXTkh3dXp2TzAwc2JEV3c5dHdJMGNwYlRRbkY1dW5rdnVHSGNmM0RFbGRzZFBTMWZQZEJZWlB0dm5lYTZvMFh6RUlQKzFJcStoZHUraUcrY3QwSFhlenRyOE5JYndxWlpCSkxUbXBGc0tZU0w3MnFFVzcxT0VJWFhvaGxHN2NqbXlxZ2VlVXBDRGZ1UXA0c3lFNUY2UnRKRE9KQjFLMXJ3QTFmSE1DM3ZnYThhTE9EUHo1c1lBRW5xR0I3anJOMFRYSkNFMzBoaVJLVmRPMUo0bE5NNGl1V2FwZXNldWkxVHhVYldwNHdoUSt0ZXRYT2ZlNTNGR3hESzVWaDJQcTg0MW1CaUZIQUo2K1d1STJlN3lZQzVrV3ZhRUE4UG9odzgxS3NYTjJLQWM1RlJUU0lSSmVnZ2lzbFpVeS92SUF6VndKZklkU1MxOTA0WWhoRFpheFRQTjhxaHFPeTBOWHJwQkFMelcvOW9RMER2N2lOa3pIY2p1cU5yMEx0Z2dYNDhEY3V4alYvZXhaaU5XZlRWSE9Rd3dtU29TcGtSdEp3UjFJUTR5YnkyUmhzcTVITWI1U3hvSXZXNWZQd3hGQVF0L3lTck8rdFpKVmhSMmQ0bE44cExqMU5QWFExZ2VGWm1VVXJEVVVtTFUwZFJjdFZ6RE9aOEN4YndiMFNpb29QMVVLM2V0MEtZV0psWk9wM3FITkw2UTFDNWNwVkxuaGt6TWExTDNjWmVqQisvQTJKNDZZYVdORXdIR01oSEJJZWhDcXhhQ213Y00wOHZQS2FONkt5Zmo2R2VNMjFVUmYzUFVNR1BJS084YkQ1UTMvdWpSbnFySEEwbG52RUF0MThuaFR4S2hpQlFlZkN0VlVJbnJJdWhpMlhuNHpORzFyd2xvOWZRMjFmQ21kOE1XZHlQb3pLWlRCVEQ4QndsOEFPTmlDYjZTYWNWdlBJNjVqU3RlTndBMDF3Q3FNNCtmVDUrUHIzdkNxQ3F5OTMwVHZvYUtFSTAxdHAwY0t5RG9kRTE1NjB4a0RZRTJweHpURkJXRHgwaU5aQUgvNytUNjNIUDk5eEZWNXpkUlVPdFFOalk5QkVSWi9mVzQ4K0hHb3RINDdOeVRCSDhZS3VRWWxMMWpzNDV4VGd1djlrYUxJc2p1b0drK2EwaFBIMllyTDVESnpCZStHUTFkcGpHVVpzaitPQ0YzZmk2cXNLMkRQbTViR3ZQUWMxRFk3ejBWZ0Z6R2tLMFY3NG1xS09CNXczTEt6QTkvNysvVURqNGhCYVhuNHBRdzJWa25zVHhudHVSbjdrajhnRjFpR1hiRVBPYkNMajdZV1pHYU5nV3VCYVVVN0FpRTRndUtFbE9pSGd1Qld3SWltWTh5MTg3WnMycnZzd1NjWUREaWZlUkRRR25kNVQ2VGo0dms4SllJeUFsU2Z4aXRjQ0ZYVmVlWWVDVE1VNFZmTGluSmZXSU5yY2lEV254ckRwbFNhRnN3eHYvL3hHU3VhYk9EU1VSdHUyWVNUVEZLcmh4YnhLdUVxSUNvckRzVXJrMDJtZFpkREt3dk1PSmd5MHhBdDQzMlhBMTRnazdUS0lUY3Nad2xqTGVBMERoTlVrQklOWEl6TkVpODNEVER5QlFDYVAydVdic1BDY05HTFI3ZWg2RnJoc0F5cm4xK0tkWDd2RE9hM0xGZTlMR3NhK01oV0hMeHprSHJqWGVjdjhHTDczYjljVHdoaFE5K1pQcFJsVUVWb0pvVU8vSWFzMDRZU1ZFTGZDU2RFaXhVSVVPRXY1YkRzRnJwYXhhSm1DRW9pdFpSaFRUU3RMOHVqait6TlllUEk4L09wSmdUMjh4TGU5VG1KMDNOWHJuc0d3OUt6RzhxeFFKUitXcmE3RmkxNTFpbWFSblh6L2kxNjVFaTk1OVRJZDVGLyt4alc0OXFiTDhaWlBuWXdObDYyQzNVWm11cHQ0YTYzRzZ6KzdEQi85Mm1wOCtPOFg2R3FJSHJKVGxiYk1VRG1NZ0hmKzFxWExxVGlPWjZVcWppU3pIUiszOGZHclhEekY3L3IrVm1EZGFWVW8wRzNrblZFcWN3L2p6QUdHYVJtNmtsYmU5dXQwcEF3dW9MWFd3TzZweC9xek4rR0s5NjdGN1R1QUZpcnBsOStFTTlaWHUzZkZIZWVpWTJtaFJ5VFFSdHUraHRIR3YzL25SaStOZDl2ZGRXZzllUVh4N1Q2SVFBUWk4UXVZYmhCV2ZCMnNaRHNaNGNrSXhGYkJ5aDJnbjJNc0lzY2c4MjF3czN0NHdTTmUraWV3aUVjcmZaVkZLN1F4ZjBrTVgyVVlzSGtEc09XTUVBYUhwUFo1eWs4cVg3aDNGMk85UlZYNGg1OWNnNy85OW12d3lYKzVFQis2YmhYZS82VXJjTTNuenNmbnZuMG1Ydk9PNVVTRVVjajlRNUNIT05EYXY0SlIxUWw3NEJ0dzluZEJEQzdBK3F1L2lROTlZajNlL3U0QWJ2aXZkWGo3QitNNm05WFpLUmhpcmRNWktGMWk0aG9NcFJ5OGZvdURwUzNBRFl3M1Y1emNBbE9sa2xUZTJjNFNwdm5ZV2tRL1hFRWxuZSt0R1Z2emFHWXViRnFxa2V1RkNKOUs5OXFNbGxYQW5Yc0oxM1FSWDN3RDRoY3NrRGRYMi9hN1g5Q3FQM1ZkUGNEYk9ZL2YvZGN2a0xSUWF6L3pML1JOWDd3Q0o1OFpRbUdnQXJtTXlXRGJSaWJuSUoyU25Qd2trbmtUaVd3S2laNG5rTUFHTXI1MnBOT0NWalNDbkZoSDV0dkQyTFNibDAyTHRSb2dDNTFRWnZQUTNYMjQ4ZTBTcTFlRzhPWHZMMEtGdFFkcEd0amFjMWFpYXRGaWJEZ3JnbFBQSTl3ZENFRXN2eG9CNnc2WWV6dmdWTDhLbWNvSFlJNzFJVEprSWhsY1FUVFlUNFVLSTFwL0tsTEQ5MUFJcllnRVRCanhwYkNkbjVERmRuS3lYd0ZSOTJxMFAwb1hrWFo1dmdLKy9PSFA2OVdrMFdRQVM2b2NmUHFOTGo1TEt2UGJEZ3RudkhnbDVWd1BPM2RJTHdwWVZPWlFtSVRDYVVPMGNqR2laTGl4VUI2VlVRZWhvRVIxekVYSUhFRk56VUpVdGlhdzdZRStQSDdMS041N2lWY1orTTA3Z0ovdndOY1pEbjUwU3NaSXBmN2tNYlZROVlaKzRIV05RWHozaTU4Z2Uxc0EvSEZiTTk3ODRmTTRxWTNBTVBIRG9VRG9VMlN3Q203cUVUZ3lBanRTU1YrMmxlVGdBTnpvcVRDZFBsaEdFeTJSOU45b3BoOU1Vb0JrQ2diaFdzRnVucGJqNW1DRjY3QnNjUmhmL3c3dzFOWWNGaTFxeFpOZERhaWV2d2pYZmZmVitPdFBMY1NHTGVmQjZGdW9VaGh3K2c0ZzJ4VkUzb2lUZ08xQmVLZ1doZTRoMkpWWDBxZFZNVERlUzZKQWVJUUg3NUdxTFJDaEdISkRUNUl3clNMVS94VmtUd0ZHc2hZclYvd0I2emFGc2ZyRmwrUHYvdldmRWFqWWdLR3hDS29qTG01L0ZCb3VWNjF0NW1mR0NhVmRKSHM1V21JTnIwVXRJZ3pCc1ZyZ09MeTFSL21lQWIwd0VZdzJFWklIRUdJQTYwcENRR1laTm0rcGhKd244TlA3dlBYU0R6R2VmZXQ2ZkxESnR2L2p1RUt1ZXBGYzR5VVZCbjU4L2Q4eG1ENk5BUlF0OU9CSUs4NS9HNkUyWHc5Wkg0TWIyd28zUGdJN1FMOFpDY0NKRWU0c2tvU3ErWVNtY2NhbEMyRkUrYnBvbzNuWGNLSWJ5VEpIWVlTb0JLVDVSbUJZclpCQ21vUXdQcGNZeitGOFJqMkxWdFZpOGNvY2J2akc1L0JLWGpFRUxmaVpneVFlS3hGc2ZoZURkeHZCL3B2NVhSY2pYYkVhNmJIYk9lWlZDSWNaMUx0OWhEb3FqYnNZb3VFaTJJVDVpRWtteWl0S0paN2xKR2ZJd3EvaGhLL2wreE1JOU40QW81c1UyT2IzRE54RnE3d0o3M3JURTdqMmZTbnNHaE1ZR2dXK3daREs3aG9seWd4U01la25qYnltdndiU1ZGSTY1RmdEa1NiTDcreUdyRnpJZVNHRGQ3cjVYQjYyV2VEemg0aGtmQnlkaC9kOFpEbTI4U1AvZVpmbnZqNXdDZkRHdFhoOWcyMy80TGhCN3VsQ0xLRU43ZjdFR3hDNCtPVWtRTDNBSCs3MjBucW5iMUhMUUJYSTVsd1VYRlVnVlNEa0JwQXBXTlRRQklsTGxQQWJKcnhta0NWUnlqbHBFZytiYkxDQkV4RkNLajFHQ3lZekpwZDM4eW12dHBZc3BMOHpqOWRzZHZFNlhtRE5xZWVpK2NWWHdDaVF5c29XV3JDaGwyMWtkb0ErbTVhZWVSekk5a0xHenVSMzlzRk85OE9PTFVjd2Z5L2NNY1lyRlJ2NStGUUVPZmtDdEN5U25IelBGOGhhNXlOWVQ3OHFWR0tac1UzMVlzaURINE9NMGxyckw0TFQ5VVZlVHhSaVhqVlFXY0R0MzNnWXQvOEUrT2psM2dMRHAraEhuMDBiakRGRE9yUGhack1JaFN4Q0x6OURhMVZyb1pXVlVZVEk0b3hDQXRFQWVZRHdWbTBpcWsrRXdCRW5zRDJ6WFNKQ2duZmhPbThCb0piUC9kUHZnTHZhOEtWREh2d2VNZVRPS05BV0laNTQ5NVVyVHIvdWhwUFJ0YmVmL2lXRjZqajk1TmdvdWpzTDFQUlJVbjlicjRlcXhlSk1WdWlTRk1WQ0ZXdFVLL2daMjh0alppbXdiRVl0akVmNFhFWm5Ud281b1d1UDlISmxYcVgvSEZ4OUZtTzhEd0tQUGxXSnRSZWRoZWJUbGtNa1Y4RnNlaGZoK3c5d2VyNFBXWEVTUDdDZnNjUXpFUFd2MXRCcTlQeUNRbDdMUWI4U1RubzczS0VIU0xicTRUYStsUDVMK1hrR3VjNHdEWWdvRUQ0SmJzVUN1TU0vMEF2YU1yS2FybUlIVVdROUxZOGtKOTFESC90aURjM1M3a1cyL3k3MFVvRFAzTldOK2ZUbGkwbU92bkFyOEx0OUFyV05ocTVDTkYwSmkzTVpDaHFJcUVKdG82RExUV0tSS0dLTWpTcEpvbUpoRTVXazFGRktMMElrYW0yTklWWVJSTVlKa2tDR3NIUjVIZTYrdHhNZnZQNEJwOE95QWtjajBCbmpVTXBqMVlvelg0TElTWi9HZ3NidHVvTEFpTk1Ya1Fnc2NGVFZXcEtrSXEyckFQS3BNZVJKUTFVMVc0YnhWNUl4emZqSUlFYkhFa2ltOG9TcGdoYm9lREtEQkdPOGZOYlY4VjgybjBNMm5jZlREeC9DcXpZNXVQNVR3QS9vU2RxU3piajQ0MHNoUmpuSjFadGdqNUtSWktnVjlWZnk5aGNNazNiVE1yZEFCZ2pmOWs2cTVsNXFaNlZtMmdGcElMRHdXbzR6QTR0c1dwTEE4RU5rNCszSXRid2JjdlNua0NQdHRNSW14aW5ORUZSRzJmQWV1T04vcEhDcTZSZlZjdEF5WU9RWHhOZ29FZkpOV0xad1BucmJQNFFmZmhONHo0dHBwYThCNXQwaDhaL2JnbGl4Y1FGaWxVR0dQd0ZFSXhIRVlqd28xRmdzaUlyS01Db2lGaW9yS0ZoS09LWUVHL0VxTUlLOEg2S3d6V3lCY1hRUzVvb0dETjAxcGtZNmROU0poU1ZMbGt6N0lnRmwxNkc5N1JzZ240YklqOUFpeC9Hbm4vd0tDVnBXd0srVzBxVW1xdXhEMStVS3ZYYVo1NUZoMUo5MzhucXROTWNqbmFZbWN1QnBWUW1ZVSswUnBsOXlLYkZyNnlGY2RVWWVuN29PZVB3eFd1ZnVPbHo5b1EwTUNUaUNKSmtwNDFBeGZDdEUvSjJNTzFYQmtjSGI1WngwdmlmS3g1MTBSTlZ2cFdEM3dja2NwTlVQdyszY0NuUEJaMkJXWFFvM3VkVXIvd3N2UUREek1BbGFBS0tHNFo4UjFIVkh6dUJQdld1UkJjSitveklyRkVidVJtN2dDVlEwWDBrbzcwUmdmd2ZPUEwwQjQyOGV3QzIvQWw2N0Viam1wUXpscWpMNDhwMXRxRDI1RlZYRXpLRGxFRDZ6SkRzV0JXenl2a0E0WkJBbGhLNVlDRm1HcmxZTXFEcGplT3ZIUytkWFlQMWFoam5kQ1J6WXhYaGRVeGZ2YnliNUhMR0Zrb0FkN0c3djNvREJIZzdBd0w1OUIvSHR6LzRiWW5HL3I4U3Z0Q3ZXRW5tTDJvUlJWWW11MWtYOTk5REYwSktGZnF5KzBmRXJFVlI1YkhyY3hkVWtRSi80R0gwMGcvd3ZmSkhoME5mUHcwVnY0SmUwOHhOUjB1ckJoNEdxQy9pQjMvT0RkRUF1TGF0cEhvVjlONVVwVG9hWkplenoxZzdENEJjR1lrdDQ3djhtNXUrSGE1RzQ1WGNqT085NnVDUkR1ZXdmcVh6ZE1IUFBJcER2aEZGOUJYM3pDS3pFNDVEeGMrR2tkc0VTYWI3SEpKeGZSaVVaUVhhSVNsQ3pnZkkvRFplOW9RMWQzWDI0NlhmaitNQlZ3TXNZTDlkVzJQU3JCM0VvU2tVUGVoVi9mckdHVjNZaUptdUxEUDk1WGJ4aWVLdE01MjVxeFBrYld6RFcxNDhEakozRFh1dmhNVXY5aVJLQjd1OW82MFdxdXhmUjZnbzR4TXhGU3kzTW4yZnJYR2l4R3M3MVcrcFVlYVk2MU9wRzNpL1h6T1k4ZjVyMzJ3clUrcnQ2WHFYdERuVzR1SXlFNEc4K1FNRW1nSWQyTk9FalgxcUo4eTZ1NUl2cVpHRWQxdWhSV2p4UjczMzBuMitFVzgxd0kvVmpUbjQvbk9RaW9PR3RFT2tIT0JITnRNZ1daQWJ1cEFEZVJoYTdEb1d1Yi9BY0ZTZ00zUU16dnBreDRrbTB1RDNJTWR4d1JuOUptRzZDV1VjeWxMb1hSbW9jOWpqRHEwZ0lWbXdaQlJORTh0Q3RxR28rRzRWTUQrR2RxSkJjZ01zdjY4WjE5d3JjOXBERUZTU0hweEdkLyttMXdLZC9LWkhtV0t1cWhkY2ZZM2dOVk9wV2taNkFmeWhCbW40OXNXcnhXRVFMZFJtYkQzYU5vZVBncUJKb1d6d2VQNnIyZldPbUJERUJiMjkvOXdnNjJ4bDgyeWtFa0VNcUpkSEY2R0ZreUR2R1NZT1Q0MTRCc3JKRVhUYnArS3NoMGx2RjBPdVdmc0xiOHZ0RytycGRuTXVKdU81dnZmenN0eGgzUHY1c004NTcyeW1FVHdweEFjT0hGU09raEE5Q3RtYmhWRDRLdXltTWZHMG5Dc0dIWU5lZURybG9NZVhkUnVzN0dWRyt4NHcvam5TSW4xbCtPWUlOTGNpTEhUQ3JDN0JidHlCY2NSdGR3VTNJSnIrS3dKSkxFR3RxSWp3U3Vpczc0YmFzZ2QxUWg0SzVHNktKY0x2NlhTUlRDeUFxeHNsa09iMkJNUVRDUFFpcE9XWlkwblRPcGJqK3ExVzQ0d0J3eS8yY0E1S05OVXU4eGlOeldDSXpMZzlidnkzZUwrMnBLUzdQS1duVlYxcGs0a2wwSE9oSGY3S2dYZDAwWGZCenNsQXhuWldHaE5nOVFITTZ0TGNUcTliVXdDQUp5c3Q2dFBXVHBwTWdxVjRPUjVjVlNIK04xTlYxcjdxanpQRHJjZUVYV2d1dnRraVYvZzhQT0ZoTTRYNzBBMTVDdmEvWFc4b1NJMC9qcmh2M0l4OXVnSjFSL3NYVVpTdVcrWlN1NmNuVFlnTEdyNm5sT1o1dlBseWIycFJYcy9WWmpxV0g0VkNDRTlUUGlUb0ZDMDQrRTRmMjNVZExwcVpWRUhwSFZJdkREcTJsd2NwZkl6L2FodXhZSHBVMTlMbVJtNUFjL0JNa0NXVXMxc080K1lkazhyVGkwWDZ2ZVRtN1ExdWNLUHhHRjB0WDFrYmg1dEpZeVdocWtONHVtd1E2ZUx1WWV2alJGd0dmdjFOQmx0QXBTOE52K1BKZzErdDNLUlpaSzhFbWVBbFZZWVpnK1RIczN6K3MyOVRweFo4SkJBSWlFb200MDZDbm5BdmtQbWN0VGxqV3puU2hrTm0vdXl0eVlhSVZOcjk5M1lhRldMeStCYm1rUS84bGRiMXFQcGZYZGF5cU1EbVp6R3FHbXl0NGZhSTV4bzA1eGpFRlIycXlOSGhvSEJVaWg3Ly9aQnpOaXgxMGRXUjBiOFJyWDh0emphc2xyeVF5aVNSU1NRK2E5YUswNVZmNE9mNXFpNEx6OUpCWFVPMDNEVnN4cjJUVUh1OWxLR0JoY085ZUpIbzZ3REFRd1NxL2xZR1RaOGJVKy8razg2MXFwYmsveTBDLzBLMFQ4OEVva2NaMFlPUWYwT3VrOEtzWVZGVzdzbVkxV2FGUVNDdEh1S0lLNzNpWjZoa05JazN5RmpTRHlJWER1R3h6SlI1TnRPRlhUL2FpcGRuVS9hU2Vja3RkL2FmS1AyMGZHbFhoWElnYVV4a2cweDhhUk51QmhOYzdaVmxQejdMM3hMU0N0V2JhT0dLMHRYVlVIaml3ZTkvZTN2V0ZrV0hHVHhLcHdXN3NlbkFmb21HdjBWR3h4RUkrcit0emxmV3BiakpMT1ZISEl3ZTZ5NHNZYlBpbjdodks0OHpsaTNEQlI3NUJ2NVpGeFJxR0ZTckJyYXc5TjRyRnVxNnlRQ0l6NWhXRHF2TlQwcktRMVBXeUtybWdlV0loUXl0SmVLZ2diRjBrYmRLaUE2cWtNRlNMVEs0TGx0dUNnRXRIUVFWU3hka2hUcnllVUZXTGFha2lMbzZWcnh1Nmk1dXZVYUsycWcybXBnaStyb3E5VlJHMkdZaFNXUUllYVFpcTVBRUZRL01UWmtBcmRkd3ZOVFFzQzVHYUNCSGgreHhyTitxcjVZVFB0SHhmNnZsUHFRbFNob1FpeHV1cEM2YlJkY2pHUGlvM3YyVm5YMTFkdjJFWTViYkVLVmZpSnFlRDNMSzMvSUtuNmFqWGozU1BJU29ab05NQ3UzdEhPRmlmNWJxWWJCZVk2R0VSRXowc1NyWUZ2MDVXM1lZREFxbDBEb1ZoTXNKd25KK1A2SzQxUTNYenlvQlg0YTQwUVNuTFJIZFJ3WE1pdXNTb3VObUJvK05nbTc1ZGRVL3JuaU9MVTh2dnpoWEdFT0h6UVRPS2dBZ2pSMmkyblF5Q2h2ZFk5WmJubkhHdldZUHZWOCtaUnJIQjFjdUxhNFd4QzM0dHBlMFZncXRDOG9KWGRTWVpoNnUxWEJPZXdpcFVVcVdkSXdtSjlyMzB0MzUvcVdMK2VyOEdIMG1rSHdHbzhzNFJJa1pydFlQR3lCaWViblBST1VoZElEY3NVREdrbE9WMlRCR3pXYXVGOHR2UVRMeXhRb2l0SFYycHQrenJmRkt2ZnNRWmR3MHc3bzdFL0laZGQxS3dSU0lrVkhlMnFyOHQxa01XOXgxd3ZLYWQwWUZSOU96ZGpZWExXM1IycFgzYmZuenZTeitCbWdYTDliaWFxbFF3aE9wZFllQk5TekZvbmFxYTNxRGxxSllHTTZTcUdGemRJNkt0T3grZ3BRczljMllrNTMxZGpoUERtTlVJMnZ4Y1FVT2VrL0ZpVDVnRndxenRyMnNRQ3dvTXEzTFFscXo4bm0ycmxnbGJGNnFwdGtQbFZoUUpzSFZDeGZiTzc2aDQyOFg4NWpqZThxWk5WQ0NETG1NVWczM2ppSVFPYi9pZGFQejEvYWR5SGFyTVZaV21xSWFsZzMyNk93RnhJUjRVUXBUYldtNU9XK0tVZzl6RDdsdUc4ZFFReldzdkE2WjFteFFoQUlZWXA5ZFVlajVOR0ZNcTE5MWljNDVmcHlQOFhoZmhhV2VVZ2hnazFQWjFkR1Boc2xxWWZIOHZyMmI3dzd1d1lxVjN6bUl4ZGJGQmFNSlgrbkd0c0h4VThBMUtUUXhSMjdzZ1JYcGkzdWl6Q2E5TXhRejZ6OG5KNTF3UFBTZUt4clJpRmp5R0x1WGtwRXQzc25KUWVrV0lFNjBaYXZGYlZmaU5EYWtLakxYMHF5WU83dTlGWDlaR1U0VVhsdWk0MHhkbXNZWEQ5dU4zdy9GYUV4Vnk3ZTNXTGgxdUlQQ2dHbjBnRUpBb3YyZmdkS1dlK3JFMVRkWFp4SFA1cXFydHFlSGhrWTREcUZIc1RPVW5FYWhCeWlXVU1jQXMrQjFjamxQdytsRmNyMnRMRVFvMVNYbEZsalRrU2krcjVLajFqZ0s2MnJxdzhmemxqQ056MUNvYmpESlExelNWbFdGaWw1RmlJYlJXSVA4bzdxVGk1RXJpc05Ca01FYVUxYkNuRk1EMGEzdFZXNzFUbUx4aUkzZzRpT21XQzN1eVBiSDR2Y1dVdDF0U0E2eERFVjduc2dVMVJKWWtaTVprSERrRThqblUwdUlWZXkrdEJDc3F1S3E4VUMyWTFDY3NhaUN2b0ZMc29VQTV0ZHVIR3hxNkRjOUNEWlRmdUdwR29WclRDSFBpeU1iamVXTms1TW0yZG5tQjJ1OUFXZWJwWnkvRzVndlhJekU4eXZpemdGdzI1KzNSdy85VXc2L3FJblBjQXUrVC9SWlVzNitOVE5ack4weU1aTENQVjNwd1h4Y2ZqRExJTDJpQkZodVpWS3pxbGdoUmxQUWFHY1lrQ3NDM0Z1a1hpaFczbkpsb3hYY24rMkhnK052TitLMkFwVUp4ZlIrSGtvSnR2MWx0MmcwM2lvcFdiTlZ2cUFvemprd2pOV3FqclcxRWh5a1ZuS2R3MUJlZ1grT3J3aFlWajZ0amxMRnJDMitiYTREZG5JcE9oajFSSWU2elRWTXRtQmdsZlM0NEVxRmFNd2h6b3NRd0pzVGpIUWZsQlgwREhNUTg0SjZIZCtLUjJ6dDBXc3R4dlcxcUJHZGJyYmdVTkY0YXZGQmJDMU5acGUxNm14WXB3dzNBQ3dNTzdPdGxTREZLYTFHYjMrUVp6NFZ4c0NPcnErdE1YL3ZWWkZ2bXBOOHBUbVpwUlY3Ukwra0o4MHRWaWgzY2hjemt4QWNxL010MlNsVGZWeHdSbUhRWnhYYUk0dVlXRThoUUpscFhscVlxQ0N0RExpd25pUUc2a24xdENhalcwSnBhRDNKTkg2SkZNZlhuMzZvU2w1WTZvRDRPL1BZeEwzbGJZNXIzZWsxeFFzNFFhODVrb2RNSzFDaTlEWmptRTczakx0b1BBT2R1SnV3R2M5aTNJNGY2ZWwrcnhlRnMxNW5DZlBXK0FpVStzWkxZY3JCdEFDTjlnNGhFVE5qSkJOYWVzUUxMVDErTVZDS3ZlMGRVKzcyamxyWjByYlZYY0owbEdtUTBBbmd4c0c0WmRBdWE1S2dReDdEOFBrK1YyT0RqWUU3NFBzc21zZkw2UTlVMkFZN3VEZldUSWVwY3hkMVYvQjU5bFJ3cEZML2Y5ZWJRc2FYK3psTHJWdGVUelFwVVIxUmlZQnlkSFVuMERPUlFIZlpTZk1VU1VGRk1Lb2pKM2h0R1psaFU3NlZFOTNScFBSdE5WVmMvcUhYWk1CeC83dDA1Q1BXdzhNV2FUWmpxMXFtb2VEd3hNcEp0YTBmNDVTOGpOQkJLRXFxRnpzLytGRnZaUmNsWml1M3hPb3p4WTlTQUQzbTF0SllldGJLd3YxdnZyUkNoSU1JTXJ1T1JBVlFGUGF0Vy90aWxJR3kvVlZydjU2Qjh0VjNRUXZMOG1hU1E4MW9vWHBPeDFJTFFHMW5CYStOemFXWTUxWU1vdkc1c1J6WHQra2tRenhJbmR3T0Q0U21mUHIvYTFBTnlZa3FMVzlUSkVyK3F5RXgrM0VCTmlIRjR5c2FCamhRR0tJcFZEUmFXTDdIUVdHZWhnVWNrSEVTZ3FoNHV6VFdkemFDbmg4WndLSTNXVmlvQTQzTGxmU0pDUEZDSXhmTHd3cFdpTUdjVEttYURYS1BNclpHcHFrcUowZEhIOSsyVDU2aDhiYnhTSUJ3elVjZUJMMnpsd0ZmVUl4eXYwejVzc0MrbE41OUtaQVM2ZGcxaDM3Tmp5Q3JpQkM5VG91YlI0TzBBNzNRZUhNQzZsVkdFZ3hJajNkMjQ3NWQ3RUsvd21TeWVDM3ZGRFRGSy9ab3dudXZmTU9VOVJuR0pvNlR6Y3FwZm5QRGJ4YjJNNUdSVGxKU1QvVERGcVZQdnpaRDkxRkM1YTRKSitrK0p4dzlJZk83ZFlWeitvZ2hDcXAxUU5meUVlVUdxbEw2U3R6bjZnekJ4dGpHc1VsM0lkdS9IWUdjQ2RmZnZRc2ZXNUowRnp6cGx5ZHlYRTZxY0pyRXd3WEl4ZzFBblNGcllNQjdzNkRiUDJibGQ0S3JMb25qTnk4TUlod093NnViRGlOV2pRTklUYW1xRUVhL1JWcEE4c0F2UnR5OUZrSTdpcC8veU5IN3pvMmNKTDE1SHRHcXJWNTJHN2Z1R1lHOXVnRW1yQ2dkQ1pNNUpYUmM3MFFOYU1xRlRDY3Bjbnl0dEU1ellrRXBPLy9sU3NqVHR1WHovT1RwT2h0dkFPREtReGlPZHpmaTdxM3ZSc3JRZW5lMFpYZXdyVEtKT2t3bTM3UUFjeG1maHhubWNzeHFJSVJNaTFNTDdKaHFiZHVLSGoxMk0xVFgvYy9jVVpsc3FURkVtSHAwMjlTZG1FS28rd2dWNzBkZXZOZDk2enNZd0JrY2pjSWZwazZyVk42azkvbFNMMVVHRUdocjEzbjRxeFdjR1E2Zys3U3prT3Rzd3ZtTVBydjdZUm4zQ3grN1o2UysxU2V4bElMM25ZRGVHc21PNjBLYTZobkRWUVVOcW1QVEJNd2xwcnMvSk1tMkVjaFpoemZaNmNiWlV4VVZ0VEtLQ1pLeDZ4V29NRFBjaTIrYkFVdnMzRlRlbFZEUEM0Tml3MUdLRzZuMjF0Qk9WeW5mVG5VZ0d3L21jNDZhcnFrYjhmSUtZWXFGaWxrelJZVzJJMWt3eHFEb2FBdktrYjc2dTY5NFZLMnZRMDZscVp0SWNSQURwc1N5cUNic09veTRuWThIcDdrTmtVWVhlcThnd3FnbUZxaVF6cEJQdXF1Rm5yQ2VGb1dFTEMrWmJXTExJd3A1RE5nNTFaZEZMRXJTQXpMbUtyREN4elF0ZGRKdDlTVXRma2ZISzBqWjYrZHdtWGxsaWphWDluckprYzdIRHV2SGxjME9SVXVHVk80cStWTlZPaGZtWmVRdzcvcmdIV0x6aElTeStzQmw5KzFONkpUbElIeHlpcEtVSTBqMDFRMVJXRW5sQ2NMSU96SG9TdTl3QWN1NCtucFFNLzJmdEJiL1pYNVpoc2VXNjBxYjlrUUpyaHE0bnJTVWZ1T2FscjVEZE4yRXNiZW8xVVJIMHRwSlJhMEMyYXNyTnFEb2pCN0hXRnZxN2VsanhhcWd3U2kwOTJabE9SRTllaXVTREQyQk5YVDllOGVFR0RkTm1iU3Y2aHZweDg0LzJvNWNCOWZKRmpOdWlxb293Z29NOWxpWkNhbmNTRmZib2pSL2xKR09jMk03VW1DUXBwUnRGR2VZVWZCS2VwWGhieUJrVDB2UE81Wk1yUjA2UUkyOVZ4SWQ2OTNCaEZqTmk2a2hTQk5VOFhZc0tUMDYrRU5uZHYwZjhuRHBFMTFaaWREQkgxNkkzaGtOZWpzRVozZ2JCdVZHRFRvNVE0RzE4UHAzSGNKZEtZemJCMk52bkNMR3cxREtueXdUTjJ2ZGlUYk9RT2lIazZub2tDcWt3TlNxRmNHVVVqdG9GUzIzdVcwSEJCTUtJTGxoQm9oTkVxanROMkUwaU8wZ0lqZVloYWszazIzdlErNzI3WUtxOVdweTRUblhaTWdDSE1IM3lLZ2NKZUIxaWhUTkl0Q2pRMHpZdHhwYVhuNFh4NFRFZDArWnlCUy9FSUFhckhWWlVQbFdGRzNwaG1KRy9DbU0wMjlTN2pLbDZJQzhYYUpmc1MrRGxaQjB2ZkNsdVplTjZJWXplSWs0Rk9JN2FjczU3bjk0eXpuVVBKMW1ZWEtDMi9CNGJnNE9mSC9iS01iUFpQWWl0cmNiT0oxTm9hYklRczRUZTcxZTFTdXF0dWNrazdhRVJ2ZDdxWkYxMERZWFIzR1JqNlpaMWlLMWVUOFZmSEwzQnZ2c1hHY2ZldnEwOWZKc1pNenB1ZlNUVWNUUTlvN04ybncwK2RYUG1rcmZXWW1EUXdlaEFBWEZHNjZHcUNITDBBd1UzQWFmM0diaDFqYkNhb2tqYmJYQXo0OVRXUG1RUERNTkpDdjBWYWozVG9NWXFtSTR6N25UY0ZKWXVEdW5GNjdaMmIzTW9GWWhueG5yUXMrY3BXSWEzbWE0ay9ocFM3Y0JsNk9TRmtTZnhVbGpzcUhBbHEvY1AxMTNWSnNPZWtHZFdhbkhkTlowSitIUk1SeSt4dVVML0QybTYvcDVFTTIvUUpNdVFwU0xrS29HcUx1NldLbFVrQm16dDc4YUxYdGVDN2tleTFINWczRFdRSFNFSlVvVmhWRVZIYjRWSHVNMUxERkhmejd3Z3BGZVdDdk1ha043NU5NSzgrTE5lczJwalpGZjd4amRmSXE4NTBPZjBYTG94czNQVUNYL25JOThTZDg2MlpIWWtBaFhwUWloakV2ZnBTMUUzejBJT1ZjaW1iY2FVZWM4QzFFYUpCNGFRU1R0YSs1eHNjYWZKSU1tUjFLbXgvdkV3RnJZWU9wbXVZTnJtKytySS9sWXNyMEJIeDdodXhHMW9vdEFMby9qVDdVK2hydGJmeWsyVUp6NVQ4N3NvZ2VOcDZ5L2s0U0hOZEtTbjNIY2R4anI4ZlpkVUNuaEpvL2ZjbnQwVTdCMXByRjV1YWhqUDBESlRodFI1YnIyWGtwRGVSaUFtYjVVMkVDMVNSZ0NDOEJzSXJZWVJhc0RpelFmeDZLTUhFSXFHMExxZ3VtWFJ5ZEdXUkRwMzdrOFd1MjA5S2VNamYvUFpvZnZtWXFGbWRYVjFZS1pjN3RnNGVoc2o5cW9WSzR5bEd2YlNycTZzMHdFbE5jNVZtektxdllQMExtQ0d0NytmWXhaSTZjMlJwS3BIclVCTmxhWFpiNlF5Q0NNY1JhUjFPVVNnQVh1M2oyRDcxZ1RPT0IxWXVRTFl0NSthUHdDMEx2U2JlSU9UaDY1SEt1NkhZRTN1bVRDeGQ0SlowaERzUHhZbHRUeWw4YXFZRXJlV0hvWmZ3Q1g4Vy8zNUVzS2xGRTN0OFNlcHVCZXQ4U0QzdGdkZDdPeTFjUGJtSUlhSDFVN2NGR2FHd3FOZ1ZibXJVQnMrYzU1VXlXcEdxZ0pySW94YTdXbGFwU3NVb2JhSmxWV29ibUJzMnRtSFVIVVV0bUI4WHRkaUxtaXRxMitPSjErMThSUWpmdHQ5K1QvTVZvSXlxMEFIMG1idXRpZUR0KzNjbXI4ak9lYm1rbW1pNzdCSUpNWVphMllSeXFSaEpsSkk5ZzJMOW4wOTV2MlA3Z3ZlZW1EUWFMdjRxdmhwNGZvQVkwdUgya3lZcnJaUVVOQXBjaVJTSThnSFhlcUR4QjIvSDhMYVZjQzZVNEh0TzRDbmRrQzNFcWgrVzlXV3I0N2k4dGxFN3RhWWJKczNqUEl0KzZYUFczNnJmc0FxV2EwUmg4ZTRycjlzcDl5dmlzUlV5NE1xUjFLYlVxckc0SEhlSnBMZTQ3Wk80S1JHcjRSem1MNzA3bzVtWFBPU0pCYXNpYUlpTHZUbWsxa2lVWUVLN3RLdEZEaVlBalhNNWtEeXJvbldaZ3BYdFg3VUxZWVZaTGlYSHFEQ1Z5STQzOFNPKzlzUnRQTUl4QmxSMU5LQU10V0lMem5WV2pnL3ZQbnQ3NGkvUDlUVGM5c2orNHpCdVVEdWRMK1BvbCs3cXkyMis2NDJYTy9uWElvSkI3T0VtVTNjZjl2WjZjc0NKQisxWkU5VnpZUnBHZGY3MFpzcTc2clNaZlN6VG1JWWk4aVNISTVnejE2dldyQyt6b1ByN3U3RGw2b21tS3ljM0wrOXVDVjVrZTBlRmtmNmczYjhCSVVpS05VMUp1WXpaRnEwd0VMektpK3pwVVk3cURiN1NCVXdQQzV3Y05zUXRqODFwcmVmS1NxUllaUnN1T0VyZzFLMjVjMk1RU3VoRzREWG4wZll6TjJOaDMrYlE4c3lmazhydzdDNDU0aWRqR2VaS3Qxb0VOVU9xdDRRQmRqS2orY3pER3RVZkpyVkJlSW00L2hvY3hNcUdoblJWd1l3c21zQTFhY3MwcHMrV2ZINXNMcXlWVy8veEtsL2lBYTNuM1hqcjYyRDB3bFVUcE9Ca0NXQmJUbGhGMTh6U3g1cnluM245dUFENis3SjNmL1NGeHZuQ3ZYREFVa09VTzgzTDNVV1NZVUpkc0ZBVGFYQTBua20yaGlNRHc0eHB1TWtMWnRQZjlUaWwyOU1XZURXbXlrWDF5cExscnFLcjA5WThrUmhjUkJYWENCdzlwbUUrV0Q1ekpaWlZaTForb0NmMmZxbnAvSGJIejZyL2FGcFRnclc4SFBYRlJ6cjRnYm8vcHg3ZGdLdmZ5TmowTk85R05UTkdkaTFsYVNNL2tHb0RhRVpqK25Fdjhvcml3QVNRUlZrajhMTjVsQVlUOEFxOU5LTmRmQnpnN1R1SlZpMW9oNTVKd3dqT29iSzVWUVV3ckg2TVFVemFDTEdpR0pveC8xMWIvLzg1bTJQdFQxYS8vdnRSbjQ2eUowcHVURGRyaHpUL3BMU2VON0kvL2UyNEYyUFBPcmNuUmlWaGVFUm1WQXRtMk5wQk5LdVlhVmp0U0pUTWMvTlZkWVhPdHF5aFQzUFpLek5HK21QQ0ZmN0QxbFlzRENJVTllRXNmYmNlVGgxeXpLc1BXc2VGcXlvd3RLVHE5QzZvZzZWVWIyVEl5SVJDYnBvZnM0N2FtcThJeFExY2VWNUZqNzBoZ2pxNHBVd2FDR2hFT05vQ3RVMWczQXdqRkJqbENTdEZtWklaWEZDaUN4Y0FtZWtnRXpYUHB6KzZuVkVrRHlTZ3dPSXhieGlhRlh5cEg3amhYd1FwQVM0OEZTdkxrZ3V1eEJWL1h1dzlNeHFWRFV5cmlTcnJxd1RxS3dWaU1WZFZGVGF0TG80SW5WQkJDb3luS0FzSXZEUUtrZVdhRmxWY05NOXlETlVNK01OQ0VhemVIYnJRVlJGbXhBaFV6UTRacE9EME9WT3VTUUtJeU1JTlROQVM4bXFPLzZVL3U5eXkyZXlqQlc2SlFHdUxFa09seE93TXcyM2xLVG96UzNWbVJXbnJBeXRObVV3R2dnRllGVFBnNGpVSXBmSkc0RzZ1dURMWGxXUHh4Ky9HMW1HT0tzV1IvRzMxOHpCa2w3cldkTFB2L1EwN3Z6cHMxNVN3QjlFbnVIQUJ5KzFzV0psMWJTWkxUZHJJVDBsczJXWWVWaVJNRGhueUl5N0ZPWVlZdFZoTEZsb29XVWxJYnFxVGx0cFgzY0tsUXlyckJxR1hQdUcwTmU3RjZ2UG1uc01HaUphRGMyclEydWRoZXg0UDJQMk1VNTBMVVMrRDNadkI0SU5OZ1k2QjdCZ0pkMFFmVThGclRKN3FFQkJWeUF6MnMzd1VPM3lZZUdVall2VzBtRk16UlJOSk9kTGY2K3JYSWJmbUFLL1U1ZHZqTU5hS0d5bitTdFhEM3p2ekhXaGVZT2pGWENHR2ViRTFacW9sMVJ3NVNFRWF1dlIzVytqZnZBUjNQOGRMMGRjR0tRMlQ4a1JoeHNiTlZTWkpUbmlmR2Nia2p2MjRLOCt0aEhKVWVET24rMmNHTmpxeldkQUpoOHFtOWxTTzVTcFNTM05iQVdvS0Rxek5kS1BKeDU2Qm5HbkI4MTc5dUVWWndZUlBxOXhSc1ZhK1pLbGFOblJpV1ZyM0RuRm9DcVpvYXVRQnh5ZEFuV0dzOGoyUFlzUWtVS283ZDJIdXhBMXd3alFOU1VmYlNlMkJ6RGV0ZzhWeXhhUnNCbUl6cWN4OEJ5SEhtbkRTS0w2MnBsOEtNcGsrRXVGV3R3TDJTbHBueWk5TFZxeVVXUEpWVisvdXVzM1M1ZlZvTGRMa3NDazRaREZwQk5aVkViSTltU0tXbXVoWTFzZllnZnZ4UnFkSXphUHlwTFU4TmZNVCtLa3R5aTJxUXFXRFN4ZUwzRm8rOXd5VzJHVjJSb1lRKzlZRXIyL2Z4Q25MM0V4bUlnZ1QrWTZWOFV5UlM5NkhuTXhyMWJNR29PcUh5ZXlYQnZqQStxSEJlZ3J5SGd6T2NKd2RvVFhuZGZacW9ydUhLSUJSMmU5Q2drYmN0REZTTmR1S29SS2kyelQzMzJvVy83cG1wL1AyMWFtNWtqN1VIT0doaVV4VGYyblFQbWZXTVNIMy96aTE5ZVBiTjFreGlzWXEyVTRNRDhvVk8xemhGeTFhYjZxaHJMRGRFSjdkOENxcXRDZHdHcWJjYUYrM1lpYUhZalF6eEU4akNnUW8xWktPUTlCdGQ1S2RwRWJIVUF1MVlIWXF2bElQZkl3QnJZZmdCa2gxT1VkckNiTWRyYjNZY05sVlNoRUF4aGpIQklXRkZ5dGlRS0Y3YWlDNit3d0NtR1N0RHJWaER4QTJPekErSjBQWTlXaUtBYjZoTzdma1h5dm5TVmFWRExzQ0hvYlNkb3BFb0NhaUxabTlhVEtEeHVTeWlXRzBUVldnWGd3TVdzTXF2eTNWUlZHcUNhRVRGcWdvVUppakt6WFVkU0c3OUVwUmNkRzE2alkydDZOZXhoQ0diVVZUbU91WUxnaFMvWERHZWdhTkRxVGVmUGR0KytxNkNvWGsxclRCS2x1bWVXYlVuakZGTDliZks4WnI4VllJZXRaaUdKNEtyMnUxa0RETVdxM3hZdHBXVUxmRWtBb0laR3FPakpMRWpGZVlaMlhJKzc3OTd0Z2pVZzgrZ3lKU00xNmJBby9xbUZXL1VyVDFNeVcrcW10MHN5V2MyQUlXVCt6bGN1ZXp1QlNIaFZFMjlsRGlLMWVodEN6ZjBKa25rQ0V5REpHaThxcHZIR2VTbUF4L0JFcTl1YjNxaDRkS3A0VjRpMEpVZjhoR3d1YkthSmh6b09iUTR6V254dkxvYVkxaEtFeE9mTGhXK3JlZWRIS1RLUXU1TVJYTkJiT1VtbjFjTUJ0R2h3M2YvUFQ3UlZQVDJkUTFneFpCM2NhMWl2TEVLbWlBbURrbVYrbUxuMWpEZnAxN3RlbTVXUVJxZ3dqcitzNngySDJFejZxNlpNeUtXeDY1WE56eEhrVmdKZmtpQVBGSEhGMkhOazlmY2hSR0U1U3I3cnFRdnU3ZDVvN0ZxMHhxazV2Q3M5WHlsRlhFOFdUanpuWXNJbXZxOTZhcEkyZzYvMDBsN1M5YmMxMVZzczJkUkczWXFFanoxT3h3bFNzNzk5Yi9laVdzd1B6bHJiSytkUEZvSkxmVVJoMmRDdGxGWDNpL29NeHVZakFzNWRjWXBDS1V4c0xrVTJuc2E4ajBLdGovejBSdFJhblN2eC9qdksvblRwdGI0dWNvUkNwbklVNlUzem54RWJnT1R1WVVoWlN6ek5YTjVQSjZhU0NEY3ZKZTBWanVRSUtoMGFRR2FBNUw0ek0yWkpVamxnWG1TRUVLK2lxOWNqOHZ6OFEvOUZUNmNyZm5XYnR2b2pLOGRkRjVXaW1jclR0RG1NNGFla2VIUDBMVDY2M1hhZWhHTEg2bFNmMWd3SnE2NERrZHB4MURCUnJkNC81cTgvOFkreC9yamcxczM1Wms3T3NxVWJPcTY0UXRhb2ozeENHS09Ta2swaUZSOGRTR0JoUGk0TmRJOVoyaHFteDkxM3UvR3hSSmYwK0w2NS9NSVdPVHVCM1cydS9pOWwvQ0ZmT0JMa0NzLzhhTGNxc25EL245ZDl2RC94K3hjTDhYZWR2TVM4U1pIWlozMExVVnFsUy93aVBXdThTK3JkTEhud29qeTFiZ25PeUpGVmlYN0JKQ2tkRTN4UHRrY2R1MjFGeGUvdUlwVnZYMC9sZ3Boek0xdFE3L2dBVklTbkFtYW9jS21IRCtQUklJSHFxWXBFejVXNSt0UEwvM0x5dFVxMkt1TC9hSG5rYzIvRUl2QVoyNmQ4V0cwSktiL1VSQ3lYZWNNNUo4dXIrZ1V6ZmFHak5ubDgvV2ZIa2dYenZ3eWl6Ly93Y0xGU0t4WXNYbXpQMXRreVRjQ2hsdU0rcFAxSzNGeTVKcno1N2pmdWFwbnE1MEZTL29HdWcxVEpsblpBeVdIQmtLcDFHNTJEQzJORTNMQVphR3JDZ3RSRVZkRi9Wa1lEYkhBcklHa3ZJQUpVZ1RTN1MwenRpN0c3ck4vZHM2d3pzM2RvVjdFcm1kWVprWWtHNEllckUvdjVWMmIrNTRtSmpvMUtPWkZMcU5yNmljcWhiQlh1dXVtOUxIU05tY3I1eXRBVzNMbDFxTGJyOFluUDlrWHgyWUZSMGIrc0kzUC9iSGJGYm5oMElkcGNJeXlrandMTENuSEtVbHBETEtiVkZNLzNHOTJIUEs0RWFNM1dmbFJIaVZNR0ttUVJia3VjMXA5d1hVNTR6cHVTSmpXa1VaK3JLL3NTNFRtM01MYnJrZFB1aVJTMnlLV3pKbW1oUU5rU0NibFZST1pJcDlIYVBHSHZicVJ6Yk93TjdudTRPSHZLVlE2NXJ5aTNrWjErNnNGazJod095T2hxUWplR2dXNjArYTFNQitkbWUvakhqMlk0QlkrY3pYWUdkangwS3RZOWwxVzVUenhGYTZlTzVDSEk2WVpZS0ZOT1JvSElDRlpqOVYrREwxaHZOVXY1cGxoSHkxTVMrTllNU3pFV3dNeW5nYkgvbEZpRXdaV0xMVFhhcGdPUXMxdWhNRVpveml6Q25nMWs1bXlETGthSzVsRG5JS2NrRVVTYUxaRXg1MzlRSk5LY01jS3FneTZVZ3haUkVoeWl6cloxUmhzakpHVmI1cDlOOFdTWnpOdlYyNnVHVXVXOVA4MzVueXZQVEVaOVpHZTFNTEhmV0F0NnBiTGJNL2FsUTdFd1phRG5oR3FVeDdBeXdMVW9nZWpwM1lFK3p3VVE1b2NvcGl1eVdlVjdPWUsyeldWMDU2M1hMbkdNMlljNVdOVDl0NmsvTXBjeCt5dXZHRE9ITjFEaDFydkJubExIS1VxaTF5eVEzTUFVZE1NMytCT1ZxV3QwWnJFRE9BTDNsQkRNWFgrbE9veXh5Rmpjd3F5Qm5pa1BGSEU0Z3BsbEhMYlhZcWJsZ1l3NytVc3hBZ01RTWpjbEg2ME9udTUycnBjb1pMSE1tUHltbktTcVlscjArbjQyblp2anRvZWRZbnBqR1NxZjZVMk9HNVRsM0ZtRk9kMHduUkdPT0V5Sm5FZTVNeDF3dDFwMkJYSld0REpuRlp6Ny9NczQ1RWlWakZ1MXl5NUNhY2xYaTVYTElNd2xUenNETVo2eG1QSVpDbllrTnl5T0EyYU1XNG1FWEp1WGN6bEd5aWVCMFZmYVlJYlNaRGo3bmFvMXpzY3lqM1lULytRaFZ6aUNzSXhWa1dXTm9iMjgvNWhZNlhZNTNUZzJvMC9oVlVhWUpaeWJoSGEwd3hUR0czK2NyNUtPS0xZKzNRREdETUdlTFpkMDVDdTVveU0reHNOQWpKVXRISStpNTVHVHhRZ3RVemtDV1poS3VuS1BnWmhPaW1JTTFIcTFBTVllSmwwY3A2RGtsMlA4M0JEcFhvV0tXRlp6cEZnTG1VbUU0RnlHS0k1eXMyYXdWYzhqbXpNVkhIaGRoSGl2SVBSSmZXazd3czFuZ1RMNVNISWZ4eitaYjUyckJzMW1qeEhINHM0N1JCTXlVYXB1TFVPVlJXdUx4RnVqUldpN20rUG94RjY1MWpDMXpKbXVkaTFMSTUybUo0aGdKOEdndDkwaGVPeTZXYWgwSDdSWnpTUGpQcGhUeXoxeWdSeUlnK1R5LyszL1Zod0p6MkFjQU15Zjl4UkdtSTQvSEpNbm4rUjU1REpUb3owYWdjeEhDYkVuLzV6T1o0aGhiNS9FVS9GK1VRT2R5WWVKLzhlTGxYOGc1LzJ3RmVqUVRJUDdNSnZWL1hXQ3prb2k1SnVkUC9QMWwvUDFmQVFZQXh6TW1pVHJNNFJrQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJZ0FBQUF4Q0FZQUFBQUJmK0h2QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG94TkRCRk1UaEJNak5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3hOREJGTVRoQk16TkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qRTBNRVV4T0VFd00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pFME1FVXhPRUV4TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZ21hU2tBQUFDVWhKUkVGVWVOcnNYSDlzRkZVZWZ6T3pQN3VsV0VpNXRrRExJVkJORmRTVEZFUWhKeUhSUU9wNVlEaE11RVROOGNkZERJbnh4Mm44NXhKeXAyZzB4QmdUSThHRFJPVU9NUm9NNUlpWTQ0UVVrWUFjQkRsYUxXaHBEeWlGMHYyOU8rUDd6TXpielA2WTJkbnR6SFpMM3lkNXlUTDc1dTNNOTMzZTUvdmpQU29NYks4akp2RFI5aHU5TGFhdFdiL0dNZjR4UXR0UHRCMm43UlBhUG0zYzJKNG8xRkV3SWNpanRHMm1iUTYzNVlSQU4yMHZVSkxzTGtZUVNWYkkzMFNCUE1kdE52RkE1LzQxT3ZjdlVxS2syVFhSMkNFbEM2OXdja3hjWU83QmdheHI3RU1zS2E3MWlNcXozRXdURytCQTcrdG4xbVlSNUhCM0tPRHp5Rzl3ODNDbzJZbEhmblAzMDcyQkRFSGFwOGZXVVhscDVxYmgwRjFORStYRTQrcG5HcENJWGtuNUxUY0xoeEU2SnlRb2lKLys0eDV1RW80Y2d0d05iNk1TUkJLVkJtNFNqcHhnRlp6d2l5cExCT0xsSnVFd1F0QTRvU3FJV0lrZlBQcS9PSGwxMXdqNTkzOWpqbzZMOFhZZGlsajJ3ZmN2NzdpaFBrT3BpQ1dVQ1IydmVrQ1dTdnpTbERxUm5MNGcwNVlnYzZkN1NmTVV5WkZ4OTU5SWtrbEI2MWM0OFgyYVhMaXNrS0MvdEZmZCswMlVuT3hOay9VUEJoMTczbHdNamNpa2J6QTE2bkdtVC9XUStsckgxN3BRTVlMYzJ1Z2x5eGNreUJmZnBzbU9BMUh5d3BwYVIxUUpFLy9VQ2k4NWRUNWgyZzk5R0FyMU16TnVPSzZvcEg3bG54SHk1OGRxc2tnQzhueDRNRm5TODI1L0puL2ZxK3U3ZU1uakZNSzZwVjd5OEwxQlZ3aFNNWFIyQkNsQlJqTFNIZkNOanBzSFRtcUduZEVna2I5OEVDM2FmL1BIc1pLTXUyWkpEUW41TlNJVUlva1RtRW1mZmQzUzh1OC9kQ2FWdFFBY0QxYWRHQVQrM1M3YVcwUnlJNnFRVFR0SGl2WjlZa1ZBVlo1Q2dCSmdkWGUwU1dxZmRVc0x5L1QzLzVmSmtiTnA5WGZuejVKTUo4a01JRTROZFUxYjl5ZXlTSUxyZGxmczc5OFlOdjN1amxZZmJhTWhpR2I3R3I5UXZRUXBqY0gyKzBiajVuMC9QNnE1aW1WM2VETVRhUmFnQW92YVBHVFpuWUd5M2cvM1hSNld0VmlxdGlJeGZjbVlXaWRXTDBFSytWYTJ5cG1zUDczS1R4Yk84enVXdVVBOW9BcFlnUXc5QThrOFV2WDB5NWJ4aC9GK0s4RGRPT0VXelJUWVRUY3g1Z1F4U3cvZjNSZlArUGhjY3VEN25mK0prSUVoaFd6c0ROazJQTzc3K0xBV2U4QlZHYkZ0Zjh6VTBIQVJoY2x0LzVDY0crUUE3cG9ORjVjdTY5NWhLcERYd3NyNElnZ21jY3RuWWZYQmx5K1FDc28vakIwS0NGUUowbW84OHNlVjlnSkFOcTRWbmw5ZDNKWEFSVUdGU29tcE5xMmY1TW9rUUozV0xDbnZYaGJmQktzNUJza0ZsSUc1Z0xVUDFGZ2FocEFJK2V4SXlsYVdnTlFTNDdZMENKYVNiTWR0ZkhRdzdsQk1WUjB3QythcmppQUlDbEhyQURuc3VBNlFwS0V1bHBjbDVPTGkxWFNtWHZCSWg0Kzh0U2R1U1NRbll5cXpMS1NVN0MwWGlKZmdFcDJNWXhoVzNPVXRPeUIzalNDb0NMNjdMNUtSN1Z1YlJQTGx5VmdtVjdlelV1RTZ6RWlDZjhOZHpab202ZkdNT1VHY0tEdzVuNzNsWjJoT0twVnhyRWhjcVQ0RjZiNll6UExwY0J0MkFIZkJNTGRaVk5YSGpDUndWM1lDUmJPc3lxM01vZGp2RlZJZ3VFRVdJQmZManRqOVZyK0RCZXBDcWQwNWdtQlZkN1NseU94ZmlGbkZKNWJtYnRsUW0vVUM3S1Z6QTc5UVFJdEp6dlVsOHdqaVZoYmhOcERGRlZOZVlPVkNuMlg4aFBRKzEzV3doS0J2VUNHcjczUE90YmdTZy94cFpTanY1Um5zc2hzeHlYMjNwMGRWMHJZVEd3eEhLa2NRcTRwcmtKSWVGVjY0eGRNWFlxU3pJMFZXTFF3V1hBeEk3enZhL0pudkVKZGhYNHNsQk5nRUhUZDFFT1oyQUR4OEtYQnI1N1FhZ2NrR2dSYk05cW1URGZYczZROFgzRUZHakFhMXdFWW4xQVNFd2JYT0RvOHBxYXFhSU9jdnB6TUJheVZocDE0Qmxia1dyaDZpZ0F6SSt2WWNqWktEcDlMazZnMU5SYUVTREFqU0VhT3grT21Xa09Cb2hicWlCSUZ2eElzQ3JRMmxLd0pTMVVXMytWMEp2Sng0dDNKV0s0NG5XRTBteG1RdXR1OUtpcno5ZVZqZGFHVEFidmpBa0pZcGdoeWJuNmgxUFM1empTQkljU0YveUZMS1lUaDhNcHFkak1STzF1QVVJTzA0cEZST1ZSVzFtNWFHaE9tOWlObHdQc1M0aFkvZGFrWVNMQmFvRE53TVNJS0NwTjNNcnFvSUFpTWFpMXJsRkpGeVUyQ25zZ2FHY3M1UnNCV04xV3NNd08zQTZrQVRsT1hyYzZrTUVUQSszQWtVQTZRNGNuWTRTMlVZU2VCdWpuV1BrUFcvOXJubVpod2xDS1FYUHBUVlFCQThsZlBnUDExT2orbzU3SnpUWU9jb2lzRVlBN0J6SlJzZXFpblo5ZVh1TWpOYnNlT1FiRUdnQ21yTVZNeGNFWXRYWUdzb1UzdExjbFJIR2x3bENGYjg4WjZrR25Pd2piU25WdmdzSDVidHArQWdjKzZ1TEV0QllheFNWcWQyTmxXeFhLME11WDNuTkhrTFRzcmhNL0VzWlRLU0R5c2Q3NHN4ck9vWElBTTcvYmJrZGs5bWtzTXhyWm9LMGowNDMxdlNZbUx4eW0wekV1cStFanZ2aTh6R3lYcUl4d25WMlBWVlBGTkZOVXFqRmVCNlBqMWl2cU9LY2V5K1pPNVJRck9qaFZiM1ByODZmNU9QQmRvZ3dvYUgvSG5mLzJxT1Z2blZ4aWorbXhnSGdiY3g2T3pzeUs4UndVWGJMWmZqbVRhdDk2bjNkSjFOcVFVektGRFZLQWlZakFyZ29qYVp6UCtsejdiMFlyVTQ1VGZ0eEJ6RmdJUExoZDROeERCVEZ3U0lzNmJGMWFDMUdIRG1ZL21DUUpaOXpHd0ZjdVR1SnhWN1J5eW1aWGNTeHc4MUNhUitjZlBBbHROOTQ2M0FCRm5IR1FpM3RybkhPbzN1N2s5bXFjUllvSEZqKzNSMTJhUmtJZW9SbGVCNE11SllHYTBTZ0FLTTlmdkpDbEV6RFdpY0VrOEtWd2tIaHdIeHBBaE9LQ3BCaHNMU0Q5d2tIRVlNamtqbkdFSFNKMzRNZnNWTndtSEV0eG9uWkJBaytkS3VwbjJSaE1qZERJZVdSU1hFb1pkM04rNmxIeE1nU1B6U3NPZks3bU9UMytlbTRRQW9GN2IxWC9OZUFUY2tFcHlKU3BYMHIxT1RydDgvTDl3d1kwcHlMamZSeEVWWFQ4M2VKN2UyN0tBZkw5QTJMQTVzT1EyQ1hLZnQ0dS9lYVgzdm05NmFBOXhNRXhQSGVvTmZVZzVzcFIvN2RVNmtwV2NmOVpQWDkwM0RqbFFxSlF2aUIxMzEzYlVCZVhCZVk2TFY3MVZDM0d3M1A0YWowcVcvSDVxeS9RL2JadjZEY3VBOHZmUWowZjZldTVMNVU5eU5HOXRSTkt1bkRmL1hmR1pkTUQzMXBWV1hGaTJaRzc2N2NYS3lOZVNYYnhFRkluRnpqbi9JQ2ttSDQrSzFnZXZlODRmT2hZNy9kYyswTGtxU1FaMFlJTWdRQkFOOXMvNVd1MDRTWEdpa3JVa25EQ3FzcUdlREhBSTM3MDBCN0FUQ2E2Q2VIOVVKQWJjeUFFRmg1RkFKUXVvWDU5Nk16Q2FnRTJVcWJaTnBDK2trRWJsdGJ3NFIwY2tSMW1PTlFaMFlNZjI3RER3bU4wZjB6cmdaVzY0K25Sd0NWNUdiUWowVWZaNXhHQ2F1dDRMbkxuNFdZQUNlSnpqU0NkOGwyUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUJzQ0FZQUFBQ2NsRUFRQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTjBJeU1FWTRORE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJOMEl5TUVZNE5UTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWTNRakl3UmpneU0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZM1FqSXdSamd6TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrYXFIMGFBQUFLRnhKUkVGVWVOcnNuYzJQTk1sZDV6TWlzNnI3ZVo1NVp2d3lxeFZpNEFpblBZRnZIREFIVmtqSWUwQUNXZXNUSU5tQVFXSlBDSUVQMkh2Ym0rMERDTzBKc0pFNElYRll0RnF2OXJqQUh3QlhCbkZneGpQenZQUkxWV1lHOGYxRlJGWmtWbVJtWkhaMVA5MDkzKzlNVFZWWFoxVmxWZHYxaWU4dmZpL3Fzei96dTRWU3FpanN2L2lQM01ZUENyZTF2ZGIrOStHMlhHdDczeGZzMVJmdER6OXQ3L3dKZS8yajlvSFA3TzJ6d3BpaWFRMnVWa25ibDlpVVpYSFgyamROMGJickhvdVBxQ3I5WjJWbFJ0Nzg2RWVTT3Q3ZTFaajFueU5GVVJSMUg5VjlxVi9ieTJ2N0pmOHY5cjUvc3R6NGUzdjdCMFhSL3AyOWJ1Mi85bTUzRWFhRW4vRjQrL01QLzkvLzZEMXJaZnlUcTBKM01BOGdGNERyM3ZWNzluZS9aYS8vcTlMbGp5a1AvaUlzQWp6WTVIWUxxSytrSXg1dmdhNE9QOTNOeDl2YTkxbXVvMmRsUHg5dGdSNjlneVRVcDk1TDczakEzSDZHaFRKMzh2NHBpcUtvdSthNk9iUC9QYk8yN1hQMk8vOC9xY0w4a29PMitXY0w4ejlYcHYydS9mbDlnRjNKL2ZZSWUzRlFQK1pyRlhBdWNBNHcxNEI3R1Y5LzNsNy9rYjMrZGZ2N3JZWDV3YzJIUlVCeGNQa1EyTlpheDd2R1hjcEQ3T3RxdlI1bHdTa1BZWW43VTZCdEVWSFE2OTI1eGdKazhKb3FCZXJwWlV4M2ZBdG5YdHk5TlkvZkFpTURGRVZSdCswa3ZXbVRMMXpudkMwQmZrd1o4M3NXM1AvTnRNMmZXcGgvb3pETmg2WjFyQjM3YXE0a3RPNFBjREF2RDlkeTBiOXM0ZnBkZS90ZE9IVU5tSXQ3RHhBL2hua0FaMlZkZjkyMEs5K25qd29zZ0hZT0xNZGNjbTJhUXExY1B5RFVYbFo2RklTcVdCaUN0NHVMdG0xWG44OU5RUjdmUjZoVEZFWGQxaGR2UkFMakxad0I0RnYzNVd2YXJRWGhiMXAzL012V21YL2QzditYQnF4cXUyVkFuMFdIc0xtMlQySEJkSUI1WlMvZlZycjZHbjRPSUZjZTVuSzdnMm8vT0s2OHM4WnpOY1U2bCs2aUEzb1Z2RmQvc0NzaUFob0xsMDNaWHpDb1kxQ3JSTFNnNThxalNFR05jSXErbXh5QzJZK1ZRS2NvaXJwZG0yNGNESlFIdXdWQTRmYlBMUWN0d0MyODMxVkdmZDhVemM4cVUveTJQYUpXN1loRGp4UGVBUFZLVjA4dHpQL1NYbjdSd2J3NkFOWW55WFVMZ2RpVkR4dzFmcjBwVmJGZjRkS3hUMkN3TDcwQzVPRWgrRnh5UXNoR0VzOVVid0dSN2M0clJDMzBLTUJUcittY3J6bDI4YTBMdGE4NWo3VXdWLzVNRGNsTlVSVDFab0FlLzFjNXdEdkcybTltaE5sMUkvdm45bzZ2V1ZhOVoyLzlpajNrNGhqb2hYZmJzbGZ1bkhsVDZPOXRMTXl0T3krVTdBMzczd2tkRDVuY1hiaDk2S0JWQkF6NzJNWVVBcW9sYWdPUUoxenpIT3VIdng4N3ZtNThlc0hDeFFNV0c1dXFURHJ0MU9LaWYzOS9MeCtmVHkwaEYzWHJXWUF4eUhPT1pkaWRvaWpxMXI2Um8vK2FnNzN5WDc1Z29FdUVhOXd4YmZHTDFyaC96OTcrSmVCcjROQmo1NDJ3ZXZrZGUvMmxCazVkQWZCVkw5U3U0dEkyZnhZcFJ4a3h2eWhMNi96ckZTNjlHRVFBYmdsMGJyR3gvTW1ycWp4NjNCVFl4NkF1TUc5Y2xPQzJOUmJ4Y0hrVWhsQ25LSXA2STB6M0hKSm84YUgrVFA3MStEUmFCYWgveVNqekhYdnJhNzN2OTE1NW10YS9ZaDM2VnlXTEhjNjZDSTc4c0gvdTRPMWRwRktUTU8vQVY2NExuV00vK2VEMGwzNCsrUTh3N1hKYXlkNjVWcU43KzJwQlJBR0pnN2NOVE1uRWw3OVhjYWZKZGhSRlVWUXUxUTlzRGRGd2xKUkxUdFZSd25yNTFYZi84N2UrUE9CUzJFTXZVWnIyblVLRkxQWlNuckF4amdBNnptYnY2dFhWRVRTT3d0eitVbFhMOTRWUnh6NldIYTVtL3NrNVJsd3BzZ3RXMU10dnFzUFdnM3pvQ1VxcUJOamp6d2p2YlYvZlBzeDErUHVwNmNYRjFDS0lpd0NLb3FnM0FQYU92ZnJBWm44TlpyLzc4OS84RHoySDdrUHUzN0xrZjljMWtDbTdlblRBeGpubGZqZTVGTXluWENyY2JMa3dpL3k0L0tzUDdGUElyT2pFaHZkUmxhbkl4RGpZVTRDRU0yOXZrZWF5M1dIUGRVazlQNkZPVVJSMVg4QStnSHFYbkY3NnFIcjVPWHZqbXoyZzI4dVBXL3YrYTcwREpaVHU5czJienNXcXJDOTZOWEprQ29KenFsdHpjb2ozb3dETGdZcEVPS1hHdHdKeTNEcWMrWnJYWHVMS1M5MlBJdVFDV3JFM0hVVlIxTDJEdW1OeTZOenFqTGRsOTY5YWwvN2ovbnRmRHZnTmU5bUVoakdIWHU2SEowVGxHUUEwNTh6VGJ0UTVWMm5Bc3RDbE54TWxiekZVMTE2V05yN0JlNmpLak9qRWhGdXZMY3pYTnR6SmRlV3B6MW5SWWxNVVJUMU1xQmVleVJHanZTSGZDTU9kUTFlQStsYzZXeC9pOUhFYzN6OGhJQlFETmhmbVEzZTdSTU9ROUpRelhxT2xJZTh0OXM0TE5icTRtSHYvcU1uZjN4TE1neXNQQ1lnNUg5RlNsODQxQVVWUjFCdUFlc2RpTldqeUp0eit5cnMvLzBjU2hQK0MvZWs5eWFRckRobnNTcVdSQUJnMWliYWtLc09odW9sa2FuSG9QYnplcVdHeTFDVnZKTUtnRndNdmZBN1lQdGpYdHdQejRNcm5QcUlsb2ZlbGl3Q0tvaWpxZHNGK3FCcjNtZkJ1YS93OXNCeWQ0bjZ1aUVoL09QcTRQM3NIOWJvVk1JU3dybG9JRGJoY2w4RStmL280Qm91SXFVWEFXc0RzRjVTTDRUVzJtekxwWW9mMTI2bG1NdGl1Mk8yYlczTGxnMlkwcHIvUU1wbnZMNVdFeUE1eUZFVlI5OFdsbTlBeGJyQi9MQXovSXNyV2Zpb0EvSURuc2JTMkdPcU5aTDh2aGJsQVNDOXo2Y2NOV1U0VGVsOFNiUSsxOUdQbFhtTmhlQWhoL1YxOWVwaUxLeStYZDVialhqcEZVZFFEQm51QzJmWjcvYWVCOVo4YzBsSDFIampobkZGRHZSRG1BWUNiQmMxbVpMU3BPZkhlZVh0b1hKUGpncmMrczMwcUlwQ0NPc3Jpcm5iMVNXdk5YWTk4TFIzNGtzbDNLM0liSmdJOEo0MktVQlJGVVRlQmVmU2QzbytzL3lTSThDTTlnT2NaOUlQejNEZCs5T284ekdNbmk3M29zc3dFT2hxd2pPMTNyMHh2UnhsZWJrSWN6bk9ZTlQ2YUJCZDljSGo2NjMxelVwaUgvdkg2Nkh5V1E1MlFwaWlLZXJBR3ZROTR5M0xFdlovM3YvSXphZTdWdEtIYm1abUYrVkN4NjgyQmVoTGlLNVZiQTQ2WE9OdU1uMmU2TzU2N0F6QS9WYTE1Y09YU29XNEUwa3RENlF5OVV4UkZQV1NxOTBqd0hFRGYrdkZicTRWczhUaDdPd2Ztb1Y0NmR5KzlXekNjQ0VJbTB6YkREWGZKZnhOcmlONllWdnZQOWE0NVdhMjVEalg4U3h2em5NaWxNK3hPVVJSMW45a3VYOFpicmZWcHZwVVJFa2ZpVnk3TWc4NDNWUllZcEFaK3d1MnFCWmUyTVZtd3hYbWRiOG9zVng2L3IxMTl1bHB6Z0J6WjlWMjVuRkxMSUQwN1luYjlYam9uc0ZFVVJkMGZhWUNpa3VTcUUwQzliZ1ZtWXhCSWdSQ2NPck5RbjNmVTBmUzF4R1dKMnN6KzdlZmJ5czFqSHlGNDZtNVoySnlnUEMyVXlia2hNRXNlcDI3Qzk4em9CbUZPVVJSMTM2eTZEaERZbE9YaXRxd3BBV2FZN1oyQytaaWp6YzE0WHplMVBBV2tlUnE1ekhhZFo4MGptQ09qL1JTdUhJdUpzYi9IbkV0WGFrV3NmZVp2aFcwRWdweWlLT29lTy9RZVNLcFM0SHBUdDM2OXIzc2pTYWRnM3JuMDdYeEwySkJSUCtWTzV5Nm1jTWxxOCs2OEhIZTdBN0NIbnZBM2hia2t2dGxGeE5ZbnZxa0p5QzRPdlM5WkFBeEEzcTZZU0VkUkZFVzlJYUNITC9WU01xbHY1dGJ4NVErNHBWckVKZ0d2WEYzNlhJSWM5dEJOdEk4K2hIWHV5YzFsbnVNOE5uN3ZmREtrSDFxNk5xYTR2R0d0T1Q1dnVQTE5pVHJpTFhYcDhmSGl4QWx5aXFLb2h3ZjA0WmMvRXVWay8zYkZ1Tk0rMVB0bFc4bUlkV2htbzVXNDB4d1h1d2pnaWZPYTB6WXFEWXQ1cUVZV0daZlhONE01M2pkZ3JsUDk3eGRBK3lZdVBjeUZ4L3NoeUNtS29oNndRMDg2VlFzYTFHRHJsZkJzZlplMDBRWXVnK2QxMmR6VHIzVzV5MDg0UzdXSXZab0p0OE9kbnlFWmJ1UTk5MXFtZTVpM0srbUh6eFVnUHh2MmlKLzR2RStaSUJkQWpraEtBRGxGVVJUMVFJRSs1Zkp3RzRERi9uYTEwcTBERkhEcVI2d1ltUlVPd0UxcG4raUpQdFlRTG5YY2ZxYW4rbm0wbHo4MTB4eHZDREJmMnpnRzBZOG5aMVUzVzMyS3ZVdGNlbzR0Ti83dkVrQk9qbE1VUlQweWh6N2VvOXgxUzl0dXlsVUpjNUl3dHE5SFh5Z09aeVA4UExkNHVNbHdscWtCbzVYUEg4aUJKaUlGYTJyTnBiYmRMbHBDaUgwTnFKZkFmN2czRG9Eajc4R3dPa1ZSMUNNRytxaFQ5MUFRVnpsUlRqWHRyRnR4NmtYR3Z1K1RDWmN1ZS9QWDY3TEowYjF0S3F6ODlLeWE2QVIzY090NEgydHF6YkZnZUhhK0djMU5tTXBrWCt2U0VWSnZQY1FEeUNtS29xaEhEUFNZQ1hQd1FLaDRqVnRIdVZnTXdyRXBZQmlHc3QyVWs0dURzVVhJMUdVS3dySi9YK3BlQkNBbFBNZlM4clRRRHg0TEJuMjBvRm1YbnpEMzJXTi92NjVkUzE2RzFTbUtvaDYvcXFVUENDQkJKamljK203aEFKSkw3NjdQTnVPaGJWeWo1U3IydStkQXRBaUhJd2NEc2srMlpjSWhINklDenVIWHhjWEM2RUFvUjR1akduamVxVHpCMGQ4VnhXUWRQbjRITjk0eXdZMmlLT3JUNmREVkJQUFVvSUZLYnpXZ1hibFZUcm5aRU9yRDVpN0RzSEU1VVpjdUNWMU51d2ptMGd1K1NVTU9FWUZxcHY1N0RjeWRLOTlJNHR2WVlpSGwwbnUvbTBwYVZPSHphUDJBbklaaGRZcWlxRTh6ME1kQk5wR1k1ZEVpcFZlYlNzTHdTMEx3Z0hvWWtESTJTLzNwK1NhWk9DWnoyT3QyOHJ5SEZ4eWZBaDJlSC92YUFaYXBldlA5dmwwRWM1d3ludk1jSWZaeWZFR1Uranh6L3c1NEt3aXBveXNmdytvVVJWRlVkc2g5RWtaK1ZuZHBJWGE5SVB2NzRxb3UzbnF5RVllY2VpMFpyMnJkZjJydlcyVXNPb3FKeUVQM0FmaXRnOVR4VXQ1bDM4dnJxMzMyQjRwb3haTXcxQ1hqTTEwQzRSQlNENW5xRkVWUkZIVXdxQm5ReTNXVGNMdFB6MTJqbEJ6T3dqRmZTSmMxMHdGdStEZ0FQeVVzR25KWmlOY1pXMlE4dDg4L3RpakFhYjIreW1zY0U4clI0TXlQUnRLcVBKYyt0b0FLNTQrRnpmVytJY3dwaXFLb1l3YnZtM1FwbDhxRVVPcDNhTTRDc09VMG82a25ISEFJZjRlUWVBL29kU3NoNXh5RmJPK2gzb3Bnbm1vaTgrcHlsd1ZQdk0vblQ3YTlwalJySWgvRGhSS2NPQUF1VVkrNlhkM0VocUlvaW5yOHFqQVVEY2xVamRGRnRVRWkya3paV3BIWDhLU1VtbXZsR3JETVpLc0RWaGNXNnM5RzNEakMySEQvdWNsZVV3bG9jVFJocW9uTXE4djlhSGxjL0x4NERsZS9ybnBqV1k4eTBxUDQrbFNvWGZiR0c3Y0FZWEliUlZFVWxRMzBjRVBDdW52c2Y2TWtyU3JLU3MwMmtKa05IL3VhZGV5dnUrbHI0NEFLV2U4QjZ2RlQ0enp3UEVNbkQvREY5ZXJKT2Q0bVhiY2UycTZtbUFtWXo5V2E0NXdrZ3ozSzhCOUNmWWxxbjZtT0N6bE9VUlJGclFaNnp6SERJVnI0Vm1VcCs4R1Z2ZWdsY0IrUTFiVnozY2grK1pUckRWQWY3cHNyNVNheEFhTHhvZ0RQaDB6eXFZVkgyS2Z2dldscDhhcDdweG9nbWdQemJXZ1NvNDhYQkRIVTUxdzZvaU83dW1HU0cwVlJGSFU3UUk4ZGNHRVpXeXNIOU8xSVJ2Z2s2Q1BRWVM4ODdKbVB1ZEFoMUVNSUhCQUdTQzhYMW9LbnpoYnZZMWc3ajVkNWVURU5jeHp6MXZtMjJHeDBpdEhaa3IxeFAxcVdZWFdLb2lqcTFvRWV1OXkyY2RPNXNQY2N4cHlHL2ZRcGQzN3N0TXZpN2FkS25QQllDQjVRbDVEMklCa09ybmpZbVE1bFhHT0xESndmempsVzZubkY3Vi9Wa3pESDQ1NC8zWGF2WmRMR083bWd3SytNTHpjTDQyUWZHOGZqUHp2WEtCUkZVZmNVNlBFWGRlUEhodUlMZkZzNXNDL3RGS2UxTHQ1K2RpWndHM1BjR0lDeXNRdUhlSkJKNkNPUHhVRFFpOWU3NHZQdm5IY0FId3EvN3k4S1hMTWFFeUVaMndCVHpoOExDYnh1UHR3T1lYZTNMMjZrQWN4REJ0MnlPZXlFT2tWUjFMMEcraER1SVR5K2FSQ0sxOFhaUmgrNTB4aHl3eS85SjM3L0cvQWU3aUhEeGI2MjRIN24yVFlxTFhPUEdSNmZPK0FrekNBUGp3bFF4d0loRmZxdS9IUzVNMStPTnBYRkhrTU14MTM3U01LYXFXejNBZHBqN1doVG9EYUZJZFFwaXFJZUt0Qmp3ZUZhSk5wcnQ5Y09SNXRyNlJDK0J6Z0J3S0ZMQnJUaHNOOTU2NnozZE0vT3ErS1RnZlBPMGROaHNwMzk1Nk9YVjhtRXRDZmVsZXRlUGY1MEZydnhDWGp0QTBoeWt5WSt4YUhIL0hoem5YVlVKc3dwaXFJZUlOQ0RHcjlQL0tMWnVhNXhDRy9yK2Zhc3BWOEU0S2lyd2N4eVpOeC84dXE2QjNVc0F0Q1ZMZXhIZi96NnV2ak1zN09qNThYOTRibHcvRmxVZHc1WCtiRjkzbUVIT1p3TE90MkY4cmtwTUNuL25nRndnQno3OWZjSlpCMnNQYmlsZVU0Y09rbTY3ZE85TnFGT1VSVDFRSUVldXpQc3RiKzgzTGt3dVl3UDFWM045aGpmZ3l0K2NiSHJsYmNKMUMyYzMzbDJnRHJDKzRnSXVLRWtaaFJtSGFTM2ZaakQ0UTlMNkpBTEVMOUdHbFRPcFlmR0x4ZVpyV0h2eW0zSDBPNXVEMERkZlY3cXhCU25LSXFpSGhmUWgzQy84RWwwRzU5RUZ5ZVlwY2ExdnYxMEsrSDN5OTBoa1F3QUJkUS9BNmRld0VWWDBvV3VhWnZaTnJVSTZaOXZ5dTU4QVBONGIxc211NTF0cEEvOW5OTU1VK0oyR2JQYWIwUGFseEFPb2UxYTEvYlAxZEFpVXhSRmZYcUFEc0FhU1JDN2ZiQUhpS0szT3FBMDF1cFZLVmRhZG1hZC9Rc0w4VkNtQnFoLy9QSzYrT3h6bDlXT1d2V1BmVTkzaE4vamhjS2xOTEZwQklCeG81cVBYbDMxbkRuZVA4TDVtTzBlTy9paHBNd09EWGZ1Y0crODlBMTlBc1RIRmtGM2lXMkcwaW1Lb3U0cDBPRmVWVm5hQ3pxZmxZVlJaUUYrNG1LTTZnQjN5aS94dlc5WUE1ZUxVRHpBWHVyalhIVzBab1VqUjJKY2FNS0N4eUtVajJFb2xRL2o3eElUeU1KODhJMzBwM2V3ZmhtRjhnRkpqRzFGaUQwNWMxMWV6ejNtdHZiR1E2aGN6c2ZEZTZvckg5MDNSVkVVTlFyMDRQaEMyTmFCVG51b3FBNXVJZm1yQTU0eE41NytGUWFSSU9rdGxJakJLTWREVTNBZW4zbCtadUZ2UVc3Qmp0ZEZsN1h6YlN0bGFDaHIrN2VQTDQ4Z0dDQ04zME03Y2ZGTjk3dTM3ZjFJZmh0eThScWhkSi9rZHNwTTlYSUFhcnhmTEVoQ1lLQVA2L0ZJd1drV0Vvb0xBb3FpcU1jSTlIa1lvYzc4NENvRGRPQmNZNmJmSkNSZGUrY05JU01kN1ZualJEYjhEQWpEWWFOMUxKd3pZSTF6UTZnZGtEL3pKWEI0TG9UZ24vcXlNeXc4Y0R3V0F3aS9ZOEd3alJMMHBLYmVnbnlYS0oxYkl5dzBFRGxRMGFKRUloQnFzTFV4QTlXNFZ2NU5pZkNuS0lwNlJFQlBmOUVYL1E1eFFrWXRBMGVNN01vN0dBRzBkZFIrTlljTmdQSDFIdnZnV3FJRmJtNjU2MHdYdXRNaEUvNmpsOWZTSlE3Zy92RDZ5cjZPa2ZHdkFEZ1dGdGdieCt2OThNV1Z3QndMQUN3VzRuTjU0VVBxUzZhY3hSRjZsM0RuSWd0NGZKZHA3Zzk2NkRBa3pDbUtvaDQ1ME1kSXA4dTR5NWdxcWlmOTFxMXc4Y2hlajhQM3hoUkhwVjh5OXRRN2ZyUk5SVlk3c3RDVmQvREtRaDJkNUQ3NDVMTDQvTnRQWERNYi94ejRyNXRSWGhULzlzbUZ1UGkzbjdnUWV5aHpRMGo5YWpmZGpqVWtvd1dvbGI3VFhLVVBUdnRvb3RwZzBYSmZIRzdxUEc5eTNIMkxKRkFVUlJIb3R3MlNRY0laUXRIUHEyMEhEOGlGeUp2ZVl4RCtEcERIRmVDTEM5dzVwclloT3ZDNTUrY1Nwb2NEeDMwSUJNaGVmMk1FNGg5K2NpWDc4Z2pWbzU4NkhqODJGQ1lNbllsMXZpMjdLSVNab1BZVUJCK2F3eldKdjkvY2V5RE1LWXFpUGdWQUJ3eEcyNHA2R0ZZU1Z0ZTk0L1lXcGdCekRBMDBjWkZPZEJldUV4MWdpeEQ4eGo2MjlVTmpzR0M0dU41TFhmbnpweHZoN3NldmRyMEZndmFqWEh2Tlp6QWp2ZFRaa0hwb2U4dm1CbjgvaXFJb2lrQ2ZiUHM2MVJBV2NGV0RzNU9zOU9qbjJpZklJY2xORXRIc0JRQ1NVanlGNFRHdDFLSmpEeDc5M3dPRVEyMTN3bXgvNmtHM0p1Uk9VUlJGMGFGUFFqM1VraDhXQi8zZlM4TGMwNjBMbDF0bi90UytuUisrdkpKUVBJNnQwSjYxTFYxbnRjaFJTeGxlaEMydFZMSVduYnJwWW81TmFDaUtvaDRFMEVOVzk1d1E2amErTWN3VW9BOHVVYm1FdUxvWnJYVVBXZStodGx0Wk95K2didHpvVWhuTDZrdlFXaG4xT3A0QUIwZVA4SDBJdVU5QktHVHdJNnNkYzkxZGM1aFRMb0RlN1A4Z3pDTjZMeFJGVVFSNkFtTEdPTGR0L0JmMTRiWVpnRmIxM0huaE05aUhNRjhyaE05RDh4c0FHQ0Yzdk02VjlJdDM5ZDV1bk91aHYvbno4MDFSTjFVM1VBV0pjYkdRbElmTDVZTHowUDY1Zy90WEUxQThOTzA1bkZONC9Kc0EzNm0zQzVqbFRsRVVkUStBampLeXBrRHhlR1BKQmxJaFJLNjlmVlpIWUw5TEFJWFdxRWh1SzcxN0RqM1g0YmgvNkd2SVViWUdzS09jRE1jQjZnQTArc0YvK09KU011aXhoeDU2dlovNWJIYlVyYVA3M0pyV3RxMWZyQ3p0bGhlUE5KMTgzeU5UMDhLQ0tSWGR5SytqUDIxQ0gyRk9VUlIxRDRBT3FDbUZ4aThJSDR2MXZvTlJMZU1nQzhCR2w3alFCQ2FHRjBMeHI5Q1QzVjdENVFMbXlHREhCY2NiaE51OWMwY28vZDEzbmtqNUdpYXNJVXYrK2JOdEYxckgxZllkTitqbDZycVJzallIK3R1YmE1N1YxdFdrZkg3K1FpSCt2SHFUNkdiQm5ILytGRVZSMUQwRCtwcytBZkFHVFdPY2M5YTlQdTR4cU9DRUFXMFhZbmY3M3VqOEJxaWpqQTJOWkpBWTk4b2VKMjFqclF2SC9mL3g3R254dWJmUGk0OWZYY3NpNEtPWFY4VmI1OXRpdTlGU3F4NjhiNWpGRHRDaTczdVlERGZYZk9hK3FMZFFNTXN3blpzUEdFY1Y1bHc1d1U5UkZQVXBBRG9BNGdheHVEM3ZLcXIvVG9FQmZkZ1JRZy9oYlRTQWVVc210R21CdHJSZkJZek40VEg0ZVNjejFGM1BkMXl3ZDQ2RU9UU2pxWFl1Tkk5cGEwTkliYVcrWFhldmhYcDQvQk1XRTQ5TnVlK0pvWFdLb3FoUE1kRGpVTEMwVFMxbFUxaGdtb2FMNmZaNDBaNFZUam1BSE0vMTl0T3R1SGpjQnBqaG9KR2hYbm00STF5T2F4eUhZL0I3U1l4N3NwV09jWUE4WnF5N1JMaEN5dHlrNUczUWFDWkl3dk0rYUlEWHhYa2hreDV3RDVDakc2VW9pcUllSmRBQnhqTHNoVzljKzlTcEJqUERldlFRV284VHpnVG0xazBINTR3U3RkclBOZzhPUDh3dGI5ckQvY2hzQjd5UnhJYncvSm1GTWx6NUp4YnFZWHhyTGYzaVhRT2F1UDNyRU5TbDlIVjMxOXZObVp6M2Z0L2V5ZDQ3UlZFVVJkMEowQUhMTURLMEdvd1B6VlhvNlg2OWI0NFdDSERjTWN4ZitNUzQ0TDdkY2FwM2pmc0IyNzJFM3E4RjVLNEpUU25QaCtjSUFNYmlBZUY1Sk5ZaElXK1QyQVpJWlladnNPKy9jYStQQlFZaUFEZ3VsTWhSRkVWUjFMMEhlaGhvNGh5NUQ2UEhkZWlSOHg1MmpJdWIwdUQySyt2STZ4RUloakI3ZU14T1dybzZGeTZaN1JON3UvZzllcnp2ZmFKYnlKekhlY1B4Zi9McXVuYzhGZ0E0RGxHRlo3N21QUVh6MUt3V21jWVdvZ1YrengvdkJ5TmtDWGVLb2lqcVhnQTl3TmNOUlhFenlVTnpsRjQwUGJkOW5IZmFFbHB2VEJKNDhaNTVVTk1lOXE4RHNLZUU3UGRMM3pFT1NYRUFkZWd1QjhlUG1la3ZmUGk5T3kvanVzMGhZdEROWTEvd29YYjk0cVBYY1pQZ25JTVBXd0prUEVWUkZIVW5RRDkwTkZOZDRsa0s4cmtNRHk0ZHdOeGJZRjVPbElUaGRkRlFKb1k1SGc5SEhlRHZGaFVqcjFXRVJEcVhSUi8yMFZHKzlsbmY2ejNBRms3OWxUU3A2WjhNZm03YXB2aW9ibVI2RzF3OVhtOXEvdm54ZVJUZG5IaGRIc2F4U2pjN0g1Rkl6WU9uS0lxaXFCc0JYWHNBRmxKT1Z2YXkwVU1mOHd4eWQ0UWZKcnhkSTZUdEU5WEdKT0h1ODQxUFFqdUU2ckcvSGtOWDJzRDY4NVB3ZGhzTlgybU5QQjRQUmVnOGhOWnhQeHo3MC9QRFd3OU8vYlV2YTB1OUhVUUZFSXJIL3ZwVTRseXVaSUhVSmZNWnlRY0lHZlNFTzBWUkZMVUs2SUMwakJ5MUFBZkU0U1NWYi8yYTc3Nm5qd09vSkVGdEF1UlFhUENpQnM1ZWVxMzcwSGxZZUJSS2RVREZQblZZSkVqV3V2MDVRRnY1NHdNb3c5ejBPUEVOdjNlMTdVcks1VktTZ1RHWGJiSHh6MTNPSk02Wll0ekt4OHgya1FhM1NHZ3IwKzI5TjFIdFBVVlJGRVZOQWwyUzJnVGlibTlaRmRNalQ1ZEFQQnowK3FyT0t1bkNmdmU1NzdjZU8zc3dEZnZmc1hQZERJQjhsTFEyT0Jidk01U1h5WUNXaTEzeEdldktlNjFSN1cxWGo2NTYrL1Fwc0wrODJBdUk0ZjdWU09KY3JvWVQ2S1JXSDRzcFA5KzlhY09GWlhFVVJWSFVDTkNQUjdETXdHY2k3QjRESHQzVmRuV1RER0dQT2ZNQTg5amg0dW5pNWpJQmVtRXZPaGVVZ1A5MU5KOGJ6M2NkWmIzSEM0SHpiZGsxdGhtVFRKQnIzSjY4bExwdCtyWDJ1ZTU4U3NwUFp3SGdrVXBnak83Z2ptMEZOcldoS0lxaU9xRG5Pc2d4Sno3OEhYNE92ZEJ6OTRMaHpNKzJWZkoxcm4yVG1kNUphOTFOVE1zVjlyNnZkcm9YOG9mcngrTGt6QU44dU1DWWMrcEJydFJOZGZ2cnl6TGk4MzVub2tSQXlTMG9YSzVBbDFUWGN1K2RvaWpxVXczMFhxMTRNVjQzbnVQU1E3SmJQYk5QSGp2UUoxc0g4ekZkcGx5eTZrTk9aWmJKU1FMZElHQndjYjJYUVMxamk0Qnd6QndyQWROUTd4NUMvRXZkZVZ4UFA1czU3OStQTWo3Y3IvMTgrdmF3QjA5UkZFWFJvUzl5NlFBSVhPcVNCQzR0KzlYVjBXQ1dtRU1YZy9hdllSSHdsdThNRjd0WE13SzlXTmp2eGpaQS9CcDRmamoxWjROYWN4TkJIWTU0dUljL3ByQ2dRWVFDcFc1YXIzUG5TeVdMR2l6Q2ZQMTdnTHRzRFJpRzVpbUtvaDY3ZERFQndxa2tMeUFVU1ZvQStlc0VlQ2RYRWI1WlM0QjU2blVBeE5UK08zckVEMnZQOGRLN3diRmgzMTFnN3krcU9QU1lqM1h0NTZtSDl6ODhHMlRFb3laK2FpcGNhcEdENFRIWWh3K2ZUVCtFUHU3T2o4Ry9qc2FBT3pMeGNkN0lJWWliQVZFVVJWR1BFT2k1dUFoY2FYMUMyV1ZHR2RwUXJzYTg2dXJIVTlBeXZsTmJTbmlzR1lBM1ZkNGx5V09KYzN0Mm5nNUtvTWJkVEx4dnJmWFI4SlljSVFTUEJjL2xndmF2cWIzejlJSnJDZDFkaUw1RWdwMG0zQ21Lb2g2YnFoZ09PWHZwQU8zYTVpZUFPUkxncEg2OE9NNnVENitGOFBiWVB2eHd2M3pwV1l6dHQrUDFYcjdlRmMrZmJVZUJLV1Z0UGhOL2w1bTlINTRIeDZOWFBkeitXVldPdXZPY3ZmT2t3MS80OTNCMS9JVmtReGdma21mV1BFVlIxQ01BK2pTUVhLTFZjUDk1TGN5THhNSWhhTGR2Um1HT3gydTl6RklPVHhlUFJ4ZTZWUGI2M3U5OWI2cHBGNzRHNmhMWnNCOWVBRHVjdnFzM1A3M1dMSEpDaVZ3TTk4VlJBSXFpS09xTlNjOUJJZFJyNDdMMnl4M3dDaEFzRWlIa2NFL3IyN0ttb2VQMnZ3VTI1dGdCTDFGb0NadlN4VlZ0ejZNZFhkakVVRjhhZm8vQmp0eURZU3ZicWRlYlczQ2RrdmFoaDMrNEhBM2dvU2lLb3U2M1E0OHoyVVB6a25yaEh2a1FESmc5ZmxRem5raVpENDFjeGtMNVNPd3FTN1VJNG1QSGhFU3hNSUoxQ0Z0MHRwc2FuUnFFV25VY2M3MnZWeTEyUWtaODVjK24xemQvWmx4ck5yOG5FeHN6LzQ0aGpxS1dOOGVoS0lxaTdnam9JZnM3QmxxTEVaOFNlbDF2eThCQ2RGRGJkSm5zMDJOVzl6TURXK0RPUi9lL1J4dzE3dDhVT2drZ1BOKythTWRCNit2SjUwQ0lzalp3ZUdweVhBN1lVVEdBWkRYc3Nlc1pPNXliTkxlVTRITk9QNEJkK2hBb2dwMmlLT28rU2NkZjVzZ0t4ejU1M2R5c1p6aUE5Q1NDK1J5WjBFTDFjbGRQd0R6ZHpTMmNkOHBwaDBWQ0trUVBuVy83aytTR1FqT1pOaEVPVDMwc0xqOWdNd3ZpdVk4Q2UvalNkYTd1Wjl6blpyYWJoWUJlRytFWUx0d1lqcWNvaXJvblFHOHhSYXk1T2NnRGZCR0tEdnZkUTBDWXhERHhPWGNyKzdnUnBNSWxRR3pNMmRkK0pHa2FSR29Td0hqWXNKZTdtYUFlRXR4a0FwdStHZDBFN0xXYkZsZTNadEpVM3dUWXEwUDRCUzA1UlZIVS9aTXB0SVNYVHpURkN6QkRtRDBHWmVwNTQvdXVkczFrcUQyRTd0Y0N6VXpBRU04NzVTNXJjY3hOc3RsTWFuVWlrWW16YWxFRG1qR0ZqUGc0Ni85Rzd0eE1meWJIMCtyNGZ3K0tvcWdINWREdEYvbk8xeW5kU0lCWUFPVFF4WTFCWFp4b1J1bVhMdFdOVGk5MjliRzdMelBLeGhBQ3I0Y2gvV1RvUDRMNjlqUlFoNUNjdUU4TXV6bGxabnQyTnYzSUV4SCtGRVZSYjh5WWh5L2hIYWp6c3YrdGI0cWxkTWRlT1RMWmUxUFhNcUMrcStjejZHTjNibEpuZDBPYW5HL25TL0dsM2p5OHpnVE00NmhDVmc3QlFyQUh0OTdPSk1JWkVwYWlLT3F4VTN4SWdKZlk2UDVYRXg5a2xqRWQwQXIxMkhQOXllTW85ZFcreVNxSnE3U2VmRHR6UGVTUmNEZDMvblBhKzlCN1ljYmZUK28rTEJiVzFxcVBDWi9adnZaOTZsZTQ3WncvSzljREZFVlI5NXpsNXZDTkxqU3dMTGMwTS8vWVVTaEtOTXY1K2o4YUUxcmtEUjBKMDhobUZ3c280ZExUaEtsbmdBMFltOEZuRUYra1ZqNER1dGV5QUptdXcwN2R0NjJXejI3UEFXNE05cHNRbk9GMmlxS29oMFR6Nkd1OVk3Zjg4SS9ZUS8rSGdEZHpqUDlSQVlKd3R5WWpCRDJFZ2JqZERQWDJvVWZxejVvWmx6LzNleEM5eXN4TVJ4ZTdPVmVlZXQrYlc0QjZESGJzOGFkSzdBcHpHbmZPekhhS29xajdaOUZqWmxzVy96MkkvSVBDdEVYZnBmdUxPY1lBSEMzZ1ZFMTBOWnVDT3BMTWNnYTdJR00rR1c2UHo5UDNtSjhFZXNaWTEyR1h0akhodklldGFjY0FPSVJnbkRSNGF1RzhBdGlYc0pkNzdSUkZVUThJNUNZQ2VvK0Z3dkFmV0dLMi85L2VlTjlJMTdTMmU1QVpnVGxhdVdMQVNVNGkxdkN1dlMrUnk1SDIvZGJIM085aUs1dFlESVNMOUluUFRHREQrZStiZHRhVnAxNWVHdVJzcWhzMW9Ka0RPODROMC9ETWlkejVLWStuS0lxaWJnWjEwOXMveDVheXdQeDllL3Z2NE5BdEI5by9DNFF5UXZyMnlLVURRZ0htWTVDWWdycWJvVjVuZHg4YkpxdmRHT3htUGprdWg3TjRtdXVSMmVaVE1POFdLc3ExaTcxcEE1bzVzS09WYkVpY1c1TThOL1dlQ0hPS29xZzM2YzVieitxTzIzLzJ3ZDkrbzlVZTROKzFsMTBYZWkvQ1FlNEpBSjlOcGFTNzJwenppK3U4NHkvL1haM2Z2QWFMaDNJc3UzMWdzRy9DOHZoNThCNXpuWE5vK2hKREx3Zm0zWUtsY0RrSXR3bDF2SFlBKzNCL1BTZWFRbEVVUmQwVG1QZmNlUnh5RjM3dmhPRmdwNy9qZmRNMmYrcmczdGdmZzB0dnhWRml2OXcxWDAzUHlKNWpRWmdxbHFzcUd1Z3lCUnJuUU9mS3RJeUFMUlZ0UDNMcFZYN2kycjd4b2ZkTUJ6dGM2QVNvVnllc1ZjOEIrNUo5Y3liRFVSUkYzUU9ZZDlCeWJIYU1ic1NsVzNiL3p3Lys5Zy9mNzREdVhmbzNpcmI1TUQ2dzhqQTNYU2kreUlaNkFCaGdrdE1OcmdPZDM2ZFBPZWtrMEdmTHN1WkwyNEpRWXJaa2V4dGJDTWZ1TnczenNUVVhNdUJ2RytveDJGdGpianhQbm02ZW9panFibUV1QnFzTnZQYkcyekxiM3ZpRDhBaHRPdHR1WVc2YXIrTkEvRndxN0p2ank3L3g0WGYvaEpIbHozSHErM3JaUFBXeFJqSXhMTU9selNSTHpuSGhPYWRlUC9XWVhUVFJMVjJiUGoreERVRGYzQUhVVTJBZjNZNmdPNmNvaW5wRElJOVkyN0czRGF6dXJpMmZmOGU2OHc4N29JZURITzNiNzF2Ny9zZmEybnBWSUVUYitNMTNmOTA2NXg2L1dHb2VkN2hudnpEVUhoeXJpZjZaQkhXYkNmVFdqQ1c0SDBGdGJBYjZtR29mZWk5R0loUnpNTzh5NE84UTZqSFlrM3YvRTU4NzNUbEZVZFFkZ0x4b3ZaRVdKeTRYNFMrdTNlVlBQdmhmZi9BWFBYUG9nTzMzeUMyNFM2Vit4OEw4UjRxMi9sSklpdGVxTEl3dTVCaDVIZGUrVGVManlqaDRxVGhXclZ3NHZHNmFSVytuOUtWcS9WNTE4YjZ6U244QXVSOVVodkRXd05XbXpTZlh2cTd0WXc3bGFEa2dUOEZSaHNYWTV6akZHTnNsWU1kbkxIUE5EME5xQ1hPS29xaTdaSG5FcXE1czNNUVo3YzBCNXFiNWEvdnpidytmcGdvcDhNNnVLeHk4TTBwOTJmNzRWL2J5Q3hZelJTdGY5Z0E0cU83aStQTDFqNW5uUlFReDVZR01TV3I3Wm5IakVqZERmY0lkRnBrdDJoSWttdTl4Ym5vTGkyWkJaRUZDNzd0NnRJV3N5UUJqT0Q5OGZNaGJ1RXVvRDhFKy96ODZpcUlvNm1RME4wVy9VNnRjdVdoNHlHczdSTW1idjdHRys4dGc5VEhRdmJYWFVwTFdPbDQzeFlWRjkzK3g5M3piUHQxWDVVNExkcmxXRHR5QXU3SFEwZUxXVlh4ZTRtNmJkbG1vSFUrcEMrMDIvYVA3cHRTMmVZc0dDYm0zK2RsdU9oVHNMd0JZM2VCOFRiR0o5dURORWlZT011QWxTdENZN0R5QlU0STk5ZG5UblZNVVJkMGUwQSszZzBzUGRlYk5JYXU5YmY0WXp0eGU3eVVNbjNMb01jenhIRERpOXRpOUJkdlg3Qy8rYjZITnQrMzF1MFlqQzF4N3A5NUtpTGJGNDVUdUtDRGR5dmJONHJlRVBXUTFnR2hxTEdrUDBrMlRSUnBzS2VCUW5WbjNqY05LKzduVUN4Y2wrMTFUcUUwNStqcExrK2Ewcks3dUh1ckRoWWRTZE9jVVJWRzNDM1VmSis3SzA2SndlOXQ4Z0FRNEM3N3ZHUlB0cHcrQkx1eVJjSG5ob0M1TzM0VmU0WldWTnQrM3YvamZoVzYvV1pqeVYrMGQyeUs0Y3VVdUNMc0Q2amlkdWpHcmVvVGpkVEhxVkUzWTh2aFpHd0ZkWHVjNXZHMEEvWGdQZm1MeFVQaGt3SVhhNzl2WkNYUlRNQjkrSnE3UzRNMUFuZTZjb2lqcXRwMVRWSjdXZ2IwRCtnNTE1dmI2RDYyRC9TRDBpQW1KNmtkQWQxdmZCOHR2aXZiUVFxYjE5bCtiRHdxamY4TkMvYjlib0gvZEdQMFZDL0FmZFNBL1FGM0tvZHAxTUZmR2J4T01PUElqU0FlSG52bVp0UXBRWEJCMngrZlMxb3VOS1Q3aUdzbUZvVG5PQ3BBUGo5WCtqOTJTckJSRlVZOEk2TkU0VkhObzYycHYvNHRyeWQ1K1J4cS9kU1ZyYlJIZlBnSjZlSjRoMU4zUUVndk5FSWZYMW5VYS9iNEYrdS9aWC95K1Vmb0xGdVkvWjQvNktYdjlFL2FJOTVyR3ZHVWZ2amxnT2hPZWFGN1RqQmRMcGNEZUltbXN5UWRjcTlwRlFIZFF4ekNaNVJEZHkwNkFUcmFTSFlPNW1iSEdidEZqaW9XN0FCUkZVZFQ5dE9hQ0MzdDU1WWFybUgrU2NlYkcvQjhNV3ZGelZpS1FSN1hvUlRvaC9OOEZHQUQvZkUzMEN3cVdWQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUEvQ0FZQUFBQXhCZXlJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xTlVSRk5qRkZSak5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFOVVJGTmpGR01ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qRTBNRVV4T0VFME0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pVMVJFVTJNVVZGTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrQ2licnVBQUFDcGhKUkVGVWVOcnNuWDlzRS9jVndOK2R6NzhkeDBtZ1l4RGFVRVlxVFpRVzFtaWpxS2hUU2FzMW82V3F5cXFWUWRXb0JUWmF0WCswVUxXalF0WGFQMXF0R2kyTWRvSzFoV2xBa1JCYVFhaXROcWtJK0lNZkFScEVDTDlGZ0pDUTJFNXN4em4vdUwxMzkvVmhKN1p6TnNuNVhPNHBUMmZIZCtldjMrZjczdmQ5MzMxOTVxNC8rU1FVS1R4cUErcXZVUjlBclVlZGhPcEd0WU1wV21RUU5ZeDZCYlVkOVREcS8xQVBvU2ExbkdES0JVL0djNkdJUnRTaS9nbjFPZFRKSnBOYkVqdlRhdFI3VVo5bS83K00raS9VZGFnZGhYcVpWcWxoYjNBT2RaVUpjMHhsTXJQeE9XYnptdEVHdWhDMURmV1BxRGJUM3JxSmpkbWNiUCs3MFFBcVlDRGZnTnR0cU9OTSs1Wk15UFpiR1l1OHc2UWc1WDdOaGE5dDV3Q2FKTk9naGhCa3NSU2gxbkpLeEl3VTRxRkNBcjJTWUpwbU5CelVwb1FTTVFYTlFQR0E5UmFBMzVybU02WVFHMktrQ2VpZ0JML0hBMTQweldaNHFDOGlxMFhEUExqemlTZlVKOTBKYm55TlJXcmpsWG1SS1FZWHpHMzhWK0w4eitkMnVEdXplcWlYbDk0M1laYlZlRm8xM3BMOFMwYklsUlRTY0RIR1Q3VnlzQ1QxM05UeVVHUzIrTCtUd2xNelBIVHF4UW9PUSswS3JyaFNvQ21sOVZLQjJDa1BHZEJmT2hKMkp5YzlhNXFuUElYWUVVTVY2T3JxNkJ3TEJ4Tk0wNVJweG92c2lLRU1GTU10NytPbFJrTTJkTW9VOEsxWkEzZHMzUW9WSzFhTTZYdFZybHdwcS9XKysvTHVSNjlUZTJyV3JRUFhNODhZeGxiSWNCN3hKQSsxMm5tWVpjUUJQMzdoQW5BdUYvQk9KN2diRzBGQVk0N0YrL0RZY1p3UFBpaXJVRitmZDErdW9rSnVqN1cyRnBLaGtHRnNoUXgvUVN3SnFNMkdlWkZSdzBsdy9jMkNTT1ZMTDQzTkdQVHd3L0kyT1RBQTBlKyt5KytoMDZhcGo4VzJOc1BZaVRHMENUSlFUakxzbFpRRWVtbmt3QUZ3b2ZlUVYxQ1lpM3oxMWFpK2gydnVYSGtiYldrQng3eDVZSjgrUFRmUU8rKzhPVzkvL3ZuOGJlL3VocjVQUHRFSHFNSlFCbXJsT1hBWmVkRHYvK3d6Y015Y0NiSExsMEhDTURlcU1MR0RXS3FWV2twazcxNXdQdlFRT082L1g5T3hJKzBYNitqUXpVYU1vVldRa3lSSkV2UzZSRmJ6NFlkZ3I2OHYrRGdLaDNRY3FXL1pNazNIUkk4ZGc5N1ZxL1B1NDNuOGNYazcyTjRPSXU1dm1UZ1I4dG5DMDlpbzdoKzdkQ2wvbThOaGtDUjlMTXRxQ0JZaE5TSFZyU2U1aWdzR2xJaU10bmhlZUVIMXp0Q3VYZkoyWU04ZUdNaXh2NERKVXdvbzdUKzRiNS9oNmd5NkF3MTkvVFZZSnVTZTh2SnV0Mm8wZWY5dnY1VjdlakVTTzNNbTkvdFVWWUhuc2NmVTBLZ0ZqcVcyOXVhNVcxc05XVGpTdmRSSEhqQlNTRTZIMmZmeHh6bTloZk42SVhiOGVGSHQ4QzVkcW5yOXdPSER3MTkvK2VYaENkRmRkNm5oMzdOb1VkN3o1MnIzV0lzTTFDaExUQ293QktiR1YvS2FZQTZqdUJjdUJPL1R5b3JIWHN3aUN3MTlka3g4S0d0T0Z5bkhXSmtyL09kN1haNXVsUktvRVlTTTdGMndRUFdBM2c4K3lCMUtUNTlXRFR2dTlkZWhGeWY3STNsK2VxajFOVGRyYmxjWXAweUpyaTVOKzFycjZzQ3BNVVArVVFPbDhGbWRWdHJyZWU4OXVVcVVTMFFNczkyclZrSE5PKytBZ0VsTk5XYTlBWThId3R1M2ovaGUxVys5SlIralZRWlBuTkRjV1NqQ2xCb29id1NZQkNZMW50MUF6eFExaklzRXZHZk5Hb2ozOXNyUGZUaW1VU2pPSjVVNExxWkMrZ0JPVVg2TVV0SXhWUFpNREprcGovRnYyUUxSUE9NaGhVdjFzYzhudDdzZnZhZUtKU2dFbGY2WHkxTTV0MXZwRE5nSi9COTlCTTR2dmxESHoxdzI4QzFaSWtjQXJYUGxYR095dmlGWDB2L3RYVGloOTZKSENUWEtLdjk0VHc4NHBrK1hsZWFxcWZrcWg1NmIya2VMRU56RTFhdFpPMFp3d3dad1l6TFVpekNUekxQVnp6L2FOcENrRWdJdGdUaG56ODRBUlk4TEFaZFB4cjN4Qm5UMTk4dVZud3dQOHZ2aDZ1TEY4bGFyQkQ3L0hDSUZqS0dWVHoxMWV5WkZBd2NQcWdrRWhTb2FRMU8xVHl1YndKUFhEaHc1b2hZV0VwMmRVREYvdm5McENvL3BXcmtTa29HQUNzdUJtVExCbEpPZlYxK0Z6aXpGODBKZ21tTm9BUkxHWHA4Z0wycHR6VEF5alpPVHZ2eFN5VERiMmlBd1pENUhuazFBNVE0d0pCTWV3REFibkRZTm5BME40UC8wMDRJK1Y2NTk3VE5tNUsxc3BZc05jd0pqaktFbGttempuQzN0MGxWYzQvd3ZvMEt6YVpPc295WHVPWFBLejBPTkpMYjBDOGg1YXJHNlJaTDkrelYzTFBKUXM3Q1FKMnlKQmlpQVIwK2MwSndVZWMzQ3d2QjVwdjJlZXhTWW1DRGRTZ0pEQ2RMdEtNWXF6dU1jTWxVeGlodzZsTFZka29aRWhtUThacnZSQlFzZ3NIbnpzT2xMdG5QbU9sY1Zac28xeTVlYmhZV0NReTJHS3Uramo2cUdDZTNjT1hLN2Nyek9zOHFUbzc0ZWJLaGlTNHYraFlEYnJiQ1EwWWk3NzRaeHI3MTJjeksvWTBkbUphZlEwTzN6M2N5VXIxMjdwYmIxVW1GaDkyNXRZMmh6TS9pTVVGaEk0dWZtU3dUWDFkUUUxUmpXMUZDTDRURzBiZHV0ZmFpMGxRVnhIUmRxbFZLSW9RbzBKa0hVeG9GSHp3YTRFYVRua1Vma3NKZ1NndG45OXR2NUc1NjJITVgzeWl0Wmw2ZTRHaHJVMEIwN2YxNXpZYUVLenpmc1hMTm5nMjJxdG1YTHRycTZqTGFsMmh2Y3VISE03VWtNVTBDbHFNVDViWnlrQzlDYU45OEUxNnhaR1l1K3lQQjllL2RxK3VBMGpmQ3d5WDVxek0wbG9RSlhNbVE3bjZ2SWFVanFYSlN0NndHVUdCSkxHV2d3eVYzeDhwSXVONUpLQjBJZ0kwZVBRaEJEYkZ5ako0VnhQQk1tVEpDOTBKWVdXdE9GYXNEUnRqYndyMTFiVU5zaVkzQ050SmhxVnpGQ0RGTkFFNTBKdm4yeWtQeVZMcFVYQm9TK0Z4S21GWDFGSkQvVTQwZWoxL2Q5ODQzaVJhd2lOVks0TjdKY1JZYkVrb0RHRGc4S2h4K3d4eGZyOWVZQkhVS1FwZ3kyUUE4MnNod2RGT2lHanpHcUZJbi82TE1maVNneDJKUXlGR0tIREk4U1N4a29EcWlCazZKbHYybWE4aFJpUnd5SnBSeHlhVGpaMkdmZk9XdGM3RGNXK1JZNHBwU0xKUENQMkJGRE9lU2VyUFhUalhiNzkwV3RwMXRGWVo5cG9uTHpUbUUvc1NPR05ISGdXY1dScXNwZDcvcGRXOUIxdytidFlzcERpZFVhdjJzenNXTU0xY3RuRkhaN1RzVXNaM2FFYmY4MiszMTVDTExhMWhhejBIU2xoekZVZ0xiVytnazRmWk8yNC8yQWE4OHhVVGhnbXN2WWNod1pJU3U2YXREQjJFbnBIa3BRUlpwYm8xNWFmc096OFZ6TWN0STBtekdGMkN4RFJzU0tNUk5UcncxZHNVQTMxYjNjbitUT050L3dyTDhZdDdTWjVqT1duSTlaVGhFYllnVEtqdzFrM0FnNUF5aDZhWUlLT2RRSmJpVDQwd3V2Vi95dFJSUU9tbVkwaGhDTFo3c3ExaEliVUg1Z3dLL01YTktBRHMyY2ZxajF4NWdidDBjazd1d2Z1aW8yYmVwM21ObHZpYlBaZnlJRFlvRk1xUEJNaVZBM1k1VWhXUzlxNDQ3aXZSMVYxOW41eEw4R25lS3VpTzNVbjMyUitUUHQ4UWJlTEQ3b0lrbjB2cFpCNGRDN0FkZC9jTnlrNU9jaTgweUNLV1k3aGp2SDdnS1NUUkNxRlRlMG5vTXVyZEgzMGUrWVlZdFBYTzZOemtXd005MmNWR21hZmZRbExIRkJCTm55OXo3SDl5ZEU0U3FiWjE1aVkyWWczVE9Sa1hhZzdBRHlSdm9xMkhoUWZsWHBwd1JaNE1EVjVCS256SFhFZmxZbkpHcHJlR204aDVjcXJaeGtNejFZdXdmR0pFNE1KYmxnVDVMcnhpUzA0L3VvOWV6dWlPMUNYSktUSGNwbnJyR3BDUTJEa1IrVVBBZUtCcHAySVAwb0RLMXFvSytJL1lSdHZhZ09VSDR3Um1ES2djNTNWaWxqVVc5cnlKVENLQzBsNldQRmd1dHNHOG9WWW9jQmRjMTRycEFHRUNnS3c3UitwSUlCOVRMUVRnYldBZ1pid0cxc0o1V3pWSkdWN2tJTUptay8rMThNQ2xqbUt4VFJvMFNtL1N3TTJKaGFHVXpUUXd2MzBBUURsN0p0RERUK091RlErYjhBQXdCd2tiQ3g5aUlZdFFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxpbWcgY2xhc3M9XFxcInJlY2hhcmdlLXJlY29yZFxcXCIgdi1iaW5kOnNyYz1cXFwicmVjb3JkSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInJlY29yZEltZ1N0eWxlXFxcIi8+PGRpdiBjbGFzcz1cXFwicmVjaGFyZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZC1pbWdcXFwiPjxkaXYgdi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiPjxpbWcgdi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIi8+PGRpdiBjbGFzcz1cXFwiYmFyY29udGVudFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIj48aW1nIGNsYXNzPVxcXCJtb25leS1pbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlJbWdcXFwiIHYtYmluZDpzcmM9XFxcIml0ZW0uZ29vZHNpbWdcXFwiLz48ZGl2IGNsYXNzPVxcXCJib251cy1tb25leVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJpdGVtLnN1Yj9ib251c01vbmV5SGFzU3ViOmJvbnVzTW9uZXlcXFwiIHYtaHRtbD1cXFwiaXRlbS5nb29kbmFtZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtbW9uZXkgYm9udXMtc3ViXFxcIiB2LWlmPVxcXCJpdGVtLnN1YlxcXCIgdi1iaW5kOnN0eWxlPVxcXCJib251c1N1YlxcXCIgdi1odG1sPVxcXCJpdGVtLnN1YlxcXCI+PC9kaXY+PGltZyBjbGFzcz1cXFwicmVjaGFyZ2VcXFwiIHYtYmluZDpzcmM9XFxcImRvcmVjaGFyZ2VcXFwiIHYtYmluZDpzdHlsZT1cXFwicmVjaGFyZ2VCdG5cXFwiLz48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJteS1tb25leVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJmb290ZXJcXFwiPuaIkeeahOmHkeW4gToge3t1c2VyaW5mby5tb25leX19PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXG1lc3NhZ2VDb21wb25lbnRcXFxccnVsZUludHJvZHVjZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNDFhZjFhZWQvcnVsZUludHJvZHVjZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3J1bGVJbnRyb2R1Y2UudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuaW50cm9kdWNlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWU/NDgyY2JkYmJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0FcIixcImZpbGVcIjpcInJ1bGVJbnRyb2R1Y2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi5pbnRyb2R1Y2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIix2LWh0bWw9XFxcInJ1bGVcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHJlYWR5KCkge1xcclxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucnVsZSlcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxcclxcbiAgICAgICAgZGF0YSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBydWxlOiByZXF1aXJlKCcuLy4uLy4uL2RhdGEvcnVsZUludHJvLmh0bWwnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5pbnRyb2R1Y2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuXHRkaXYuaW50cm9kdWNlKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIix2LWh0bWw9XCJydWxlXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnJ1bGUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczogWyd6b29tUmF0ZSddLFxyXG4gICAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBydWxlOiByZXF1aXJlKCcuLy4uLy4uL2RhdGEvcnVsZUludHJvLmh0bWwnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDU4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5pbnRyb2R1Y2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHJ1bGVJbnRyb2R1Y2UudnVlPzQ4MmNiZGJiXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcblwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImludHJvZHVjZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIiB2LWh0bWw9XFxcInJ1bGVcXFwiPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtb2RlbFxcXCIgdi1zaG93PVxcXCJkaWFsb2dTaG93XFxcIiB0cmFuc2l0aW9uPVxcXCJtZXNzYWdlXFxcIj48ZGl2IGNsYXNzPVxcXCJkaWFsb2dcXFwiIHYtYmluZDpzdHlsZT1cXFwiZGlhbG9nXFxcIj48ZGl2IGNsYXNzPVxcXCJjbG9zZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjbG9zZVxcXCIgQHRvdWNoZW5kPVxcXCJkaWFsb2dTaG93ID0gZmFsc2VcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PC9kaXY+PGRpdiB2LWJpbmQ6aXM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLnR5cGVcXFwiIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIj48L2Rpdj48aW1nIHYtYmluZDpzcmM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcXFwiLz48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIC8v5pWw5o2u5qih5p2/XG4gICAgbm90aWNlOiB7XG4gICAgICAgICdjb250ZW50JzogJz8/Pz8/JyxcbiAgICAgICAgJ2NyZWF0ZWRBdCc6IDE0Njk1NDM5ODAwMDAsXG4gICAgICAgICdpZCc6IDYsXG4gICAgICAgICd0aXRsZSc6ICd0aXRsZSdcbiAgICB9LFxuICAgIG9wdGlvbnM6IFsn5oqV5rOo6K6w5b2VJywgJ+W8gOWlluiusOW9lScsICfmuLjmiI/op4TliJknLCAn5YWR5o2i56S85ZOBJywgJ+i1oOmAgeWlveWPiyddXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL2RhdGEuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9ub3RpY2UuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIC8vIOeUqOaIt+S/oeaBr+aVsOaNruaooeadv1xyXG4gICAgJ2NyZWF0ZWRBdCc6IDE0Njk1NDg2NzUwMDAsXHJcbiAgICAnbW9uZXknOiAxMDAwMCxcclxuICAgICdjb2RlJzogMCxcclxuICAgICduaWNrbmFtZSc6ICfmtYvor5XnlKjmiLcyMjInLFxyXG4gICAgJ29wZW5pZCc6ICd4eHh4eHh4eHh4eHgnXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXHRpcC1tb2RhbC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi02OTFjMDMxYi90aXAtbW9kYWwudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi90aXAtbW9kYWwudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxyXFxuLnRpcC1jb250ZW50IHtcXHJcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXHJcXG4gICAgbWFyZ2luOiAwJSAwIDAgMzAlO1xcclxcbiAgICB3aWR0aDogNDAlO1xcclxcbiAgICBwYWRkaW5nOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjM1KTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLXRyYW5zaXRpb24ge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIC8qIOWQpuWImSBzY2FsZSDliqjnlLvkuI3otbfkvZznlKggKi9cXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1lbnRlciB7XFxyXFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xcclxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1sZWF2ZSB7XFxyXFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBib3VuY2Utb3V0IC41cztcXHJcXG4gICAgICAgICAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT83OTE4N2NiZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7SUFDQSxvQkFBQTtJQUNBLG1CQUFBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSwrQkFBQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLG1CQUFBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLHNCQUFBO0lBQ0EscUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGlDQUFBO1lBQUEseUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGtDQUFBO1lBQUEsMEJBQUE7Q0FDQTs7QUFFQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBOztBQVBBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0E7O0FBRUE7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7Q0FDQTs7QUFQQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJ0aXAtbW9kYWwudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcblxcdGRpdi50aXAtY29udGVudCh0cmFuc2l0aW9uPVxcXCJib3VuY2VcXFwiLHYtc2hvdz1cXFwiaXNTaG93XFxcIix2LWh0bWw9XFxcImNvbnRlbnRcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHByb3BzOiBbXSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgaXNTaG93OiBmYWxzZSxcXHJcXG4gICAgICAgICAgICBjb250ZW50OiAnJ1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICBzaG93VGlwKGNvbnRlbnQpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XFxyXFxuICAgICAgICAgICAgdGhpcy5pc1Nob3cgPSB0cnVlXFxyXFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmlzU2hvdyA9IGZhbHNlLCAzMDAwKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBldmVudHM6IHtcXHJcXG4gICAgICAgIHNob3dUaXAoZXZlbnQpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLnNob3dUaXAoZXZlbnQpXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbi50aXAtY29udGVudCB7XFxyXFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxyXFxuICAgIG1hcmdpbjogMCUgMCAwIDMwJTtcXHJcXG4gICAgd2lkdGg6IDQwJTtcXHJcXG4gICAgcGFkZGluZzogNXB4O1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC4zNSk7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS10cmFuc2l0aW9uIHtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAvKiDlkKbliJkgc2NhbGUg5Yqo55S75LiN6LW35L2c55SoICovXFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtZW50ZXIge1xcclxcbiAgICBhbmltYXRpb246IGJvdW5jZS1pbiAuNXM7XFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtbGVhdmUge1xcclxcbiAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGJvdW5jZS1pbiB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi50aXAtY29udGVudCh0cmFuc2l0aW9uPVwiYm91bmNlXCIsdi1zaG93PVwiaXNTaG93XCIsdi1odG1sPVwiY29udGVudFwiKVxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczogW10sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzU2hvdzogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBzaG93VGlwKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudFxyXG4gICAgICAgICAgICB0aGlzLmlzU2hvdyA9IHRydWVcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmlzU2hvdyA9IGZhbHNlLCAzMDAwKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpcChldmVudClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuLnRpcC1jb250ZW50IHtcclxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XHJcbiAgICBtYXJnaW46IDAlIDAgMCAzMCU7XHJcbiAgICB3aWR0aDogNDAlO1xyXG4gICAgcGFkZGluZzogNXB4O1xyXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuMzUpO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xyXG59XHJcblxyXG4uYm91bmNlLXRyYW5zaXRpb24ge1xyXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgLyog5ZCm5YiZIHNjYWxlIOWKqOeUu+S4jei1t+S9nOeUqCAqL1xyXG59XHJcblxyXG4uYm91bmNlLWVudGVyIHtcclxuICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcclxufVxyXG5cclxuLmJvdW5jZS1sZWF2ZSB7XHJcbiAgICBhbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xyXG59XHJcblxyXG5Aa2V5ZnJhbWVzIGJvdW5jZS1pbiB7XHJcbiAgICAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkBrZXlmcmFtZXMgYm91bmNlLW91dCB7XHJcbiAgICAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogdGlwLW1vZGFsLnZ1ZT83OTE4N2NiZVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ0aXAtY29udGVudFxcXCIgdHJhbnNpdGlvbj1cXFwiYm91bmNlXFxcIiB2LXNob3c9XFxcImlzU2hvd1xcXCIgdi1odG1sPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJhY2tncm91bmQ+PC9iYWNrZ3JvdW5kPjxtZW51LWJhciB2LWJpbmQ6Z2FtZS1kYXRhPVxcXCJnYW1lRGF0YVxcXCIgdi1iaW5kOm5vdGljZT1cXFwibm90aWNlXFxcIiB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCI+PC9tZW51LWJhcj48YmV0LWFuZC1ib251cyB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIgdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIgdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIiB2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIj48L2JldC1hbmQtYm9udXM+PHBsYXktcGFuZWwgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiIHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIgdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIgdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIiB2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiIHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiIHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIgdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCI+PC9wbGF5LXBhbmVsPjxzdGF0ZSB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiPjwvc3RhdGU+PG1lc3NhZ2Ugdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCI+PC9tZXNzYWdlPjxtb2RhbCBjbGFzcz1cXFwibW9kYWxcXFwiIHYtaWY9XFxcImVycm9yXFxcIj48L21vZGFsPjx0aXAtbW9kYWw+PC90aXAtbW9kYWw+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIiFmdW5jdGlvbiAoYSwgYikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYihhKVxufSh3aW5kb3csIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgZnVuY3Rpb24gYyhiLCBjLCBkKSB7XG4gICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgPyBXZWl4aW5KU0JyaWRnZS5pbnZva2UoYiwgZShjKSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGcoYiwgYSwgZClcbiAgICAgICAgfSkgOiBqKGIsIGQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZChiLCBjLCBkKSB7XG4gICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgPyBXZWl4aW5KU0JyaWRnZS5vbihiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZCAmJiBkLnRyaWdnZXIgJiYgZC50cmlnZ2VyKGEpLCBnKGIsIGEsIGMpXG4gICAgICAgIH0pIDogZCA/IGooYiwgZCkgOiBqKGIsIGMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZShhKSB7XG4gICAgICAgIHJldHVybiBhID0gYSB8fCB7fSwgYS5hcHBJZCA9IHouYXBwSWQsIGEudmVyaWZ5QXBwSWQgPSB6LmFwcElkLCBhLnZlcmlmeVNpZ25UeXBlID0gXCJzaGExXCIsIGEudmVyaWZ5VGltZXN0YW1wID0gei50aW1lc3RhbXAgKyBcIlwiLCBhLnZlcmlmeU5vbmNlU3RyID0gei5ub25jZVN0ciwgYS52ZXJpZnlTaWduYXR1cmUgPSB6LnNpZ25hdHVyZSwgYVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZVN0YW1wOiBhLnRpbWVzdGFtcCArIFwiXCIsXG4gICAgICAgICAgICBub25jZVN0cjogYS5ub25jZVN0cixcbiAgICAgICAgICAgIFwicGFja2FnZVwiOiBhLnBhY2thZ2UsXG4gICAgICAgICAgICBwYXlTaWduOiBhLnBheVNpZ24sXG4gICAgICAgICAgICBzaWduVHlwZTogYS5zaWduVHlwZSB8fCBcIlNIQTFcIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZyhhLCBiLCBjKSB7XG4gICAgICAgIHZhciBkLCBlLCBmO1xuICAgICAgICBzd2l0Y2ggKGRlbGV0ZSBiLmVycl9jb2RlLCBkZWxldGUgYi5lcnJfZGVzYywgZGVsZXRlIGIuZXJyX2RldGFpbCwgZCA9IGIuZXJyTXNnLCBkIHx8IChkID0gYi5lcnJfbXNnLCBkZWxldGUgYi5lcnJfbXNnLCBkID0gaChhLCBkLCBjKSwgYi5lcnJNc2cgPSBkKSwgYyA9IGMgfHwge30sIGMuX2NvbXBsZXRlICYmIChjLl9jb21wbGV0ZShiKSwgZGVsZXRlIGMuX2NvbXBsZXRlKSwgZCA9IGIuZXJyTXNnIHx8IFwiXCIsIHouZGVidWcgJiYgIWMuaXNJbm5lckludm9rZSAmJiBhbGVydChKU09OLnN0cmluZ2lmeShiKSksIGUgPSBkLmluZGV4T2YoXCI6XCIpLCBmID0gZC5zdWJzdHJpbmcoZSArIDEpKSB7XG4gICAgICAgICAgICBjYXNlXCJva1wiOlxuICAgICAgICAgICAgICAgIGMuc3VjY2VzcyAmJiBjLnN1Y2Nlc3MoYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlXCJjYW5jZWxcIjpcbiAgICAgICAgICAgICAgICBjLmNhbmNlbCAmJiBjLmNhbmNlbChiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYy5mYWlsICYmIGMuZmFpbChiKVxuICAgICAgICB9XG4gICAgICAgIGMuY29tcGxldGUgJiYgYy5jb21wbGV0ZShiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGgoYSwgYikge1xuICAgICAgICB2YXIgZCwgZSwgZiwgZztcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZCA9IGIuaW5kZXhPZihcIjpcIiksIGEpIHtcbiAgICAgICAgICAgICAgICBjYXNlIG8uY29uZmlnOlxuICAgICAgICAgICAgICAgICAgICBlID0gXCJjb25maWdcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvLm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3OlxuICAgICAgICAgICAgICAgICAgICBlID0gXCJvcGVuUHJvZHVjdFNwZWNpZmljVmlld1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBlID0gYi5zdWJzdHJpbmcoMCwgZCksIGUgPSBlLnJlcGxhY2UoL18vZywgXCIgXCIpLCBlID0gZS5yZXBsYWNlKC9cXGJcXHcrXFxiL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIGEuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlID0gZS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSArIGUuc3Vic3RyaW5nKDEpLCBlID0gZS5yZXBsYWNlKC8gL2csIFwiXCIpLCAtMSAhPSBlLmluZGV4T2YoXCJXY3BheVwiKSAmJiAoZSA9IGUucmVwbGFjZShcIldjcGF5XCIsIFwiV0NQYXlcIikpLCBmID0gcFtlXSwgZiAmJiAoZSA9IGYpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnID0gYi5zdWJzdHJpbmcoZCArIDEpLCBcImNvbmZpcm1cIiA9PSBnICYmIChnID0gXCJva1wiKSwgXCJmYWlsZWRcIiA9PSBnICYmIChnID0gXCJmYWlsXCIpLCAtMSAhPSBnLmluZGV4T2YoXCJmYWlsZWRfXCIpICYmIChnID0gZy5zdWJzdHJpbmcoNykpLCAtMSAhPSBnLmluZGV4T2YoXCJmYWlsX1wiKSAmJiAoZyA9IGcuc3Vic3RyaW5nKDUpKSwgZyA9IGcucmVwbGFjZSgvXy9nLCBcIiBcIiksIGcgPSBnLnRvTG93ZXJDYXNlKCksIChcImFjY2VzcyBkZW5pZWRcIiA9PSBnIHx8IFwibm8gcGVybWlzc2lvbiB0byBleGVjdXRlXCIgPT0gZykgJiYgKGcgPSBcInBlcm1pc3Npb24gZGVuaWVkXCIpLCBcImNvbmZpZ1wiID09IGUgJiYgXCJmdW5jdGlvbiBub3QgZXhpc3RcIiA9PSBnICYmIChnID0gXCJva1wiKSwgYiA9IGUgKyBcIjpcIiArIGdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGkoYSkge1xuICAgICAgICB2YXIgYiwgYywgZCwgZTtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIGZvciAoYiA9IDAsIGMgPSBhLmxlbmd0aDsgYyA+IGI7ICsrYilkID0gYVtiXSwgZSA9IG9bZF0sIGUgJiYgKGFbYl0gPSBlKTtcbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoIXouZGVidWcgfHwgYiAmJiBiLmlzSW5uZXJJbnZva2UpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHBbYV07XG4gICAgICAgICAgICBjICYmIChhID0gYyksIGIgJiYgYi5fY29tcGxldGUgJiYgZGVsZXRlIGIuX2NvbXBsZXRlLCBjb25zb2xlLmxvZygnXCInICsgYSArICdcIiwnLCBiIHx8IFwiXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrKCkge1xuICAgICAgICBpZiAoIShcIjYuMC4yXCIgPiB3IHx8IHkuc3lzdGVtVHlwZSA8IDApKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBJbWFnZTtcbiAgICAgICAgICAgIHkuYXBwSWQgPSB6LmFwcElkLCB5LmluaXRUaW1lID0geC5pbml0RW5kVGltZSAtIHguaW5pdFN0YXJ0VGltZSwgeS5wcmVWZXJpZnlUaW1lID0geC5wcmVWZXJpZnlFbmRUaW1lIC0geC5wcmVWZXJpZnlTdGFydFRpbWUsIEMuZ2V0TmV0d29ya1R5cGUoe1xuICAgICAgICAgICAgICAgIGlzSW5uZXJJbnZva2U6ICEwLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHkubmV0d29ya1R5cGUgPSBhLm5ldHdvcmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFwiaHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20vc2RrL3JlcG9ydD92PVwiICsgeS52ZXJzaW9uICsgXCImbz1cIiArIHkuaXNQcmVWZXJpZnlPayArIFwiJnM9XCIgKyB5LnN5c3RlbVR5cGUgKyBcIiZjPVwiICsgeS5jbGllbnRWZXJzaW9uICsgXCImYT1cIiArIHkuYXBwSWQgKyBcIiZuPVwiICsgeS5uZXR3b3JrVHlwZSArIFwiJmk9XCIgKyB5LmluaXRUaW1lICsgXCImcD1cIiArIHkucHJlVmVyaWZ5VGltZSArIFwiJnU9XCIgKyB5LnVybDtcbiAgICAgICAgICAgICAgICAgICAgYi5zcmMgPSBjXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIHJldHVybiAobmV3IERhdGUpLmdldFRpbWUoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG0oYikge1xuICAgICAgICB0ICYmIChhLldlaXhpbkpTQnJpZGdlID8gYigpIDogcS5hZGRFdmVudExpc3RlbmVyICYmIHEuYWRkRXZlbnRMaXN0ZW5lcihcIldlaXhpbkpTQnJpZGdlUmVhZHlcIiwgYiwgITEpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgIEMuaW52b2tlIHx8IChDLmludm9rZSA9IGZ1bmN0aW9uIChiLCBjLCBkKSB7XG4gICAgICAgICAgICBhLldlaXhpbkpTQnJpZGdlICYmIFdlaXhpbkpTQnJpZGdlLmludm9rZShiLCBlKGMpLCBkKVxuICAgICAgICB9LCBDLm9uID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgJiYgV2VpeGluSlNCcmlkZ2Uub24oYiwgYylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB2YXIgbywgcCwgcSwgciwgcywgdCwgdSwgdiwgdywgeCwgeSwgeiwgQSwgQiwgQztcbiAgICBpZiAoIWEualdlaXhpbilyZXR1cm4gbyA9IHtcbiAgICAgICAgY29uZmlnOiBcInByZVZlcmlmeUpTQVBJXCIsXG4gICAgICAgIG9uTWVudVNoYXJlVGltZWxpbmU6IFwibWVudTpzaGFyZTp0aW1lbGluZVwiLFxuICAgICAgICBvbk1lbnVTaGFyZUFwcE1lc3NhZ2U6IFwibWVudTpzaGFyZTphcHBtZXNzYWdlXCIsXG4gICAgICAgIG9uTWVudVNoYXJlUVE6IFwibWVudTpzaGFyZTpxcVwiLFxuICAgICAgICBvbk1lbnVTaGFyZVdlaWJvOiBcIm1lbnU6c2hhcmU6d2VpYm9BcHBcIixcbiAgICAgICAgb25NZW51U2hhcmVRWm9uZTogXCJtZW51OnNoYXJlOlFab25lXCIsXG4gICAgICAgIHByZXZpZXdJbWFnZTogXCJpbWFnZVByZXZpZXdcIixcbiAgICAgICAgZ2V0TG9jYXRpb246IFwiZ2VvTG9jYXRpb25cIixcbiAgICAgICAgb3BlblByb2R1Y3RTcGVjaWZpY1ZpZXc6IFwib3BlblByb2R1Y3RWaWV3V2l0aFBpZFwiLFxuICAgICAgICBhZGRDYXJkOiBcImJhdGNoQWRkQ2FyZFwiLFxuICAgICAgICBvcGVuQ2FyZDogXCJiYXRjaFZpZXdDYXJkXCIsXG4gICAgICAgIGNob29zZVdYUGF5OiBcImdldEJyYW5kV0NQYXlSZXF1ZXN0XCJcbiAgICB9LCBwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgYSA9IHt9O1xuICAgICAgICBmb3IgKGIgaW4gbylhW29bYl1dID0gYjtcbiAgICAgICAgcmV0dXJuIGFcbiAgICB9KCksIHEgPSBhLmRvY3VtZW50LFxuICAgICAgICByID0gcS50aXRsZSxcbiAgICAgICAgcyA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSwgdCA9IC0xICE9IHMuaW5kZXhPZihcIm1pY3JvbWVzc2VuZ2VyXCIpLCB1ID0gLTEgIT0gcy5pbmRleE9mKFwiYW5kcm9pZFwiKSwgdiA9IC0xICE9IHMuaW5kZXhPZihcImlwaG9uZVwiKSB8fCAtMSAhPSBzLmluZGV4T2YoXCJpcGFkXCIpLCB3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHMubWF0Y2goL21pY3JvbWVzc2VuZ2VyXFwvKFxcZCtcXC5cXGQrXFwuXFxkKykvKSB8fCBzLm1hdGNoKC9taWNyb21lc3NlbmdlclxcLyhcXGQrXFwuXFxkKykvKTtcbiAgICAgICAgcmV0dXJuIGEgPyBhWzFdIDogXCJcIlxuICAgIH0oKSwgeCA9IHtpbml0U3RhcnRUaW1lOiBsKCksIGluaXRFbmRUaW1lOiAwLCBwcmVWZXJpZnlTdGFydFRpbWU6IDAsIHByZVZlcmlmeUVuZFRpbWU6IDB9LCB5ID0ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBhcHBJZDogXCJcIixcbiAgICAgICAgaW5pdFRpbWU6IDAsXG4gICAgICAgIHByZVZlcmlmeVRpbWU6IDAsXG4gICAgICAgIG5ldHdvcmtUeXBlOiBcIlwiLFxuICAgICAgICBpc1ByZVZlcmlmeU9rOiAxLFxuICAgICAgICBzeXN0ZW1UeXBlOiB2ID8gMSA6IHUgPyAyIDogLTEsXG4gICAgICAgIGNsaWVudFZlcnNpb246IHcsXG4gICAgICAgIHVybDogZW5jb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhyZWYpXG4gICAgfSwgeiA9IHt9LCBBID0ge19jb21wbGV0ZXM6IFtdfSwgQiA9IHtzdGF0ZTogMCwgcmVzOiB7fX0sIG0oZnVuY3Rpb24gKCkge1xuICAgICAgICB4LmluaXRFbmRUaW1lID0gbCgpXG4gICAgfSksIEMgPSB7XG4gICAgICAgIGNvbmZpZzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHogPSBhLCBqKFwiY29uZmlnXCIsIGEpO1xuICAgICAgICAgICAgdmFyIGIgPSB6LmNoZWNrID09PSAhMSA/ICExIDogITA7XG4gICAgICAgICAgICBtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgZCwgZTtcbiAgICAgICAgICAgICAgICBpZiAoYiljKG8uY29uZmlnLCB7dmVyaWZ5SnNBcGlMaXN0OiBpKHouanNBcGlMaXN0KX0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgQS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5wcmVWZXJpZnlFbmRUaW1lID0gbCgpLCBCLnN0YXRlID0gMSwgQi5yZXMgPSBhXG4gICAgICAgICAgICAgICAgICAgIH0sIEEuc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuaXNQcmVWZXJpZnlPayA9IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgQS5mYWlsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEEuX2ZhaWwgPyBBLl9mYWlsKGEpIDogQi5zdGF0ZSA9IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gQS5fY29tcGxldGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHouZGVidWcgfHwgaygpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBBLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgZCA+IGM7ICsrYylhW2NdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZXMgPSBbXVxuICAgICAgICAgICAgICAgICAgICB9LCBBXG4gICAgICAgICAgICAgICAgfSgpKSwgeC5wcmVWZXJpZnlTdGFydFRpbWUgPSBsKCk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKEIuc3RhdGUgPSAxLCBhID0gQS5fY29tcGxldGVzLCBkID0gMCwgZSA9IGEubGVuZ3RoOyBlID4gZDsgKytkKWFbZF0oKTtcbiAgICAgICAgICAgICAgICAgICAgQS5fY29tcGxldGVzID0gW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgei5iZXRhICYmIG4oKVxuICAgICAgICB9LCByZWFkeTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIDAgIT0gQi5zdGF0ZSA/IGEoKSA6IChBLl9jb21wbGV0ZXMucHVzaChhKSwgIXQgJiYgei5kZWJ1ZyAmJiBhKCkpXG4gICAgICAgIH0sIGVycm9yOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgXCI2LjAuMlwiID4gdyB8fCAoLTEgPT0gQi5zdGF0ZSA/IGEoQi5yZXMpIDogQS5fZmFpbCA9IGEpXG4gICAgICAgIH0sIGNoZWNrSnNBcGk6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGQsIGIgPSBhLmNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgIGZvciAoYyBpbiBiKWQgPSBwW2NdLCBkICYmIChiW2RdID0gYltjXSwgZGVsZXRlIGJbY10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYyhcImNoZWNrSnNBcGlcIiwge2pzQXBpTGlzdDogaShhLmpzQXBpTGlzdCl9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gYS5jaGVja1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgKGEuY2hlY2tSZXN1bHQgPSBKU09OLnBhcnNlKGMpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiKGEpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVRpbWVsaW5lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlVGltZWxpbmUsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVUaW1lbGluZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nX3VybDogYS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IGEubGluayB8fCBsb2NhdGlvbi5ocmVmXG4gICAgICAgICAgICAgICAgICAgIH0sIGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgfSwgb25NZW51U2hhcmVBcHBNZXNzYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlQXBwTWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzZW5kQXBwTWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhLnR5cGUgfHwgXCJsaW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3VybDogYS5kYXRhVXJsIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVFROiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlUVEsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVRUVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVdlaWJvOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlV2VpYm8sIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVXZWlib0FwcFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZVFab25lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChvLm9uTWVudVNoYXJlUVpvbmUsIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjKFwic2hhcmVRWm9uZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYS50aXRsZSB8fCByLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogYS5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBzdGFydFJlY29yZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdGFydFJlY29yZFwiLCB7fSwgYSlcbiAgICAgICAgfSwgc3RvcFJlY29yZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdG9wUmVjb3JkXCIsIHt9LCBhKVxuICAgICAgICB9LCBvblZvaWNlUmVjb3JkRW5kOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChcIm9uVm9pY2VSZWNvcmRFbmRcIiwgYSlcbiAgICAgICAgfSwgcGxheVZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInBsYXlWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkfSwgYSlcbiAgICAgICAgfSwgcGF1c2VWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJwYXVzZVZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBzdG9wVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwic3RvcFZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBvblZvaWNlUGxheUVuZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGQoXCJvblZvaWNlUGxheUVuZFwiLCBhKVxuICAgICAgICB9LCB1cGxvYWRWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ1cGxvYWRWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGRvd25sb2FkVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiZG93bmxvYWRWb2ljZVwiLCB7c2VydmVySWQ6IGEuc2VydmVySWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgdHJhbnNsYXRlVm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwidHJhbnNsYXRlVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCBjaG9vc2VJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJjaG9vc2VJbWFnZVwiLCB7XG4gICAgICAgICAgICAgICAgc2NlbmU6IFwiMXwyXCIsXG4gICAgICAgICAgICAgICAgY291bnQ6IGEuY291bnQgfHwgOSxcbiAgICAgICAgICAgICAgICBzaXplVHlwZTogYS5zaXplVHlwZSB8fCBbXCJvcmlnaW5hbFwiLCBcImNvbXByZXNzZWRcIl0sXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZTogYS5zb3VyY2VUeXBlIHx8IFtcImFsYnVtXCIsIFwiY2FtZXJhXCJdXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gYS5sb2NhbElkcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgJiYgKGEubG9jYWxJZHMgPSBKU09OLnBhcnNlKGIpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBwcmV2aWV3SW1hZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKG8ucHJldmlld0ltYWdlLCB7Y3VycmVudDogYS5jdXJyZW50LCB1cmxzOiBhLnVybHN9LCBhKVxuICAgICAgICB9LCB1cGxvYWRJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ1cGxvYWRJbWFnZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGRvd25sb2FkSW1hZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiZG93bmxvYWRJbWFnZVwiLCB7c2VydmVySWQ6IGEuc2VydmVySWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZ2V0TmV0d29ya1R5cGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGQsIGUsIGIgPSBhLmVyck1zZztcbiAgICAgICAgICAgICAgICBpZiAoYS5lcnJNc2cgPSBcImdldE5ldHdvcmtUeXBlOm9rXCIsIGMgPSBhLnN1YnR5cGUsIGRlbGV0ZSBhLnN1YnR5cGUsIGMpYS5uZXR3b3JrVHlwZSA9IGM7IGVsc2Ugc3dpdGNoIChkID0gYi5pbmRleE9mKFwiOlwiKSwgZSA9IGIuc3Vic3RyaW5nKGQgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlXCJ3aWZpXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2VcImVkZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZVwid3dhblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5uZXR3b3JrVHlwZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZXJyTXNnID0gXCJnZXROZXR3b3JrVHlwZTpmYWlsXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjKFwiZ2V0TmV0d29ya1R5cGVcIiwge30sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhID0gYihhKVxuICAgICAgICAgICAgICAgIH0sIGFcbiAgICAgICAgICAgIH0oKSlcbiAgICAgICAgfSwgb3BlbkxvY2F0aW9uOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcIm9wZW5Mb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGEubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBhLmxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBhLm5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhLmFkZHJlc3MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzY2FsZTogYS5zY2FsZSB8fCAyOCxcbiAgICAgICAgICAgICAgICBpbmZvVXJsOiBhLmluZm9VcmwgfHwgXCJcIlxuICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgfSwgZ2V0TG9jYXRpb246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhvLmdldExvY2F0aW9uLCB7dHlwZTogYS50eXBlIHx8IFwid2dzODRcIn0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYS50eXBlXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBoaWRlT3B0aW9uTWVudTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJoaWRlT3B0aW9uTWVudVwiLCB7fSwgYSlcbiAgICAgICAgfSwgc2hvd09wdGlvbk1lbnU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwic2hvd09wdGlvbk1lbnVcIiwge30sIGEpXG4gICAgICAgIH0sIGNsb3NlV2luZG93OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSA9IGEgfHwge30sIGMoXCJjbG9zZVdpbmRvd1wiLCB7aW1tZWRpYXRlX2Nsb3NlOiBhLmltbWVkaWF0ZUNsb3NlIHx8IDB9LCBhKVxuICAgICAgICB9LCBoaWRlTWVudUl0ZW1zOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImhpZGVNZW51SXRlbXNcIiwge21lbnVMaXN0OiBhLm1lbnVMaXN0fSwgYSlcbiAgICAgICAgfSwgc2hvd01lbnVJdGVtczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93TWVudUl0ZW1zXCIsIHttZW51TGlzdDogYS5tZW51TGlzdH0sIGEpXG4gICAgICAgIH0sIGhpZGVBbGxOb25CYXNlTWVudUl0ZW06IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiaGlkZUFsbE5vbkJhc2VNZW51SXRlbVwiLCB7fSwgYSlcbiAgICAgICAgfSwgc2hvd0FsbE5vbkJhc2VNZW51SXRlbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93QWxsTm9uQmFzZU1lbnVJdGVtXCIsIHt9LCBhKVxuICAgICAgICB9LCBzY2FuUVJDb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSA9IGEgfHwge30sIGMoXCJzY2FuUVJDb2RlXCIsIHtcbiAgICAgICAgICAgICAgICBuZWVkUmVzdWx0OiBhLm5lZWRSZXN1bHQgfHwgMCxcbiAgICAgICAgICAgICAgICBzY2FuVHlwZTogYS5zY2FuVHlwZSB8fCBbXCJxckNvZGVcIiwgXCJiYXJDb2RlXCJdXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGM7XG4gICAgICAgICAgICAgICAgICAgIHYgJiYgKGIgPSBhLnJlc3VsdFN0ciwgYiAmJiAoYyA9IEpTT04ucGFyc2UoYiksIGEucmVzdWx0U3RyID0gYyAmJiBjLnNjYW5fY29kZSAmJiBjLnNjYW5fY29kZS5zY2FuX3Jlc3VsdCkpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvcGVuUHJvZHVjdFNwZWNpZmljVmlldzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoby5vcGVuUHJvZHVjdFNwZWNpZmljVmlldywge3BpZDogYS5wcm9kdWN0SWQsIHZpZXdfdHlwZTogYS52aWV3VHlwZSB8fCAwfSwgYSlcbiAgICAgICAgfSwgYWRkQ2FyZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBlLCBmLCBnLCBoLCBiID0gYS5jYXJkTGlzdCwgZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChlID0gMCwgZiA9IGIubGVuZ3RoOyBmID4gZTsgKytlKWcgPSBiW2VdLCBoID0ge2NhcmRfaWQ6IGcuY2FyZElkLCBjYXJkX2V4dDogZy5jYXJkRXh0fSwgZC5wdXNoKGgpO1xuICAgICAgICAgICAgYyhvLmFkZENhcmQsIHtjYXJkX2xpc3Q6IGR9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMsIGQsIGUsIGIgPSBhLmNhcmRfbGlzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiA9IEpTT04ucGFyc2UoYiksIGMgPSAwLCBkID0gYi5sZW5ndGg7IGQgPiBjOyArK2MpZSA9IGJbY10sIGUuY2FyZElkID0gZS5jYXJkX2lkLCBlLmNhcmRFeHQgPSBlLmNhcmRfZXh0LCBlLmlzU3VjY2VzcyA9IGUuaXNfc3VjYyA/ICEwIDogITEsIGRlbGV0ZSBlLmNhcmRfaWQsIGRlbGV0ZSBlLmNhcmRfZXh0LCBkZWxldGUgZS5pc19zdWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5jYXJkTGlzdCA9IGIsIGRlbGV0ZSBhLmNhcmRfbGlzdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBjaG9vc2VDYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImNob29zZUNhcmRcIiwge1xuICAgICAgICAgICAgICAgIGFwcF9pZDogei5hcHBJZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbl9pZDogYS5zaG9wSWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzaWduX3R5cGU6IGEuc2lnblR5cGUgfHwgXCJTSEExXCIsXG4gICAgICAgICAgICAgICAgY2FyZF9pZDogYS5jYXJkSWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjYXJkX3R5cGU6IGEuY2FyZFR5cGUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjYXJkX3NpZ246IGEuY2FyZFNpZ24sXG4gICAgICAgICAgICAgICAgdGltZV9zdGFtcDogYS50aW1lc3RhbXAgKyBcIlwiLFxuICAgICAgICAgICAgICAgIG5vbmNlX3N0cjogYS5ub25jZVN0clxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEuY2FyZExpc3QgPSBhLmNob29zZV9jYXJkX2luZm8sIGRlbGV0ZSBhLmNob29zZV9jYXJkX2luZm9cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9wZW5DYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIGIgPSBhLmNhcmRMaXN0LCBkID0gW107XG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBmID0gYi5sZW5ndGg7IGYgPiBlOyArK2UpZyA9IGJbZV0sIGggPSB7Y2FyZF9pZDogZy5jYXJkSWQsIGNvZGU6IGcuY29kZX0sIGQucHVzaChoKTtcbiAgICAgICAgICAgIGMoby5vcGVuQ2FyZCwge2NhcmRfbGlzdDogZH0sIGEpXG4gICAgICAgIH0sIGNob29zZVdYUGF5OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhvLmNob29zZVdYUGF5LCBmKGEpLCBhKVxuICAgICAgICB9XG4gICAgfSwgYiAmJiAoYS53eCA9IGEualdlaXhpbiA9IEMpLCBDXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC93ZWl4aW4tanMtc2RrLzEuMC43L3dlaXhpbi1qcy1zZGsvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=